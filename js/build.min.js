/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/jquery/dist/jquery.js":
/*!********************************************!*\
  !*** ./node_modules/jquery/dist/jquery.js ***!
  \********************************************/
/***/ (function(module, exports) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * jQuery JavaScript Library v2.2.4\n * http://jquery.com/\n *\n * Includes Sizzle.js\n * http://sizzlejs.com/\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2016-05-20T17:23Z\n */\n\n(function( global, factory ) {\n\n\tif (  true && typeof module.exports === \"object\" ) {\n\t\t// For CommonJS and CommonJS-like environments where a proper `window`\n\t\t// is present, execute the factory and get jQuery.\n\t\t// For environments that do not have a `window` with a `document`\n\t\t// (such as Node.js), expose a factory as module.exports.\n\t\t// This accentuates the need for the creation of a real `window`.\n\t\t// e.g. var jQuery = require(\"jquery\")(window);\n\t\t// See ticket #14549 for more info.\n\t\tmodule.exports = global.document ?\n\t\t\tfactory( global, true ) :\n\t\t\tfunction( w ) {\n\t\t\t\tif ( !w.document ) {\n\t\t\t\t\tthrow new Error( \"jQuery requires a window with a document\" );\n\t\t\t\t}\n\t\t\t\treturn factory( w );\n\t\t\t};\n\t} else {\n\t\tfactory( global );\n\t}\n\n// Pass this if window is not defined yet\n}(typeof window !== \"undefined\" ? window : this, function( window, noGlobal ) {\n\n// Support: Firefox 18+\n// Can't be in strict mode, several libs including ASP.NET trace\n// the stack via arguments.caller.callee and Firefox dies if\n// you try to trace through \"use strict\" call chains. (#13335)\n//\"use strict\";\nvar arr = [];\n\nvar document = window.document;\n\nvar slice = arr.slice;\n\nvar concat = arr.concat;\n\nvar push = arr.push;\n\nvar indexOf = arr.indexOf;\n\nvar class2type = {};\n\nvar toString = class2type.toString;\n\nvar hasOwn = class2type.hasOwnProperty;\n\nvar support = {};\n\n\n\nvar\n\tversion = \"2.2.4\",\n\n\t// Define a local copy of jQuery\n\tjQuery = function( selector, context ) {\n\n\t\t// The jQuery object is actually just the init constructor 'enhanced'\n\t\t// Need init if jQuery is called (just allow error to be thrown if not included)\n\t\treturn new jQuery.fn.init( selector, context );\n\t},\n\n\t// Support: Android<4.1\n\t// Make sure we trim BOM and NBSP\n\trtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,\n\n\t// Matches dashed string for camelizing\n\trmsPrefix = /^-ms-/,\n\trdashAlpha = /-([\\da-z])/gi,\n\n\t// Used by jQuery.camelCase as callback to replace()\n\tfcamelCase = function( all, letter ) {\n\t\treturn letter.toUpperCase();\n\t};\n\njQuery.fn = jQuery.prototype = {\n\n\t// The current version of jQuery being used\n\tjquery: version,\n\n\tconstructor: jQuery,\n\n\t// Start with an empty selector\n\tselector: \"\",\n\n\t// The default length of a jQuery object is 0\n\tlength: 0,\n\n\ttoArray: function() {\n\t\treturn slice.call( this );\n\t},\n\n\t// Get the Nth element in the matched element set OR\n\t// Get the whole matched element set as a clean array\n\tget: function( num ) {\n\t\treturn num != null ?\n\n\t\t\t// Return just the one element from the set\n\t\t\t( num < 0 ? this[ num + this.length ] : this[ num ] ) :\n\n\t\t\t// Return all the elements in a clean array\n\t\t\tslice.call( this );\n\t},\n\n\t// Take an array of elements and push it onto the stack\n\t// (returning the new matched element set)\n\tpushStack: function( elems ) {\n\n\t\t// Build a new jQuery matched element set\n\t\tvar ret = jQuery.merge( this.constructor(), elems );\n\n\t\t// Add the old object onto the stack (as a reference)\n\t\tret.prevObject = this;\n\t\tret.context = this.context;\n\n\t\t// Return the newly-formed element set\n\t\treturn ret;\n\t},\n\n\t// Execute a callback for every element in the matched set.\n\teach: function( callback ) {\n\t\treturn jQuery.each( this, callback );\n\t},\n\n\tmap: function( callback ) {\n\t\treturn this.pushStack( jQuery.map( this, function( elem, i ) {\n\t\t\treturn callback.call( elem, i, elem );\n\t\t} ) );\n\t},\n\n\tslice: function() {\n\t\treturn this.pushStack( slice.apply( this, arguments ) );\n\t},\n\n\tfirst: function() {\n\t\treturn this.eq( 0 );\n\t},\n\n\tlast: function() {\n\t\treturn this.eq( -1 );\n\t},\n\n\teq: function( i ) {\n\t\tvar len = this.length,\n\t\t\tj = +i + ( i < 0 ? len : 0 );\n\t\treturn this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );\n\t},\n\n\tend: function() {\n\t\treturn this.prevObject || this.constructor();\n\t},\n\n\t// For internal use only.\n\t// Behaves like an Array's method, not like a jQuery method.\n\tpush: push,\n\tsort: arr.sort,\n\tsplice: arr.splice\n};\n\njQuery.extend = jQuery.fn.extend = function() {\n\tvar options, name, src, copy, copyIsArray, clone,\n\t\ttarget = arguments[ 0 ] || {},\n\t\ti = 1,\n\t\tlength = arguments.length,\n\t\tdeep = false;\n\n\t// Handle a deep copy situation\n\tif ( typeof target === \"boolean\" ) {\n\t\tdeep = target;\n\n\t\t// Skip the boolean and the target\n\t\ttarget = arguments[ i ] || {};\n\t\ti++;\n\t}\n\n\t// Handle case when target is a string or something (possible in deep copy)\n\tif ( typeof target !== \"object\" && !jQuery.isFunction( target ) ) {\n\t\ttarget = {};\n\t}\n\n\t// Extend jQuery itself if only one argument is passed\n\tif ( i === length ) {\n\t\ttarget = this;\n\t\ti--;\n\t}\n\n\tfor ( ; i < length; i++ ) {\n\n\t\t// Only deal with non-null/undefined values\n\t\tif ( ( options = arguments[ i ] ) != null ) {\n\n\t\t\t// Extend the base object\n\t\t\tfor ( name in options ) {\n\t\t\t\tsrc = target[ name ];\n\t\t\t\tcopy = options[ name ];\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif ( target === copy ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\tif ( deep && copy && ( jQuery.isPlainObject( copy ) ||\n\t\t\t\t\t( copyIsArray = jQuery.isArray( copy ) ) ) ) {\n\n\t\t\t\t\tif ( copyIsArray ) {\n\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\tclone = src && jQuery.isArray( src ) ? src : [];\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclone = src && jQuery.isPlainObject( src ) ? src : {};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\n\n\t\t\t\t// Don't bring in undefined values\n\t\t\t\t} else if ( copy !== undefined ) {\n\t\t\t\t\ttarget[ name ] = copy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\njQuery.extend( {\n\n\t// Unique for each copy of jQuery on the page\n\texpando: \"jQuery\" + ( version + Math.random() ).replace( /\\D/g, \"\" ),\n\n\t// Assume jQuery is ready without the ready module\n\tisReady: true,\n\n\terror: function( msg ) {\n\t\tthrow new Error( msg );\n\t},\n\n\tnoop: function() {},\n\n\tisFunction: function( obj ) {\n\t\treturn jQuery.type( obj ) === \"function\";\n\t},\n\n\tisArray: Array.isArray,\n\n\tisWindow: function( obj ) {\n\t\treturn obj != null && obj === obj.window;\n\t},\n\n\tisNumeric: function( obj ) {\n\n\t\t// parseFloat NaNs numeric-cast false positives (null|true|false|\"\")\n\t\t// ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n\t\t// subtraction forces infinities to NaN\n\t\t// adding 1 corrects loss of precision from parseFloat (#15100)\n\t\tvar realStringObj = obj && obj.toString();\n\t\treturn !jQuery.isArray( obj ) && ( realStringObj - parseFloat( realStringObj ) + 1 ) >= 0;\n\t},\n\n\tisPlainObject: function( obj ) {\n\t\tvar key;\n\n\t\t// Not plain objects:\n\t\t// - Any object or value whose internal [[Class]] property is not \"[object Object]\"\n\t\t// - DOM nodes\n\t\t// - window\n\t\tif ( jQuery.type( obj ) !== \"object\" || obj.nodeType || jQuery.isWindow( obj ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Not own constructor property must be Object\n\t\tif ( obj.constructor &&\n\t\t\t\t!hasOwn.call( obj, \"constructor\" ) &&\n\t\t\t\t!hasOwn.call( obj.constructor.prototype || {}, \"isPrototypeOf\" ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Own properties are enumerated firstly, so to speed up,\n\t\t// if last one is own, then all properties are own\n\t\tfor ( key in obj ) {}\n\n\t\treturn key === undefined || hasOwn.call( obj, key );\n\t},\n\n\tisEmptyObject: function( obj ) {\n\t\tvar name;\n\t\tfor ( name in obj ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\n\ttype: function( obj ) {\n\t\tif ( obj == null ) {\n\t\t\treturn obj + \"\";\n\t\t}\n\n\t\t// Support: Android<4.0, iOS<6 (functionish RegExp)\n\t\treturn typeof obj === \"object\" || typeof obj === \"function\" ?\n\t\t\tclass2type[ toString.call( obj ) ] || \"object\" :\n\t\t\ttypeof obj;\n\t},\n\n\t// Evaluates a script in a global context\n\tglobalEval: function( code ) {\n\t\tvar script,\n\t\t\tindirect = eval;\n\n\t\tcode = jQuery.trim( code );\n\n\t\tif ( code ) {\n\n\t\t\t// If the code includes a valid, prologue position\n\t\t\t// strict mode pragma, execute code by injecting a\n\t\t\t// script tag into the document.\n\t\t\tif ( code.indexOf( \"use strict\" ) === 1 ) {\n\t\t\t\tscript = document.createElement( \"script\" );\n\t\t\t\tscript.text = code;\n\t\t\t\tdocument.head.appendChild( script ).parentNode.removeChild( script );\n\t\t\t} else {\n\n\t\t\t\t// Otherwise, avoid the DOM node creation, insertion\n\t\t\t\t// and removal by using an indirect global eval\n\n\t\t\t\tindirect( code );\n\t\t\t}\n\t\t}\n\t},\n\n\t// Convert dashed to camelCase; used by the css and data modules\n\t// Support: IE9-11+\n\t// Microsoft forgot to hump their vendor prefix (#9572)\n\tcamelCase: function( string ) {\n\t\treturn string.replace( rmsPrefix, \"ms-\" ).replace( rdashAlpha, fcamelCase );\n\t},\n\n\tnodeName: function( elem, name ) {\n\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n\t},\n\n\teach: function( obj, callback ) {\n\t\tvar length, i = 0;\n\n\t\tif ( isArrayLike( obj ) ) {\n\t\t\tlength = obj.length;\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor ( i in obj ) {\n\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn obj;\n\t},\n\n\t// Support: Android<4.1\n\ttrim: function( text ) {\n\t\treturn text == null ?\n\t\t\t\"\" :\n\t\t\t( text + \"\" ).replace( rtrim, \"\" );\n\t},\n\n\t// results is for internal usage only\n\tmakeArray: function( arr, results ) {\n\t\tvar ret = results || [];\n\n\t\tif ( arr != null ) {\n\t\t\tif ( isArrayLike( Object( arr ) ) ) {\n\t\t\t\tjQuery.merge( ret,\n\t\t\t\t\ttypeof arr === \"string\" ?\n\t\t\t\t\t[ arr ] : arr\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tpush.call( ret, arr );\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tinArray: function( elem, arr, i ) {\n\t\treturn arr == null ? -1 : indexOf.call( arr, elem, i );\n\t},\n\n\tmerge: function( first, second ) {\n\t\tvar len = +second.length,\n\t\t\tj = 0,\n\t\t\ti = first.length;\n\n\t\tfor ( ; j < len; j++ ) {\n\t\t\tfirst[ i++ ] = second[ j ];\n\t\t}\n\n\t\tfirst.length = i;\n\n\t\treturn first;\n\t},\n\n\tgrep: function( elems, callback, invert ) {\n\t\tvar callbackInverse,\n\t\t\tmatches = [],\n\t\t\ti = 0,\n\t\t\tlength = elems.length,\n\t\t\tcallbackExpect = !invert;\n\n\t\t// Go through the array, only saving the items\n\t\t// that pass the validator function\n\t\tfor ( ; i < length; i++ ) {\n\t\t\tcallbackInverse = !callback( elems[ i ], i );\n\t\t\tif ( callbackInverse !== callbackExpect ) {\n\t\t\t\tmatches.push( elems[ i ] );\n\t\t\t}\n\t\t}\n\n\t\treturn matches;\n\t},\n\n\t// arg is for internal usage only\n\tmap: function( elems, callback, arg ) {\n\t\tvar length, value,\n\t\t\ti = 0,\n\t\t\tret = [];\n\n\t\t// Go through the array, translating each of the items to their new values\n\t\tif ( isArrayLike( elems ) ) {\n\t\t\tlength = elems.length;\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Go through every key on the object,\n\t\t} else {\n\t\t\tfor ( i in elems ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Flatten any nested arrays\n\t\treturn concat.apply( [], ret );\n\t},\n\n\t// A global GUID counter for objects\n\tguid: 1,\n\n\t// Bind a function to a context, optionally partially applying any\n\t// arguments.\n\tproxy: function( fn, context ) {\n\t\tvar tmp, args, proxy;\n\n\t\tif ( typeof context === \"string\" ) {\n\t\t\ttmp = fn[ context ];\n\t\t\tcontext = fn;\n\t\t\tfn = tmp;\n\t\t}\n\n\t\t// Quick check to determine if target is callable, in the spec\n\t\t// this throws a TypeError, but we will just return undefined.\n\t\tif ( !jQuery.isFunction( fn ) ) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Simulated bind\n\t\targs = slice.call( arguments, 2 );\n\t\tproxy = function() {\n\t\t\treturn fn.apply( context || this, args.concat( slice.call( arguments ) ) );\n\t\t};\n\n\t\t// Set the guid of unique handler to the same of original handler, so it can be removed\n\t\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\n\n\t\treturn proxy;\n\t},\n\n\tnow: Date.now,\n\n\t// jQuery.support is not used in Core but other projects attach their\n\t// properties to it so it needs to exist.\n\tsupport: support\n} );\n\n// JSHint would error on this code due to the Symbol not being defined in ES5.\n// Defining this global in .jshintrc would create a danger of using the global\n// unguarded in another place, it seems safer to just disable JSHint for these\n// three lines.\n/* jshint ignore: start */\nif ( typeof Symbol === \"function\" ) {\n\tjQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];\n}\n/* jshint ignore: end */\n\n// Populate the class2type map\njQuery.each( \"Boolean Number String Function Array Date RegExp Object Error Symbol\".split( \" \" ),\nfunction( i, name ) {\n\tclass2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\n} );\n\nfunction isArrayLike( obj ) {\n\n\t// Support: iOS 8.2 (not reproducible in simulator)\n\t// `in` check used to prevent JIT error (gh-2145)\n\t// hasOwn isn't used here due to false negatives\n\t// regarding Nodelist length in IE\n\tvar length = !!obj && \"length\" in obj && obj.length,\n\t\ttype = jQuery.type( obj );\n\n\tif ( type === \"function\" || jQuery.isWindow( obj ) ) {\n\t\treturn false;\n\t}\n\n\treturn type === \"array\" || length === 0 ||\n\t\ttypeof length === \"number\" && length > 0 && ( length - 1 ) in obj;\n}\nvar Sizzle =\n/*!\n * Sizzle CSS Selector Engine v2.2.1\n * http://sizzlejs.com/\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2015-10-17\n */\n(function( window ) {\n\nvar i,\n\tsupport,\n\tExpr,\n\tgetText,\n\tisXML,\n\ttokenize,\n\tcompile,\n\tselect,\n\toutermostContext,\n\tsortInput,\n\thasDuplicate,\n\n\t// Local document vars\n\tsetDocument,\n\tdocument,\n\tdocElem,\n\tdocumentIsHTML,\n\trbuggyQSA,\n\trbuggyMatches,\n\tmatches,\n\tcontains,\n\n\t// Instance-specific data\n\texpando = \"sizzle\" + 1 * new Date(),\n\tpreferredDoc = window.document,\n\tdirruns = 0,\n\tdone = 0,\n\tclassCache = createCache(),\n\ttokenCache = createCache(),\n\tcompilerCache = createCache(),\n\tsortOrder = function( a, b ) {\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t}\n\t\treturn 0;\n\t},\n\n\t// General-purpose constants\n\tMAX_NEGATIVE = 1 << 31,\n\n\t// Instance methods\n\thasOwn = ({}).hasOwnProperty,\n\tarr = [],\n\tpop = arr.pop,\n\tpush_native = arr.push,\n\tpush = arr.push,\n\tslice = arr.slice,\n\t// Use a stripped-down indexOf as it's faster than native\n\t// http://jsperf.com/thor-indexof-vs-for/5\n\tindexOf = function( list, elem ) {\n\t\tvar i = 0,\n\t\t\tlen = list.length;\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tif ( list[i] === elem ) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t},\n\n\tbooleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\n\n\t// Regular expressions\n\n\t// http://www.w3.org/TR/css3-selectors/#whitespace\n\twhitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n\n\t// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n\tidentifier = \"(?:\\\\\\\\.|[\\\\w-]|[^\\\\x00-\\\\xa0])+\",\n\n\t// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n\tattributes = \"\\\\[\" + whitespace + \"*(\" + identifier + \")(?:\" + whitespace +\n\t\t// Operator (capture 2)\n\t\t\"*([*^$|!~]?=)\" + whitespace +\n\t\t// \"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\"\n\t\t\"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" + whitespace +\n\t\t\"*\\\\]\",\n\n\tpseudos = \":(\" + identifier + \")(?:\\\\((\" +\n\t\t// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n\t\t// 1. quoted (capture 3; capture 4 or capture 5)\n\t\t\"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" +\n\t\t// 2. simple (capture 6)\n\t\t\"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" +\n\t\t// 3. anything else (capture 2)\n\t\t\".*\" +\n\t\t\")\\\\)|)\",\n\n\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n\trwhitespace = new RegExp( whitespace + \"+\", \"g\" ),\n\trtrim = new RegExp( \"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\" ),\n\n\trcomma = new RegExp( \"^\" + whitespace + \"*,\" + whitespace + \"*\" ),\n\trcombinators = new RegExp( \"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\" ),\n\n\trattributeQuotes = new RegExp( \"=\" + whitespace + \"*([^\\\\]'\\\"]*?)\" + whitespace + \"*\\\\]\", \"g\" ),\n\n\trpseudo = new RegExp( pseudos ),\n\tridentifier = new RegExp( \"^\" + identifier + \"$\" ),\n\n\tmatchExpr = {\n\t\t\"ID\": new RegExp( \"^#(\" + identifier + \")\" ),\n\t\t\"CLASS\": new RegExp( \"^\\\\.(\" + identifier + \")\" ),\n\t\t\"TAG\": new RegExp( \"^(\" + identifier + \"|[*])\" ),\n\t\t\"ATTR\": new RegExp( \"^\" + attributes ),\n\t\t\"PSEUDO\": new RegExp( \"^\" + pseudos ),\n\t\t\"CHILD\": new RegExp( \"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace +\n\t\t\t\"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace +\n\t\t\t\"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\" ),\n\t\t\"bool\": new RegExp( \"^(?:\" + booleans + \")$\", \"i\" ),\n\t\t// For use in libraries implementing .is()\n\t\t// We use this for POS matching in `select`\n\t\t\"needsContext\": new RegExp( \"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" +\n\t\t\twhitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\" )\n\t},\n\n\trinputs = /^(?:input|select|textarea|button)$/i,\n\trheader = /^h\\d$/i,\n\n\trnative = /^[^{]+\\{\\s*\\[native \\w/,\n\n\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\n\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\n\trsibling = /[+~]/,\n\trescape = /'|\\\\/g,\n\n\t// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n\trunescape = new RegExp( \"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\", \"ig\" ),\n\tfunescape = function( _, escaped, escapedWhitespace ) {\n\t\tvar high = \"0x\" + escaped - 0x10000;\n\t\t// NaN means non-codepoint\n\t\t// Support: Firefox<24\n\t\t// Workaround erroneous numeric interpretation of +\"0x\"\n\t\treturn high !== high || escapedWhitespace ?\n\t\t\tescaped :\n\t\t\thigh < 0 ?\n\t\t\t\t// BMP codepoint\n\t\t\t\tString.fromCharCode( high + 0x10000 ) :\n\t\t\t\t// Supplemental Plane codepoint (surrogate pair)\n\t\t\t\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n\t},\n\n\t// Used for iframes\n\t// See setDocument()\n\t// Removing the function wrapper causes a \"Permission Denied\"\n\t// error in IE\n\tunloadHandler = function() {\n\t\tsetDocument();\n\t};\n\n// Optimize for push.apply( _, NodeList )\ntry {\n\tpush.apply(\n\t\t(arr = slice.call( preferredDoc.childNodes )),\n\t\tpreferredDoc.childNodes\n\t);\n\t// Support: Android<4.0\n\t// Detect silently failing push.apply\n\tarr[ preferredDoc.childNodes.length ].nodeType;\n} catch ( e ) {\n\tpush = { apply: arr.length ?\n\n\t\t// Leverage slice if possible\n\t\tfunction( target, els ) {\n\t\t\tpush_native.apply( target, slice.call(els) );\n\t\t} :\n\n\t\t// Support: IE<9\n\t\t// Otherwise append directly\n\t\tfunction( target, els ) {\n\t\t\tvar j = target.length,\n\t\t\t\ti = 0;\n\t\t\t// Can't trust NodeList.length\n\t\t\twhile ( (target[j++] = els[i++]) ) {}\n\t\t\ttarget.length = j - 1;\n\t\t}\n\t};\n}\n\nfunction Sizzle( selector, context, results, seed ) {\n\tvar m, i, elem, nid, nidselect, match, groups, newSelector,\n\t\tnewContext = context && context.ownerDocument,\n\n\t\t// nodeType defaults to 9, since context defaults to document\n\t\tnodeType = context ? context.nodeType : 9;\n\n\tresults = results || [];\n\n\t// Return early from calls with invalid selector or context\n\tif ( typeof selector !== \"string\" || !selector ||\n\t\tnodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {\n\n\t\treturn results;\n\t}\n\n\t// Try to shortcut find operations (as opposed to filters) in HTML documents\n\tif ( !seed ) {\n\n\t\tif ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\n\t\t\tsetDocument( context );\n\t\t}\n\t\tcontext = context || document;\n\n\t\tif ( documentIsHTML ) {\n\n\t\t\t// If the selector is sufficiently simple, try using a \"get*By*\" DOM method\n\t\t\t// (excepting DocumentFragment context, where the methods don't exist)\n\t\t\tif ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {\n\n\t\t\t\t// ID selector\n\t\t\t\tif ( (m = match[1]) ) {\n\n\t\t\t\t\t// Document context\n\t\t\t\t\tif ( nodeType === 9 ) {\n\t\t\t\t\t\tif ( (elem = context.getElementById( m )) ) {\n\n\t\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\t\tif ( elem.id === m ) {\n\t\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t// Element context\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\tif ( newContext && (elem = newContext.getElementById( m )) &&\n\t\t\t\t\t\t\tcontains( context, elem ) &&\n\t\t\t\t\t\t\telem.id === m ) {\n\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t// Type selector\n\t\t\t\t} else if ( match[2] ) {\n\t\t\t\t\tpush.apply( results, context.getElementsByTagName( selector ) );\n\t\t\t\t\treturn results;\n\n\t\t\t\t// Class selector\n\t\t\t\t} else if ( (m = match[3]) && support.getElementsByClassName &&\n\t\t\t\t\tcontext.getElementsByClassName ) {\n\n\t\t\t\t\tpush.apply( results, context.getElementsByClassName( m ) );\n\t\t\t\t\treturn results;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Take advantage of querySelectorAll\n\t\t\tif ( support.qsa &&\n\t\t\t\t!compilerCache[ selector + \" \" ] &&\n\t\t\t\t(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {\n\n\t\t\t\tif ( nodeType !== 1 ) {\n\t\t\t\t\tnewContext = context;\n\t\t\t\t\tnewSelector = selector;\n\n\t\t\t\t// qSA looks outside Element context, which is not what we want\n\t\t\t\t// Thanks to Andrew Dupont for this workaround technique\n\t\t\t\t// Support: IE <=8\n\t\t\t\t// Exclude object elements\n\t\t\t\t} else if ( context.nodeName.toLowerCase() !== \"object\" ) {\n\n\t\t\t\t\t// Capture the context ID, setting it first if necessary\n\t\t\t\t\tif ( (nid = context.getAttribute( \"id\" )) ) {\n\t\t\t\t\t\tnid = nid.replace( rescape, \"\\\\$&\" );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontext.setAttribute( \"id\", (nid = expando) );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prefix every selector in the list\n\t\t\t\t\tgroups = tokenize( selector );\n\t\t\t\t\ti = groups.length;\n\t\t\t\t\tnidselect = ridentifier.test( nid ) ? \"#\" + nid : \"[id='\" + nid + \"']\";\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tgroups[i] = nidselect + \" \" + toSelector( groups[i] );\n\t\t\t\t\t}\n\t\t\t\t\tnewSelector = groups.join( \",\" );\n\n\t\t\t\t\t// Expand context for sibling selectors\n\t\t\t\t\tnewContext = rsibling.test( selector ) && testContext( context.parentNode ) ||\n\t\t\t\t\t\tcontext;\n\t\t\t\t}\n\n\t\t\t\tif ( newSelector ) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tpush.apply( results,\n\t\t\t\t\t\t\tnewContext.querySelectorAll( newSelector )\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t} catch ( qsaError ) {\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tif ( nid === expando ) {\n\t\t\t\t\t\t\tcontext.removeAttribute( \"id\" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// All others\n\treturn select( selector.replace( rtrim, \"$1\" ), context, results, seed );\n}\n\n/**\n * Create key-value caches of limited size\n * @returns {function(string, object)} Returns the Object data after storing it on itself with\n *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n *\tdeleting the oldest entry\n */\nfunction createCache() {\n\tvar keys = [];\n\n\tfunction cache( key, value ) {\n\t\t// Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n\t\tif ( keys.push( key + \" \" ) > Expr.cacheLength ) {\n\t\t\t// Only keep the most recent entries\n\t\t\tdelete cache[ keys.shift() ];\n\t\t}\n\t\treturn (cache[ key + \" \" ] = value);\n\t}\n\treturn cache;\n}\n\n/**\n * Mark a function for special use by Sizzle\n * @param {Function} fn The function to mark\n */\nfunction markFunction( fn ) {\n\tfn[ expando ] = true;\n\treturn fn;\n}\n\n/**\n * Support testing using an element\n * @param {Function} fn Passed the created div and expects a boolean result\n */\nfunction assert( fn ) {\n\tvar div = document.createElement(\"div\");\n\n\ttry {\n\t\treturn !!fn( div );\n\t} catch (e) {\n\t\treturn false;\n\t} finally {\n\t\t// Remove from its parent by default\n\t\tif ( div.parentNode ) {\n\t\t\tdiv.parentNode.removeChild( div );\n\t\t}\n\t\t// release memory in IE\n\t\tdiv = null;\n\t}\n}\n\n/**\n * Adds the same handler for all of the specified attrs\n * @param {String} attrs Pipe-separated list of attributes\n * @param {Function} handler The method that will be applied\n */\nfunction addHandle( attrs, handler ) {\n\tvar arr = attrs.split(\"|\"),\n\t\ti = arr.length;\n\n\twhile ( i-- ) {\n\t\tExpr.attrHandle[ arr[i] ] = handler;\n\t}\n}\n\n/**\n * Checks document order of two siblings\n * @param {Element} a\n * @param {Element} b\n * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n */\nfunction siblingCheck( a, b ) {\n\tvar cur = b && a,\n\t\tdiff = cur && a.nodeType === 1 && b.nodeType === 1 &&\n\t\t\t( ~b.sourceIndex || MAX_NEGATIVE ) -\n\t\t\t( ~a.sourceIndex || MAX_NEGATIVE );\n\n\t// Use IE sourceIndex if available on both nodes\n\tif ( diff ) {\n\t\treturn diff;\n\t}\n\n\t// Check if b follows a\n\tif ( cur ) {\n\t\twhile ( (cur = cur.nextSibling) ) {\n\t\t\tif ( cur === b ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn a ? 1 : -1;\n}\n\n/**\n * Returns a function to use in pseudos for input types\n * @param {String} type\n */\nfunction createInputPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn name === \"input\" && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for buttons\n * @param {String} type\n */\nfunction createButtonPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn (name === \"input\" || name === \"button\") && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for positionals\n * @param {Function} fn\n */\nfunction createPositionalPseudo( fn ) {\n\treturn markFunction(function( argument ) {\n\t\targument = +argument;\n\t\treturn markFunction(function( seed, matches ) {\n\t\t\tvar j,\n\t\t\t\tmatchIndexes = fn( [], seed.length, argument ),\n\t\t\t\ti = matchIndexes.length;\n\n\t\t\t// Match elements found at the specified indexes\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( seed[ (j = matchIndexes[i]) ] ) {\n\t\t\t\t\tseed[j] = !(matches[j] = seed[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Checks a node for validity as a Sizzle context\n * @param {Element|Object=} context\n * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n */\nfunction testContext( context ) {\n\treturn context && typeof context.getElementsByTagName !== \"undefined\" && context;\n}\n\n// Expose support vars for convenience\nsupport = Sizzle.support = {};\n\n/**\n * Detects XML nodes\n * @param {Element|Object} elem An element or a document\n * @returns {Boolean} True iff elem is a non-HTML XML node\n */\nisXML = Sizzle.isXML = function( elem ) {\n\t// documentElement is verified for cases where it doesn't yet exist\n\t// (such as loading iframes in IE - #4833)\n\tvar documentElement = elem && (elem.ownerDocument || elem).documentElement;\n\treturn documentElement ? documentElement.nodeName !== \"HTML\" : false;\n};\n\n/**\n * Sets document-related variables once based on the current document\n * @param {Element|Object} [doc] An element or document object to use to set the document\n * @returns {Object} Returns the current document\n */\nsetDocument = Sizzle.setDocument = function( node ) {\n\tvar hasCompare, parent,\n\t\tdoc = node ? node.ownerDocument || node : preferredDoc;\n\n\t// Return early if doc is invalid or already selected\n\tif ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\n\t\treturn document;\n\t}\n\n\t// Update global variables\n\tdocument = doc;\n\tdocElem = document.documentElement;\n\tdocumentIsHTML = !isXML( document );\n\n\t// Support: IE 9-11, Edge\n\t// Accessing iframe documents after unload throws \"permission denied\" errors (jQuery #13936)\n\tif ( (parent = document.defaultView) && parent.top !== parent ) {\n\t\t// Support: IE 11\n\t\tif ( parent.addEventListener ) {\n\t\t\tparent.addEventListener( \"unload\", unloadHandler, false );\n\n\t\t// Support: IE 9 - 10 only\n\t\t} else if ( parent.attachEvent ) {\n\t\t\tparent.attachEvent( \"onunload\", unloadHandler );\n\t\t}\n\t}\n\n\t/* Attributes\n\t---------------------------------------------------------------------- */\n\n\t// Support: IE<8\n\t// Verify that getAttribute really returns attributes and not properties\n\t// (excepting IE8 booleans)\n\tsupport.attributes = assert(function( div ) {\n\t\tdiv.className = \"i\";\n\t\treturn !div.getAttribute(\"className\");\n\t});\n\n\t/* getElement(s)By*\n\t---------------------------------------------------------------------- */\n\n\t// Check if getElementsByTagName(\"*\") returns only elements\n\tsupport.getElementsByTagName = assert(function( div ) {\n\t\tdiv.appendChild( document.createComment(\"\") );\n\t\treturn !div.getElementsByTagName(\"*\").length;\n\t});\n\n\t// Support: IE<9\n\tsupport.getElementsByClassName = rnative.test( document.getElementsByClassName );\n\n\t// Support: IE<10\n\t// Check if getElementById returns elements by name\n\t// The broken getElementById methods don't pick up programatically-set names,\n\t// so use a roundabout getElementsByName test\n\tsupport.getById = assert(function( div ) {\n\t\tdocElem.appendChild( div ).id = expando;\n\t\treturn !document.getElementsByName || !document.getElementsByName( expando ).length;\n\t});\n\n\t// ID find and filter\n\tif ( support.getById ) {\n\t\tExpr.find[\"ID\"] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\tvar m = context.getElementById( id );\n\t\t\t\treturn m ? [ m ] : [];\n\t\t\t}\n\t\t};\n\t\tExpr.filter[\"ID\"] = function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn elem.getAttribute(\"id\") === attrId;\n\t\t\t};\n\t\t};\n\t} else {\n\t\t// Support: IE6/7\n\t\t// getElementById is not reliable as a find shortcut\n\t\tdelete Expr.find[\"ID\"];\n\n\t\tExpr.filter[\"ID\"] =  function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\tvar node = typeof elem.getAttributeNode !== \"undefined\" &&\n\t\t\t\t\telem.getAttributeNode(\"id\");\n\t\t\t\treturn node && node.value === attrId;\n\t\t\t};\n\t\t};\n\t}\n\n\t// Tag\n\tExpr.find[\"TAG\"] = support.getElementsByTagName ?\n\t\tfunction( tag, context ) {\n\t\t\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n\t\t\t\treturn context.getElementsByTagName( tag );\n\n\t\t\t// DocumentFragment nodes don't have gEBTN\n\t\t\t} else if ( support.qsa ) {\n\t\t\t\treturn context.querySelectorAll( tag );\n\t\t\t}\n\t\t} :\n\n\t\tfunction( tag, context ) {\n\t\t\tvar elem,\n\t\t\t\ttmp = [],\n\t\t\t\ti = 0,\n\t\t\t\t// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n\t\t\t\tresults = context.getElementsByTagName( tag );\n\n\t\t\t// Filter out possible comments\n\t\t\tif ( tag === \"*\" ) {\n\t\t\t\twhile ( (elem = results[i++]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\ttmp.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\n\t// Class\n\tExpr.find[\"CLASS\"] = support.getElementsByClassName && function( className, context ) {\n\t\tif ( typeof context.getElementsByClassName !== \"undefined\" && documentIsHTML ) {\n\t\t\treturn context.getElementsByClassName( className );\n\t\t}\n\t};\n\n\t/* QSA/matchesSelector\n\t---------------------------------------------------------------------- */\n\n\t// QSA and matchesSelector support\n\n\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\trbuggyMatches = [];\n\n\t// qSa(:focus) reports false when true (Chrome 21)\n\t// We allow this because of a bug in IE8/9 that throws an error\n\t// whenever `document.activeElement` is accessed on an iframe\n\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\n\t// See http://bugs.jquery.com/ticket/13378\n\trbuggyQSA = [];\n\n\tif ( (support.qsa = rnative.test( document.querySelectorAll )) ) {\n\t\t// Build QSA regex\n\t\t// Regex strategy adopted from Diego Perini\n\t\tassert(function( div ) {\n\t\t\t// Select is set to empty string on purpose\n\t\t\t// This is to test IE's treatment of not explicitly\n\t\t\t// setting a boolean content attribute,\n\t\t\t// since its presence should be enough\n\t\t\t// http://bugs.jquery.com/ticket/12359\n\t\t\tdocElem.appendChild( div ).innerHTML = \"<a id='\" + expando + \"'></a>\" +\n\t\t\t\t\"<select id='\" + expando + \"-\\r\\\\' msallowcapture=''>\" +\n\t\t\t\t\"<option selected=''></option></select>\";\n\n\t\t\t// Support: IE8, Opera 11-12.16\n\t\t\t// Nothing should be selected when empty strings follow ^= or $= or *=\n\t\t\t// The test attribute must be unknown in Opera but \"safe\" for WinRT\n\t\t\t// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n\t\t\tif ( div.querySelectorAll(\"[msallowcapture^='']\").length ) {\n\t\t\t\trbuggyQSA.push( \"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\" );\n\t\t\t}\n\n\t\t\t// Support: IE8\n\t\t\t// Boolean attributes and \"value\" are not treated correctly\n\t\t\tif ( !div.querySelectorAll(\"[selected]\").length ) {\n\t\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\" );\n\t\t\t}\n\n\t\t\t// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\n\t\t\tif ( !div.querySelectorAll( \"[id~=\" + expando + \"-]\" ).length ) {\n\t\t\t\trbuggyQSA.push(\"~=\");\n\t\t\t}\n\n\t\t\t// Webkit/Opera - :checked should return selected option elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( !div.querySelectorAll(\":checked\").length ) {\n\t\t\t\trbuggyQSA.push(\":checked\");\n\t\t\t}\n\n\t\t\t// Support: Safari 8+, iOS 8+\n\t\t\t// https://bugs.webkit.org/show_bug.cgi?id=136851\n\t\t\t// In-page `selector#id sibing-combinator selector` fails\n\t\t\tif ( !div.querySelectorAll( \"a#\" + expando + \"+*\" ).length ) {\n\t\t\t\trbuggyQSA.push(\".#.+[+~]\");\n\t\t\t}\n\t\t});\n\n\t\tassert(function( div ) {\n\t\t\t// Support: Windows 8 Native Apps\n\t\t\t// The type and name attributes are restricted during .innerHTML assignment\n\t\t\tvar input = document.createElement(\"input\");\n\t\t\tinput.setAttribute( \"type\", \"hidden\" );\n\t\t\tdiv.appendChild( input ).setAttribute( \"name\", \"D\" );\n\n\t\t\t// Support: IE8\n\t\t\t// Enforce case-sensitivity of name attribute\n\t\t\tif ( div.querySelectorAll(\"[name=d]\").length ) {\n\t\t\t\trbuggyQSA.push( \"name\" + whitespace + \"*[*^$|!~]?=\" );\n\t\t\t}\n\n\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( !div.querySelectorAll(\":enabled\").length ) {\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t}\n\n\t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\n\t\t\tdiv.querySelectorAll(\"*,:x\");\n\t\t\trbuggyQSA.push(\",.*:\");\n\t\t});\n\t}\n\n\tif ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||\n\t\tdocElem.webkitMatchesSelector ||\n\t\tdocElem.mozMatchesSelector ||\n\t\tdocElem.oMatchesSelector ||\n\t\tdocElem.msMatchesSelector) )) ) {\n\n\t\tassert(function( div ) {\n\t\t\t// Check to see if it's possible to do matchesSelector\n\t\t\t// on a disconnected node (IE 9)\n\t\t\tsupport.disconnectedMatch = matches.call( div, \"div\" );\n\n\t\t\t// This should fail with an exception\n\t\t\t// Gecko does not error, returns false instead\n\t\t\tmatches.call( div, \"[s!='']:x\" );\n\t\t\trbuggyMatches.push( \"!=\", pseudos );\n\t\t});\n\t}\n\n\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join(\"|\") );\n\trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join(\"|\") );\n\n\t/* Contains\n\t---------------------------------------------------------------------- */\n\thasCompare = rnative.test( docElem.compareDocumentPosition );\n\n\t// Element contains another\n\t// Purposefully self-exclusive\n\t// As in, an element does not contain itself\n\tcontains = hasCompare || rnative.test( docElem.contains ) ?\n\t\tfunction( a, b ) {\n\t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\n\t\t\t\tbup = b && b.parentNode;\n\t\t\treturn a === bup || !!( bup && bup.nodeType === 1 && (\n\t\t\t\tadown.contains ?\n\t\t\t\t\tadown.contains( bup ) :\n\t\t\t\t\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n\t\t\t));\n\t\t} :\n\t\tfunction( a, b ) {\n\t\t\tif ( b ) {\n\t\t\t\twhile ( (b = b.parentNode) ) {\n\t\t\t\t\tif ( b === a ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t/* Sorting\n\t---------------------------------------------------------------------- */\n\n\t// Document order sorting\n\tsortOrder = hasCompare ?\n\tfunction( a, b ) {\n\n\t\t// Flag for duplicate removal\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Sort on method existence if only one input has compareDocumentPosition\n\t\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\t\tif ( compare ) {\n\t\t\treturn compare;\n\t\t}\n\n\t\t// Calculate position if both inputs belong to the same document\n\t\tcompare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?\n\t\t\ta.compareDocumentPosition( b ) :\n\n\t\t\t// Otherwise we know they are disconnected\n\t\t\t1;\n\n\t\t// Disconnected nodes\n\t\tif ( compare & 1 ||\n\t\t\t(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {\n\n\t\t\t// Choose the first element that is related to our preferred document\n\t\t\tif ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t// Maintain original order\n\t\t\treturn sortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\t\t}\n\n\t\treturn compare & 4 ? -1 : 1;\n\t} :\n\tfunction( a, b ) {\n\t\t// Exit early if the nodes are identical\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\taup = a.parentNode,\n\t\t\tbup = b.parentNode,\n\t\t\tap = [ a ],\n\t\t\tbp = [ b ];\n\n\t\t// Parentless nodes are either documents or disconnected\n\t\tif ( !aup || !bup ) {\n\t\t\treturn a === document ? -1 :\n\t\t\t\tb === document ? 1 :\n\t\t\t\taup ? -1 :\n\t\t\t\tbup ? 1 :\n\t\t\t\tsortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\n\t\t// If the nodes are siblings, we can do a quick check\n\t\t} else if ( aup === bup ) {\n\t\t\treturn siblingCheck( a, b );\n\t\t}\n\n\t\t// Otherwise we need full lists of their ancestors for comparison\n\t\tcur = a;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tap.unshift( cur );\n\t\t}\n\t\tcur = b;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tbp.unshift( cur );\n\t\t}\n\n\t\t// Walk down the tree looking for a discrepancy\n\t\twhile ( ap[i] === bp[i] ) {\n\t\t\ti++;\n\t\t}\n\n\t\treturn i ?\n\t\t\t// Do a sibling check if the nodes have a common ancestor\n\t\t\tsiblingCheck( ap[i], bp[i] ) :\n\n\t\t\t// Otherwise nodes in our document sort first\n\t\t\tap[i] === preferredDoc ? -1 :\n\t\t\tbp[i] === preferredDoc ? 1 :\n\t\t\t0;\n\t};\n\n\treturn document;\n};\n\nSizzle.matches = function( expr, elements ) {\n\treturn Sizzle( expr, null, null, elements );\n};\n\nSizzle.matchesSelector = function( elem, expr ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\t// Make sure that attribute selectors are quoted\n\texpr = expr.replace( rattributeQuotes, \"='$1']\" );\n\n\tif ( support.matchesSelector && documentIsHTML &&\n\t\t!compilerCache[ expr + \" \" ] &&\n\t\t( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\n\t\t( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\n\n\t\ttry {\n\t\t\tvar ret = matches.call( elem, expr );\n\n\t\t\t// IE 9's matchesSelector returns false on disconnected nodes\n\t\t\tif ( ret || support.disconnectedMatch ||\n\t\t\t\t\t// As well, disconnected nodes are said to be in a document\n\t\t\t\t\t// fragment in IE 9\n\t\t\t\t\telem.document && elem.document.nodeType !== 11 ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} catch (e) {}\n\t}\n\n\treturn Sizzle( expr, document, null, [ elem ] ).length > 0;\n};\n\nSizzle.contains = function( context, elem ) {\n\t// Set document vars if needed\n\tif ( ( context.ownerDocument || context ) !== document ) {\n\t\tsetDocument( context );\n\t}\n\treturn contains( context, elem );\n};\n\nSizzle.attr = function( elem, name ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\n\t\t// Don't get fooled by Object.prototype properties (jQuery #13807)\n\t\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\n\t\t\tfn( elem, name, !documentIsHTML ) :\n\t\t\tundefined;\n\n\treturn val !== undefined ?\n\t\tval :\n\t\tsupport.attributes || !documentIsHTML ?\n\t\t\telem.getAttribute( name ) :\n\t\t\t(val = elem.getAttributeNode(name)) && val.specified ?\n\t\t\t\tval.value :\n\t\t\t\tnull;\n};\n\nSizzle.error = function( msg ) {\n\tthrow new Error( \"Syntax error, unrecognized expression: \" + msg );\n};\n\n/**\n * Document sorting and removing duplicates\n * @param {ArrayLike} results\n */\nSizzle.uniqueSort = function( results ) {\n\tvar elem,\n\t\tduplicates = [],\n\t\tj = 0,\n\t\ti = 0;\n\n\t// Unless we *know* we can detect duplicates, assume their presence\n\thasDuplicate = !support.detectDuplicates;\n\tsortInput = !support.sortStable && results.slice( 0 );\n\tresults.sort( sortOrder );\n\n\tif ( hasDuplicate ) {\n\t\twhile ( (elem = results[i++]) ) {\n\t\t\tif ( elem === results[ i ] ) {\n\t\t\t\tj = duplicates.push( i );\n\t\t\t}\n\t\t}\n\t\twhile ( j-- ) {\n\t\t\tresults.splice( duplicates[ j ], 1 );\n\t\t}\n\t}\n\n\t// Clear input after sorting to release objects\n\t// See https://github.com/jquery/sizzle/pull/225\n\tsortInput = null;\n\n\treturn results;\n};\n\n/**\n * Utility function for retrieving the text value of an array of DOM nodes\n * @param {Array|Element} elem\n */\ngetText = Sizzle.getText = function( elem ) {\n\tvar node,\n\t\tret = \"\",\n\t\ti = 0,\n\t\tnodeType = elem.nodeType;\n\n\tif ( !nodeType ) {\n\t\t// If no nodeType, this is expected to be an array\n\t\twhile ( (node = elem[i++]) ) {\n\t\t\t// Do not traverse comment nodes\n\t\t\tret += getText( node );\n\t\t}\n\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\n\t\t// Use textContent for elements\n\t\t// innerText usage removed for consistency of new lines (jQuery #11153)\n\t\tif ( typeof elem.textContent === \"string\" ) {\n\t\t\treturn elem.textContent;\n\t\t} else {\n\t\t\t// Traverse its children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tret += getText( elem );\n\t\t\t}\n\t\t}\n\t} else if ( nodeType === 3 || nodeType === 4 ) {\n\t\treturn elem.nodeValue;\n\t}\n\t// Do not include comment or processing instruction nodes\n\n\treturn ret;\n};\n\nExpr = Sizzle.selectors = {\n\n\t// Can be adjusted by the user\n\tcacheLength: 50,\n\n\tcreatePseudo: markFunction,\n\n\tmatch: matchExpr,\n\n\tattrHandle: {},\n\n\tfind: {},\n\n\trelative: {\n\t\t\">\": { dir: \"parentNode\", first: true },\n\t\t\" \": { dir: \"parentNode\" },\n\t\t\"+\": { dir: \"previousSibling\", first: true },\n\t\t\"~\": { dir: \"previousSibling\" }\n\t},\n\n\tpreFilter: {\n\t\t\"ATTR\": function( match ) {\n\t\t\tmatch[1] = match[1].replace( runescape, funescape );\n\n\t\t\t// Move the given value to match[3] whether quoted or unquoted\n\t\t\tmatch[3] = ( match[3] || match[4] || match[5] || \"\" ).replace( runescape, funescape );\n\n\t\t\tif ( match[2] === \"~=\" ) {\n\t\t\t\tmatch[3] = \" \" + match[3] + \" \";\n\t\t\t}\n\n\t\t\treturn match.slice( 0, 4 );\n\t\t},\n\n\t\t\"CHILD\": function( match ) {\n\t\t\t/* matches from matchExpr[\"CHILD\"]\n\t\t\t\t1 type (only|nth|...)\n\t\t\t\t2 what (child|of-type)\n\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\n\t\t\t\t5 sign of xn-component\n\t\t\t\t6 x of xn-component\n\t\t\t\t7 sign of y-component\n\t\t\t\t8 y of y-component\n\t\t\t*/\n\t\t\tmatch[1] = match[1].toLowerCase();\n\n\t\t\tif ( match[1].slice( 0, 3 ) === \"nth\" ) {\n\t\t\t\t// nth-* requires argument\n\t\t\t\tif ( !match[3] ) {\n\t\t\t\t\tSizzle.error( match[0] );\n\t\t\t\t}\n\n\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\n\t\t\t\t// remember that false/true cast respectively to 0/1\n\t\t\t\tmatch[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === \"even\" || match[3] === \"odd\" ) );\n\t\t\t\tmatch[5] = +( ( match[7] + match[8] ) || match[3] === \"odd\" );\n\n\t\t\t// other types prohibit arguments\n\t\t\t} else if ( match[3] ) {\n\t\t\t\tSizzle.error( match[0] );\n\t\t\t}\n\n\t\t\treturn match;\n\t\t},\n\n\t\t\"PSEUDO\": function( match ) {\n\t\t\tvar excess,\n\t\t\t\tunquoted = !match[6] && match[2];\n\n\t\t\tif ( matchExpr[\"CHILD\"].test( match[0] ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Accept quoted arguments as-is\n\t\t\tif ( match[3] ) {\n\t\t\t\tmatch[2] = match[4] || match[5] || \"\";\n\n\t\t\t// Strip excess characters from unquoted arguments\n\t\t\t} else if ( unquoted && rpseudo.test( unquoted ) &&\n\t\t\t\t// Get excess from tokenize (recursively)\n\t\t\t\t(excess = tokenize( unquoted, true )) &&\n\t\t\t\t// advance to the next closing parenthesis\n\t\t\t\t(excess = unquoted.indexOf( \")\", unquoted.length - excess ) - unquoted.length) ) {\n\n\t\t\t\t// excess is a negative index\n\t\t\t\tmatch[0] = match[0].slice( 0, excess );\n\t\t\t\tmatch[2] = unquoted.slice( 0, excess );\n\t\t\t}\n\n\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\n\t\t\treturn match.slice( 0, 3 );\n\t\t}\n\t},\n\n\tfilter: {\n\n\t\t\"TAG\": function( nodeNameSelector ) {\n\t\t\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn nodeNameSelector === \"*\" ?\n\t\t\t\tfunction() { return true; } :\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n\t\t\t\t};\n\t\t},\n\n\t\t\"CLASS\": function( className ) {\n\t\t\tvar pattern = classCache[ className + \" \" ];\n\n\t\t\treturn pattern ||\n\t\t\t\t(pattern = new RegExp( \"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\" )) &&\n\t\t\t\tclassCache( className, function( elem ) {\n\t\t\t\t\treturn pattern.test( typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== \"undefined\" && elem.getAttribute(\"class\") || \"\" );\n\t\t\t\t});\n\t\t},\n\n\t\t\"ATTR\": function( name, operator, check ) {\n\t\t\treturn function( elem ) {\n\t\t\t\tvar result = Sizzle.attr( elem, name );\n\n\t\t\t\tif ( result == null ) {\n\t\t\t\t\treturn operator === \"!=\";\n\t\t\t\t}\n\t\t\t\tif ( !operator ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tresult += \"\";\n\n\t\t\t\treturn operator === \"=\" ? result === check :\n\t\t\t\t\toperator === \"!=\" ? result !== check :\n\t\t\t\t\toperator === \"^=\" ? check && result.indexOf( check ) === 0 :\n\t\t\t\t\toperator === \"*=\" ? check && result.indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"$=\" ? check && result.slice( -check.length ) === check :\n\t\t\t\t\toperator === \"~=\" ? ( \" \" + result.replace( rwhitespace, \" \" ) + \" \" ).indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"|=\" ? result === check || result.slice( 0, check.length + 1 ) === check + \"-\" :\n\t\t\t\t\tfalse;\n\t\t\t};\n\t\t},\n\n\t\t\"CHILD\": function( type, what, argument, first, last ) {\n\t\t\tvar simple = type.slice( 0, 3 ) !== \"nth\",\n\t\t\t\tforward = type.slice( -4 ) !== \"last\",\n\t\t\t\tofType = what === \"of-type\";\n\n\t\t\treturn first === 1 && last === 0 ?\n\n\t\t\t\t// Shortcut for :nth-*(n)\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn !!elem.parentNode;\n\t\t\t\t} :\n\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tvar cache, uniqueCache, outerCache, node, nodeIndex, start,\n\t\t\t\t\t\tdir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n\t\t\t\t\t\tparent = elem.parentNode,\n\t\t\t\t\t\tname = ofType && elem.nodeName.toLowerCase(),\n\t\t\t\t\t\tuseCache = !xml && !ofType,\n\t\t\t\t\t\tdiff = false;\n\n\t\t\t\t\tif ( parent ) {\n\n\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\n\t\t\t\t\t\tif ( simple ) {\n\t\t\t\t\t\t\twhile ( dir ) {\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\twhile ( (node = node[ dir ]) ) {\n\t\t\t\t\t\t\t\t\tif ( ofType ?\n\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) {\n\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven't yet done so)\n\t\t\t\t\t\t\t\tstart = dir = type === \"only\" && !start && \"nextSibling\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstart = [ forward ? parent.firstChild : parent.lastChild ];\n\n\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\n\t\t\t\t\t\tif ( forward && useCache ) {\n\n\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\n\n\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\tnode = parent;\n\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\tdiff = nodeIndex && cache[ 2 ];\n\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\n\n\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\n\t\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\n\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\n\t\t\t\t\t\t\t\tif ( node.nodeType === 1 && ++diff && node === elem ) {\n\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, nodeIndex, diff ];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Use previously-cached element index if available\n\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\t\tdiff = nodeIndex;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// xml :nth-child(...)\n\t\t\t\t\t\t\t// or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\t\t\t\t\t\t\tif ( diff === false ) {\n\t\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\n\t\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\t\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t\tif ( ( ofType ?\n\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) &&\n\t\t\t\t\t\t\t\t\t\t++diff ) {\n\n\t\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\n\t\t\t\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, diff ];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif ( node === elem ) {\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\n\t\t\t\t\t\tdiff -= last;\n\t\t\t\t\t\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t},\n\n\t\t\"PSEUDO\": function( pseudo, argument ) {\n\t\t\t// pseudo-class names are case-insensitive\n\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\n\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n\t\t\t// Remember that setFilters inherits from pseudos\n\t\t\tvar args,\n\t\t\t\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n\t\t\t\t\tSizzle.error( \"unsupported pseudo: \" + pseudo );\n\n\t\t\t// The user may use createPseudo to indicate that\n\t\t\t// arguments are needed to create the filter function\n\t\t\t// just as Sizzle does\n\t\t\tif ( fn[ expando ] ) {\n\t\t\t\treturn fn( argument );\n\t\t\t}\n\n\t\t\t// But maintain support for old signatures\n\t\t\tif ( fn.length > 1 ) {\n\t\t\t\targs = [ pseudo, pseudo, \"\", argument ];\n\t\t\t\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n\t\t\t\t\tmarkFunction(function( seed, matches ) {\n\t\t\t\t\t\tvar idx,\n\t\t\t\t\t\t\tmatched = fn( seed, argument ),\n\t\t\t\t\t\t\ti = matched.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tidx = indexOf( seed, matched[i] );\n\t\t\t\t\t\t\tseed[ idx ] = !( matches[ idx ] = matched[i] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}) :\n\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\treturn fn( elem, 0, args );\n\t\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn fn;\n\t\t}\n\t},\n\n\tpseudos: {\n\t\t// Potentially complex pseudos\n\t\t\"not\": markFunction(function( selector ) {\n\t\t\t// Trim the selector passed to compile\n\t\t\t// to avoid treating leading and trailing\n\t\t\t// spaces as combinators\n\t\t\tvar input = [],\n\t\t\t\tresults = [],\n\t\t\t\tmatcher = compile( selector.replace( rtrim, \"$1\" ) );\n\n\t\t\treturn matcher[ expando ] ?\n\t\t\t\tmarkFunction(function( seed, matches, context, xml ) {\n\t\t\t\t\tvar elem,\n\t\t\t\t\t\tunmatched = matcher( seed, null, xml, [] ),\n\t\t\t\t\t\ti = seed.length;\n\n\t\t\t\t\t// Match elements unmatched by `matcher`\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = unmatched[i]) ) {\n\t\t\t\t\t\t\tseed[i] = !(matches[i] = elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}) :\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tinput[0] = elem;\n\t\t\t\t\tmatcher( input, null, xml, results );\n\t\t\t\t\t// Don't keep the element (issue #299)\n\t\t\t\t\tinput[0] = null;\n\t\t\t\t\treturn !results.pop();\n\t\t\t\t};\n\t\t}),\n\n\t\t\"has\": markFunction(function( selector ) {\n\t\t\treturn function( elem ) {\n\t\t\t\treturn Sizzle( selector, elem ).length > 0;\n\t\t\t};\n\t\t}),\n\n\t\t\"contains\": markFunction(function( text ) {\n\t\t\ttext = text.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;\n\t\t\t};\n\t\t}),\n\n\t\t// \"Whether an element is represented by a :lang() selector\n\t\t// is based solely on the element's language value\n\t\t// being equal to the identifier C,\n\t\t// or beginning with the identifier C immediately followed by \"-\".\n\t\t// The matching of C against the element's language value is performed case-insensitively.\n\t\t// The identifier C does not have to be a valid language name.\"\n\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\n\t\t\"lang\": markFunction( function( lang ) {\n\t\t\t// lang value must be a valid identifier\n\t\t\tif ( !ridentifier.test(lang || \"\") ) {\n\t\t\t\tSizzle.error( \"unsupported lang: \" + lang );\n\t\t\t}\n\t\t\tlang = lang.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn function( elem ) {\n\t\t\t\tvar elemLang;\n\t\t\t\tdo {\n\t\t\t\t\tif ( (elemLang = documentIsHTML ?\n\t\t\t\t\t\telem.lang :\n\t\t\t\t\t\telem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) ) {\n\n\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf( lang + \"-\" ) === 0;\n\t\t\t\t\t}\n\t\t\t\t} while ( (elem = elem.parentNode) && elem.nodeType === 1 );\n\t\t\t\treturn false;\n\t\t\t};\n\t\t}),\n\n\t\t// Miscellaneous\n\t\t\"target\": function( elem ) {\n\t\t\tvar hash = window.location && window.location.hash;\n\t\t\treturn hash && hash.slice( 1 ) === elem.id;\n\t\t},\n\n\t\t\"root\": function( elem ) {\n\t\t\treturn elem === docElem;\n\t\t},\n\n\t\t\"focus\": function( elem ) {\n\t\t\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n\t\t},\n\n\t\t// Boolean properties\n\t\t\"enabled\": function( elem ) {\n\t\t\treturn elem.disabled === false;\n\t\t},\n\n\t\t\"disabled\": function( elem ) {\n\t\t\treturn elem.disabled === true;\n\t\t},\n\n\t\t\"checked\": function( elem ) {\n\t\t\t// In CSS3, :checked should return both checked and selected elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\tvar nodeName = elem.nodeName.toLowerCase();\n\t\t\treturn (nodeName === \"input\" && !!elem.checked) || (nodeName === \"option\" && !!elem.selected);\n\t\t},\n\n\t\t\"selected\": function( elem ) {\n\t\t\t// Accessing this property makes selected-by-default\n\t\t\t// options in Safari work properly\n\t\t\tif ( elem.parentNode ) {\n\t\t\t\telem.parentNode.selectedIndex;\n\t\t\t}\n\n\t\t\treturn elem.selected === true;\n\t\t},\n\n\t\t// Contents\n\t\t\"empty\": function( elem ) {\n\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\n\t\t\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n\t\t\t//   but not by others (comment: 8; processing instruction: 7; etc.)\n\t\t\t// nodeType < 6 works because attributes (2) do not appear as children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tif ( elem.nodeType < 6 ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\n\t\t\"parent\": function( elem ) {\n\t\t\treturn !Expr.pseudos[\"empty\"]( elem );\n\t\t},\n\n\t\t// Element/input types\n\t\t\"header\": function( elem ) {\n\t\t\treturn rheader.test( elem.nodeName );\n\t\t},\n\n\t\t\"input\": function( elem ) {\n\t\t\treturn rinputs.test( elem.nodeName );\n\t\t},\n\n\t\t\"button\": function( elem ) {\n\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\treturn name === \"input\" && elem.type === \"button\" || name === \"button\";\n\t\t},\n\n\t\t\"text\": function( elem ) {\n\t\t\tvar attr;\n\t\t\treturn elem.nodeName.toLowerCase() === \"input\" &&\n\t\t\t\telem.type === \"text\" &&\n\n\t\t\t\t// Support: IE<8\n\t\t\t\t// New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\n\t\t\t\t( (attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === \"text\" );\n\t\t},\n\n\t\t// Position-in-collection\n\t\t\"first\": createPositionalPseudo(function() {\n\t\t\treturn [ 0 ];\n\t\t}),\n\n\t\t\"last\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\treturn [ length - 1 ];\n\t\t}),\n\n\t\t\"eq\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\treturn [ argument < 0 ? argument + length : argument ];\n\t\t}),\n\n\t\t\"even\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"odd\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 1;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"lt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; --i >= 0; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"gt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; ++i < length; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t})\n\t}\n};\n\nExpr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"];\n\n// Add button/input type pseudos\nfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n\tExpr.pseudos[ i ] = createInputPseudo( i );\n}\nfor ( i in { submit: true, reset: true } ) {\n\tExpr.pseudos[ i ] = createButtonPseudo( i );\n}\n\n// Easy API for creating new setFilters\nfunction setFilters() {}\nsetFilters.prototype = Expr.filters = Expr.pseudos;\nExpr.setFilters = new setFilters();\n\ntokenize = Sizzle.tokenize = function( selector, parseOnly ) {\n\tvar matched, match, tokens, type,\n\t\tsoFar, groups, preFilters,\n\t\tcached = tokenCache[ selector + \" \" ];\n\n\tif ( cached ) {\n\t\treturn parseOnly ? 0 : cached.slice( 0 );\n\t}\n\n\tsoFar = selector;\n\tgroups = [];\n\tpreFilters = Expr.preFilter;\n\n\twhile ( soFar ) {\n\n\t\t// Comma and first run\n\t\tif ( !matched || (match = rcomma.exec( soFar )) ) {\n\t\t\tif ( match ) {\n\t\t\t\t// Don't consume trailing commas as valid\n\t\t\t\tsoFar = soFar.slice( match[0].length ) || soFar;\n\t\t\t}\n\t\t\tgroups.push( (tokens = []) );\n\t\t}\n\n\t\tmatched = false;\n\n\t\t// Combinators\n\t\tif ( (match = rcombinators.exec( soFar )) ) {\n\t\t\tmatched = match.shift();\n\t\t\ttokens.push({\n\t\t\t\tvalue: matched,\n\t\t\t\t// Cast descendant combinators to space\n\t\t\t\ttype: match[0].replace( rtrim, \" \" )\n\t\t\t});\n\t\t\tsoFar = soFar.slice( matched.length );\n\t\t}\n\n\t\t// Filters\n\t\tfor ( type in Expr.filter ) {\n\t\t\tif ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\n\t\t\t\t(match = preFilters[ type ]( match ))) ) {\n\t\t\t\tmatched = match.shift();\n\t\t\t\ttokens.push({\n\t\t\t\t\tvalue: matched,\n\t\t\t\t\ttype: type,\n\t\t\t\t\tmatches: match\n\t\t\t\t});\n\t\t\t\tsoFar = soFar.slice( matched.length );\n\t\t\t}\n\t\t}\n\n\t\tif ( !matched ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Return the length of the invalid excess\n\t// if we're just parsing\n\t// Otherwise, throw an error or return tokens\n\treturn parseOnly ?\n\t\tsoFar.length :\n\t\tsoFar ?\n\t\t\tSizzle.error( selector ) :\n\t\t\t// Cache the tokens\n\t\t\ttokenCache( selector, groups ).slice( 0 );\n};\n\nfunction toSelector( tokens ) {\n\tvar i = 0,\n\t\tlen = tokens.length,\n\t\tselector = \"\";\n\tfor ( ; i < len; i++ ) {\n\t\tselector += tokens[i].value;\n\t}\n\treturn selector;\n}\n\nfunction addCombinator( matcher, combinator, base ) {\n\tvar dir = combinator.dir,\n\t\tcheckNonElements = base && dir === \"parentNode\",\n\t\tdoneName = done++;\n\n\treturn combinator.first ?\n\t\t// Check against closest ancestor/preceding element\n\t\tfunction( elem, context, xml ) {\n\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\treturn matcher( elem, context, xml );\n\t\t\t\t}\n\t\t\t}\n\t\t} :\n\n\t\t// Check against all ancestor/preceding elements\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar oldCache, uniqueCache, outerCache,\n\t\t\t\tnewCache = [ dirruns, doneName ];\n\n\t\t\t// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching\n\t\t\tif ( xml ) {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\touterCache = elem[ expando ] || (elem[ expando ] = {});\n\n\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\tuniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});\n\n\t\t\t\t\t\tif ( (oldCache = uniqueCache[ dir ]) &&\n\t\t\t\t\t\t\toldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\n\n\t\t\t\t\t\t\t// Assign to newCache so results back-propagate to previous elements\n\t\t\t\t\t\t\treturn (newCache[ 2 ] = oldCache[ 2 ]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Reuse newcache so results back-propagate to previous elements\n\t\t\t\t\t\t\tuniqueCache[ dir ] = newCache;\n\n\t\t\t\t\t\t\t// A match means we're done; a fail means we have to keep checking\n\t\t\t\t\t\t\tif ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n}\n\nfunction elementMatcher( matchers ) {\n\treturn matchers.length > 1 ?\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar i = matchers.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( !matchers[i]( elem, context, xml ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} :\n\t\tmatchers[0];\n}\n\nfunction multipleContexts( selector, contexts, results ) {\n\tvar i = 0,\n\t\tlen = contexts.length;\n\tfor ( ; i < len; i++ ) {\n\t\tSizzle( selector, contexts[i], results );\n\t}\n\treturn results;\n}\n\nfunction condense( unmatched, map, filter, context, xml ) {\n\tvar elem,\n\t\tnewUnmatched = [],\n\t\ti = 0,\n\t\tlen = unmatched.length,\n\t\tmapped = map != null;\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (elem = unmatched[i]) ) {\n\t\t\tif ( !filter || filter( elem, context, xml ) ) {\n\t\t\t\tnewUnmatched.push( elem );\n\t\t\t\tif ( mapped ) {\n\t\t\t\t\tmap.push( i );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn newUnmatched;\n}\n\nfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n\tif ( postFilter && !postFilter[ expando ] ) {\n\t\tpostFilter = setMatcher( postFilter );\n\t}\n\tif ( postFinder && !postFinder[ expando ] ) {\n\t\tpostFinder = setMatcher( postFinder, postSelector );\n\t}\n\treturn markFunction(function( seed, results, context, xml ) {\n\t\tvar temp, i, elem,\n\t\t\tpreMap = [],\n\t\t\tpostMap = [],\n\t\t\tpreexisting = results.length,\n\n\t\t\t// Get initial elements from seed or context\n\t\t\telems = seed || multipleContexts( selector || \"*\", context.nodeType ? [ context ] : context, [] ),\n\n\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\n\t\t\tmatcherIn = preFilter && ( seed || !selector ) ?\n\t\t\t\tcondense( elems, preMap, preFilter, context, xml ) :\n\t\t\t\telems,\n\n\t\t\tmatcherOut = matcher ?\n\t\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n\t\t\t\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n\n\t\t\t\t\t// ...intermediate processing is necessary\n\t\t\t\t\t[] :\n\n\t\t\t\t\t// ...otherwise use results directly\n\t\t\t\t\tresults :\n\t\t\t\tmatcherIn;\n\n\t\t// Find primary matches\n\t\tif ( matcher ) {\n\t\t\tmatcher( matcherIn, matcherOut, context, xml );\n\t\t}\n\n\t\t// Apply postFilter\n\t\tif ( postFilter ) {\n\t\t\ttemp = condense( matcherOut, postMap );\n\t\t\tpostFilter( temp, [], context, xml );\n\n\t\t\t// Un-match failing elements by moving them back to matcherIn\n\t\t\ti = temp.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( (elem = temp[i]) ) {\n\t\t\t\t\tmatcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( seed ) {\n\t\t\tif ( postFinder || preFilter ) {\n\t\t\t\tif ( postFinder ) {\n\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\n\t\t\t\t\ttemp = [];\n\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = matcherOut[i]) ) {\n\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\n\t\t\t\t\t\t\ttemp.push( (matcherIn[i] = elem) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpostFinder( null, (matcherOut = []), temp, xml );\n\t\t\t\t}\n\n\t\t\t\t// Move matched elements from seed to results to keep them synchronized\n\t\t\t\ti = matcherOut.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( (elem = matcherOut[i]) &&\n\t\t\t\t\t\t(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {\n\n\t\t\t\t\t\tseed[temp] = !(results[temp] = elem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Add elements to results, through postFinder if defined\n\t\t} else {\n\t\t\tmatcherOut = condense(\n\t\t\t\tmatcherOut === results ?\n\t\t\t\t\tmatcherOut.splice( preexisting, matcherOut.length ) :\n\t\t\t\t\tmatcherOut\n\t\t\t);\n\t\t\tif ( postFinder ) {\n\t\t\t\tpostFinder( null, results, matcherOut, xml );\n\t\t\t} else {\n\t\t\t\tpush.apply( results, matcherOut );\n\t\t\t}\n\t\t}\n\t});\n}\n\nfunction matcherFromTokens( tokens ) {\n\tvar checkContext, matcher, j,\n\t\tlen = tokens.length,\n\t\tleadingRelative = Expr.relative[ tokens[0].type ],\n\t\timplicitRelative = leadingRelative || Expr.relative[\" \"],\n\t\ti = leadingRelative ? 1 : 0,\n\n\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\n\t\tmatchContext = addCombinator( function( elem ) {\n\t\t\treturn elem === checkContext;\n\t\t}, implicitRelative, true ),\n\t\tmatchAnyContext = addCombinator( function( elem ) {\n\t\t\treturn indexOf( checkContext, elem ) > -1;\n\t\t}, implicitRelative, true ),\n\t\tmatchers = [ function( elem, context, xml ) {\n\t\t\tvar ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\n\t\t\t\t(checkContext = context).nodeType ?\n\t\t\t\t\tmatchContext( elem, context, xml ) :\n\t\t\t\t\tmatchAnyContext( elem, context, xml ) );\n\t\t\t// Avoid hanging onto element (issue #299)\n\t\t\tcheckContext = null;\n\t\t\treturn ret;\n\t\t} ];\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (matcher = Expr.relative[ tokens[i].type ]) ) {\n\t\t\tmatchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\n\t\t} else {\n\t\t\tmatcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\n\n\t\t\t// Return special upon seeing a positional matcher\n\t\t\tif ( matcher[ expando ] ) {\n\t\t\t\t// Find the next relative operator (if any) for proper handling\n\t\t\t\tj = ++i;\n\t\t\t\tfor ( ; j < len; j++ ) {\n\t\t\t\t\tif ( Expr.relative[ tokens[j].type ] ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn setMatcher(\n\t\t\t\t\ti > 1 && elementMatcher( matchers ),\n\t\t\t\t\ti > 1 && toSelector(\n\t\t\t\t\t\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n\t\t\t\t\t\ttokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === \" \" ? \"*\" : \"\" })\n\t\t\t\t\t).replace( rtrim, \"$1\" ),\n\t\t\t\t\tmatcher,\n\t\t\t\t\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\n\t\t\t\t\tj < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\n\t\t\t\t\tj < len && toSelector( tokens )\n\t\t\t\t);\n\t\t\t}\n\t\t\tmatchers.push( matcher );\n\t\t}\n\t}\n\n\treturn elementMatcher( matchers );\n}\n\nfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n\tvar bySet = setMatchers.length > 0,\n\t\tbyElement = elementMatchers.length > 0,\n\t\tsuperMatcher = function( seed, context, xml, results, outermost ) {\n\t\t\tvar elem, j, matcher,\n\t\t\t\tmatchedCount = 0,\n\t\t\t\ti = \"0\",\n\t\t\t\tunmatched = seed && [],\n\t\t\t\tsetMatched = [],\n\t\t\t\tcontextBackup = outermostContext,\n\t\t\t\t// We must always have either seed elements or outermost context\n\t\t\t\telems = seed || byElement && Expr.find[\"TAG\"]( \"*\", outermost ),\n\t\t\t\t// Use integer dirruns iff this is the outermost matcher\n\t\t\t\tdirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),\n\t\t\t\tlen = elems.length;\n\n\t\t\tif ( outermost ) {\n\t\t\t\toutermostContext = context === document || context || outermost;\n\t\t\t}\n\n\t\t\t// Add elements passing elementMatchers directly to results\n\t\t\t// Support: IE<9, Safari\n\t\t\t// Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n\t\t\tfor ( ; i !== len && (elem = elems[i]) != null; i++ ) {\n\t\t\t\tif ( byElement && elem ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\tif ( !context && elem.ownerDocument !== document ) {\n\t\t\t\t\t\tsetDocument( elem );\n\t\t\t\t\t\txml = !documentIsHTML;\n\t\t\t\t\t}\n\t\t\t\t\twhile ( (matcher = elementMatchers[j++]) ) {\n\t\t\t\t\t\tif ( matcher( elem, context || document, xml) ) {\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( outermost ) {\n\t\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Track unmatched elements for set filters\n\t\t\t\tif ( bySet ) {\n\t\t\t\t\t// They will have gone through all possible matchers\n\t\t\t\t\tif ( (elem = !matcher && elem) ) {\n\t\t\t\t\t\tmatchedCount--;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Lengthen the array for every element, matched or not\n\t\t\t\t\tif ( seed ) {\n\t\t\t\t\t\tunmatched.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// `i` is now the count of elements visited above, and adding it to `matchedCount`\n\t\t\t// makes the latter nonnegative.\n\t\t\tmatchedCount += i;\n\n\t\t\t// Apply set filters to unmatched elements\n\t\t\t// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\n\t\t\t// equals `i`), unless we didn't visit _any_ elements in the above loop because we have\n\t\t\t// no element matchers and no seed.\n\t\t\t// Incrementing an initially-string \"0\" `i` allows `i` to remain a string only in that\n\t\t\t// case, which will result in a \"00\" `matchedCount` that differs from `i` but is also\n\t\t\t// numerically zero.\n\t\t\tif ( bySet && i !== matchedCount ) {\n\t\t\t\tj = 0;\n\t\t\t\twhile ( (matcher = setMatchers[j++]) ) {\n\t\t\t\t\tmatcher( unmatched, setMatched, context, xml );\n\t\t\t\t}\n\n\t\t\t\tif ( seed ) {\n\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\n\t\t\t\t\tif ( matchedCount > 0 ) {\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tif ( !(unmatched[i] || setMatched[i]) ) {\n\t\t\t\t\t\t\t\tsetMatched[i] = pop.call( results );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Discard index placeholder values to get only actual matches\n\t\t\t\t\tsetMatched = condense( setMatched );\n\t\t\t\t}\n\n\t\t\t\t// Add matches to results\n\t\t\t\tpush.apply( results, setMatched );\n\n\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\n\t\t\t\tif ( outermost && !seed && setMatched.length > 0 &&\n\t\t\t\t\t( matchedCount + setMatchers.length ) > 1 ) {\n\n\t\t\t\t\tSizzle.uniqueSort( results );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Override manipulation of globals by nested matchers\n\t\t\tif ( outermost ) {\n\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\toutermostContext = contextBackup;\n\t\t\t}\n\n\t\t\treturn unmatched;\n\t\t};\n\n\treturn bySet ?\n\t\tmarkFunction( superMatcher ) :\n\t\tsuperMatcher;\n}\n\ncompile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {\n\tvar i,\n\t\tsetMatchers = [],\n\t\telementMatchers = [],\n\t\tcached = compilerCache[ selector + \" \" ];\n\n\tif ( !cached ) {\n\t\t// Generate a function of recursive functions that can be used to check each element\n\t\tif ( !match ) {\n\t\t\tmatch = tokenize( selector );\n\t\t}\n\t\ti = match.length;\n\t\twhile ( i-- ) {\n\t\t\tcached = matcherFromTokens( match[i] );\n\t\t\tif ( cached[ expando ] ) {\n\t\t\t\tsetMatchers.push( cached );\n\t\t\t} else {\n\t\t\t\telementMatchers.push( cached );\n\t\t\t}\n\t\t}\n\n\t\t// Cache the compiled function\n\t\tcached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\n\n\t\t// Save selector and tokenization\n\t\tcached.selector = selector;\n\t}\n\treturn cached;\n};\n\n/**\n * A low-level selection function that works with Sizzle's compiled\n *  selector functions\n * @param {String|Function} selector A selector or a pre-compiled\n *  selector function built with Sizzle.compile\n * @param {Element} context\n * @param {Array} [results]\n * @param {Array} [seed] A set of elements to match against\n */\nselect = Sizzle.select = function( selector, context, results, seed ) {\n\tvar i, tokens, token, type, find,\n\t\tcompiled = typeof selector === \"function\" && selector,\n\t\tmatch = !seed && tokenize( (selector = compiled.selector || selector) );\n\n\tresults = results || [];\n\n\t// Try to minimize operations if there is only one selector in the list and no seed\n\t// (the latter of which guarantees us context)\n\tif ( match.length === 1 ) {\n\n\t\t// Reduce context if the leading compound selector is an ID\n\t\ttokens = match[0] = match[0].slice( 0 );\n\t\tif ( tokens.length > 2 && (token = tokens[0]).type === \"ID\" &&\n\t\t\t\tsupport.getById && context.nodeType === 9 && documentIsHTML &&\n\t\t\t\tExpr.relative[ tokens[1].type ] ) {\n\n\t\t\tcontext = ( Expr.find[\"ID\"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];\n\t\t\tif ( !context ) {\n\t\t\t\treturn results;\n\n\t\t\t// Precompiled matchers will still verify ancestry, so step up a level\n\t\t\t} else if ( compiled ) {\n\t\t\t\tcontext = context.parentNode;\n\t\t\t}\n\n\t\t\tselector = selector.slice( tokens.shift().value.length );\n\t\t}\n\n\t\t// Fetch a seed set for right-to-left matching\n\t\ti = matchExpr[\"needsContext\"].test( selector ) ? 0 : tokens.length;\n\t\twhile ( i-- ) {\n\t\t\ttoken = tokens[i];\n\n\t\t\t// Abort if we hit a combinator\n\t\t\tif ( Expr.relative[ (type = token.type) ] ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( (find = Expr.find[ type ]) ) {\n\t\t\t\t// Search, expanding context for leading sibling combinators\n\t\t\t\tif ( (seed = find(\n\t\t\t\t\ttoken.matches[0].replace( runescape, funescape ),\n\t\t\t\t\trsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context\n\t\t\t\t)) ) {\n\n\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\n\t\t\t\t\ttokens.splice( i, 1 );\n\t\t\t\t\tselector = seed.length && toSelector( tokens );\n\t\t\t\t\tif ( !selector ) {\n\t\t\t\t\t\tpush.apply( results, seed );\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Compile and execute a filtering function if one is not provided\n\t// Provide `match` to avoid retokenization if we modified the selector above\n\t( compiled || compile( selector, match ) )(\n\t\tseed,\n\t\tcontext,\n\t\t!documentIsHTML,\n\t\tresults,\n\t\t!context || rsibling.test( selector ) && testContext( context.parentNode ) || context\n\t);\n\treturn results;\n};\n\n// One-time assignments\n\n// Sort stability\nsupport.sortStable = expando.split(\"\").sort( sortOrder ).join(\"\") === expando;\n\n// Support: Chrome 14-35+\n// Always assume duplicates if they aren't passed to the comparison function\nsupport.detectDuplicates = !!hasDuplicate;\n\n// Initialize against the default document\nsetDocument();\n\n// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n// Detached nodes confoundingly follow *each other*\nsupport.sortDetached = assert(function( div1 ) {\n\t// Should return 1, but returns 4 (following)\n\treturn div1.compareDocumentPosition( document.createElement(\"div\") ) & 1;\n});\n\n// Support: IE<8\n// Prevent attribute/property \"interpolation\"\n// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\nif ( !assert(function( div ) {\n\tdiv.innerHTML = \"<a href='#'></a>\";\n\treturn div.firstChild.getAttribute(\"href\") === \"#\" ;\n}) ) {\n\taddHandle( \"type|href|height|width\", function( elem, name, isXML ) {\n\t\tif ( !isXML ) {\n\t\t\treturn elem.getAttribute( name, name.toLowerCase() === \"type\" ? 1 : 2 );\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use defaultValue in place of getAttribute(\"value\")\nif ( !support.attributes || !assert(function( div ) {\n\tdiv.innerHTML = \"<input/>\";\n\tdiv.firstChild.setAttribute( \"value\", \"\" );\n\treturn div.firstChild.getAttribute( \"value\" ) === \"\";\n}) ) {\n\taddHandle( \"value\", function( elem, name, isXML ) {\n\t\tif ( !isXML && elem.nodeName.toLowerCase() === \"input\" ) {\n\t\t\treturn elem.defaultValue;\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use getAttributeNode to fetch booleans when getAttribute lies\nif ( !assert(function( div ) {\n\treturn div.getAttribute(\"disabled\") == null;\n}) ) {\n\taddHandle( booleans, function( elem, name, isXML ) {\n\t\tvar val;\n\t\tif ( !isXML ) {\n\t\t\treturn elem[ name ] === true ? name.toLowerCase() :\n\t\t\t\t\t(val = elem.getAttributeNode( name )) && val.specified ?\n\t\t\t\t\tval.value :\n\t\t\t\tnull;\n\t\t}\n\t});\n}\n\nreturn Sizzle;\n\n})( window );\n\n\n\njQuery.find = Sizzle;\njQuery.expr = Sizzle.selectors;\njQuery.expr[ \":\" ] = jQuery.expr.pseudos;\njQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;\njQuery.text = Sizzle.getText;\njQuery.isXMLDoc = Sizzle.isXML;\njQuery.contains = Sizzle.contains;\n\n\n\nvar dir = function( elem, dir, until ) {\n\tvar matched = [],\n\t\ttruncate = until !== undefined;\n\n\twhile ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {\n\t\tif ( elem.nodeType === 1 ) {\n\t\t\tif ( truncate && jQuery( elem ).is( until ) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmatched.push( elem );\n\t\t}\n\t}\n\treturn matched;\n};\n\n\nvar siblings = function( n, elem ) {\n\tvar matched = [];\n\n\tfor ( ; n; n = n.nextSibling ) {\n\t\tif ( n.nodeType === 1 && n !== elem ) {\n\t\t\tmatched.push( n );\n\t\t}\n\t}\n\n\treturn matched;\n};\n\n\nvar rneedsContext = jQuery.expr.match.needsContext;\n\nvar rsingleTag = ( /^<([\\w-]+)\\s*\\/?>(?:<\\/\\1>|)$/ );\n\n\n\nvar risSimple = /^.[^:#\\[\\.,]*$/;\n\n// Implement the identical functionality for filter and not\nfunction winnow( elements, qualifier, not ) {\n\tif ( jQuery.isFunction( qualifier ) ) {\n\t\treturn jQuery.grep( elements, function( elem, i ) {\n\t\t\t/* jshint -W018 */\n\t\t\treturn !!qualifier.call( elem, i, elem ) !== not;\n\t\t} );\n\n\t}\n\n\tif ( qualifier.nodeType ) {\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( elem === qualifier ) !== not;\n\t\t} );\n\n\t}\n\n\tif ( typeof qualifier === \"string\" ) {\n\t\tif ( risSimple.test( qualifier ) ) {\n\t\t\treturn jQuery.filter( qualifier, elements, not );\n\t\t}\n\n\t\tqualifier = jQuery.filter( qualifier, elements );\n\t}\n\n\treturn jQuery.grep( elements, function( elem ) {\n\t\treturn ( indexOf.call( qualifier, elem ) > -1 ) !== not;\n\t} );\n}\n\njQuery.filter = function( expr, elems, not ) {\n\tvar elem = elems[ 0 ];\n\n\tif ( not ) {\n\t\texpr = \":not(\" + expr + \")\";\n\t}\n\n\treturn elems.length === 1 && elem.nodeType === 1 ?\n\t\tjQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :\n\t\tjQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\n\t\t\treturn elem.nodeType === 1;\n\t\t} ) );\n};\n\njQuery.fn.extend( {\n\tfind: function( selector ) {\n\t\tvar i,\n\t\t\tlen = this.length,\n\t\t\tret = [],\n\t\t\tself = this;\n\n\t\tif ( typeof selector !== \"string\" ) {\n\t\t\treturn this.pushStack( jQuery( selector ).filter( function() {\n\t\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\t\tif ( jQuery.contains( self[ i ], this ) ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} ) );\n\t\t}\n\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\tjQuery.find( selector, self[ i ], ret );\n\t\t}\n\n\t\t// Needed because $( selector, context ) becomes $( context ).find( selector )\n\t\tret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );\n\t\tret.selector = this.selector ? this.selector + \" \" + selector : selector;\n\t\treturn ret;\n\t},\n\tfilter: function( selector ) {\n\t\treturn this.pushStack( winnow( this, selector || [], false ) );\n\t},\n\tnot: function( selector ) {\n\t\treturn this.pushStack( winnow( this, selector || [], true ) );\n\t},\n\tis: function( selector ) {\n\t\treturn !!winnow(\n\t\t\tthis,\n\n\t\t\t// If this is a positional/relative selector, check membership in the returned set\n\t\t\t// so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n\t\t\ttypeof selector === \"string\" && rneedsContext.test( selector ) ?\n\t\t\t\tjQuery( selector ) :\n\t\t\t\tselector || [],\n\t\t\tfalse\n\t\t).length;\n\t}\n} );\n\n\n// Initialize a jQuery object\n\n\n// A central reference to the root jQuery(document)\nvar rootjQuery,\n\n\t// A simple way to check for HTML strings\n\t// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n\t// Strict HTML recognition (#11290: must start with <)\n\trquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]*))$/,\n\n\tinit = jQuery.fn.init = function( selector, context, root ) {\n\t\tvar match, elem;\n\n\t\t// HANDLE: $(\"\"), $(null), $(undefined), $(false)\n\t\tif ( !selector ) {\n\t\t\treturn this;\n\t\t}\n\n\t\t// Method init() accepts an alternate rootjQuery\n\t\t// so migrate can support jQuery.sub (gh-2101)\n\t\troot = root || rootjQuery;\n\n\t\t// Handle HTML strings\n\t\tif ( typeof selector === \"string\" ) {\n\t\t\tif ( selector[ 0 ] === \"<\" &&\n\t\t\t\tselector[ selector.length - 1 ] === \">\" &&\n\t\t\t\tselector.length >= 3 ) {\n\n\t\t\t\t// Assume that strings that start and end with <> are HTML and skip the regex check\n\t\t\t\tmatch = [ null, selector, null ];\n\n\t\t\t} else {\n\t\t\t\tmatch = rquickExpr.exec( selector );\n\t\t\t}\n\n\t\t\t// Match html or make sure no context is specified for #id\n\t\t\tif ( match && ( match[ 1 ] || !context ) ) {\n\n\t\t\t\t// HANDLE: $(html) -> $(array)\n\t\t\t\tif ( match[ 1 ] ) {\n\t\t\t\t\tcontext = context instanceof jQuery ? context[ 0 ] : context;\n\n\t\t\t\t\t// Option to run scripts is true for back-compat\n\t\t\t\t\t// Intentionally let the error be thrown if parseHTML is not present\n\t\t\t\t\tjQuery.merge( this, jQuery.parseHTML(\n\t\t\t\t\t\tmatch[ 1 ],\n\t\t\t\t\t\tcontext && context.nodeType ? context.ownerDocument || context : document,\n\t\t\t\t\t\ttrue\n\t\t\t\t\t) );\n\n\t\t\t\t\t// HANDLE: $(html, props)\n\t\t\t\t\tif ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {\n\t\t\t\t\t\tfor ( match in context ) {\n\n\t\t\t\t\t\t\t// Properties of context are called as methods if possible\n\t\t\t\t\t\t\tif ( jQuery.isFunction( this[ match ] ) ) {\n\t\t\t\t\t\t\t\tthis[ match ]( context[ match ] );\n\n\t\t\t\t\t\t\t// ...and otherwise set as attributes\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.attr( match, context[ match ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this;\n\n\t\t\t\t// HANDLE: $(#id)\n\t\t\t\t} else {\n\t\t\t\t\telem = document.getElementById( match[ 2 ] );\n\n\t\t\t\t\t// Support: Blackberry 4.6\n\t\t\t\t\t// gEBID returns nodes no longer in the document (#6963)\n\t\t\t\t\tif ( elem && elem.parentNode ) {\n\n\t\t\t\t\t\t// Inject the element directly into the jQuery object\n\t\t\t\t\t\tthis.length = 1;\n\t\t\t\t\t\tthis[ 0 ] = elem;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.context = document;\n\t\t\t\t\tthis.selector = selector;\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t// HANDLE: $(expr, $(...))\n\t\t\t} else if ( !context || context.jquery ) {\n\t\t\t\treturn ( context || root ).find( selector );\n\n\t\t\t// HANDLE: $(expr, context)\n\t\t\t// (which is just equivalent to: $(context).find(expr)\n\t\t\t} else {\n\t\t\t\treturn this.constructor( context ).find( selector );\n\t\t\t}\n\n\t\t// HANDLE: $(DOMElement)\n\t\t} else if ( selector.nodeType ) {\n\t\t\tthis.context = this[ 0 ] = selector;\n\t\t\tthis.length = 1;\n\t\t\treturn this;\n\n\t\t// HANDLE: $(function)\n\t\t// Shortcut for document ready\n\t\t} else if ( jQuery.isFunction( selector ) ) {\n\t\t\treturn root.ready !== undefined ?\n\t\t\t\troot.ready( selector ) :\n\n\t\t\t\t// Execute immediately if ready is not present\n\t\t\t\tselector( jQuery );\n\t\t}\n\n\t\tif ( selector.selector !== undefined ) {\n\t\t\tthis.selector = selector.selector;\n\t\t\tthis.context = selector.context;\n\t\t}\n\n\t\treturn jQuery.makeArray( selector, this );\n\t};\n\n// Give the init function the jQuery prototype for later instantiation\ninit.prototype = jQuery.fn;\n\n// Initialize central reference\nrootjQuery = jQuery( document );\n\n\nvar rparentsprev = /^(?:parents|prev(?:Until|All))/,\n\n\t// Methods guaranteed to produce a unique set when starting from a unique set\n\tguaranteedUnique = {\n\t\tchildren: true,\n\t\tcontents: true,\n\t\tnext: true,\n\t\tprev: true\n\t};\n\njQuery.fn.extend( {\n\thas: function( target ) {\n\t\tvar targets = jQuery( target, this ),\n\t\t\tl = targets.length;\n\n\t\treturn this.filter( function() {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tif ( jQuery.contains( this, targets[ i ] ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t},\n\n\tclosest: function( selectors, context ) {\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\tl = this.length,\n\t\t\tmatched = [],\n\t\t\tpos = rneedsContext.test( selectors ) || typeof selectors !== \"string\" ?\n\t\t\t\tjQuery( selectors, context || this.context ) :\n\t\t\t\t0;\n\n\t\tfor ( ; i < l; i++ ) {\n\t\t\tfor ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {\n\n\t\t\t\t// Always skip document fragments\n\t\t\t\tif ( cur.nodeType < 11 && ( pos ?\n\t\t\t\t\tpos.index( cur ) > -1 :\n\n\t\t\t\t\t// Don't pass non-elements to Sizzle\n\t\t\t\t\tcur.nodeType === 1 &&\n\t\t\t\t\t\tjQuery.find.matchesSelector( cur, selectors ) ) ) {\n\n\t\t\t\t\tmatched.push( cur );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );\n\t},\n\n\t// Determine the position of an element within the set\n\tindex: function( elem ) {\n\n\t\t// No argument, return index in parent\n\t\tif ( !elem ) {\n\t\t\treturn ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;\n\t\t}\n\n\t\t// Index in selector\n\t\tif ( typeof elem === \"string\" ) {\n\t\t\treturn indexOf.call( jQuery( elem ), this[ 0 ] );\n\t\t}\n\n\t\t// Locate the position of the desired element\n\t\treturn indexOf.call( this,\n\n\t\t\t// If it receives a jQuery object, the first element is used\n\t\t\telem.jquery ? elem[ 0 ] : elem\n\t\t);\n\t},\n\n\tadd: function( selector, context ) {\n\t\treturn this.pushStack(\n\t\t\tjQuery.uniqueSort(\n\t\t\t\tjQuery.merge( this.get(), jQuery( selector, context ) )\n\t\t\t)\n\t\t);\n\t},\n\n\taddBack: function( selector ) {\n\t\treturn this.add( selector == null ?\n\t\t\tthis.prevObject : this.prevObject.filter( selector )\n\t\t);\n\t}\n} );\n\nfunction sibling( cur, dir ) {\n\twhile ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}\n\treturn cur;\n}\n\njQuery.each( {\n\tparent: function( elem ) {\n\t\tvar parent = elem.parentNode;\n\t\treturn parent && parent.nodeType !== 11 ? parent : null;\n\t},\n\tparents: function( elem ) {\n\t\treturn dir( elem, \"parentNode\" );\n\t},\n\tparentsUntil: function( elem, i, until ) {\n\t\treturn dir( elem, \"parentNode\", until );\n\t},\n\tnext: function( elem ) {\n\t\treturn sibling( elem, \"nextSibling\" );\n\t},\n\tprev: function( elem ) {\n\t\treturn sibling( elem, \"previousSibling\" );\n\t},\n\tnextAll: function( elem ) {\n\t\treturn dir( elem, \"nextSibling\" );\n\t},\n\tprevAll: function( elem ) {\n\t\treturn dir( elem, \"previousSibling\" );\n\t},\n\tnextUntil: function( elem, i, until ) {\n\t\treturn dir( elem, \"nextSibling\", until );\n\t},\n\tprevUntil: function( elem, i, until ) {\n\t\treturn dir( elem, \"previousSibling\", until );\n\t},\n\tsiblings: function( elem ) {\n\t\treturn siblings( ( elem.parentNode || {} ).firstChild, elem );\n\t},\n\tchildren: function( elem ) {\n\t\treturn siblings( elem.firstChild );\n\t},\n\tcontents: function( elem ) {\n\t\treturn elem.contentDocument || jQuery.merge( [], elem.childNodes );\n\t}\n}, function( name, fn ) {\n\tjQuery.fn[ name ] = function( until, selector ) {\n\t\tvar matched = jQuery.map( this, fn, until );\n\n\t\tif ( name.slice( -5 ) !== \"Until\" ) {\n\t\t\tselector = until;\n\t\t}\n\n\t\tif ( selector && typeof selector === \"string\" ) {\n\t\t\tmatched = jQuery.filter( selector, matched );\n\t\t}\n\n\t\tif ( this.length > 1 ) {\n\n\t\t\t// Remove duplicates\n\t\t\tif ( !guaranteedUnique[ name ] ) {\n\t\t\t\tjQuery.uniqueSort( matched );\n\t\t\t}\n\n\t\t\t// Reverse order for parents* and prev-derivatives\n\t\t\tif ( rparentsprev.test( name ) ) {\n\t\t\t\tmatched.reverse();\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched );\n\t};\n} );\nvar rnotwhite = ( /\\S+/g );\n\n\n\n// Convert String-formatted options into Object-formatted ones\nfunction createOptions( options ) {\n\tvar object = {};\n\tjQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {\n\t\tobject[ flag ] = true;\n\t} );\n\treturn object;\n}\n\n/*\n * Create a callback list using the following parameters:\n *\n *\toptions: an optional list of space-separated options that will change how\n *\t\t\tthe callback list behaves or a more traditional option object\n *\n * By default a callback list will act like an event callback list and can be\n * \"fired\" multiple times.\n *\n * Possible options:\n *\n *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n *\n *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n *\t\t\t\t\tvalues (like a Deferred)\n *\n *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n *\n *\tstopOnFalse:\tinterrupt callings when a callback returns false\n *\n */\njQuery.Callbacks = function( options ) {\n\n\t// Convert options from String-formatted to Object-formatted if needed\n\t// (we check in cache first)\n\toptions = typeof options === \"string\" ?\n\t\tcreateOptions( options ) :\n\t\tjQuery.extend( {}, options );\n\n\tvar // Flag to know if list is currently firing\n\t\tfiring,\n\n\t\t// Last fire value for non-forgettable lists\n\t\tmemory,\n\n\t\t// Flag to know if list was already fired\n\t\tfired,\n\n\t\t// Flag to prevent firing\n\t\tlocked,\n\n\t\t// Actual callback list\n\t\tlist = [],\n\n\t\t// Queue of execution data for repeatable lists\n\t\tqueue = [],\n\n\t\t// Index of currently firing callback (modified by add/remove as needed)\n\t\tfiringIndex = -1,\n\n\t\t// Fire callbacks\n\t\tfire = function() {\n\n\t\t\t// Enforce single-firing\n\t\t\tlocked = options.once;\n\n\t\t\t// Execute callbacks for all pending executions,\n\t\t\t// respecting firingIndex overrides and runtime changes\n\t\t\tfired = firing = true;\n\t\t\tfor ( ; queue.length; firingIndex = -1 ) {\n\t\t\t\tmemory = queue.shift();\n\t\t\t\twhile ( ++firingIndex < list.length ) {\n\n\t\t\t\t\t// Run callback and check for early termination\n\t\t\t\t\tif ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&\n\t\t\t\t\t\toptions.stopOnFalse ) {\n\n\t\t\t\t\t\t// Jump to end and forget the data so .add doesn't re-fire\n\t\t\t\t\t\tfiringIndex = list.length;\n\t\t\t\t\t\tmemory = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Forget the data if we're done with it\n\t\t\tif ( !options.memory ) {\n\t\t\t\tmemory = false;\n\t\t\t}\n\n\t\t\tfiring = false;\n\n\t\t\t// Clean up if we're done firing for good\n\t\t\tif ( locked ) {\n\n\t\t\t\t// Keep an empty list if we have data for future add calls\n\t\t\t\tif ( memory ) {\n\t\t\t\t\tlist = [];\n\n\t\t\t\t// Otherwise, this object is spent\n\t\t\t\t} else {\n\t\t\t\t\tlist = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t// Actual Callbacks object\n\t\tself = {\n\n\t\t\t// Add a callback or a collection of callbacks to the list\n\t\t\tadd: function() {\n\t\t\t\tif ( list ) {\n\n\t\t\t\t\t// If we have memory from a past run, we should fire after adding\n\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\tfiringIndex = list.length - 1;\n\t\t\t\t\t\tqueue.push( memory );\n\t\t\t\t\t}\n\n\t\t\t\t\t( function add( args ) {\n\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\n\t\t\t\t\t\t\tif ( jQuery.isFunction( arg ) ) {\n\t\t\t\t\t\t\t\tif ( !options.unique || !self.has( arg ) ) {\n\t\t\t\t\t\t\t\t\tlist.push( arg );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if ( arg && arg.length && jQuery.type( arg ) !== \"string\" ) {\n\n\t\t\t\t\t\t\t\t// Inspect recursively\n\t\t\t\t\t\t\t\tadd( arg );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} );\n\t\t\t\t\t} )( arguments );\n\n\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Remove a callback from the list\n\t\t\tremove: function() {\n\t\t\t\tjQuery.each( arguments, function( _, arg ) {\n\t\t\t\t\tvar index;\n\t\t\t\t\twhile ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n\t\t\t\t\t\tlist.splice( index, 1 );\n\n\t\t\t\t\t\t// Handle firing indexes\n\t\t\t\t\t\tif ( index <= firingIndex ) {\n\t\t\t\t\t\t\tfiringIndex--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Check if a given callback is in the list.\n\t\t\t// If no argument is given, return whether or not list has callbacks attached.\n\t\t\thas: function( fn ) {\n\t\t\t\treturn fn ?\n\t\t\t\t\tjQuery.inArray( fn, list ) > -1 :\n\t\t\t\t\tlist.length > 0;\n\t\t\t},\n\n\t\t\t// Remove all callbacks from the list\n\t\t\tempty: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\tlist = [];\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Disable .fire and .add\n\t\t\t// Abort any current/pending executions\n\t\t\t// Clear all callbacks and values\n\t\t\tdisable: function() {\n\t\t\t\tlocked = queue = [];\n\t\t\t\tlist = memory = \"\";\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tdisabled: function() {\n\t\t\t\treturn !list;\n\t\t\t},\n\n\t\t\t// Disable .fire\n\t\t\t// Also disable .add unless we have memory (since it would have no effect)\n\t\t\t// Abort any pending executions\n\t\t\tlock: function() {\n\t\t\t\tlocked = queue = [];\n\t\t\t\tif ( !memory ) {\n\t\t\t\t\tlist = memory = \"\";\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tlocked: function() {\n\t\t\t\treturn !!locked;\n\t\t\t},\n\n\t\t\t// Call all callbacks with the given context and arguments\n\t\t\tfireWith: function( context, args ) {\n\t\t\t\tif ( !locked ) {\n\t\t\t\t\targs = args || [];\n\t\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\n\t\t\t\t\tqueue.push( args );\n\t\t\t\t\tif ( !firing ) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Call all the callbacks with the given arguments\n\t\t\tfire: function() {\n\t\t\t\tself.fireWith( this, arguments );\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// To know if the callbacks have already been called at least once\n\t\t\tfired: function() {\n\t\t\t\treturn !!fired;\n\t\t\t}\n\t\t};\n\n\treturn self;\n};\n\n\njQuery.extend( {\n\n\tDeferred: function( func ) {\n\t\tvar tuples = [\n\n\t\t\t\t// action, add listener, listener list, final state\n\t\t\t\t[ \"resolve\", \"done\", jQuery.Callbacks( \"once memory\" ), \"resolved\" ],\n\t\t\t\t[ \"reject\", \"fail\", jQuery.Callbacks( \"once memory\" ), \"rejected\" ],\n\t\t\t\t[ \"notify\", \"progress\", jQuery.Callbacks( \"memory\" ) ]\n\t\t\t],\n\t\t\tstate = \"pending\",\n\t\t\tpromise = {\n\t\t\t\tstate: function() {\n\t\t\t\t\treturn state;\n\t\t\t\t},\n\t\t\t\talways: function() {\n\t\t\t\t\tdeferred.done( arguments ).fail( arguments );\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\tthen: function( /* fnDone, fnFail, fnProgress */ ) {\n\t\t\t\t\tvar fns = arguments;\n\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n\t\t\t\t\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\t\t\t\t\tvar fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];\n\n\t\t\t\t\t\t\t// deferred[ done | fail | progress ] for forwarding actions to newDefer\n\t\t\t\t\t\t\tdeferred[ tuple[ 1 ] ]( function() {\n\t\t\t\t\t\t\t\tvar returned = fn && fn.apply( this, arguments );\n\t\t\t\t\t\t\t\tif ( returned && jQuery.isFunction( returned.promise ) ) {\n\t\t\t\t\t\t\t\t\treturned.promise()\n\t\t\t\t\t\t\t\t\t\t.progress( newDefer.notify )\n\t\t\t\t\t\t\t\t\t\t.done( newDefer.resolve )\n\t\t\t\t\t\t\t\t\t\t.fail( newDefer.reject );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tnewDefer[ tuple[ 0 ] + \"With\" ](\n\t\t\t\t\t\t\t\t\t\tthis === promise ? newDefer.promise() : this,\n\t\t\t\t\t\t\t\t\t\tfn ? [ returned ] : arguments\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tfns = null;\n\t\t\t\t\t} ).promise();\n\t\t\t\t},\n\n\t\t\t\t// Get a promise for this deferred\n\t\t\t\t// If obj is provided, the promise aspect is added to the object\n\t\t\t\tpromise: function( obj ) {\n\t\t\t\t\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdeferred = {};\n\n\t\t// Keep pipe for back-compat\n\t\tpromise.pipe = promise.then;\n\n\t\t// Add list-specific methods\n\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\tvar list = tuple[ 2 ],\n\t\t\t\tstateString = tuple[ 3 ];\n\n\t\t\t// promise[ done | fail | progress ] = list.add\n\t\t\tpromise[ tuple[ 1 ] ] = list.add;\n\n\t\t\t// Handle state\n\t\t\tif ( stateString ) {\n\t\t\t\tlist.add( function() {\n\n\t\t\t\t\t// state = [ resolved | rejected ]\n\t\t\t\t\tstate = stateString;\n\n\t\t\t\t// [ reject_list | resolve_list ].disable; progress_list.lock\n\t\t\t\t}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );\n\t\t\t}\n\n\t\t\t// deferred[ resolve | reject | notify ]\n\t\t\tdeferred[ tuple[ 0 ] ] = function() {\n\t\t\t\tdeferred[ tuple[ 0 ] + \"With\" ]( this === deferred ? promise : this, arguments );\n\t\t\t\treturn this;\n\t\t\t};\n\t\t\tdeferred[ tuple[ 0 ] + \"With\" ] = list.fireWith;\n\t\t} );\n\n\t\t// Make the deferred a promise\n\t\tpromise.promise( deferred );\n\n\t\t// Call given func if any\n\t\tif ( func ) {\n\t\t\tfunc.call( deferred, deferred );\n\t\t}\n\n\t\t// All done!\n\t\treturn deferred;\n\t},\n\n\t// Deferred helper\n\twhen: function( subordinate /* , ..., subordinateN */ ) {\n\t\tvar i = 0,\n\t\t\tresolveValues = slice.call( arguments ),\n\t\t\tlength = resolveValues.length,\n\n\t\t\t// the count of uncompleted subordinates\n\t\t\tremaining = length !== 1 ||\n\t\t\t\t( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,\n\n\t\t\t// the master Deferred.\n\t\t\t// If resolveValues consist of only a single Deferred, just use that.\n\t\t\tdeferred = remaining === 1 ? subordinate : jQuery.Deferred(),\n\n\t\t\t// Update function for both resolve and progress values\n\t\t\tupdateFunc = function( i, contexts, values ) {\n\t\t\t\treturn function( value ) {\n\t\t\t\t\tcontexts[ i ] = this;\n\t\t\t\t\tvalues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\n\t\t\t\t\tif ( values === progressValues ) {\n\t\t\t\t\t\tdeferred.notifyWith( contexts, values );\n\t\t\t\t\t} else if ( !( --remaining ) ) {\n\t\t\t\t\t\tdeferred.resolveWith( contexts, values );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t},\n\n\t\t\tprogressValues, progressContexts, resolveContexts;\n\n\t\t// Add listeners to Deferred subordinates; treat others as resolved\n\t\tif ( length > 1 ) {\n\t\t\tprogressValues = new Array( length );\n\t\t\tprogressContexts = new Array( length );\n\t\t\tresolveContexts = new Array( length );\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tif ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {\n\t\t\t\t\tresolveValues[ i ].promise()\n\t\t\t\t\t\t.progress( updateFunc( i, progressContexts, progressValues ) )\n\t\t\t\t\t\t.done( updateFunc( i, resolveContexts, resolveValues ) )\n\t\t\t\t\t\t.fail( deferred.reject );\n\t\t\t\t} else {\n\t\t\t\t\t--remaining;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If we're not waiting on anything, resolve the master\n\t\tif ( !remaining ) {\n\t\t\tdeferred.resolveWith( resolveContexts, resolveValues );\n\t\t}\n\n\t\treturn deferred.promise();\n\t}\n} );\n\n\n// The deferred used on DOM ready\nvar readyList;\n\njQuery.fn.ready = function( fn ) {\n\n\t// Add the callback\n\tjQuery.ready.promise().done( fn );\n\n\treturn this;\n};\n\njQuery.extend( {\n\n\t// Is the DOM ready to be used? Set to true once it occurs.\n\tisReady: false,\n\n\t// A counter to track how many items to wait for before\n\t// the ready event fires. See #6781\n\treadyWait: 1,\n\n\t// Hold (or release) the ready event\n\tholdReady: function( hold ) {\n\t\tif ( hold ) {\n\t\t\tjQuery.readyWait++;\n\t\t} else {\n\t\t\tjQuery.ready( true );\n\t\t}\n\t},\n\n\t// Handle when the DOM is ready\n\tready: function( wait ) {\n\n\t\t// Abort if there are pending holds or we're already ready\n\t\tif ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Remember that the DOM is ready\n\t\tjQuery.isReady = true;\n\n\t\t// If a normal DOM Ready event fired, decrement, and wait if need be\n\t\tif ( wait !== true && --jQuery.readyWait > 0 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If there are functions bound, to execute\n\t\treadyList.resolveWith( document, [ jQuery ] );\n\n\t\t// Trigger any bound ready events\n\t\tif ( jQuery.fn.triggerHandler ) {\n\t\t\tjQuery( document ).triggerHandler( \"ready\" );\n\t\t\tjQuery( document ).off( \"ready\" );\n\t\t}\n\t}\n} );\n\n/**\n * The ready event handler and self cleanup method\n */\nfunction completed() {\n\tdocument.removeEventListener( \"DOMContentLoaded\", completed );\n\twindow.removeEventListener( \"load\", completed );\n\tjQuery.ready();\n}\n\njQuery.ready.promise = function( obj ) {\n\tif ( !readyList ) {\n\n\t\treadyList = jQuery.Deferred();\n\n\t\t// Catch cases where $(document).ready() is called\n\t\t// after the browser event has already occurred.\n\t\t// Support: IE9-10 only\n\t\t// Older IE sometimes signals \"interactive\" too soon\n\t\tif ( document.readyState === \"complete\" ||\n\t\t\t( document.readyState !== \"loading\" && !document.documentElement.doScroll ) ) {\n\n\t\t\t// Handle it asynchronously to allow scripts the opportunity to delay ready\n\t\t\twindow.setTimeout( jQuery.ready );\n\n\t\t} else {\n\n\t\t\t// Use the handy event callback\n\t\t\tdocument.addEventListener( \"DOMContentLoaded\", completed );\n\n\t\t\t// A fallback to window.onload, that will always work\n\t\t\twindow.addEventListener( \"load\", completed );\n\t\t}\n\t}\n\treturn readyList.promise( obj );\n};\n\n// Kick off the DOM ready check even if the user does not\njQuery.ready.promise();\n\n\n\n\n// Multifunctional method to get and set values of a collection\n// The value/s can optionally be executed if it's a function\nvar access = function( elems, fn, key, value, chainable, emptyGet, raw ) {\n\tvar i = 0,\n\t\tlen = elems.length,\n\t\tbulk = key == null;\n\n\t// Sets many values\n\tif ( jQuery.type( key ) === \"object\" ) {\n\t\tchainable = true;\n\t\tfor ( i in key ) {\n\t\t\taccess( elems, fn, i, key[ i ], true, emptyGet, raw );\n\t\t}\n\n\t// Sets one value\n\t} else if ( value !== undefined ) {\n\t\tchainable = true;\n\n\t\tif ( !jQuery.isFunction( value ) ) {\n\t\t\traw = true;\n\t\t}\n\n\t\tif ( bulk ) {\n\n\t\t\t// Bulk operations run against the entire set\n\t\t\tif ( raw ) {\n\t\t\t\tfn.call( elems, value );\n\t\t\t\tfn = null;\n\n\t\t\t// ...except when executing function values\n\t\t\t} else {\n\t\t\t\tbulk = fn;\n\t\t\t\tfn = function( elem, key, value ) {\n\t\t\t\t\treturn bulk.call( jQuery( elem ), value );\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tif ( fn ) {\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\tfn(\n\t\t\t\t\telems[ i ], key, raw ?\n\t\t\t\t\tvalue :\n\t\t\t\t\tvalue.call( elems[ i ], i, fn( elems[ i ], key ) )\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn chainable ?\n\t\telems :\n\n\t\t// Gets\n\t\tbulk ?\n\t\t\tfn.call( elems ) :\n\t\t\tlen ? fn( elems[ 0 ], key ) : emptyGet;\n};\nvar acceptData = function( owner ) {\n\n\t// Accepts only:\n\t//  - Node\n\t//    - Node.ELEMENT_NODE\n\t//    - Node.DOCUMENT_NODE\n\t//  - Object\n\t//    - Any\n\t/* jshint -W018 */\n\treturn owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );\n};\n\n\n\n\nfunction Data() {\n\tthis.expando = jQuery.expando + Data.uid++;\n}\n\nData.uid = 1;\n\nData.prototype = {\n\n\tregister: function( owner, initial ) {\n\t\tvar value = initial || {};\n\n\t\t// If it is a node unlikely to be stringify-ed or looped over\n\t\t// use plain assignment\n\t\tif ( owner.nodeType ) {\n\t\t\towner[ this.expando ] = value;\n\n\t\t// Otherwise secure it in a non-enumerable, non-writable property\n\t\t// configurability must be true to allow the property to be\n\t\t// deleted with the delete operator\n\t\t} else {\n\t\t\tObject.defineProperty( owner, this.expando, {\n\t\t\t\tvalue: value,\n\t\t\t\twritable: true,\n\t\t\t\tconfigurable: true\n\t\t\t} );\n\t\t}\n\t\treturn owner[ this.expando ];\n\t},\n\tcache: function( owner ) {\n\n\t\t// We can accept data for non-element nodes in modern browsers,\n\t\t// but we should not, see #8335.\n\t\t// Always return an empty object.\n\t\tif ( !acceptData( owner ) ) {\n\t\t\treturn {};\n\t\t}\n\n\t\t// Check if the owner object already has a cache\n\t\tvar value = owner[ this.expando ];\n\n\t\t// If not, create one\n\t\tif ( !value ) {\n\t\t\tvalue = {};\n\n\t\t\t// We can accept data for non-element nodes in modern browsers,\n\t\t\t// but we should not, see #8335.\n\t\t\t// Always return an empty object.\n\t\t\tif ( acceptData( owner ) ) {\n\n\t\t\t\t// If it is a node unlikely to be stringify-ed or looped over\n\t\t\t\t// use plain assignment\n\t\t\t\tif ( owner.nodeType ) {\n\t\t\t\t\towner[ this.expando ] = value;\n\n\t\t\t\t// Otherwise secure it in a non-enumerable property\n\t\t\t\t// configurable must be true to allow the property to be\n\t\t\t\t// deleted when data is removed\n\t\t\t\t} else {\n\t\t\t\t\tObject.defineProperty( owner, this.expando, {\n\t\t\t\t\t\tvalue: value,\n\t\t\t\t\t\tconfigurable: true\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn value;\n\t},\n\tset: function( owner, data, value ) {\n\t\tvar prop,\n\t\t\tcache = this.cache( owner );\n\n\t\t// Handle: [ owner, key, value ] args\n\t\tif ( typeof data === \"string\" ) {\n\t\t\tcache[ data ] = value;\n\n\t\t// Handle: [ owner, { properties } ] args\n\t\t} else {\n\n\t\t\t// Copy the properties one-by-one to the cache object\n\t\t\tfor ( prop in data ) {\n\t\t\t\tcache[ prop ] = data[ prop ];\n\t\t\t}\n\t\t}\n\t\treturn cache;\n\t},\n\tget: function( owner, key ) {\n\t\treturn key === undefined ?\n\t\t\tthis.cache( owner ) :\n\t\t\towner[ this.expando ] && owner[ this.expando ][ key ];\n\t},\n\taccess: function( owner, key, value ) {\n\t\tvar stored;\n\n\t\t// In cases where either:\n\t\t//\n\t\t//   1. No key was specified\n\t\t//   2. A string key was specified, but no value provided\n\t\t//\n\t\t// Take the \"read\" path and allow the get method to determine\n\t\t// which value to return, respectively either:\n\t\t//\n\t\t//   1. The entire cache object\n\t\t//   2. The data stored at the key\n\t\t//\n\t\tif ( key === undefined ||\n\t\t\t\t( ( key && typeof key === \"string\" ) && value === undefined ) ) {\n\n\t\t\tstored = this.get( owner, key );\n\n\t\t\treturn stored !== undefined ?\n\t\t\t\tstored : this.get( owner, jQuery.camelCase( key ) );\n\t\t}\n\n\t\t// When the key is not a string, or both a key and value\n\t\t// are specified, set or extend (existing objects) with either:\n\t\t//\n\t\t//   1. An object of properties\n\t\t//   2. A key and value\n\t\t//\n\t\tthis.set( owner, key, value );\n\n\t\t// Since the \"set\" path can have two possible entry points\n\t\t// return the expected data based on which path was taken[*]\n\t\treturn value !== undefined ? value : key;\n\t},\n\tremove: function( owner, key ) {\n\t\tvar i, name, camel,\n\t\t\tcache = owner[ this.expando ];\n\n\t\tif ( cache === undefined ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( key === undefined ) {\n\t\t\tthis.register( owner );\n\n\t\t} else {\n\n\t\t\t// Support array or space separated string of keys\n\t\t\tif ( jQuery.isArray( key ) ) {\n\n\t\t\t\t// If \"name\" is an array of keys...\n\t\t\t\t// When data is initially created, via (\"key\", \"val\") signature,\n\t\t\t\t// keys will be converted to camelCase.\n\t\t\t\t// Since there is no way to tell _how_ a key was added, remove\n\t\t\t\t// both plain key and camelCase key. #12786\n\t\t\t\t// This will only penalize the array argument path.\n\t\t\t\tname = key.concat( key.map( jQuery.camelCase ) );\n\t\t\t} else {\n\t\t\t\tcamel = jQuery.camelCase( key );\n\n\t\t\t\t// Try the string as a key before any manipulation\n\t\t\t\tif ( key in cache ) {\n\t\t\t\t\tname = [ key, camel ];\n\t\t\t\t} else {\n\n\t\t\t\t\t// If a key with the spaces exists, use it.\n\t\t\t\t\t// Otherwise, create an array by matching non-whitespace\n\t\t\t\t\tname = camel;\n\t\t\t\t\tname = name in cache ?\n\t\t\t\t\t\t[ name ] : ( name.match( rnotwhite ) || [] );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ti = name.length;\n\n\t\t\twhile ( i-- ) {\n\t\t\t\tdelete cache[ name[ i ] ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove the expando if there's no more data\n\t\tif ( key === undefined || jQuery.isEmptyObject( cache ) ) {\n\n\t\t\t// Support: Chrome <= 35-45+\n\t\t\t// Webkit & Blink performance suffers when deleting properties\n\t\t\t// from DOM nodes, so set to undefined instead\n\t\t\t// https://code.google.com/p/chromium/issues/detail?id=378607\n\t\t\tif ( owner.nodeType ) {\n\t\t\t\towner[ this.expando ] = undefined;\n\t\t\t} else {\n\t\t\t\tdelete owner[ this.expando ];\n\t\t\t}\n\t\t}\n\t},\n\thasData: function( owner ) {\n\t\tvar cache = owner[ this.expando ];\n\t\treturn cache !== undefined && !jQuery.isEmptyObject( cache );\n\t}\n};\nvar dataPriv = new Data();\n\nvar dataUser = new Data();\n\n\n\n//\tImplementation Summary\n//\n//\t1. Enforce API surface and semantic compatibility with 1.9.x branch\n//\t2. Improve the module's maintainability by reducing the storage\n//\t\tpaths to a single mechanism.\n//\t3. Use the same single mechanism to support \"private\" and \"user\" data.\n//\t4. _Never_ expose \"private\" data to user code (TODO: Drop _data, _removeData)\n//\t5. Avoid exposing implementation details on user objects (eg. expando properties)\n//\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\n\nvar rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n\trmultiDash = /[A-Z]/g;\n\nfunction dataAttr( elem, key, data ) {\n\tvar name;\n\n\t// If nothing was found internally, try to fetch any\n\t// data from the HTML5 data-* attribute\n\tif ( data === undefined && elem.nodeType === 1 ) {\n\t\tname = \"data-\" + key.replace( rmultiDash, \"-$&\" ).toLowerCase();\n\t\tdata = elem.getAttribute( name );\n\n\t\tif ( typeof data === \"string\" ) {\n\t\t\ttry {\n\t\t\t\tdata = data === \"true\" ? true :\n\t\t\t\t\tdata === \"false\" ? false :\n\t\t\t\t\tdata === \"null\" ? null :\n\n\t\t\t\t\t// Only convert to a number if it doesn't change the string\n\t\t\t\t\t+data + \"\" === data ? +data :\n\t\t\t\t\trbrace.test( data ) ? jQuery.parseJSON( data ) :\n\t\t\t\t\tdata;\n\t\t\t} catch ( e ) {}\n\n\t\t\t// Make sure we set the data so it isn't changed later\n\t\t\tdataUser.set( elem, key, data );\n\t\t} else {\n\t\t\tdata = undefined;\n\t\t}\n\t}\n\treturn data;\n}\n\njQuery.extend( {\n\thasData: function( elem ) {\n\t\treturn dataUser.hasData( elem ) || dataPriv.hasData( elem );\n\t},\n\n\tdata: function( elem, name, data ) {\n\t\treturn dataUser.access( elem, name, data );\n\t},\n\n\tremoveData: function( elem, name ) {\n\t\tdataUser.remove( elem, name );\n\t},\n\n\t// TODO: Now that all calls to _data and _removeData have been replaced\n\t// with direct calls to dataPriv methods, these can be deprecated.\n\t_data: function( elem, name, data ) {\n\t\treturn dataPriv.access( elem, name, data );\n\t},\n\n\t_removeData: function( elem, name ) {\n\t\tdataPriv.remove( elem, name );\n\t}\n} );\n\njQuery.fn.extend( {\n\tdata: function( key, value ) {\n\t\tvar i, name, data,\n\t\t\telem = this[ 0 ],\n\t\t\tattrs = elem && elem.attributes;\n\n\t\t// Gets all values\n\t\tif ( key === undefined ) {\n\t\t\tif ( this.length ) {\n\t\t\t\tdata = dataUser.get( elem );\n\n\t\t\t\tif ( elem.nodeType === 1 && !dataPriv.get( elem, \"hasDataAttrs\" ) ) {\n\t\t\t\t\ti = attrs.length;\n\t\t\t\t\twhile ( i-- ) {\n\n\t\t\t\t\t\t// Support: IE11+\n\t\t\t\t\t\t// The attrs elements can be null (#14894)\n\t\t\t\t\t\tif ( attrs[ i ] ) {\n\t\t\t\t\t\t\tname = attrs[ i ].name;\n\t\t\t\t\t\t\tif ( name.indexOf( \"data-\" ) === 0 ) {\n\t\t\t\t\t\t\t\tname = jQuery.camelCase( name.slice( 5 ) );\n\t\t\t\t\t\t\t\tdataAttr( elem, name, data[ name ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdataPriv.set( elem, \"hasDataAttrs\", true );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\t// Sets multiple values\n\t\tif ( typeof key === \"object\" ) {\n\t\t\treturn this.each( function() {\n\t\t\t\tdataUser.set( this, key );\n\t\t\t} );\n\t\t}\n\n\t\treturn access( this, function( value ) {\n\t\t\tvar data, camelKey;\n\n\t\t\t// The calling jQuery object (element matches) is not empty\n\t\t\t// (and therefore has an element appears at this[ 0 ]) and the\n\t\t\t// `value` parameter was not undefined. An empty jQuery object\n\t\t\t// will result in `undefined` for elem = this[ 0 ] which will\n\t\t\t// throw an exception if an attempt to read a data cache is made.\n\t\t\tif ( elem && value === undefined ) {\n\n\t\t\t\t// Attempt to get data from the cache\n\t\t\t\t// with the key as-is\n\t\t\t\tdata = dataUser.get( elem, key ) ||\n\n\t\t\t\t\t// Try to find dashed key if it exists (gh-2779)\n\t\t\t\t\t// This is for 2.2.x only\n\t\t\t\t\tdataUser.get( elem, key.replace( rmultiDash, \"-$&\" ).toLowerCase() );\n\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\tcamelKey = jQuery.camelCase( key );\n\n\t\t\t\t// Attempt to get data from the cache\n\t\t\t\t// with the key camelized\n\t\t\t\tdata = dataUser.get( elem, camelKey );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// Attempt to \"discover\" the data in\n\t\t\t\t// HTML5 custom data-* attrs\n\t\t\t\tdata = dataAttr( elem, camelKey, undefined );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// We tried really hard, but the data doesn't exist.\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Set the data...\n\t\t\tcamelKey = jQuery.camelCase( key );\n\t\t\tthis.each( function() {\n\n\t\t\t\t// First, attempt to store a copy or reference of any\n\t\t\t\t// data that might've been store with a camelCased key.\n\t\t\t\tvar data = dataUser.get( this, camelKey );\n\n\t\t\t\t// For HTML5 data-* attribute interop, we have to\n\t\t\t\t// store property names with dashes in a camelCase form.\n\t\t\t\t// This might not apply to all properties...*\n\t\t\t\tdataUser.set( this, camelKey, value );\n\n\t\t\t\t// *... In the case of properties that might _actually_\n\t\t\t\t// have dashes, we need to also store a copy of that\n\t\t\t\t// unchanged property.\n\t\t\t\tif ( key.indexOf( \"-\" ) > -1 && data !== undefined ) {\n\t\t\t\t\tdataUser.set( this, key, value );\n\t\t\t\t}\n\t\t\t} );\n\t\t}, null, value, arguments.length > 1, null, true );\n\t},\n\n\tremoveData: function( key ) {\n\t\treturn this.each( function() {\n\t\t\tdataUser.remove( this, key );\n\t\t} );\n\t}\n} );\n\n\njQuery.extend( {\n\tqueue: function( elem, type, data ) {\n\t\tvar queue;\n\n\t\tif ( elem ) {\n\t\t\ttype = ( type || \"fx\" ) + \"queue\";\n\t\t\tqueue = dataPriv.get( elem, type );\n\n\t\t\t// Speed up dequeue by getting out quickly if this is just a lookup\n\t\t\tif ( data ) {\n\t\t\t\tif ( !queue || jQuery.isArray( data ) ) {\n\t\t\t\t\tqueue = dataPriv.access( elem, type, jQuery.makeArray( data ) );\n\t\t\t\t} else {\n\t\t\t\t\tqueue.push( data );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn queue || [];\n\t\t}\n\t},\n\n\tdequeue: function( elem, type ) {\n\t\ttype = type || \"fx\";\n\n\t\tvar queue = jQuery.queue( elem, type ),\n\t\t\tstartLength = queue.length,\n\t\t\tfn = queue.shift(),\n\t\t\thooks = jQuery._queueHooks( elem, type ),\n\t\t\tnext = function() {\n\t\t\t\tjQuery.dequeue( elem, type );\n\t\t\t};\n\n\t\t// If the fx queue is dequeued, always remove the progress sentinel\n\t\tif ( fn === \"inprogress\" ) {\n\t\t\tfn = queue.shift();\n\t\t\tstartLength--;\n\t\t}\n\n\t\tif ( fn ) {\n\n\t\t\t// Add a progress sentinel to prevent the fx queue from being\n\t\t\t// automatically dequeued\n\t\t\tif ( type === \"fx\" ) {\n\t\t\t\tqueue.unshift( \"inprogress\" );\n\t\t\t}\n\n\t\t\t// Clear up the last queue stop function\n\t\t\tdelete hooks.stop;\n\t\t\tfn.call( elem, next, hooks );\n\t\t}\n\n\t\tif ( !startLength && hooks ) {\n\t\t\thooks.empty.fire();\n\t\t}\n\t},\n\n\t// Not public - generate a queueHooks object, or return the current one\n\t_queueHooks: function( elem, type ) {\n\t\tvar key = type + \"queueHooks\";\n\t\treturn dataPriv.get( elem, key ) || dataPriv.access( elem, key, {\n\t\t\tempty: jQuery.Callbacks( \"once memory\" ).add( function() {\n\t\t\t\tdataPriv.remove( elem, [ type + \"queue\", key ] );\n\t\t\t} )\n\t\t} );\n\t}\n} );\n\njQuery.fn.extend( {\n\tqueue: function( type, data ) {\n\t\tvar setter = 2;\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tdata = type;\n\t\t\ttype = \"fx\";\n\t\t\tsetter--;\n\t\t}\n\n\t\tif ( arguments.length < setter ) {\n\t\t\treturn jQuery.queue( this[ 0 ], type );\n\t\t}\n\n\t\treturn data === undefined ?\n\t\t\tthis :\n\t\t\tthis.each( function() {\n\t\t\t\tvar queue = jQuery.queue( this, type, data );\n\n\t\t\t\t// Ensure a hooks for this queue\n\t\t\t\tjQuery._queueHooks( this, type );\n\n\t\t\t\tif ( type === \"fx\" && queue[ 0 ] !== \"inprogress\" ) {\n\t\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t\t}\n\t\t\t} );\n\t},\n\tdequeue: function( type ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.dequeue( this, type );\n\t\t} );\n\t},\n\tclearQueue: function( type ) {\n\t\treturn this.queue( type || \"fx\", [] );\n\t},\n\n\t// Get a promise resolved when queues of a certain type\n\t// are emptied (fx is the type by default)\n\tpromise: function( type, obj ) {\n\t\tvar tmp,\n\t\t\tcount = 1,\n\t\t\tdefer = jQuery.Deferred(),\n\t\t\telements = this,\n\t\t\ti = this.length,\n\t\t\tresolve = function() {\n\t\t\t\tif ( !( --count ) ) {\n\t\t\t\t\tdefer.resolveWith( elements, [ elements ] );\n\t\t\t\t}\n\t\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tobj = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\ttype = type || \"fx\";\n\n\t\twhile ( i-- ) {\n\t\t\ttmp = dataPriv.get( elements[ i ], type + \"queueHooks\" );\n\t\t\tif ( tmp && tmp.empty ) {\n\t\t\t\tcount++;\n\t\t\t\ttmp.empty.add( resolve );\n\t\t\t}\n\t\t}\n\t\tresolve();\n\t\treturn defer.promise( obj );\n\t}\n} );\nvar pnum = ( /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/ ).source;\n\nvar rcssNum = new RegExp( \"^(?:([+-])=|)(\" + pnum + \")([a-z%]*)$\", \"i\" );\n\n\nvar cssExpand = [ \"Top\", \"Right\", \"Bottom\", \"Left\" ];\n\nvar isHidden = function( elem, el ) {\n\n\t\t// isHidden might be called from jQuery#filter function;\n\t\t// in that case, element will be second argument\n\t\telem = el || elem;\n\t\treturn jQuery.css( elem, \"display\" ) === \"none\" ||\n\t\t\t!jQuery.contains( elem.ownerDocument, elem );\n\t};\n\n\n\nfunction adjustCSS( elem, prop, valueParts, tween ) {\n\tvar adjusted,\n\t\tscale = 1,\n\t\tmaxIterations = 20,\n\t\tcurrentValue = tween ?\n\t\t\tfunction() { return tween.cur(); } :\n\t\t\tfunction() { return jQuery.css( elem, prop, \"\" ); },\n\t\tinitial = currentValue(),\n\t\tunit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" ),\n\n\t\t// Starting value computation is required for potential unit mismatches\n\t\tinitialInUnit = ( jQuery.cssNumber[ prop ] || unit !== \"px\" && +initial ) &&\n\t\t\trcssNum.exec( jQuery.css( elem, prop ) );\n\n\tif ( initialInUnit && initialInUnit[ 3 ] !== unit ) {\n\n\t\t// Trust units reported by jQuery.css\n\t\tunit = unit || initialInUnit[ 3 ];\n\n\t\t// Make sure we update the tween properties later on\n\t\tvalueParts = valueParts || [];\n\n\t\t// Iteratively approximate from a nonzero starting point\n\t\tinitialInUnit = +initial || 1;\n\n\t\tdo {\n\n\t\t\t// If previous iteration zeroed out, double until we get *something*.\n\t\t\t// Use string for doubling so we don't accidentally see scale as unchanged below\n\t\t\tscale = scale || \".5\";\n\n\t\t\t// Adjust and apply\n\t\t\tinitialInUnit = initialInUnit / scale;\n\t\t\tjQuery.style( elem, prop, initialInUnit + unit );\n\n\t\t// Update scale, tolerating zero or NaN from tween.cur()\n\t\t// Break the loop if scale is unchanged or perfect, or if we've just had enough.\n\t\t} while (\n\t\t\tscale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations\n\t\t);\n\t}\n\n\tif ( valueParts ) {\n\t\tinitialInUnit = +initialInUnit || +initial || 0;\n\n\t\t// Apply relative offset (+=/-=) if specified\n\t\tadjusted = valueParts[ 1 ] ?\n\t\t\tinitialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :\n\t\t\t+valueParts[ 2 ];\n\t\tif ( tween ) {\n\t\t\ttween.unit = unit;\n\t\t\ttween.start = initialInUnit;\n\t\t\ttween.end = adjusted;\n\t\t}\n\t}\n\treturn adjusted;\n}\nvar rcheckableType = ( /^(?:checkbox|radio)$/i );\n\nvar rtagName = ( /<([\\w:-]+)/ );\n\nvar rscriptType = ( /^$|\\/(?:java|ecma)script/i );\n\n\n\n// We have to close these tags to support XHTML (#13200)\nvar wrapMap = {\n\n\t// Support: IE9\n\toption: [ 1, \"<select multiple='multiple'>\", \"</select>\" ],\n\n\t// XHTML parsers do not magically insert elements in the\n\t// same way that tag soup parsers do. So we cannot shorten\n\t// this by omitting <tbody> or other required elements.\n\tthead: [ 1, \"<table>\", \"</table>\" ],\n\tcol: [ 2, \"<table><colgroup>\", \"</colgroup></table>\" ],\n\ttr: [ 2, \"<table><tbody>\", \"</tbody></table>\" ],\n\ttd: [ 3, \"<table><tbody><tr>\", \"</tr></tbody></table>\" ],\n\n\t_default: [ 0, \"\", \"\" ]\n};\n\n// Support: IE9\nwrapMap.optgroup = wrapMap.option;\n\nwrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\nwrapMap.th = wrapMap.td;\n\n\nfunction getAll( context, tag ) {\n\n\t// Support: IE9-11+\n\t// Use typeof to avoid zero-argument method invocation on host objects (#15151)\n\tvar ret = typeof context.getElementsByTagName !== \"undefined\" ?\n\t\t\tcontext.getElementsByTagName( tag || \"*\" ) :\n\t\t\ttypeof context.querySelectorAll !== \"undefined\" ?\n\t\t\t\tcontext.querySelectorAll( tag || \"*\" ) :\n\t\t\t[];\n\n\treturn tag === undefined || tag && jQuery.nodeName( context, tag ) ?\n\t\tjQuery.merge( [ context ], ret ) :\n\t\tret;\n}\n\n\n// Mark scripts as having already been evaluated\nfunction setGlobalEval( elems, refElements ) {\n\tvar i = 0,\n\t\tl = elems.length;\n\n\tfor ( ; i < l; i++ ) {\n\t\tdataPriv.set(\n\t\t\telems[ i ],\n\t\t\t\"globalEval\",\n\t\t\t!refElements || dataPriv.get( refElements[ i ], \"globalEval\" )\n\t\t);\n\t}\n}\n\n\nvar rhtml = /<|&#?\\w+;/;\n\nfunction buildFragment( elems, context, scripts, selection, ignored ) {\n\tvar elem, tmp, tag, wrap, contains, j,\n\t\tfragment = context.createDocumentFragment(),\n\t\tnodes = [],\n\t\ti = 0,\n\t\tl = elems.length;\n\n\tfor ( ; i < l; i++ ) {\n\t\telem = elems[ i ];\n\n\t\tif ( elem || elem === 0 ) {\n\n\t\t\t// Add nodes directly\n\t\t\tif ( jQuery.type( elem ) === \"object\" ) {\n\n\t\t\t\t// Support: Android<4.1, PhantomJS<2\n\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\tjQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\n\n\t\t\t// Convert non-html into a text node\n\t\t\t} else if ( !rhtml.test( elem ) ) {\n\t\t\t\tnodes.push( context.createTextNode( elem ) );\n\n\t\t\t// Convert html into DOM nodes\n\t\t\t} else {\n\t\t\t\ttmp = tmp || fragment.appendChild( context.createElement( \"div\" ) );\n\n\t\t\t\t// Deserialize a standard representation\n\t\t\t\ttag = ( rtagName.exec( elem ) || [ \"\", \"\" ] )[ 1 ].toLowerCase();\n\t\t\t\twrap = wrapMap[ tag ] || wrapMap._default;\n\t\t\t\ttmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];\n\n\t\t\t\t// Descend through wrappers to the right content\n\t\t\t\tj = wrap[ 0 ];\n\t\t\t\twhile ( j-- ) {\n\t\t\t\t\ttmp = tmp.lastChild;\n\t\t\t\t}\n\n\t\t\t\t// Support: Android<4.1, PhantomJS<2\n\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\tjQuery.merge( nodes, tmp.childNodes );\n\n\t\t\t\t// Remember the top-level container\n\t\t\t\ttmp = fragment.firstChild;\n\n\t\t\t\t// Ensure the created nodes are orphaned (#12392)\n\t\t\t\ttmp.textContent = \"\";\n\t\t\t}\n\t\t}\n\t}\n\n\t// Remove wrapper from fragment\n\tfragment.textContent = \"\";\n\n\ti = 0;\n\twhile ( ( elem = nodes[ i++ ] ) ) {\n\n\t\t// Skip elements already in the context collection (trac-4087)\n\t\tif ( selection && jQuery.inArray( elem, selection ) > -1 ) {\n\t\t\tif ( ignored ) {\n\t\t\t\tignored.push( elem );\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tcontains = jQuery.contains( elem.ownerDocument, elem );\n\n\t\t// Append to fragment\n\t\ttmp = getAll( fragment.appendChild( elem ), \"script\" );\n\n\t\t// Preserve script evaluation history\n\t\tif ( contains ) {\n\t\t\tsetGlobalEval( tmp );\n\t\t}\n\n\t\t// Capture executables\n\t\tif ( scripts ) {\n\t\t\tj = 0;\n\t\t\twhile ( ( elem = tmp[ j++ ] ) ) {\n\t\t\t\tif ( rscriptType.test( elem.type || \"\" ) ) {\n\t\t\t\t\tscripts.push( elem );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn fragment;\n}\n\n\n( function() {\n\tvar fragment = document.createDocumentFragment(),\n\t\tdiv = fragment.appendChild( document.createElement( \"div\" ) ),\n\t\tinput = document.createElement( \"input\" );\n\n\t// Support: Android 4.0-4.3, Safari<=5.1\n\t// Check state lost if the name is set (#11217)\n\t// Support: Windows Web Apps (WWA)\n\t// `name` and `type` must use .setAttribute for WWA (#14901)\n\tinput.setAttribute( \"type\", \"radio\" );\n\tinput.setAttribute( \"checked\", \"checked\" );\n\tinput.setAttribute( \"name\", \"t\" );\n\n\tdiv.appendChild( input );\n\n\t// Support: Safari<=5.1, Android<4.2\n\t// Older WebKit doesn't clone checked state correctly in fragments\n\tsupport.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;\n\n\t// Support: IE<=11+\n\t// Make sure textarea (and checkbox) defaultValue is properly cloned\n\tdiv.innerHTML = \"<textarea>x</textarea>\";\n\tsupport.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;\n} )();\n\n\nvar\n\trkeyEvent = /^key/,\n\trmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,\n\trtypenamespace = /^([^.]*)(?:\\.(.+)|)/;\n\nfunction returnTrue() {\n\treturn true;\n}\n\nfunction returnFalse() {\n\treturn false;\n}\n\n// Support: IE9\n// See #13393 for more info\nfunction safeActiveElement() {\n\ttry {\n\t\treturn document.activeElement;\n\t} catch ( err ) { }\n}\n\nfunction on( elem, types, selector, data, fn, one ) {\n\tvar origFn, type;\n\n\t// Types can be a map of types/handlers\n\tif ( typeof types === \"object\" ) {\n\n\t\t// ( types-Object, selector, data )\n\t\tif ( typeof selector !== \"string\" ) {\n\n\t\t\t// ( types-Object, data )\n\t\t\tdata = data || selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tfor ( type in types ) {\n\t\t\ton( elem, type, selector, data, types[ type ], one );\n\t\t}\n\t\treturn elem;\n\t}\n\n\tif ( data == null && fn == null ) {\n\n\t\t// ( types, fn )\n\t\tfn = selector;\n\t\tdata = selector = undefined;\n\t} else if ( fn == null ) {\n\t\tif ( typeof selector === \"string\" ) {\n\n\t\t\t// ( types, selector, fn )\n\t\t\tfn = data;\n\t\t\tdata = undefined;\n\t\t} else {\n\n\t\t\t// ( types, data, fn )\n\t\t\tfn = data;\n\t\t\tdata = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t}\n\tif ( fn === false ) {\n\t\tfn = returnFalse;\n\t} else if ( !fn ) {\n\t\treturn elem;\n\t}\n\n\tif ( one === 1 ) {\n\t\torigFn = fn;\n\t\tfn = function( event ) {\n\n\t\t\t// Can use an empty set, since event contains the info\n\t\t\tjQuery().off( event );\n\t\t\treturn origFn.apply( this, arguments );\n\t\t};\n\n\t\t// Use same guid so caller can remove using origFn\n\t\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\n\t}\n\treturn elem.each( function() {\n\t\tjQuery.event.add( this, types, fn, data, selector );\n\t} );\n}\n\n/*\n * Helper functions for managing events -- not part of the public interface.\n * Props to Dean Edwards' addEvent library for many of the ideas.\n */\njQuery.event = {\n\n\tglobal: {},\n\n\tadd: function( elem, types, handler, data, selector ) {\n\n\t\tvar handleObjIn, eventHandle, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = dataPriv.get( elem );\n\n\t\t// Don't attach events to noData or text/comment nodes (but allow plain objects)\n\t\tif ( !elemData ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Caller can pass in an object of custom data in lieu of the handler\n\t\tif ( handler.handler ) {\n\t\t\thandleObjIn = handler;\n\t\t\thandler = handleObjIn.handler;\n\t\t\tselector = handleObjIn.selector;\n\t\t}\n\n\t\t// Make sure that the handler has a unique ID, used to find/remove it later\n\t\tif ( !handler.guid ) {\n\t\t\thandler.guid = jQuery.guid++;\n\t\t}\n\n\t\t// Init the element's event structure and main handler, if this is the first\n\t\tif ( !( events = elemData.events ) ) {\n\t\t\tevents = elemData.events = {};\n\t\t}\n\t\tif ( !( eventHandle = elemData.handle ) ) {\n\t\t\teventHandle = elemData.handle = function( e ) {\n\n\t\t\t\t// Discard the second event of a jQuery.event.trigger() and\n\t\t\t\t// when an event is called after a page has unloaded\n\t\t\t\treturn typeof jQuery !== \"undefined\" && jQuery.event.triggered !== e.type ?\n\t\t\t\t\tjQuery.event.dispatch.apply( elem, arguments ) : undefined;\n\t\t\t};\n\t\t}\n\n\t\t// Handle multiple events separated by a space\n\t\ttypes = ( types || \"\" ).match( rnotwhite ) || [ \"\" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n\t\t\ttype = origType = tmp[ 1 ];\n\t\t\tnamespaces = ( tmp[ 2 ] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// There *must* be a type, no attaching namespace-only handlers\n\t\t\tif ( !type ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If event changes its type, use the special event handlers for the changed type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// If selector defined, determine special event api type, otherwise given type\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\n\t\t\t// Update special based on newly reset type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// handleObj is passed to all event handlers\n\t\t\thandleObj = jQuery.extend( {\n\t\t\t\ttype: type,\n\t\t\t\torigType: origType,\n\t\t\t\tdata: data,\n\t\t\t\thandler: handler,\n\t\t\t\tguid: handler.guid,\n\t\t\t\tselector: selector,\n\t\t\t\tneedsContext: selector && jQuery.expr.match.needsContext.test( selector ),\n\t\t\t\tnamespace: namespaces.join( \".\" )\n\t\t\t}, handleObjIn );\n\n\t\t\t// Init the event handler queue if we're the first\n\t\t\tif ( !( handlers = events[ type ] ) ) {\n\t\t\t\thandlers = events[ type ] = [];\n\t\t\t\thandlers.delegateCount = 0;\n\n\t\t\t\t// Only use addEventListener if the special events handler returns false\n\t\t\t\tif ( !special.setup ||\n\t\t\t\t\tspecial.setup.call( elem, data, namespaces, eventHandle ) === false ) {\n\n\t\t\t\t\tif ( elem.addEventListener ) {\n\t\t\t\t\t\telem.addEventListener( type, eventHandle );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( special.add ) {\n\t\t\t\tspecial.add.call( elem, handleObj );\n\n\t\t\t\tif ( !handleObj.handler.guid ) {\n\t\t\t\t\thandleObj.handler.guid = handler.guid;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add to the element's handler list, delegates in front\n\t\t\tif ( selector ) {\n\t\t\t\thandlers.splice( handlers.delegateCount++, 0, handleObj );\n\t\t\t} else {\n\t\t\t\thandlers.push( handleObj );\n\t\t\t}\n\n\t\t\t// Keep track of which events have ever been used, for event optimization\n\t\t\tjQuery.event.global[ type ] = true;\n\t\t}\n\n\t},\n\n\t// Detach an event or set of events from an element\n\tremove: function( elem, types, handler, selector, mappedTypes ) {\n\n\t\tvar j, origCount, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = dataPriv.hasData( elem ) && dataPriv.get( elem );\n\n\t\tif ( !elemData || !( events = elemData.events ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Once for each type.namespace in types; type may be omitted\n\t\ttypes = ( types || \"\" ).match( rnotwhite ) || [ \"\" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n\t\t\ttype = origType = tmp[ 1 ];\n\t\t\tnamespaces = ( tmp[ 2 ] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// Unbind all events (on this namespace, if provided) for the element\n\t\t\tif ( !type ) {\n\t\t\t\tfor ( type in events ) {\n\t\t\t\t\tjQuery.event.remove( elem, type + types[ t ], handler, selector, true );\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\t\t\thandlers = events[ type ] || [];\n\t\t\ttmp = tmp[ 2 ] &&\n\t\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join( \"\\\\.(?:.*\\\\.|)\" ) + \"(\\\\.|$)\" );\n\n\t\t\t// Remove matching events\n\t\t\torigCount = j = handlers.length;\n\t\t\twhile ( j-- ) {\n\t\t\t\thandleObj = handlers[ j ];\n\n\t\t\t\tif ( ( mappedTypes || origType === handleObj.origType ) &&\n\t\t\t\t\t( !handler || handler.guid === handleObj.guid ) &&\n\t\t\t\t\t( !tmp || tmp.test( handleObj.namespace ) ) &&\n\t\t\t\t\t( !selector || selector === handleObj.selector ||\n\t\t\t\t\t\tselector === \"**\" && handleObj.selector ) ) {\n\t\t\t\t\thandlers.splice( j, 1 );\n\n\t\t\t\t\tif ( handleObj.selector ) {\n\t\t\t\t\t\thandlers.delegateCount--;\n\t\t\t\t\t}\n\t\t\t\t\tif ( special.remove ) {\n\t\t\t\t\t\tspecial.remove.call( elem, handleObj );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove generic event handler if we removed something and no more handlers exist\n\t\t\t// (avoids potential for endless recursion during removal of special event handlers)\n\t\t\tif ( origCount && !handlers.length ) {\n\t\t\t\tif ( !special.teardown ||\n\t\t\t\t\tspecial.teardown.call( elem, namespaces, elemData.handle ) === false ) {\n\n\t\t\t\t\tjQuery.removeEvent( elem, type, elemData.handle );\n\t\t\t\t}\n\n\t\t\t\tdelete events[ type ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove data and the expando if it's no longer used\n\t\tif ( jQuery.isEmptyObject( events ) ) {\n\t\t\tdataPriv.remove( elem, \"handle events\" );\n\t\t}\n\t},\n\n\tdispatch: function( event ) {\n\n\t\t// Make a writable jQuery.Event from the native event object\n\t\tevent = jQuery.event.fix( event );\n\n\t\tvar i, j, ret, matched, handleObj,\n\t\t\thandlerQueue = [],\n\t\t\targs = slice.call( arguments ),\n\t\t\thandlers = ( dataPriv.get( this, \"events\" ) || {} )[ event.type ] || [],\n\t\t\tspecial = jQuery.event.special[ event.type ] || {};\n\n\t\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\n\t\targs[ 0 ] = event;\n\t\tevent.delegateTarget = this;\n\n\t\t// Call the preDispatch hook for the mapped type, and let it bail if desired\n\t\tif ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine handlers\n\t\thandlerQueue = jQuery.event.handlers.call( this, event, handlers );\n\n\t\t// Run delegates first; they may want to stop propagation beneath us\n\t\ti = 0;\n\t\twhile ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {\n\t\t\tevent.currentTarget = matched.elem;\n\n\t\t\tj = 0;\n\t\t\twhile ( ( handleObj = matched.handlers[ j++ ] ) &&\n\t\t\t\t!event.isImmediatePropagationStopped() ) {\n\n\t\t\t\t// Triggered event must either 1) have no namespace, or 2) have namespace(s)\n\t\t\t\t// a subset or equal to those in the bound event (both can have no namespace).\n\t\t\t\tif ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {\n\n\t\t\t\t\tevent.handleObj = handleObj;\n\t\t\t\t\tevent.data = handleObj.data;\n\n\t\t\t\t\tret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||\n\t\t\t\t\t\thandleObj.handler ).apply( matched.elem, args );\n\n\t\t\t\t\tif ( ret !== undefined ) {\n\t\t\t\t\t\tif ( ( event.result = ret ) === false ) {\n\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Call the postDispatch hook for the mapped type\n\t\tif ( special.postDispatch ) {\n\t\t\tspecial.postDispatch.call( this, event );\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\thandlers: function( event, handlers ) {\n\t\tvar i, matches, sel, handleObj,\n\t\t\thandlerQueue = [],\n\t\t\tdelegateCount = handlers.delegateCount,\n\t\t\tcur = event.target;\n\n\t\t// Support (at least): Chrome, IE9\n\t\t// Find delegate handlers\n\t\t// Black-hole SVG <use> instance trees (#13180)\n\t\t//\n\t\t// Support: Firefox<=42+\n\t\t// Avoid non-left-click in FF but don't block IE radio events (#3861, gh-2343)\n\t\tif ( delegateCount && cur.nodeType &&\n\t\t\t( event.type !== \"click\" || isNaN( event.button ) || event.button < 1 ) ) {\n\n\t\t\tfor ( ; cur !== this; cur = cur.parentNode || this ) {\n\n\t\t\t\t// Don't check non-elements (#13208)\n\t\t\t\t// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\n\t\t\t\tif ( cur.nodeType === 1 && ( cur.disabled !== true || event.type !== \"click\" ) ) {\n\t\t\t\t\tmatches = [];\n\t\t\t\t\tfor ( i = 0; i < delegateCount; i++ ) {\n\t\t\t\t\t\thandleObj = handlers[ i ];\n\n\t\t\t\t\t\t// Don't conflict with Object.prototype properties (#13203)\n\t\t\t\t\t\tsel = handleObj.selector + \" \";\n\n\t\t\t\t\t\tif ( matches[ sel ] === undefined ) {\n\t\t\t\t\t\t\tmatches[ sel ] = handleObj.needsContext ?\n\t\t\t\t\t\t\t\tjQuery( sel, this ).index( cur ) > -1 :\n\t\t\t\t\t\t\t\tjQuery.find( sel, this, null, [ cur ] ).length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( matches[ sel ] ) {\n\t\t\t\t\t\t\tmatches.push( handleObj );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( matches.length ) {\n\t\t\t\t\t\thandlerQueue.push( { elem: cur, handlers: matches } );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add the remaining (directly-bound) handlers\n\t\tif ( delegateCount < handlers.length ) {\n\t\t\thandlerQueue.push( { elem: this, handlers: handlers.slice( delegateCount ) } );\n\t\t}\n\n\t\treturn handlerQueue;\n\t},\n\n\t// Includes some event props shared by KeyEvent and MouseEvent\n\tprops: ( \"altKey bubbles cancelable ctrlKey currentTarget detail eventPhase \" +\n\t\t\"metaKey relatedTarget shiftKey target timeStamp view which\" ).split( \" \" ),\n\n\tfixHooks: {},\n\n\tkeyHooks: {\n\t\tprops: \"char charCode key keyCode\".split( \" \" ),\n\t\tfilter: function( event, original ) {\n\n\t\t\t// Add which for key events\n\t\t\tif ( event.which == null ) {\n\t\t\t\tevent.which = original.charCode != null ? original.charCode : original.keyCode;\n\t\t\t}\n\n\t\t\treturn event;\n\t\t}\n\t},\n\n\tmouseHooks: {\n\t\tprops: ( \"button buttons clientX clientY offsetX offsetY pageX pageY \" +\n\t\t\t\"screenX screenY toElement\" ).split( \" \" ),\n\t\tfilter: function( event, original ) {\n\t\t\tvar eventDoc, doc, body,\n\t\t\t\tbutton = original.button;\n\n\t\t\t// Calculate pageX/Y if missing and clientX/Y available\n\t\t\tif ( event.pageX == null && original.clientX != null ) {\n\t\t\t\teventDoc = event.target.ownerDocument || document;\n\t\t\t\tdoc = eventDoc.documentElement;\n\t\t\t\tbody = eventDoc.body;\n\n\t\t\t\tevent.pageX = original.clientX +\n\t\t\t\t\t( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) -\n\t\t\t\t\t( doc && doc.clientLeft || body && body.clientLeft || 0 );\n\t\t\t\tevent.pageY = original.clientY +\n\t\t\t\t\t( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) -\n\t\t\t\t\t( doc && doc.clientTop  || body && body.clientTop  || 0 );\n\t\t\t}\n\n\t\t\t// Add which for click: 1 === left; 2 === middle; 3 === right\n\t\t\t// Note: button is not normalized, so don't use it\n\t\t\tif ( !event.which && button !== undefined ) {\n\t\t\t\tevent.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );\n\t\t\t}\n\n\t\t\treturn event;\n\t\t}\n\t},\n\n\tfix: function( event ) {\n\t\tif ( event[ jQuery.expando ] ) {\n\t\t\treturn event;\n\t\t}\n\n\t\t// Create a writable copy of the event object and normalize some properties\n\t\tvar i, prop, copy,\n\t\t\ttype = event.type,\n\t\t\toriginalEvent = event,\n\t\t\tfixHook = this.fixHooks[ type ];\n\n\t\tif ( !fixHook ) {\n\t\t\tthis.fixHooks[ type ] = fixHook =\n\t\t\t\trmouseEvent.test( type ) ? this.mouseHooks :\n\t\t\t\trkeyEvent.test( type ) ? this.keyHooks :\n\t\t\t\t{};\n\t\t}\n\t\tcopy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;\n\n\t\tevent = new jQuery.Event( originalEvent );\n\n\t\ti = copy.length;\n\t\twhile ( i-- ) {\n\t\t\tprop = copy[ i ];\n\t\t\tevent[ prop ] = originalEvent[ prop ];\n\t\t}\n\n\t\t// Support: Cordova 2.5 (WebKit) (#13255)\n\t\t// All events should have a target; Cordova deviceready doesn't\n\t\tif ( !event.target ) {\n\t\t\tevent.target = document;\n\t\t}\n\n\t\t// Support: Safari 6.0+, Chrome<28\n\t\t// Target should not be a text node (#504, #13143)\n\t\tif ( event.target.nodeType === 3 ) {\n\t\t\tevent.target = event.target.parentNode;\n\t\t}\n\n\t\treturn fixHook.filter ? fixHook.filter( event, originalEvent ) : event;\n\t},\n\n\tspecial: {\n\t\tload: {\n\n\t\t\t// Prevent triggered image.load events from bubbling to window.load\n\t\t\tnoBubble: true\n\t\t},\n\t\tfocus: {\n\n\t\t\t// Fire native event if possible so blur/focus sequence is correct\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this !== safeActiveElement() && this.focus ) {\n\t\t\t\t\tthis.focus();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelegateType: \"focusin\"\n\t\t},\n\t\tblur: {\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this === safeActiveElement() && this.blur ) {\n\t\t\t\t\tthis.blur();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelegateType: \"focusout\"\n\t\t},\n\t\tclick: {\n\n\t\t\t// For checkbox, fire native event so checked state will be right\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this.type === \"checkbox\" && this.click && jQuery.nodeName( this, \"input\" ) ) {\n\t\t\t\t\tthis.click();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// For cross-browser consistency, don't fire native .click() on links\n\t\t\t_default: function( event ) {\n\t\t\t\treturn jQuery.nodeName( event.target, \"a\" );\n\t\t\t}\n\t\t},\n\n\t\tbeforeunload: {\n\t\t\tpostDispatch: function( event ) {\n\n\t\t\t\t// Support: Firefox 20+\n\t\t\t\t// Firefox doesn't alert if the returnValue field is not set.\n\t\t\t\tif ( event.result !== undefined && event.originalEvent ) {\n\t\t\t\t\tevent.originalEvent.returnValue = event.result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\njQuery.removeEvent = function( elem, type, handle ) {\n\n\t// This \"if\" is needed for plain objects\n\tif ( elem.removeEventListener ) {\n\t\telem.removeEventListener( type, handle );\n\t}\n};\n\njQuery.Event = function( src, props ) {\n\n\t// Allow instantiation without the 'new' keyword\n\tif ( !( this instanceof jQuery.Event ) ) {\n\t\treturn new jQuery.Event( src, props );\n\t}\n\n\t// Event object\n\tif ( src && src.type ) {\n\t\tthis.originalEvent = src;\n\t\tthis.type = src.type;\n\n\t\t// Events bubbling up the document may have been marked as prevented\n\t\t// by a handler lower down the tree; reflect the correct value.\n\t\tthis.isDefaultPrevented = src.defaultPrevented ||\n\t\t\t\tsrc.defaultPrevented === undefined &&\n\n\t\t\t\t// Support: Android<4.0\n\t\t\t\tsrc.returnValue === false ?\n\t\t\treturnTrue :\n\t\t\treturnFalse;\n\n\t// Event type\n\t} else {\n\t\tthis.type = src;\n\t}\n\n\t// Put explicitly provided properties onto the event object\n\tif ( props ) {\n\t\tjQuery.extend( this, props );\n\t}\n\n\t// Create a timestamp if incoming event doesn't have one\n\tthis.timeStamp = src && src.timeStamp || jQuery.now();\n\n\t// Mark it as fixed\n\tthis[ jQuery.expando ] = true;\n};\n\n// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\njQuery.Event.prototype = {\n\tconstructor: jQuery.Event,\n\tisDefaultPrevented: returnFalse,\n\tisPropagationStopped: returnFalse,\n\tisImmediatePropagationStopped: returnFalse,\n\tisSimulated: false,\n\n\tpreventDefault: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isDefaultPrevented = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.preventDefault();\n\t\t}\n\t},\n\tstopPropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isPropagationStopped = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.stopPropagation();\n\t\t}\n\t},\n\tstopImmediatePropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isImmediatePropagationStopped = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.stopImmediatePropagation();\n\t\t}\n\n\t\tthis.stopPropagation();\n\t}\n};\n\n// Create mouseenter/leave events using mouseover/out and event-time checks\n// so that event delegation works in jQuery.\n// Do the same for pointerenter/pointerleave and pointerover/pointerout\n//\n// Support: Safari 7 only\n// Safari sends mouseenter too often; see:\n// https://code.google.com/p/chromium/issues/detail?id=470258\n// for the description of the bug (it existed in older Chrome versions as well).\njQuery.each( {\n\tmouseenter: \"mouseover\",\n\tmouseleave: \"mouseout\",\n\tpointerenter: \"pointerover\",\n\tpointerleave: \"pointerout\"\n}, function( orig, fix ) {\n\tjQuery.event.special[ orig ] = {\n\t\tdelegateType: fix,\n\t\tbindType: fix,\n\n\t\thandle: function( event ) {\n\t\t\tvar ret,\n\t\t\t\ttarget = this,\n\t\t\t\trelated = event.relatedTarget,\n\t\t\t\thandleObj = event.handleObj;\n\n\t\t\t// For mouseenter/leave call the handler if related is outside the target.\n\t\t\t// NB: No relatedTarget if the mouse left/entered the browser window\n\t\t\tif ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {\n\t\t\t\tevent.type = handleObj.origType;\n\t\t\t\tret = handleObj.handler.apply( this, arguments );\n\t\t\t\tevent.type = fix;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t};\n} );\n\njQuery.fn.extend( {\n\ton: function( types, selector, data, fn ) {\n\t\treturn on( this, types, selector, data, fn );\n\t},\n\tone: function( types, selector, data, fn ) {\n\t\treturn on( this, types, selector, data, fn, 1 );\n\t},\n\toff: function( types, selector, fn ) {\n\t\tvar handleObj, type;\n\t\tif ( types && types.preventDefault && types.handleObj ) {\n\n\t\t\t// ( event )  dispatched jQuery.Event\n\t\t\thandleObj = types.handleObj;\n\t\t\tjQuery( types.delegateTarget ).off(\n\t\t\t\thandleObj.namespace ?\n\t\t\t\t\thandleObj.origType + \".\" + handleObj.namespace :\n\t\t\t\t\thandleObj.origType,\n\t\t\t\thandleObj.selector,\n\t\t\t\thandleObj.handler\n\t\t\t);\n\t\t\treturn this;\n\t\t}\n\t\tif ( typeof types === \"object\" ) {\n\n\t\t\t// ( types-object [, selector] )\n\t\t\tfor ( type in types ) {\n\t\t\t\tthis.off( type, selector, types[ type ] );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\tif ( selector === false || typeof selector === \"function\" ) {\n\n\t\t\t// ( types [, fn] )\n\t\t\tfn = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tif ( fn === false ) {\n\t\t\tfn = returnFalse;\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.remove( this, types, fn, selector );\n\t\t} );\n\t}\n} );\n\n\nvar\n\trxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:-]+)[^>]*)\\/>/gi,\n\n\t// Support: IE 10-11, Edge 10240+\n\t// In IE/Edge using regex groups here causes severe slowdowns.\n\t// See https://connect.microsoft.com/IE/feedback/details/1736512/\n\trnoInnerhtml = /<script|<style|<link/i,\n\n\t// checked=\"checked\" or checked\n\trchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n\trscriptTypeMasked = /^true\\/(.*)/,\n\trcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g;\n\n// Manipulating tables requires a tbody\nfunction manipulationTarget( elem, content ) {\n\treturn jQuery.nodeName( elem, \"table\" ) &&\n\t\tjQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, \"tr\" ) ?\n\n\t\telem.getElementsByTagName( \"tbody\" )[ 0 ] ||\n\t\t\telem.appendChild( elem.ownerDocument.createElement( \"tbody\" ) ) :\n\t\telem;\n}\n\n// Replace/restore the type attribute of script elements for safe DOM manipulation\nfunction disableScript( elem ) {\n\telem.type = ( elem.getAttribute( \"type\" ) !== null ) + \"/\" + elem.type;\n\treturn elem;\n}\nfunction restoreScript( elem ) {\n\tvar match = rscriptTypeMasked.exec( elem.type );\n\n\tif ( match ) {\n\t\telem.type = match[ 1 ];\n\t} else {\n\t\telem.removeAttribute( \"type\" );\n\t}\n\n\treturn elem;\n}\n\nfunction cloneCopyEvent( src, dest ) {\n\tvar i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;\n\n\tif ( dest.nodeType !== 1 ) {\n\t\treturn;\n\t}\n\n\t// 1. Copy private data: events, handlers, etc.\n\tif ( dataPriv.hasData( src ) ) {\n\t\tpdataOld = dataPriv.access( src );\n\t\tpdataCur = dataPriv.set( dest, pdataOld );\n\t\tevents = pdataOld.events;\n\n\t\tif ( events ) {\n\t\t\tdelete pdataCur.handle;\n\t\t\tpdataCur.events = {};\n\n\t\t\tfor ( type in events ) {\n\t\t\t\tfor ( i = 0, l = events[ type ].length; i < l; i++ ) {\n\t\t\t\t\tjQuery.event.add( dest, type, events[ type ][ i ] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// 2. Copy user data\n\tif ( dataUser.hasData( src ) ) {\n\t\tudataOld = dataUser.access( src );\n\t\tudataCur = jQuery.extend( {}, udataOld );\n\n\t\tdataUser.set( dest, udataCur );\n\t}\n}\n\n// Fix IE bugs, see support tests\nfunction fixInput( src, dest ) {\n\tvar nodeName = dest.nodeName.toLowerCase();\n\n\t// Fails to persist the checked state of a cloned checkbox or radio button.\n\tif ( nodeName === \"input\" && rcheckableType.test( src.type ) ) {\n\t\tdest.checked = src.checked;\n\n\t// Fails to return the selected option to the default selected state when cloning options\n\t} else if ( nodeName === \"input\" || nodeName === \"textarea\" ) {\n\t\tdest.defaultValue = src.defaultValue;\n\t}\n}\n\nfunction domManip( collection, args, callback, ignored ) {\n\n\t// Flatten any nested arrays\n\targs = concat.apply( [], args );\n\n\tvar fragment, first, scripts, hasScripts, node, doc,\n\t\ti = 0,\n\t\tl = collection.length,\n\t\tiNoClone = l - 1,\n\t\tvalue = args[ 0 ],\n\t\tisFunction = jQuery.isFunction( value );\n\n\t// We can't cloneNode fragments that contain checked, in WebKit\n\tif ( isFunction ||\n\t\t\t( l > 1 && typeof value === \"string\" &&\n\t\t\t\t!support.checkClone && rchecked.test( value ) ) ) {\n\t\treturn collection.each( function( index ) {\n\t\t\tvar self = collection.eq( index );\n\t\t\tif ( isFunction ) {\n\t\t\t\targs[ 0 ] = value.call( this, index, self.html() );\n\t\t\t}\n\t\t\tdomManip( self, args, callback, ignored );\n\t\t} );\n\t}\n\n\tif ( l ) {\n\t\tfragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );\n\t\tfirst = fragment.firstChild;\n\n\t\tif ( fragment.childNodes.length === 1 ) {\n\t\t\tfragment = first;\n\t\t}\n\n\t\t// Require either new content or an interest in ignored elements to invoke the callback\n\t\tif ( first || ignored ) {\n\t\t\tscripts = jQuery.map( getAll( fragment, \"script\" ), disableScript );\n\t\t\thasScripts = scripts.length;\n\n\t\t\t// Use the original fragment for the last item\n\t\t\t// instead of the first because it can end up\n\t\t\t// being emptied incorrectly in certain situations (#8070).\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tnode = fragment;\n\n\t\t\t\tif ( i !== iNoClone ) {\n\t\t\t\t\tnode = jQuery.clone( node, true, true );\n\n\t\t\t\t\t// Keep references to cloned scripts for later restoration\n\t\t\t\t\tif ( hasScripts ) {\n\n\t\t\t\t\t\t// Support: Android<4.1, PhantomJS<2\n\t\t\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\t\t\tjQuery.merge( scripts, getAll( node, \"script\" ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcallback.call( collection[ i ], node, i );\n\t\t\t}\n\n\t\t\tif ( hasScripts ) {\n\t\t\t\tdoc = scripts[ scripts.length - 1 ].ownerDocument;\n\n\t\t\t\t// Reenable scripts\n\t\t\t\tjQuery.map( scripts, restoreScript );\n\n\t\t\t\t// Evaluate executable scripts on first document insertion\n\t\t\t\tfor ( i = 0; i < hasScripts; i++ ) {\n\t\t\t\t\tnode = scripts[ i ];\n\t\t\t\t\tif ( rscriptType.test( node.type || \"\" ) &&\n\t\t\t\t\t\t!dataPriv.access( node, \"globalEval\" ) &&\n\t\t\t\t\t\tjQuery.contains( doc, node ) ) {\n\n\t\t\t\t\t\tif ( node.src ) {\n\n\t\t\t\t\t\t\t// Optional AJAX dependency, but won't run scripts if not present\n\t\t\t\t\t\t\tif ( jQuery._evalUrl ) {\n\t\t\t\t\t\t\t\tjQuery._evalUrl( node.src );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tjQuery.globalEval( node.textContent.replace( rcleanScript, \"\" ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn collection;\n}\n\nfunction remove( elem, selector, keepData ) {\n\tvar node,\n\t\tnodes = selector ? jQuery.filter( selector, elem ) : elem,\n\t\ti = 0;\n\n\tfor ( ; ( node = nodes[ i ] ) != null; i++ ) {\n\t\tif ( !keepData && node.nodeType === 1 ) {\n\t\t\tjQuery.cleanData( getAll( node ) );\n\t\t}\n\n\t\tif ( node.parentNode ) {\n\t\t\tif ( keepData && jQuery.contains( node.ownerDocument, node ) ) {\n\t\t\t\tsetGlobalEval( getAll( node, \"script\" ) );\n\t\t\t}\n\t\t\tnode.parentNode.removeChild( node );\n\t\t}\n\t}\n\n\treturn elem;\n}\n\njQuery.extend( {\n\thtmlPrefilter: function( html ) {\n\t\treturn html.replace( rxhtmlTag, \"<$1></$2>\" );\n\t},\n\n\tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\n\t\tvar i, l, srcElements, destElements,\n\t\t\tclone = elem.cloneNode( true ),\n\t\t\tinPage = jQuery.contains( elem.ownerDocument, elem );\n\n\t\t// Fix IE cloning issues\n\t\tif ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&\n\t\t\t\t!jQuery.isXMLDoc( elem ) ) {\n\n\t\t\t// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2\n\t\t\tdestElements = getAll( clone );\n\t\t\tsrcElements = getAll( elem );\n\n\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\tfixInput( srcElements[ i ], destElements[ i ] );\n\t\t\t}\n\t\t}\n\n\t\t// Copy the events from the original to the clone\n\t\tif ( dataAndEvents ) {\n\t\t\tif ( deepDataAndEvents ) {\n\t\t\t\tsrcElements = srcElements || getAll( elem );\n\t\t\t\tdestElements = destElements || getAll( clone );\n\n\t\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\t\tcloneCopyEvent( srcElements[ i ], destElements[ i ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcloneCopyEvent( elem, clone );\n\t\t\t}\n\t\t}\n\n\t\t// Preserve script evaluation history\n\t\tdestElements = getAll( clone, \"script\" );\n\t\tif ( destElements.length > 0 ) {\n\t\t\tsetGlobalEval( destElements, !inPage && getAll( elem, \"script\" ) );\n\t\t}\n\n\t\t// Return the cloned set\n\t\treturn clone;\n\t},\n\n\tcleanData: function( elems ) {\n\t\tvar data, elem, type,\n\t\t\tspecial = jQuery.event.special,\n\t\t\ti = 0;\n\n\t\tfor ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {\n\t\t\tif ( acceptData( elem ) ) {\n\t\t\t\tif ( ( data = elem[ dataPriv.expando ] ) ) {\n\t\t\t\t\tif ( data.events ) {\n\t\t\t\t\t\tfor ( type in data.events ) {\n\t\t\t\t\t\t\tif ( special[ type ] ) {\n\t\t\t\t\t\t\t\tjQuery.event.remove( elem, type );\n\n\t\t\t\t\t\t\t// This is a shortcut to avoid jQuery.event.remove's overhead\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tjQuery.removeEvent( elem, type, data.handle );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Support: Chrome <= 35-45+\n\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n\t\t\t\t\telem[ dataPriv.expando ] = undefined;\n\t\t\t\t}\n\t\t\t\tif ( elem[ dataUser.expando ] ) {\n\n\t\t\t\t\t// Support: Chrome <= 35-45+\n\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n\t\t\t\t\telem[ dataUser.expando ] = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n} );\n\njQuery.fn.extend( {\n\n\t// Keep domManip exposed until 3.0 (gh-2225)\n\tdomManip: domManip,\n\n\tdetach: function( selector ) {\n\t\treturn remove( this, selector, true );\n\t},\n\n\tremove: function( selector ) {\n\t\treturn remove( this, selector );\n\t},\n\n\ttext: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\treturn value === undefined ?\n\t\t\t\tjQuery.text( this ) :\n\t\t\t\tthis.empty().each( function() {\n\t\t\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\t\t\tthis.textContent = value;\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t}, null, value, arguments.length );\n\t},\n\n\tappend: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.appendChild( elem );\n\t\t\t}\n\t\t} );\n\t},\n\n\tprepend: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.insertBefore( elem, target.firstChild );\n\t\t\t}\n\t\t} );\n\t},\n\n\tbefore: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this );\n\t\t\t}\n\t\t} );\n\t},\n\n\tafter: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this.nextSibling );\n\t\t\t}\n\t\t} );\n\t},\n\n\tempty: function() {\n\t\tvar elem,\n\t\t\ti = 0;\n\n\t\tfor ( ; ( elem = this[ i ] ) != null; i++ ) {\n\t\t\tif ( elem.nodeType === 1 ) {\n\n\t\t\t\t// Prevent memory leaks\n\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\n\t\t\t\t// Remove any remaining nodes\n\t\t\t\telem.textContent = \"\";\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tclone: function( dataAndEvents, deepDataAndEvents ) {\n\t\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n\t\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n\n\t\treturn this.map( function() {\n\t\t\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\n\t\t} );\n\t},\n\n\thtml: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\tvar elem = this[ 0 ] || {},\n\t\t\t\ti = 0,\n\t\t\t\tl = this.length;\n\n\t\t\tif ( value === undefined && elem.nodeType === 1 ) {\n\t\t\t\treturn elem.innerHTML;\n\t\t\t}\n\n\t\t\t// See if we can take a shortcut and just use innerHTML\n\t\t\tif ( typeof value === \"string\" && !rnoInnerhtml.test( value ) &&\n\t\t\t\t!wrapMap[ ( rtagName.exec( value ) || [ \"\", \"\" ] )[ 1 ].toLowerCase() ] ) {\n\n\t\t\t\tvalue = jQuery.htmlPrefilter( value );\n\n\t\t\t\ttry {\n\t\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\t\telem = this[ i ] || {};\n\n\t\t\t\t\t\t// Remove element nodes and prevent memory leaks\n\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\t\t\t\t\t\t\telem.innerHTML = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telem = 0;\n\n\t\t\t\t// If using innerHTML throws an exception, use the fallback method\n\t\t\t\t} catch ( e ) {}\n\t\t\t}\n\n\t\t\tif ( elem ) {\n\t\t\t\tthis.empty().append( value );\n\t\t\t}\n\t\t}, null, value, arguments.length );\n\t},\n\n\treplaceWith: function() {\n\t\tvar ignored = [];\n\n\t\t// Make the changes, replacing each non-ignored context element with the new content\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tvar parent = this.parentNode;\n\n\t\t\tif ( jQuery.inArray( this, ignored ) < 0 ) {\n\t\t\t\tjQuery.cleanData( getAll( this ) );\n\t\t\t\tif ( parent ) {\n\t\t\t\t\tparent.replaceChild( elem, this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Force callback invocation\n\t\t}, ignored );\n\t}\n} );\n\njQuery.each( {\n\tappendTo: \"append\",\n\tprependTo: \"prepend\",\n\tinsertBefore: \"before\",\n\tinsertAfter: \"after\",\n\treplaceAll: \"replaceWith\"\n}, function( name, original ) {\n\tjQuery.fn[ name ] = function( selector ) {\n\t\tvar elems,\n\t\t\tret = [],\n\t\t\tinsert = jQuery( selector ),\n\t\t\tlast = insert.length - 1,\n\t\t\ti = 0;\n\n\t\tfor ( ; i <= last; i++ ) {\n\t\t\telems = i === last ? this : this.clone( true );\n\t\t\tjQuery( insert[ i ] )[ original ]( elems );\n\n\t\t\t// Support: QtWebKit\n\t\t\t// .get() because push.apply(_, arraylike) throws\n\t\t\tpush.apply( ret, elems.get() );\n\t\t}\n\n\t\treturn this.pushStack( ret );\n\t};\n} );\n\n\nvar iframe,\n\telemdisplay = {\n\n\t\t// Support: Firefox\n\t\t// We have to pre-define these values for FF (#10227)\n\t\tHTML: \"block\",\n\t\tBODY: \"block\"\n\t};\n\n/**\n * Retrieve the actual display of a element\n * @param {String} name nodeName of the element\n * @param {Object} doc Document object\n */\n\n// Called only from within defaultDisplay\nfunction actualDisplay( name, doc ) {\n\tvar elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),\n\n\t\tdisplay = jQuery.css( elem[ 0 ], \"display\" );\n\n\t// We don't have any data stored on the element,\n\t// so use \"detach\" method as fast way to get rid of the element\n\telem.detach();\n\n\treturn display;\n}\n\n/**\n * Try to determine the default display value of an element\n * @param {String} nodeName\n */\nfunction defaultDisplay( nodeName ) {\n\tvar doc = document,\n\t\tdisplay = elemdisplay[ nodeName ];\n\n\tif ( !display ) {\n\t\tdisplay = actualDisplay( nodeName, doc );\n\n\t\t// If the simple way fails, read from inside an iframe\n\t\tif ( display === \"none\" || !display ) {\n\n\t\t\t// Use the already-created iframe if possible\n\t\t\tiframe = ( iframe || jQuery( \"<iframe frameborder='0' width='0' height='0'/>\" ) )\n\t\t\t\t.appendTo( doc.documentElement );\n\n\t\t\t// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse\n\t\t\tdoc = iframe[ 0 ].contentDocument;\n\n\t\t\t// Support: IE\n\t\t\tdoc.write();\n\t\t\tdoc.close();\n\n\t\t\tdisplay = actualDisplay( nodeName, doc );\n\t\t\tiframe.detach();\n\t\t}\n\n\t\t// Store the correct default display\n\t\telemdisplay[ nodeName ] = display;\n\t}\n\n\treturn display;\n}\nvar rmargin = ( /^margin/ );\n\nvar rnumnonpx = new RegExp( \"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\" );\n\nvar getStyles = function( elem ) {\n\n\t\t// Support: IE<=11+, Firefox<=30+ (#15098, #14150)\n\t\t// IE throws on elements created in popups\n\t\t// FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\n\t\tvar view = elem.ownerDocument.defaultView;\n\n\t\tif ( !view || !view.opener ) {\n\t\t\tview = window;\n\t\t}\n\n\t\treturn view.getComputedStyle( elem );\n\t};\n\nvar swap = function( elem, options, callback, args ) {\n\tvar ret, name,\n\t\told = {};\n\n\t// Remember the old values, and insert the new ones\n\tfor ( name in options ) {\n\t\told[ name ] = elem.style[ name ];\n\t\telem.style[ name ] = options[ name ];\n\t}\n\n\tret = callback.apply( elem, args || [] );\n\n\t// Revert the old values\n\tfor ( name in options ) {\n\t\telem.style[ name ] = old[ name ];\n\t}\n\n\treturn ret;\n};\n\n\nvar documentElement = document.documentElement;\n\n\n\n( function() {\n\tvar pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,\n\t\tcontainer = document.createElement( \"div\" ),\n\t\tdiv = document.createElement( \"div\" );\n\n\t// Finish early in limited (non-browser) environments\n\tif ( !div.style ) {\n\t\treturn;\n\t}\n\n\t// Support: IE9-11+\n\t// Style of cloned element affects source element cloned (#8908)\n\tdiv.style.backgroundClip = \"content-box\";\n\tdiv.cloneNode( true ).style.backgroundClip = \"\";\n\tsupport.clearCloneStyle = div.style.backgroundClip === \"content-box\";\n\n\tcontainer.style.cssText = \"border:0;width:8px;height:0;top:0;left:-9999px;\" +\n\t\t\"padding:0;margin-top:1px;position:absolute\";\n\tcontainer.appendChild( div );\n\n\t// Executing both pixelPosition & boxSizingReliable tests require only one layout\n\t// so they're executed at the same time to save the second computation.\n\tfunction computeStyleTests() {\n\t\tdiv.style.cssText =\n\n\t\t\t// Support: Firefox<29, Android 2.3\n\t\t\t// Vendor-prefix box-sizing\n\t\t\t\"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;\" +\n\t\t\t\"position:relative;display:block;\" +\n\t\t\t\"margin:auto;border:1px;padding:1px;\" +\n\t\t\t\"top:1%;width:50%\";\n\t\tdiv.innerHTML = \"\";\n\t\tdocumentElement.appendChild( container );\n\n\t\tvar divStyle = window.getComputedStyle( div );\n\t\tpixelPositionVal = divStyle.top !== \"1%\";\n\t\treliableMarginLeftVal = divStyle.marginLeft === \"2px\";\n\t\tboxSizingReliableVal = divStyle.width === \"4px\";\n\n\t\t// Support: Android 4.0 - 4.3 only\n\t\t// Some styles come back with percentage values, even though they shouldn't\n\t\tdiv.style.marginRight = \"50%\";\n\t\tpixelMarginRightVal = divStyle.marginRight === \"4px\";\n\n\t\tdocumentElement.removeChild( container );\n\t}\n\n\tjQuery.extend( support, {\n\t\tpixelPosition: function() {\n\n\t\t\t// This test is executed only once but we still do memoizing\n\t\t\t// since we can use the boxSizingReliable pre-computing.\n\t\t\t// No need to check if the test was already performed, though.\n\t\t\tcomputeStyleTests();\n\t\t\treturn pixelPositionVal;\n\t\t},\n\t\tboxSizingReliable: function() {\n\t\t\tif ( boxSizingReliableVal == null ) {\n\t\t\t\tcomputeStyleTests();\n\t\t\t}\n\t\t\treturn boxSizingReliableVal;\n\t\t},\n\t\tpixelMarginRight: function() {\n\n\t\t\t// Support: Android 4.0-4.3\n\t\t\t// We're checking for boxSizingReliableVal here instead of pixelMarginRightVal\n\t\t\t// since that compresses better and they're computed together anyway.\n\t\t\tif ( boxSizingReliableVal == null ) {\n\t\t\t\tcomputeStyleTests();\n\t\t\t}\n\t\t\treturn pixelMarginRightVal;\n\t\t},\n\t\treliableMarginLeft: function() {\n\n\t\t\t// Support: IE <=8 only, Android 4.0 - 4.3 only, Firefox <=3 - 37\n\t\t\tif ( boxSizingReliableVal == null ) {\n\t\t\t\tcomputeStyleTests();\n\t\t\t}\n\t\t\treturn reliableMarginLeftVal;\n\t\t},\n\t\treliableMarginRight: function() {\n\n\t\t\t// Support: Android 2.3\n\t\t\t// Check if div with explicit width and no margin-right incorrectly\n\t\t\t// gets computed margin-right based on width of container. (#3333)\n\t\t\t// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right\n\t\t\t// This support function is only executed once so no memoizing is needed.\n\t\t\tvar ret,\n\t\t\t\tmarginDiv = div.appendChild( document.createElement( \"div\" ) );\n\n\t\t\t// Reset CSS: box-sizing; display; margin; border; padding\n\t\t\tmarginDiv.style.cssText = div.style.cssText =\n\n\t\t\t\t// Support: Android 2.3\n\t\t\t\t// Vendor-prefix box-sizing\n\t\t\t\t\"-webkit-box-sizing:content-box;box-sizing:content-box;\" +\n\t\t\t\t\"display:block;margin:0;border:0;padding:0\";\n\t\t\tmarginDiv.style.marginRight = marginDiv.style.width = \"0\";\n\t\t\tdiv.style.width = \"1px\";\n\t\t\tdocumentElement.appendChild( container );\n\n\t\t\tret = !parseFloat( window.getComputedStyle( marginDiv ).marginRight );\n\n\t\t\tdocumentElement.removeChild( container );\n\t\t\tdiv.removeChild( marginDiv );\n\n\t\t\treturn ret;\n\t\t}\n\t} );\n} )();\n\n\nfunction curCSS( elem, name, computed ) {\n\tvar width, minWidth, maxWidth, ret,\n\t\tstyle = elem.style;\n\n\tcomputed = computed || getStyles( elem );\n\tret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined;\n\n\t// Support: Opera 12.1x only\n\t// Fall back to style even without computed\n\t// computed is undefined for elems on document fragments\n\tif ( ( ret === \"\" || ret === undefined ) && !jQuery.contains( elem.ownerDocument, elem ) ) {\n\t\tret = jQuery.style( elem, name );\n\t}\n\n\t// Support: IE9\n\t// getPropertyValue is only needed for .css('filter') (#12537)\n\tif ( computed ) {\n\n\t\t// A tribute to the \"awesome hack by Dean Edwards\"\n\t\t// Android Browser returns percentage for some values,\n\t\t// but width seems to be reliably pixels.\n\t\t// This is against the CSSOM draft spec:\n\t\t// http://dev.w3.org/csswg/cssom/#resolved-values\n\t\tif ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {\n\n\t\t\t// Remember the original values\n\t\t\twidth = style.width;\n\t\t\tminWidth = style.minWidth;\n\t\t\tmaxWidth = style.maxWidth;\n\n\t\t\t// Put in the new values to get a computed value out\n\t\t\tstyle.minWidth = style.maxWidth = style.width = ret;\n\t\t\tret = computed.width;\n\n\t\t\t// Revert the changed values\n\t\t\tstyle.width = width;\n\t\t\tstyle.minWidth = minWidth;\n\t\t\tstyle.maxWidth = maxWidth;\n\t\t}\n\t}\n\n\treturn ret !== undefined ?\n\n\t\t// Support: IE9-11+\n\t\t// IE returns zIndex value as an integer.\n\t\tret + \"\" :\n\t\tret;\n}\n\n\nfunction addGetHookIf( conditionFn, hookFn ) {\n\n\t// Define the hook, we'll check on the first run if it's really needed.\n\treturn {\n\t\tget: function() {\n\t\t\tif ( conditionFn() ) {\n\n\t\t\t\t// Hook not needed (or it's not possible to use it due\n\t\t\t\t// to missing dependency), remove it.\n\t\t\t\tdelete this.get;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Hook needed; redefine it so that the support test is not executed again.\n\t\t\treturn ( this.get = hookFn ).apply( this, arguments );\n\t\t}\n\t};\n}\n\n\nvar\n\n\t// Swappable if display is none or starts with table\n\t// except \"table\", \"table-cell\", or \"table-caption\"\n\t// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\n\n\tcssShow = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\n\tcssNormalTransform = {\n\t\tletterSpacing: \"0\",\n\t\tfontWeight: \"400\"\n\t},\n\n\tcssPrefixes = [ \"Webkit\", \"O\", \"Moz\", \"ms\" ],\n\temptyStyle = document.createElement( \"div\" ).style;\n\n// Return a css property mapped to a potentially vendor prefixed property\nfunction vendorPropName( name ) {\n\n\t// Shortcut for names that are not vendor prefixed\n\tif ( name in emptyStyle ) {\n\t\treturn name;\n\t}\n\n\t// Check for vendor prefixed names\n\tvar capName = name[ 0 ].toUpperCase() + name.slice( 1 ),\n\t\ti = cssPrefixes.length;\n\n\twhile ( i-- ) {\n\t\tname = cssPrefixes[ i ] + capName;\n\t\tif ( name in emptyStyle ) {\n\t\t\treturn name;\n\t\t}\n\t}\n}\n\nfunction setPositiveNumber( elem, value, subtract ) {\n\n\t// Any relative (+/-) values have already been\n\t// normalized at this point\n\tvar matches = rcssNum.exec( value );\n\treturn matches ?\n\n\t\t// Guard against undefined \"subtract\", e.g., when used as in cssHooks\n\t\tMath.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || \"px\" ) :\n\t\tvalue;\n}\n\nfunction augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {\n\tvar i = extra === ( isBorderBox ? \"border\" : \"content\" ) ?\n\n\t\t// If we already have the right measurement, avoid augmentation\n\t\t4 :\n\n\t\t// Otherwise initialize for horizontal or vertical properties\n\t\tname === \"width\" ? 1 : 0,\n\n\t\tval = 0;\n\n\tfor ( ; i < 4; i += 2 ) {\n\n\t\t// Both box models exclude margin, so add it if we want it\n\t\tif ( extra === \"margin\" ) {\n\t\t\tval += jQuery.css( elem, extra + cssExpand[ i ], true, styles );\n\t\t}\n\n\t\tif ( isBorderBox ) {\n\n\t\t\t// border-box includes padding, so remove it if we want content\n\t\t\tif ( extra === \"content\" ) {\n\t\t\t\tval -= jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\t\t\t}\n\n\t\t\t// At this point, extra isn't border nor margin, so remove border\n\t\t\tif ( extra !== \"margin\" ) {\n\t\t\t\tval -= jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\t\t} else {\n\n\t\t\t// At this point, extra isn't content, so add padding\n\t\t\tval += jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\n\t\t\t// At this point, extra isn't content nor padding, so add border\n\t\t\tif ( extra !== \"padding\" ) {\n\t\t\t\tval += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn val;\n}\n\nfunction getWidthOrHeight( elem, name, extra ) {\n\n\t// Start with offset property, which is equivalent to the border-box value\n\tvar valueIsBorderBox = true,\n\t\tval = name === \"width\" ? elem.offsetWidth : elem.offsetHeight,\n\t\tstyles = getStyles( elem ),\n\t\tisBorderBox = jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\";\n\n\t// Some non-html elements return undefined for offsetWidth, so check for null/undefined\n\t// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285\n\t// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668\n\tif ( val <= 0 || val == null ) {\n\n\t\t// Fall back to computed then uncomputed css if necessary\n\t\tval = curCSS( elem, name, styles );\n\t\tif ( val < 0 || val == null ) {\n\t\t\tval = elem.style[ name ];\n\t\t}\n\n\t\t// Computed unit is not pixels. Stop here and return.\n\t\tif ( rnumnonpx.test( val ) ) {\n\t\t\treturn val;\n\t\t}\n\n\t\t// Check for style in case a browser which returns unreliable values\n\t\t// for getComputedStyle silently falls back to the reliable elem.style\n\t\tvalueIsBorderBox = isBorderBox &&\n\t\t\t( support.boxSizingReliable() || val === elem.style[ name ] );\n\n\t\t// Normalize \"\", auto, and prepare for extra\n\t\tval = parseFloat( val ) || 0;\n\t}\n\n\t// Use the active box-sizing model to add/subtract irrelevant styles\n\treturn ( val +\n\t\taugmentWidthOrHeight(\n\t\t\telem,\n\t\t\tname,\n\t\t\textra || ( isBorderBox ? \"border\" : \"content\" ),\n\t\t\tvalueIsBorderBox,\n\t\t\tstyles\n\t\t)\n\t) + \"px\";\n}\n\nfunction showHide( elements, show ) {\n\tvar display, elem, hidden,\n\t\tvalues = [],\n\t\tindex = 0,\n\t\tlength = elements.length;\n\n\tfor ( ; index < length; index++ ) {\n\t\telem = elements[ index ];\n\t\tif ( !elem.style ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tvalues[ index ] = dataPriv.get( elem, \"olddisplay\" );\n\t\tdisplay = elem.style.display;\n\t\tif ( show ) {\n\n\t\t\t// Reset the inline display of this element to learn if it is\n\t\t\t// being hidden by cascaded rules or not\n\t\t\tif ( !values[ index ] && display === \"none\" ) {\n\t\t\t\telem.style.display = \"\";\n\t\t\t}\n\n\t\t\t// Set elements which have been overridden with display: none\n\t\t\t// in a stylesheet to whatever the default browser style is\n\t\t\t// for such an element\n\t\t\tif ( elem.style.display === \"\" && isHidden( elem ) ) {\n\t\t\t\tvalues[ index ] = dataPriv.access(\n\t\t\t\t\telem,\n\t\t\t\t\t\"olddisplay\",\n\t\t\t\t\tdefaultDisplay( elem.nodeName )\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\thidden = isHidden( elem );\n\n\t\t\tif ( display !== \"none\" || !hidden ) {\n\t\t\t\tdataPriv.set(\n\t\t\t\t\telem,\n\t\t\t\t\t\"olddisplay\",\n\t\t\t\t\thidden ? display : jQuery.css( elem, \"display\" )\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set the display of most of the elements in a second loop\n\t// to avoid the constant reflow\n\tfor ( index = 0; index < length; index++ ) {\n\t\telem = elements[ index ];\n\t\tif ( !elem.style ) {\n\t\t\tcontinue;\n\t\t}\n\t\tif ( !show || elem.style.display === \"none\" || elem.style.display === \"\" ) {\n\t\t\telem.style.display = show ? values[ index ] || \"\" : \"none\";\n\t\t}\n\t}\n\n\treturn elements;\n}\n\njQuery.extend( {\n\n\t// Add in style property hooks for overriding the default\n\t// behavior of getting and setting a style property\n\tcssHooks: {\n\t\topacity: {\n\t\t\tget: function( elem, computed ) {\n\t\t\t\tif ( computed ) {\n\n\t\t\t\t\t// We should always get a number back from opacity\n\t\t\t\t\tvar ret = curCSS( elem, \"opacity\" );\n\t\t\t\t\treturn ret === \"\" ? \"1\" : ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t// Don't automatically add \"px\" to these possibly-unitless properties\n\tcssNumber: {\n\t\t\"animationIterationCount\": true,\n\t\t\"columnCount\": true,\n\t\t\"fillOpacity\": true,\n\t\t\"flexGrow\": true,\n\t\t\"flexShrink\": true,\n\t\t\"fontWeight\": true,\n\t\t\"lineHeight\": true,\n\t\t\"opacity\": true,\n\t\t\"order\": true,\n\t\t\"orphans\": true,\n\t\t\"widows\": true,\n\t\t\"zIndex\": true,\n\t\t\"zoom\": true\n\t},\n\n\t// Add in properties whose names you wish to fix before\n\t// setting or getting the value\n\tcssProps: {\n\t\t\"float\": \"cssFloat\"\n\t},\n\n\t// Get and set the style property on a DOM Node\n\tstyle: function( elem, name, value, extra ) {\n\n\t\t// Don't set styles on text and comment nodes\n\t\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Make sure that we're working with the right name\n\t\tvar ret, type, hooks,\n\t\t\torigName = jQuery.camelCase( name ),\n\t\t\tstyle = elem.style;\n\n\t\tname = jQuery.cssProps[ origName ] ||\n\t\t\t( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );\n\n\t\t// Gets hook for the prefixed version, then unprefixed version\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// Check if we're setting a value\n\t\tif ( value !== undefined ) {\n\t\t\ttype = typeof value;\n\n\t\t\t// Convert \"+=\" or \"-=\" to relative numbers (#7345)\n\t\t\tif ( type === \"string\" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {\n\t\t\t\tvalue = adjustCSS( elem, name, ret );\n\n\t\t\t\t// Fixes bug #9237\n\t\t\t\ttype = \"number\";\n\t\t\t}\n\n\t\t\t// Make sure that null and NaN values aren't set (#7116)\n\t\t\tif ( value == null || value !== value ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If a number was passed in, add the unit (except for certain CSS properties)\n\t\t\tif ( type === \"number\" ) {\n\t\t\t\tvalue += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? \"\" : \"px\" );\n\t\t\t}\n\n\t\t\t// Support: IE9-11+\n\t\t\t// background-* props affect original clone's values\n\t\t\tif ( !support.clearCloneStyle && value === \"\" && name.indexOf( \"background\" ) === 0 ) {\n\t\t\t\tstyle[ name ] = \"inherit\";\n\t\t\t}\n\n\t\t\t// If a hook was provided, use that value, otherwise just set the specified value\n\t\t\tif ( !hooks || !( \"set\" in hooks ) ||\n\t\t\t\t( value = hooks.set( elem, value, extra ) ) !== undefined ) {\n\n\t\t\t\tstyle[ name ] = value;\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// If a hook was provided get the non-computed value from there\n\t\t\tif ( hooks && \"get\" in hooks &&\n\t\t\t\t( ret = hooks.get( elem, false, extra ) ) !== undefined ) {\n\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t// Otherwise just get the value from the style object\n\t\t\treturn style[ name ];\n\t\t}\n\t},\n\n\tcss: function( elem, name, extra, styles ) {\n\t\tvar val, num, hooks,\n\t\t\torigName = jQuery.camelCase( name );\n\n\t\t// Make sure that we're working with the right name\n\t\tname = jQuery.cssProps[ origName ] ||\n\t\t\t( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );\n\n\t\t// Try prefixed name followed by the unprefixed name\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// If a hook was provided get the computed value from there\n\t\tif ( hooks && \"get\" in hooks ) {\n\t\t\tval = hooks.get( elem, true, extra );\n\t\t}\n\n\t\t// Otherwise, if a way to get the computed value exists, use that\n\t\tif ( val === undefined ) {\n\t\t\tval = curCSS( elem, name, styles );\n\t\t}\n\n\t\t// Convert \"normal\" to computed value\n\t\tif ( val === \"normal\" && name in cssNormalTransform ) {\n\t\t\tval = cssNormalTransform[ name ];\n\t\t}\n\n\t\t// Make numeric if forced or a qualifier was provided and val looks numeric\n\t\tif ( extra === \"\" || extra ) {\n\t\t\tnum = parseFloat( val );\n\t\t\treturn extra === true || isFinite( num ) ? num || 0 : val;\n\t\t}\n\t\treturn val;\n\t}\n} );\n\njQuery.each( [ \"height\", \"width\" ], function( i, name ) {\n\tjQuery.cssHooks[ name ] = {\n\t\tget: function( elem, computed, extra ) {\n\t\t\tif ( computed ) {\n\n\t\t\t\t// Certain elements can have dimension info if we invisibly show them\n\t\t\t\t// but it must have a current display style that would benefit\n\t\t\t\treturn rdisplayswap.test( jQuery.css( elem, \"display\" ) ) &&\n\t\t\t\t\telem.offsetWidth === 0 ?\n\t\t\t\t\t\tswap( elem, cssShow, function() {\n\t\t\t\t\t\t\treturn getWidthOrHeight( elem, name, extra );\n\t\t\t\t\t\t} ) :\n\t\t\t\t\t\tgetWidthOrHeight( elem, name, extra );\n\t\t\t}\n\t\t},\n\n\t\tset: function( elem, value, extra ) {\n\t\t\tvar matches,\n\t\t\t\tstyles = extra && getStyles( elem ),\n\t\t\t\tsubtract = extra && augmentWidthOrHeight(\n\t\t\t\t\telem,\n\t\t\t\t\tname,\n\t\t\t\t\textra,\n\t\t\t\t\tjQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\n\t\t\t\t\tstyles\n\t\t\t\t);\n\n\t\t\t// Convert to pixels if value adjustment is needed\n\t\t\tif ( subtract && ( matches = rcssNum.exec( value ) ) &&\n\t\t\t\t( matches[ 3 ] || \"px\" ) !== \"px\" ) {\n\n\t\t\t\telem.style[ name ] = value;\n\t\t\t\tvalue = jQuery.css( elem, name );\n\t\t\t}\n\n\t\t\treturn setPositiveNumber( elem, value, subtract );\n\t\t}\n\t};\n} );\n\njQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,\n\tfunction( elem, computed ) {\n\t\tif ( computed ) {\n\t\t\treturn ( parseFloat( curCSS( elem, \"marginLeft\" ) ) ||\n\t\t\t\telem.getBoundingClientRect().left -\n\t\t\t\t\tswap( elem, { marginLeft: 0 }, function() {\n\t\t\t\t\t\treturn elem.getBoundingClientRect().left;\n\t\t\t\t\t} )\n\t\t\t\t) + \"px\";\n\t\t}\n\t}\n);\n\n// Support: Android 2.3\njQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,\n\tfunction( elem, computed ) {\n\t\tif ( computed ) {\n\t\t\treturn swap( elem, { \"display\": \"inline-block\" },\n\t\t\t\tcurCSS, [ elem, \"marginRight\" ] );\n\t\t}\n\t}\n);\n\n// These hooks are used by animate to expand properties\njQuery.each( {\n\tmargin: \"\",\n\tpadding: \"\",\n\tborder: \"Width\"\n}, function( prefix, suffix ) {\n\tjQuery.cssHooks[ prefix + suffix ] = {\n\t\texpand: function( value ) {\n\t\t\tvar i = 0,\n\t\t\t\texpanded = {},\n\n\t\t\t\t// Assumes a single number if not a string\n\t\t\t\tparts = typeof value === \"string\" ? value.split( \" \" ) : [ value ];\n\n\t\t\tfor ( ; i < 4; i++ ) {\n\t\t\t\texpanded[ prefix + cssExpand[ i ] + suffix ] =\n\t\t\t\t\tparts[ i ] || parts[ i - 2 ] || parts[ 0 ];\n\t\t\t}\n\n\t\t\treturn expanded;\n\t\t}\n\t};\n\n\tif ( !rmargin.test( prefix ) ) {\n\t\tjQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\n\t}\n} );\n\njQuery.fn.extend( {\n\tcss: function( name, value ) {\n\t\treturn access( this, function( elem, name, value ) {\n\t\t\tvar styles, len,\n\t\t\t\tmap = {},\n\t\t\t\ti = 0;\n\n\t\t\tif ( jQuery.isArray( name ) ) {\n\t\t\t\tstyles = getStyles( elem );\n\t\t\t\tlen = name.length;\n\n\t\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\t\tmap[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\n\t\t\t\t}\n\n\t\t\t\treturn map;\n\t\t\t}\n\n\t\t\treturn value !== undefined ?\n\t\t\t\tjQuery.style( elem, name, value ) :\n\t\t\t\tjQuery.css( elem, name );\n\t\t}, name, value, arguments.length > 1 );\n\t},\n\tshow: function() {\n\t\treturn showHide( this, true );\n\t},\n\thide: function() {\n\t\treturn showHide( this );\n\t},\n\ttoggle: function( state ) {\n\t\tif ( typeof state === \"boolean\" ) {\n\t\t\treturn state ? this.show() : this.hide();\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tif ( isHidden( this ) ) {\n\t\t\t\tjQuery( this ).show();\n\t\t\t} else {\n\t\t\t\tjQuery( this ).hide();\n\t\t\t}\n\t\t} );\n\t}\n} );\n\n\nfunction Tween( elem, options, prop, end, easing ) {\n\treturn new Tween.prototype.init( elem, options, prop, end, easing );\n}\njQuery.Tween = Tween;\n\nTween.prototype = {\n\tconstructor: Tween,\n\tinit: function( elem, options, prop, end, easing, unit ) {\n\t\tthis.elem = elem;\n\t\tthis.prop = prop;\n\t\tthis.easing = easing || jQuery.easing._default;\n\t\tthis.options = options;\n\t\tthis.start = this.now = this.cur();\n\t\tthis.end = end;\n\t\tthis.unit = unit || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" );\n\t},\n\tcur: function() {\n\t\tvar hooks = Tween.propHooks[ this.prop ];\n\n\t\treturn hooks && hooks.get ?\n\t\t\thooks.get( this ) :\n\t\t\tTween.propHooks._default.get( this );\n\t},\n\trun: function( percent ) {\n\t\tvar eased,\n\t\t\thooks = Tween.propHooks[ this.prop ];\n\n\t\tif ( this.options.duration ) {\n\t\t\tthis.pos = eased = jQuery.easing[ this.easing ](\n\t\t\t\tpercent, this.options.duration * percent, 0, 1, this.options.duration\n\t\t\t);\n\t\t} else {\n\t\t\tthis.pos = eased = percent;\n\t\t}\n\t\tthis.now = ( this.end - this.start ) * eased + this.start;\n\n\t\tif ( this.options.step ) {\n\t\t\tthis.options.step.call( this.elem, this.now, this );\n\t\t}\n\n\t\tif ( hooks && hooks.set ) {\n\t\t\thooks.set( this );\n\t\t} else {\n\t\t\tTween.propHooks._default.set( this );\n\t\t}\n\t\treturn this;\n\t}\n};\n\nTween.prototype.init.prototype = Tween.prototype;\n\nTween.propHooks = {\n\t_default: {\n\t\tget: function( tween ) {\n\t\t\tvar result;\n\n\t\t\t// Use a property on the element directly when it is not a DOM element,\n\t\t\t// or when there is no matching style property that exists.\n\t\t\tif ( tween.elem.nodeType !== 1 ||\n\t\t\t\ttween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {\n\t\t\t\treturn tween.elem[ tween.prop ];\n\t\t\t}\n\n\t\t\t// Passing an empty string as a 3rd parameter to .css will automatically\n\t\t\t// attempt a parseFloat and fallback to a string if the parse fails.\n\t\t\t// Simple values such as \"10px\" are parsed to Float;\n\t\t\t// complex values such as \"rotate(1rad)\" are returned as-is.\n\t\t\tresult = jQuery.css( tween.elem, tween.prop, \"\" );\n\n\t\t\t// Empty strings, null, undefined and \"auto\" are converted to 0.\n\t\t\treturn !result || result === \"auto\" ? 0 : result;\n\t\t},\n\t\tset: function( tween ) {\n\n\t\t\t// Use step hook for back compat.\n\t\t\t// Use cssHook if its there.\n\t\t\t// Use .style if available and use plain properties where available.\n\t\t\tif ( jQuery.fx.step[ tween.prop ] ) {\n\t\t\t\tjQuery.fx.step[ tween.prop ]( tween );\n\t\t\t} else if ( tween.elem.nodeType === 1 &&\n\t\t\t\t( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||\n\t\t\t\t\tjQuery.cssHooks[ tween.prop ] ) ) {\n\t\t\t\tjQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\n\t\t\t} else {\n\t\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t\t}\n\t\t}\n\t}\n};\n\n// Support: IE9\n// Panic based approach to setting things on disconnected nodes\nTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n\tset: function( tween ) {\n\t\tif ( tween.elem.nodeType && tween.elem.parentNode ) {\n\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t}\n\t}\n};\n\njQuery.easing = {\n\tlinear: function( p ) {\n\t\treturn p;\n\t},\n\tswing: function( p ) {\n\t\treturn 0.5 - Math.cos( p * Math.PI ) / 2;\n\t},\n\t_default: \"swing\"\n};\n\njQuery.fx = Tween.prototype.init;\n\n// Back Compat <1.8 extension point\njQuery.fx.step = {};\n\n\n\n\nvar\n\tfxNow, timerId,\n\trfxtypes = /^(?:toggle|show|hide)$/,\n\trrun = /queueHooks$/;\n\n// Animations created synchronously will run synchronously\nfunction createFxNow() {\n\twindow.setTimeout( function() {\n\t\tfxNow = undefined;\n\t} );\n\treturn ( fxNow = jQuery.now() );\n}\n\n// Generate parameters to create a standard animation\nfunction genFx( type, includeWidth ) {\n\tvar which,\n\t\ti = 0,\n\t\tattrs = { height: type };\n\n\t// If we include width, step value is 1 to do all cssExpand values,\n\t// otherwise step value is 2 to skip over Left and Right\n\tincludeWidth = includeWidth ? 1 : 0;\n\tfor ( ; i < 4 ; i += 2 - includeWidth ) {\n\t\twhich = cssExpand[ i ];\n\t\tattrs[ \"margin\" + which ] = attrs[ \"padding\" + which ] = type;\n\t}\n\n\tif ( includeWidth ) {\n\t\tattrs.opacity = attrs.width = type;\n\t}\n\n\treturn attrs;\n}\n\nfunction createTween( value, prop, animation ) {\n\tvar tween,\n\t\tcollection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ \"*\" ] ),\n\t\tindex = 0,\n\t\tlength = collection.length;\n\tfor ( ; index < length; index++ ) {\n\t\tif ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {\n\n\t\t\t// We're done with this property\n\t\t\treturn tween;\n\t\t}\n\t}\n}\n\nfunction defaultPrefilter( elem, props, opts ) {\n\t/* jshint validthis: true */\n\tvar prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,\n\t\tanim = this,\n\t\torig = {},\n\t\tstyle = elem.style,\n\t\thidden = elem.nodeType && isHidden( elem ),\n\t\tdataShow = dataPriv.get( elem, \"fxshow\" );\n\n\t// Handle queue: false promises\n\tif ( !opts.queue ) {\n\t\thooks = jQuery._queueHooks( elem, \"fx\" );\n\t\tif ( hooks.unqueued == null ) {\n\t\t\thooks.unqueued = 0;\n\t\t\toldfire = hooks.empty.fire;\n\t\t\thooks.empty.fire = function() {\n\t\t\t\tif ( !hooks.unqueued ) {\n\t\t\t\t\toldfire();\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\thooks.unqueued++;\n\n\t\tanim.always( function() {\n\n\t\t\t// Ensure the complete handler is called before this completes\n\t\t\tanim.always( function() {\n\t\t\t\thooks.unqueued--;\n\t\t\t\tif ( !jQuery.queue( elem, \"fx\" ).length ) {\n\t\t\t\t\thooks.empty.fire();\n\t\t\t\t}\n\t\t\t} );\n\t\t} );\n\t}\n\n\t// Height/width overflow pass\n\tif ( elem.nodeType === 1 && ( \"height\" in props || \"width\" in props ) ) {\n\n\t\t// Make sure that nothing sneaks out\n\t\t// Record all 3 overflow attributes because IE9-10 do not\n\t\t// change the overflow attribute when overflowX and\n\t\t// overflowY are set to the same value\n\t\topts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\n\n\t\t// Set display property to inline-block for height/width\n\t\t// animations on inline elements that are having width/height animated\n\t\tdisplay = jQuery.css( elem, \"display\" );\n\n\t\t// Test default display if display is currently \"none\"\n\t\tcheckDisplay = display === \"none\" ?\n\t\t\tdataPriv.get( elem, \"olddisplay\" ) || defaultDisplay( elem.nodeName ) : display;\n\n\t\tif ( checkDisplay === \"inline\" && jQuery.css( elem, \"float\" ) === \"none\" ) {\n\t\t\tstyle.display = \"inline-block\";\n\t\t}\n\t}\n\n\tif ( opts.overflow ) {\n\t\tstyle.overflow = \"hidden\";\n\t\tanim.always( function() {\n\t\t\tstyle.overflow = opts.overflow[ 0 ];\n\t\t\tstyle.overflowX = opts.overflow[ 1 ];\n\t\t\tstyle.overflowY = opts.overflow[ 2 ];\n\t\t} );\n\t}\n\n\t// show/hide pass\n\tfor ( prop in props ) {\n\t\tvalue = props[ prop ];\n\t\tif ( rfxtypes.exec( value ) ) {\n\t\t\tdelete props[ prop ];\n\t\t\ttoggle = toggle || value === \"toggle\";\n\t\t\tif ( value === ( hidden ? \"hide\" : \"show\" ) ) {\n\n\t\t\t\t// If there is dataShow left over from a stopped hide or show\n\t\t\t\t// and we are going to proceed with show, we should pretend to be hidden\n\t\t\t\tif ( value === \"show\" && dataShow && dataShow[ prop ] !== undefined ) {\n\t\t\t\t\thidden = true;\n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\torig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\n\n\t\t// Any non-fx value stops us from restoring the original display value\n\t\t} else {\n\t\t\tdisplay = undefined;\n\t\t}\n\t}\n\n\tif ( !jQuery.isEmptyObject( orig ) ) {\n\t\tif ( dataShow ) {\n\t\t\tif ( \"hidden\" in dataShow ) {\n\t\t\t\thidden = dataShow.hidden;\n\t\t\t}\n\t\t} else {\n\t\t\tdataShow = dataPriv.access( elem, \"fxshow\", {} );\n\t\t}\n\n\t\t// Store state if its toggle - enables .stop().toggle() to \"reverse\"\n\t\tif ( toggle ) {\n\t\t\tdataShow.hidden = !hidden;\n\t\t}\n\t\tif ( hidden ) {\n\t\t\tjQuery( elem ).show();\n\t\t} else {\n\t\t\tanim.done( function() {\n\t\t\t\tjQuery( elem ).hide();\n\t\t\t} );\n\t\t}\n\t\tanim.done( function() {\n\t\t\tvar prop;\n\n\t\t\tdataPriv.remove( elem, \"fxshow\" );\n\t\t\tfor ( prop in orig ) {\n\t\t\t\tjQuery.style( elem, prop, orig[ prop ] );\n\t\t\t}\n\t\t} );\n\t\tfor ( prop in orig ) {\n\t\t\ttween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\n\n\t\t\tif ( !( prop in dataShow ) ) {\n\t\t\t\tdataShow[ prop ] = tween.start;\n\t\t\t\tif ( hidden ) {\n\t\t\t\t\ttween.end = tween.start;\n\t\t\t\t\ttween.start = prop === \"width\" || prop === \"height\" ? 1 : 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t// If this is a noop like .hide().hide(), restore an overwritten display value\n\t} else if ( ( display === \"none\" ? defaultDisplay( elem.nodeName ) : display ) === \"inline\" ) {\n\t\tstyle.display = display;\n\t}\n}\n\nfunction propFilter( props, specialEasing ) {\n\tvar index, name, easing, value, hooks;\n\n\t// camelCase, specialEasing and expand cssHook pass\n\tfor ( index in props ) {\n\t\tname = jQuery.camelCase( index );\n\t\teasing = specialEasing[ name ];\n\t\tvalue = props[ index ];\n\t\tif ( jQuery.isArray( value ) ) {\n\t\t\teasing = value[ 1 ];\n\t\t\tvalue = props[ index ] = value[ 0 ];\n\t\t}\n\n\t\tif ( index !== name ) {\n\t\t\tprops[ name ] = value;\n\t\t\tdelete props[ index ];\n\t\t}\n\n\t\thooks = jQuery.cssHooks[ name ];\n\t\tif ( hooks && \"expand\" in hooks ) {\n\t\t\tvalue = hooks.expand( value );\n\t\t\tdelete props[ name ];\n\n\t\t\t// Not quite $.extend, this won't overwrite existing keys.\n\t\t\t// Reusing 'index' because we have the correct \"name\"\n\t\t\tfor ( index in value ) {\n\t\t\t\tif ( !( index in props ) ) {\n\t\t\t\t\tprops[ index ] = value[ index ];\n\t\t\t\t\tspecialEasing[ index ] = easing;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tspecialEasing[ name ] = easing;\n\t\t}\n\t}\n}\n\nfunction Animation( elem, properties, options ) {\n\tvar result,\n\t\tstopped,\n\t\tindex = 0,\n\t\tlength = Animation.prefilters.length,\n\t\tdeferred = jQuery.Deferred().always( function() {\n\n\t\t\t// Don't match elem in the :animated selector\n\t\t\tdelete tick.elem;\n\t\t} ),\n\t\ttick = function() {\n\t\t\tif ( stopped ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar currentTime = fxNow || createFxNow(),\n\t\t\t\tremaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\n\n\t\t\t\t// Support: Android 2.3\n\t\t\t\t// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)\n\t\t\t\ttemp = remaining / animation.duration || 0,\n\t\t\t\tpercent = 1 - temp,\n\t\t\t\tindex = 0,\n\t\t\t\tlength = animation.tweens.length;\n\n\t\t\tfor ( ; index < length ; index++ ) {\n\t\t\t\tanimation.tweens[ index ].run( percent );\n\t\t\t}\n\n\t\t\tdeferred.notifyWith( elem, [ animation, percent, remaining ] );\n\n\t\t\tif ( percent < 1 && length ) {\n\t\t\t\treturn remaining;\n\t\t\t} else {\n\t\t\t\tdeferred.resolveWith( elem, [ animation ] );\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t\tanimation = deferred.promise( {\n\t\t\telem: elem,\n\t\t\tprops: jQuery.extend( {}, properties ),\n\t\t\topts: jQuery.extend( true, {\n\t\t\t\tspecialEasing: {},\n\t\t\t\teasing: jQuery.easing._default\n\t\t\t}, options ),\n\t\t\toriginalProperties: properties,\n\t\t\toriginalOptions: options,\n\t\t\tstartTime: fxNow || createFxNow(),\n\t\t\tduration: options.duration,\n\t\t\ttweens: [],\n\t\t\tcreateTween: function( prop, end ) {\n\t\t\t\tvar tween = jQuery.Tween( elem, animation.opts, prop, end,\n\t\t\t\t\t\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\n\t\t\t\tanimation.tweens.push( tween );\n\t\t\t\treturn tween;\n\t\t\t},\n\t\t\tstop: function( gotoEnd ) {\n\t\t\t\tvar index = 0,\n\n\t\t\t\t\t// If we are going to the end, we want to run all the tweens\n\t\t\t\t\t// otherwise we skip this part\n\t\t\t\t\tlength = gotoEnd ? animation.tweens.length : 0;\n\t\t\t\tif ( stopped ) {\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\tstopped = true;\n\t\t\t\tfor ( ; index < length ; index++ ) {\n\t\t\t\t\tanimation.tweens[ index ].run( 1 );\n\t\t\t\t}\n\n\t\t\t\t// Resolve when we played the last frame; otherwise, reject\n\t\t\t\tif ( gotoEnd ) {\n\t\t\t\t\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\n\t\t\t\t\tdeferred.resolveWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.rejectWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t} ),\n\t\tprops = animation.props;\n\n\tpropFilter( props, animation.opts.specialEasing );\n\n\tfor ( ; index < length ; index++ ) {\n\t\tresult = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );\n\t\tif ( result ) {\n\t\t\tif ( jQuery.isFunction( result.stop ) ) {\n\t\t\t\tjQuery._queueHooks( animation.elem, animation.opts.queue ).stop =\n\t\t\t\t\tjQuery.proxy( result.stop, result );\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tjQuery.map( props, createTween, animation );\n\n\tif ( jQuery.isFunction( animation.opts.start ) ) {\n\t\tanimation.opts.start.call( elem, animation );\n\t}\n\n\tjQuery.fx.timer(\n\t\tjQuery.extend( tick, {\n\t\t\telem: elem,\n\t\t\tanim: animation,\n\t\t\tqueue: animation.opts.queue\n\t\t} )\n\t);\n\n\t// attach callbacks from options\n\treturn animation.progress( animation.opts.progress )\n\t\t.done( animation.opts.done, animation.opts.complete )\n\t\t.fail( animation.opts.fail )\n\t\t.always( animation.opts.always );\n}\n\njQuery.Animation = jQuery.extend( Animation, {\n\ttweeners: {\n\t\t\"*\": [ function( prop, value ) {\n\t\t\tvar tween = this.createTween( prop, value );\n\t\t\tadjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );\n\t\t\treturn tween;\n\t\t} ]\n\t},\n\n\ttweener: function( props, callback ) {\n\t\tif ( jQuery.isFunction( props ) ) {\n\t\t\tcallback = props;\n\t\t\tprops = [ \"*\" ];\n\t\t} else {\n\t\t\tprops = props.match( rnotwhite );\n\t\t}\n\n\t\tvar prop,\n\t\t\tindex = 0,\n\t\t\tlength = props.length;\n\n\t\tfor ( ; index < length ; index++ ) {\n\t\t\tprop = props[ index ];\n\t\t\tAnimation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];\n\t\t\tAnimation.tweeners[ prop ].unshift( callback );\n\t\t}\n\t},\n\n\tprefilters: [ defaultPrefilter ],\n\n\tprefilter: function( callback, prepend ) {\n\t\tif ( prepend ) {\n\t\t\tAnimation.prefilters.unshift( callback );\n\t\t} else {\n\t\t\tAnimation.prefilters.push( callback );\n\t\t}\n\t}\n} );\n\njQuery.speed = function( speed, easing, fn ) {\n\tvar opt = speed && typeof speed === \"object\" ? jQuery.extend( {}, speed ) : {\n\t\tcomplete: fn || !fn && easing ||\n\t\t\tjQuery.isFunction( speed ) && speed,\n\t\tduration: speed,\n\t\teasing: fn && easing || easing && !jQuery.isFunction( easing ) && easing\n\t};\n\n\topt.duration = jQuery.fx.off ? 0 : typeof opt.duration === \"number\" ?\n\t\topt.duration : opt.duration in jQuery.fx.speeds ?\n\t\t\tjQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;\n\n\t// Normalize opt.queue - true/undefined/null -> \"fx\"\n\tif ( opt.queue == null || opt.queue === true ) {\n\t\topt.queue = \"fx\";\n\t}\n\n\t// Queueing\n\topt.old = opt.complete;\n\n\topt.complete = function() {\n\t\tif ( jQuery.isFunction( opt.old ) ) {\n\t\t\topt.old.call( this );\n\t\t}\n\n\t\tif ( opt.queue ) {\n\t\t\tjQuery.dequeue( this, opt.queue );\n\t\t}\n\t};\n\n\treturn opt;\n};\n\njQuery.fn.extend( {\n\tfadeTo: function( speed, to, easing, callback ) {\n\n\t\t// Show any hidden elements after setting opacity to 0\n\t\treturn this.filter( isHidden ).css( \"opacity\", 0 ).show()\n\n\t\t\t// Animate to the value specified\n\t\t\t.end().animate( { opacity: to }, speed, easing, callback );\n\t},\n\tanimate: function( prop, speed, easing, callback ) {\n\t\tvar empty = jQuery.isEmptyObject( prop ),\n\t\t\toptall = jQuery.speed( speed, easing, callback ),\n\t\t\tdoAnimation = function() {\n\n\t\t\t\t// Operate on a copy of prop so per-property easing won't be lost\n\t\t\t\tvar anim = Animation( this, jQuery.extend( {}, prop ), optall );\n\n\t\t\t\t// Empty animations, or finishing resolves immediately\n\t\t\t\tif ( empty || dataPriv.get( this, \"finish\" ) ) {\n\t\t\t\t\tanim.stop( true );\n\t\t\t\t}\n\t\t\t};\n\t\t\tdoAnimation.finish = doAnimation;\n\n\t\treturn empty || optall.queue === false ?\n\t\t\tthis.each( doAnimation ) :\n\t\t\tthis.queue( optall.queue, doAnimation );\n\t},\n\tstop: function( type, clearQueue, gotoEnd ) {\n\t\tvar stopQueue = function( hooks ) {\n\t\t\tvar stop = hooks.stop;\n\t\t\tdelete hooks.stop;\n\t\t\tstop( gotoEnd );\n\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tgotoEnd = clearQueue;\n\t\t\tclearQueue = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\tif ( clearQueue && type !== false ) {\n\t\t\tthis.queue( type || \"fx\", [] );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar dequeue = true,\n\t\t\t\tindex = type != null && type + \"queueHooks\",\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tdata = dataPriv.get( this );\n\n\t\t\tif ( index ) {\n\t\t\t\tif ( data[ index ] && data[ index ].stop ) {\n\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( index in data ) {\n\t\t\t\t\tif ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\n\t\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this &&\n\t\t\t\t\t( type == null || timers[ index ].queue === type ) ) {\n\n\t\t\t\t\ttimers[ index ].anim.stop( gotoEnd );\n\t\t\t\t\tdequeue = false;\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Start the next in the queue if the last step wasn't forced.\n\t\t\t// Timers currently will call their complete callbacks, which\n\t\t\t// will dequeue but only if they were gotoEnd.\n\t\t\tif ( dequeue || !gotoEnd ) {\n\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t}\n\t\t} );\n\t},\n\tfinish: function( type ) {\n\t\tif ( type !== false ) {\n\t\t\ttype = type || \"fx\";\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tvar index,\n\t\t\t\tdata = dataPriv.get( this ),\n\t\t\t\tqueue = data[ type + \"queue\" ],\n\t\t\t\thooks = data[ type + \"queueHooks\" ],\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tlength = queue ? queue.length : 0;\n\n\t\t\t// Enable finishing flag on private data\n\t\t\tdata.finish = true;\n\n\t\t\t// Empty the queue first\n\t\t\tjQuery.queue( this, type, [] );\n\n\t\t\tif ( hooks && hooks.stop ) {\n\t\t\t\thooks.stop.call( this, true );\n\t\t\t}\n\n\t\t\t// Look for any active animations, and finish them\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this && timers[ index ].queue === type ) {\n\t\t\t\t\ttimers[ index ].anim.stop( true );\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Look for any animations in the old queue and finish them\n\t\t\tfor ( index = 0; index < length; index++ ) {\n\t\t\t\tif ( queue[ index ] && queue[ index ].finish ) {\n\t\t\t\t\tqueue[ index ].finish.call( this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Turn off finishing flag\n\t\t\tdelete data.finish;\n\t\t} );\n\t}\n} );\n\njQuery.each( [ \"toggle\", \"show\", \"hide\" ], function( i, name ) {\n\tvar cssFn = jQuery.fn[ name ];\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn speed == null || typeof speed === \"boolean\" ?\n\t\t\tcssFn.apply( this, arguments ) :\n\t\t\tthis.animate( genFx( name, true ), speed, easing, callback );\n\t};\n} );\n\n// Generate shortcuts for custom animations\njQuery.each( {\n\tslideDown: genFx( \"show\" ),\n\tslideUp: genFx( \"hide\" ),\n\tslideToggle: genFx( \"toggle\" ),\n\tfadeIn: { opacity: \"show\" },\n\tfadeOut: { opacity: \"hide\" },\n\tfadeToggle: { opacity: \"toggle\" }\n}, function( name, props ) {\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn this.animate( props, speed, easing, callback );\n\t};\n} );\n\njQuery.timers = [];\njQuery.fx.tick = function() {\n\tvar timer,\n\t\ti = 0,\n\t\ttimers = jQuery.timers;\n\n\tfxNow = jQuery.now();\n\n\tfor ( ; i < timers.length; i++ ) {\n\t\ttimer = timers[ i ];\n\n\t\t// Checks the timer has not already been removed\n\t\tif ( !timer() && timers[ i ] === timer ) {\n\t\t\ttimers.splice( i--, 1 );\n\t\t}\n\t}\n\n\tif ( !timers.length ) {\n\t\tjQuery.fx.stop();\n\t}\n\tfxNow = undefined;\n};\n\njQuery.fx.timer = function( timer ) {\n\tjQuery.timers.push( timer );\n\tif ( timer() ) {\n\t\tjQuery.fx.start();\n\t} else {\n\t\tjQuery.timers.pop();\n\t}\n};\n\njQuery.fx.interval = 13;\njQuery.fx.start = function() {\n\tif ( !timerId ) {\n\t\ttimerId = window.setInterval( jQuery.fx.tick, jQuery.fx.interval );\n\t}\n};\n\njQuery.fx.stop = function() {\n\twindow.clearInterval( timerId );\n\n\ttimerId = null;\n};\n\njQuery.fx.speeds = {\n\tslow: 600,\n\tfast: 200,\n\n\t// Default speed\n\t_default: 400\n};\n\n\n// Based off of the plugin by Clint Helfers, with permission.\n// http://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/\njQuery.fn.delay = function( time, type ) {\n\ttime = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\n\ttype = type || \"fx\";\n\n\treturn this.queue( type, function( next, hooks ) {\n\t\tvar timeout = window.setTimeout( next, time );\n\t\thooks.stop = function() {\n\t\t\twindow.clearTimeout( timeout );\n\t\t};\n\t} );\n};\n\n\n( function() {\n\tvar input = document.createElement( \"input\" ),\n\t\tselect = document.createElement( \"select\" ),\n\t\topt = select.appendChild( document.createElement( \"option\" ) );\n\n\tinput.type = \"checkbox\";\n\n\t// Support: iOS<=5.1, Android<=4.2+\n\t// Default value for a checkbox should be \"on\"\n\tsupport.checkOn = input.value !== \"\";\n\n\t// Support: IE<=11+\n\t// Must access selectedIndex to make default options select\n\tsupport.optSelected = opt.selected;\n\n\t// Support: Android<=2.3\n\t// Options inside disabled selects are incorrectly marked as disabled\n\tselect.disabled = true;\n\tsupport.optDisabled = !opt.disabled;\n\n\t// Support: IE<=11+\n\t// An input loses its value after becoming a radio\n\tinput = document.createElement( \"input\" );\n\tinput.value = \"t\";\n\tinput.type = \"radio\";\n\tsupport.radioValue = input.value === \"t\";\n} )();\n\n\nvar boolHook,\n\tattrHandle = jQuery.expr.attrHandle;\n\njQuery.fn.extend( {\n\tattr: function( name, value ) {\n\t\treturn access( this, jQuery.attr, name, value, arguments.length > 1 );\n\t},\n\n\tremoveAttr: function( name ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.removeAttr( this, name );\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tattr: function( elem, name, value ) {\n\t\tvar ret, hooks,\n\t\t\tnType = elem.nodeType;\n\n\t\t// Don't get/set attributes on text, comment and attribute nodes\n\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Fallback to prop when attributes are not supported\n\t\tif ( typeof elem.getAttribute === \"undefined\" ) {\n\t\t\treturn jQuery.prop( elem, name, value );\n\t\t}\n\n\t\t// All attributes are lowercase\n\t\t// Grab necessary hook if one is defined\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\t\t\tname = name.toLowerCase();\n\t\t\thooks = jQuery.attrHooks[ name ] ||\n\t\t\t\t( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\tif ( value === null ) {\n\t\t\t\tjQuery.removeAttr( elem, name );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( hooks && \"set\" in hooks &&\n\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\telem.setAttribute( name, value + \"\" );\n\t\t\treturn value;\n\t\t}\n\n\t\tif ( hooks && \"get\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = jQuery.find.attr( elem, name );\n\n\t\t// Non-existent attributes return null, we normalize to undefined\n\t\treturn ret == null ? undefined : ret;\n\t},\n\n\tattrHooks: {\n\t\ttype: {\n\t\t\tset: function( elem, value ) {\n\t\t\t\tif ( !support.radioValue && value === \"radio\" &&\n\t\t\t\t\tjQuery.nodeName( elem, \"input\" ) ) {\n\t\t\t\t\tvar val = elem.value;\n\t\t\t\t\telem.setAttribute( \"type\", value );\n\t\t\t\t\tif ( val ) {\n\t\t\t\t\t\telem.value = val;\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tremoveAttr: function( elem, value ) {\n\t\tvar name, propName,\n\t\t\ti = 0,\n\t\t\tattrNames = value && value.match( rnotwhite );\n\n\t\tif ( attrNames && elem.nodeType === 1 ) {\n\t\t\twhile ( ( name = attrNames[ i++ ] ) ) {\n\t\t\t\tpropName = jQuery.propFix[ name ] || name;\n\n\t\t\t\t// Boolean attributes get special treatment (#10870)\n\t\t\t\tif ( jQuery.expr.match.bool.test( name ) ) {\n\n\t\t\t\t\t// Set corresponding property to false\n\t\t\t\t\telem[ propName ] = false;\n\t\t\t\t}\n\n\t\t\t\telem.removeAttribute( name );\n\t\t\t}\n\t\t}\n\t}\n} );\n\n// Hooks for boolean attributes\nboolHook = {\n\tset: function( elem, value, name ) {\n\t\tif ( value === false ) {\n\n\t\t\t// Remove boolean attributes when set to false\n\t\t\tjQuery.removeAttr( elem, name );\n\t\t} else {\n\t\t\telem.setAttribute( name, name );\n\t\t}\n\t\treturn name;\n\t}\n};\njQuery.each( jQuery.expr.match.bool.source.match( /\\w+/g ), function( i, name ) {\n\tvar getter = attrHandle[ name ] || jQuery.find.attr;\n\n\tattrHandle[ name ] = function( elem, name, isXML ) {\n\t\tvar ret, handle;\n\t\tif ( !isXML ) {\n\n\t\t\t// Avoid an infinite loop by temporarily removing this function from the getter\n\t\t\thandle = attrHandle[ name ];\n\t\t\tattrHandle[ name ] = ret;\n\t\t\tret = getter( elem, name, isXML ) != null ?\n\t\t\t\tname.toLowerCase() :\n\t\t\t\tnull;\n\t\t\tattrHandle[ name ] = handle;\n\t\t}\n\t\treturn ret;\n\t};\n} );\n\n\n\n\nvar rfocusable = /^(?:input|select|textarea|button)$/i,\n\trclickable = /^(?:a|area)$/i;\n\njQuery.fn.extend( {\n\tprop: function( name, value ) {\n\t\treturn access( this, jQuery.prop, name, value, arguments.length > 1 );\n\t},\n\n\tremoveProp: function( name ) {\n\t\treturn this.each( function() {\n\t\t\tdelete this[ jQuery.propFix[ name ] || name ];\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tprop: function( elem, name, value ) {\n\t\tvar ret, hooks,\n\t\t\tnType = elem.nodeType;\n\n\t\t// Don't get/set properties on text, comment and attribute nodes\n\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\n\t\t\t// Fix name and attach hooks\n\t\t\tname = jQuery.propFix[ name ] || name;\n\t\t\thooks = jQuery.propHooks[ name ];\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\tif ( hooks && \"set\" in hooks &&\n\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\treturn ( elem[ name ] = value );\n\t\t}\n\n\t\tif ( hooks && \"get\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n\t\t\treturn ret;\n\t\t}\n\n\t\treturn elem[ name ];\n\t},\n\n\tpropHooks: {\n\t\ttabIndex: {\n\t\t\tget: function( elem ) {\n\n\t\t\t\t// elem.tabIndex doesn't always return the\n\t\t\t\t// correct value when it hasn't been explicitly set\n\t\t\t\t// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\n\t\t\t\t// Use proper attribute retrieval(#12072)\n\t\t\t\tvar tabindex = jQuery.find.attr( elem, \"tabindex\" );\n\n\t\t\t\treturn tabindex ?\n\t\t\t\t\tparseInt( tabindex, 10 ) :\n\t\t\t\t\trfocusable.test( elem.nodeName ) ||\n\t\t\t\t\t\trclickable.test( elem.nodeName ) && elem.href ?\n\t\t\t\t\t\t\t0 :\n\t\t\t\t\t\t\t-1;\n\t\t\t}\n\t\t}\n\t},\n\n\tpropFix: {\n\t\t\"for\": \"htmlFor\",\n\t\t\"class\": \"className\"\n\t}\n} );\n\n// Support: IE <=11 only\n// Accessing the selectedIndex property\n// forces the browser to respect setting selected\n// on the option\n// The getter ensures a default option is selected\n// when in an optgroup\nif ( !support.optSelected ) {\n\tjQuery.propHooks.selected = {\n\t\tget: function( elem ) {\n\t\t\tvar parent = elem.parentNode;\n\t\t\tif ( parent && parent.parentNode ) {\n\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\t\tset: function( elem ) {\n\t\t\tvar parent = elem.parentNode;\n\t\t\tif ( parent ) {\n\t\t\t\tparent.selectedIndex;\n\n\t\t\t\tif ( parent.parentNode ) {\n\t\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\njQuery.each( [\n\t\"tabIndex\",\n\t\"readOnly\",\n\t\"maxLength\",\n\t\"cellSpacing\",\n\t\"cellPadding\",\n\t\"rowSpan\",\n\t\"colSpan\",\n\t\"useMap\",\n\t\"frameBorder\",\n\t\"contentEditable\"\n], function() {\n\tjQuery.propFix[ this.toLowerCase() ] = this;\n} );\n\n\n\n\nvar rclass = /[\\t\\r\\n\\f]/g;\n\nfunction getClass( elem ) {\n\treturn elem.getAttribute && elem.getAttribute( \"class\" ) || \"\";\n}\n\njQuery.fn.extend( {\n\taddClass: function( value ) {\n\t\tvar classes, elem, cur, curValue, clazz, j, finalValue,\n\t\t\ti = 0;\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each( function( j ) {\n\t\t\t\tjQuery( this ).addClass( value.call( this, j, getClass( this ) ) );\n\t\t\t} );\n\t\t}\n\n\t\tif ( typeof value === \"string\" && value ) {\n\t\t\tclasses = value.match( rnotwhite ) || [];\n\n\t\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\t\tcurValue = getClass( elem );\n\t\t\t\tcur = elem.nodeType === 1 &&\n\t\t\t\t\t( \" \" + curValue + \" \" ).replace( rclass, \" \" );\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( ( clazz = classes[ j++ ] ) ) {\n\t\t\t\t\t\tif ( cur.indexOf( \" \" + clazz + \" \" ) < 0 ) {\n\t\t\t\t\t\t\tcur += clazz + \" \";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = jQuery.trim( cur );\n\t\t\t\t\tif ( curValue !== finalValue ) {\n\t\t\t\t\t\telem.setAttribute( \"class\", finalValue );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tremoveClass: function( value ) {\n\t\tvar classes, elem, cur, curValue, clazz, j, finalValue,\n\t\t\ti = 0;\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each( function( j ) {\n\t\t\t\tjQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );\n\t\t\t} );\n\t\t}\n\n\t\tif ( !arguments.length ) {\n\t\t\treturn this.attr( \"class\", \"\" );\n\t\t}\n\n\t\tif ( typeof value === \"string\" && value ) {\n\t\t\tclasses = value.match( rnotwhite ) || [];\n\n\t\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\t\tcurValue = getClass( elem );\n\n\t\t\t\t// This expression is here for better compressibility (see addClass)\n\t\t\t\tcur = elem.nodeType === 1 &&\n\t\t\t\t\t( \" \" + curValue + \" \" ).replace( rclass, \" \" );\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( ( clazz = classes[ j++ ] ) ) {\n\n\t\t\t\t\t\t// Remove *all* instances\n\t\t\t\t\t\twhile ( cur.indexOf( \" \" + clazz + \" \" ) > -1 ) {\n\t\t\t\t\t\t\tcur = cur.replace( \" \" + clazz + \" \", \" \" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = jQuery.trim( cur );\n\t\t\t\t\tif ( curValue !== finalValue ) {\n\t\t\t\t\t\telem.setAttribute( \"class\", finalValue );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\ttoggleClass: function( value, stateVal ) {\n\t\tvar type = typeof value;\n\n\t\tif ( typeof stateVal === \"boolean\" && type === \"string\" ) {\n\t\t\treturn stateVal ? this.addClass( value ) : this.removeClass( value );\n\t\t}\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each( function( i ) {\n\t\t\t\tjQuery( this ).toggleClass(\n\t\t\t\t\tvalue.call( this, i, getClass( this ), stateVal ),\n\t\t\t\t\tstateVal\n\t\t\t\t);\n\t\t\t} );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar className, i, self, classNames;\n\n\t\t\tif ( type === \"string\" ) {\n\n\t\t\t\t// Toggle individual class names\n\t\t\t\ti = 0;\n\t\t\t\tself = jQuery( this );\n\t\t\t\tclassNames = value.match( rnotwhite ) || [];\n\n\t\t\t\twhile ( ( className = classNames[ i++ ] ) ) {\n\n\t\t\t\t\t// Check each className given, space separated list\n\t\t\t\t\tif ( self.hasClass( className ) ) {\n\t\t\t\t\t\tself.removeClass( className );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.addClass( className );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Toggle whole class name\n\t\t\t} else if ( value === undefined || type === \"boolean\" ) {\n\t\t\t\tclassName = getClass( this );\n\t\t\t\tif ( className ) {\n\n\t\t\t\t\t// Store className if set\n\t\t\t\t\tdataPriv.set( this, \"__className__\", className );\n\t\t\t\t}\n\n\t\t\t\t// If the element has a class name or if we're passed `false`,\n\t\t\t\t// then remove the whole classname (if there was one, the above saved it).\n\t\t\t\t// Otherwise bring back whatever was previously saved (if anything),\n\t\t\t\t// falling back to the empty string if nothing was stored.\n\t\t\t\tif ( this.setAttribute ) {\n\t\t\t\t\tthis.setAttribute( \"class\",\n\t\t\t\t\t\tclassName || value === false ?\n\t\t\t\t\t\t\"\" :\n\t\t\t\t\t\tdataPriv.get( this, \"__className__\" ) || \"\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t},\n\n\thasClass: function( selector ) {\n\t\tvar className, elem,\n\t\t\ti = 0;\n\n\t\tclassName = \" \" + selector + \" \";\n\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\tif ( elem.nodeType === 1 &&\n\t\t\t\t( \" \" + getClass( elem ) + \" \" ).replace( rclass, \" \" )\n\t\t\t\t\t.indexOf( className ) > -1\n\t\t\t) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n} );\n\n\n\n\nvar rreturn = /\\r/g,\n\trspaces = /[\\x20\\t\\r\\n\\f]+/g;\n\njQuery.fn.extend( {\n\tval: function( value ) {\n\t\tvar hooks, ret, isFunction,\n\t\t\telem = this[ 0 ];\n\n\t\tif ( !arguments.length ) {\n\t\t\tif ( elem ) {\n\t\t\t\thooks = jQuery.valHooks[ elem.type ] ||\n\t\t\t\t\tjQuery.valHooks[ elem.nodeName.toLowerCase() ];\n\n\t\t\t\tif ( hooks &&\n\t\t\t\t\t\"get\" in hooks &&\n\t\t\t\t\t( ret = hooks.get( elem, \"value\" ) ) !== undefined\n\t\t\t\t) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tret = elem.value;\n\n\t\t\t\treturn typeof ret === \"string\" ?\n\n\t\t\t\t\t// Handle most common string cases\n\t\t\t\t\tret.replace( rreturn, \"\" ) :\n\n\t\t\t\t\t// Handle cases where value is null/undef or number\n\t\t\t\t\tret == null ? \"\" : ret;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tisFunction = jQuery.isFunction( value );\n\n\t\treturn this.each( function( i ) {\n\t\t\tvar val;\n\n\t\t\tif ( this.nodeType !== 1 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( isFunction ) {\n\t\t\t\tval = value.call( this, i, jQuery( this ).val() );\n\t\t\t} else {\n\t\t\t\tval = value;\n\t\t\t}\n\n\t\t\t// Treat null/undefined as \"\"; convert numbers to string\n\t\t\tif ( val == null ) {\n\t\t\t\tval = \"\";\n\n\t\t\t} else if ( typeof val === \"number\" ) {\n\t\t\t\tval += \"\";\n\n\t\t\t} else if ( jQuery.isArray( val ) ) {\n\t\t\t\tval = jQuery.map( val, function( value ) {\n\t\t\t\t\treturn value == null ? \"\" : value + \"\";\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\thooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\n\n\t\t\t// If set returns undefined, fall back to normal setting\n\t\t\tif ( !hooks || !( \"set\" in hooks ) || hooks.set( this, val, \"value\" ) === undefined ) {\n\t\t\t\tthis.value = val;\n\t\t\t}\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tvalHooks: {\n\t\toption: {\n\t\t\tget: function( elem ) {\n\n\t\t\t\tvar val = jQuery.find.attr( elem, \"value\" );\n\t\t\t\treturn val != null ?\n\t\t\t\t\tval :\n\n\t\t\t\t\t// Support: IE10-11+\n\t\t\t\t\t// option.text throws exceptions (#14686, #14858)\n\t\t\t\t\t// Strip and collapse whitespace\n\t\t\t\t\t// https://html.spec.whatwg.org/#strip-and-collapse-whitespace\n\t\t\t\t\tjQuery.trim( jQuery.text( elem ) ).replace( rspaces, \" \" );\n\t\t\t}\n\t\t},\n\t\tselect: {\n\t\t\tget: function( elem ) {\n\t\t\t\tvar value, option,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tindex = elem.selectedIndex,\n\t\t\t\t\tone = elem.type === \"select-one\" || index < 0,\n\t\t\t\t\tvalues = one ? null : [],\n\t\t\t\t\tmax = one ? index + 1 : options.length,\n\t\t\t\t\ti = index < 0 ?\n\t\t\t\t\t\tmax :\n\t\t\t\t\t\tone ? index : 0;\n\n\t\t\t\t// Loop through all the selected options\n\t\t\t\tfor ( ; i < max; i++ ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t// IE8-9 doesn't update selected after form reset (#2551)\n\t\t\t\t\tif ( ( option.selected || i === index ) &&\n\n\t\t\t\t\t\t\t// Don't return options that are disabled or in a disabled optgroup\n\t\t\t\t\t\t\t( support.optDisabled ?\n\t\t\t\t\t\t\t\t!option.disabled : option.getAttribute( \"disabled\" ) === null ) &&\n\t\t\t\t\t\t\t( !option.parentNode.disabled ||\n\t\t\t\t\t\t\t\t!jQuery.nodeName( option.parentNode, \"optgroup\" ) ) ) {\n\n\t\t\t\t\t\t// Get the specific value for the option\n\t\t\t\t\t\tvalue = jQuery( option ).val();\n\n\t\t\t\t\t\t// We don't need an array for one selects\n\t\t\t\t\t\tif ( one ) {\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Multi-Selects return an array\n\t\t\t\t\t\tvalues.push( value );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn values;\n\t\t\t},\n\n\t\t\tset: function( elem, value ) {\n\t\t\t\tvar optionSet, option,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tvalues = jQuery.makeArray( value ),\n\t\t\t\t\ti = options.length;\n\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\toption = options[ i ];\n\t\t\t\t\tif ( option.selected =\n\t\t\t\t\t\tjQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1\n\t\t\t\t\t) {\n\t\t\t\t\t\toptionSet = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Force browsers to behave consistently when non-matching value is set\n\t\t\t\tif ( !optionSet ) {\n\t\t\t\t\telem.selectedIndex = -1;\n\t\t\t\t}\n\t\t\t\treturn values;\n\t\t\t}\n\t\t}\n\t}\n} );\n\n// Radios and checkboxes getter/setter\njQuery.each( [ \"radio\", \"checkbox\" ], function() {\n\tjQuery.valHooks[ this ] = {\n\t\tset: function( elem, value ) {\n\t\t\tif ( jQuery.isArray( value ) ) {\n\t\t\t\treturn ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );\n\t\t\t}\n\t\t}\n\t};\n\tif ( !support.checkOn ) {\n\t\tjQuery.valHooks[ this ].get = function( elem ) {\n\t\t\treturn elem.getAttribute( \"value\" ) === null ? \"on\" : elem.value;\n\t\t};\n\t}\n} );\n\n\n\n\n// Return jQuery for attributes-only inclusion\n\n\nvar rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;\n\njQuery.extend( jQuery.event, {\n\n\ttrigger: function( event, data, elem, onlyHandlers ) {\n\n\t\tvar i, cur, tmp, bubbleType, ontype, handle, special,\n\t\t\teventPath = [ elem || document ],\n\t\t\ttype = hasOwn.call( event, \"type\" ) ? event.type : event,\n\t\t\tnamespaces = hasOwn.call( event, \"namespace\" ) ? event.namespace.split( \".\" ) : [];\n\n\t\tcur = tmp = elem = elem || document;\n\n\t\t// Don't do events on text and comment nodes\n\t\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// focus/blur morphs to focusin/out; ensure we're not firing them right now\n\t\tif ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( type.indexOf( \".\" ) > -1 ) {\n\n\t\t\t// Namespaced trigger; create a regexp to match event type in handle()\n\t\t\tnamespaces = type.split( \".\" );\n\t\t\ttype = namespaces.shift();\n\t\t\tnamespaces.sort();\n\t\t}\n\t\tontype = type.indexOf( \":\" ) < 0 && \"on\" + type;\n\n\t\t// Caller can pass in a jQuery.Event object, Object, or just an event type string\n\t\tevent = event[ jQuery.expando ] ?\n\t\t\tevent :\n\t\t\tnew jQuery.Event( type, typeof event === \"object\" && event );\n\n\t\t// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n\t\tevent.isTrigger = onlyHandlers ? 2 : 3;\n\t\tevent.namespace = namespaces.join( \".\" );\n\t\tevent.rnamespace = event.namespace ?\n\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join( \"\\\\.(?:.*\\\\.|)\" ) + \"(\\\\.|$)\" ) :\n\t\t\tnull;\n\n\t\t// Clean up the event in case it is being reused\n\t\tevent.result = undefined;\n\t\tif ( !event.target ) {\n\t\t\tevent.target = elem;\n\t\t}\n\n\t\t// Clone any incoming data and prepend the event, creating the handler arg list\n\t\tdata = data == null ?\n\t\t\t[ event ] :\n\t\t\tjQuery.makeArray( data, [ event ] );\n\n\t\t// Allow special events to draw outside the lines\n\t\tspecial = jQuery.event.special[ type ] || {};\n\t\tif ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine event propagation path in advance, per W3C events spec (#9951)\n\t\t// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n\t\tif ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {\n\n\t\t\tbubbleType = special.delegateType || type;\n\t\t\tif ( !rfocusMorph.test( bubbleType + type ) ) {\n\t\t\t\tcur = cur.parentNode;\n\t\t\t}\n\t\t\tfor ( ; cur; cur = cur.parentNode ) {\n\t\t\t\teventPath.push( cur );\n\t\t\t\ttmp = cur;\n\t\t\t}\n\n\t\t\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\n\t\t\tif ( tmp === ( elem.ownerDocument || document ) ) {\n\t\t\t\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\n\t\t\t}\n\t\t}\n\n\t\t// Fire handlers on the event path\n\t\ti = 0;\n\t\twhile ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {\n\n\t\t\tevent.type = i > 1 ?\n\t\t\t\tbubbleType :\n\t\t\t\tspecial.bindType || type;\n\n\t\t\t// jQuery handler\n\t\t\thandle = ( dataPriv.get( cur, \"events\" ) || {} )[ event.type ] &&\n\t\t\t\tdataPriv.get( cur, \"handle\" );\n\t\t\tif ( handle ) {\n\t\t\t\thandle.apply( cur, data );\n\t\t\t}\n\n\t\t\t// Native handler\n\t\t\thandle = ontype && cur[ ontype ];\n\t\t\tif ( handle && handle.apply && acceptData( cur ) ) {\n\t\t\t\tevent.result = handle.apply( cur, data );\n\t\t\t\tif ( event.result === false ) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tevent.type = type;\n\n\t\t// If nobody prevented the default action, do it now\n\t\tif ( !onlyHandlers && !event.isDefaultPrevented() ) {\n\n\t\t\tif ( ( !special._default ||\n\t\t\t\tspecial._default.apply( eventPath.pop(), data ) === false ) &&\n\t\t\t\tacceptData( elem ) ) {\n\n\t\t\t\t// Call a native DOM method on the target with the same name name as the event.\n\t\t\t\t// Don't do default actions on window, that's where global variables be (#6170)\n\t\t\t\tif ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {\n\n\t\t\t\t\t// Don't re-trigger an onFOO event when we call its FOO() method\n\t\t\t\t\ttmp = elem[ ontype ];\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = null;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prevent re-triggering of the same event, since we already bubbled it above\n\t\t\t\t\tjQuery.event.triggered = type;\n\t\t\t\t\telem[ type ]();\n\t\t\t\t\tjQuery.event.triggered = undefined;\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\t// Piggyback on a donor event to simulate a different one\n\t// Used only for `focus(in | out)` events\n\tsimulate: function( type, elem, event ) {\n\t\tvar e = jQuery.extend(\n\t\t\tnew jQuery.Event(),\n\t\t\tevent,\n\t\t\t{\n\t\t\t\ttype: type,\n\t\t\t\tisSimulated: true\n\t\t\t}\n\t\t);\n\n\t\tjQuery.event.trigger( e, null, elem );\n\t}\n\n} );\n\njQuery.fn.extend( {\n\n\ttrigger: function( type, data ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.trigger( type, data, this );\n\t\t} );\n\t},\n\ttriggerHandler: function( type, data ) {\n\t\tvar elem = this[ 0 ];\n\t\tif ( elem ) {\n\t\t\treturn jQuery.event.trigger( type, data, elem, true );\n\t\t}\n\t}\n} );\n\n\njQuery.each( ( \"blur focus focusin focusout load resize scroll unload click dblclick \" +\n\t\"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\n\t\"change select submit keydown keypress keyup error contextmenu\" ).split( \" \" ),\n\tfunction( i, name ) {\n\n\t// Handle event binding\n\tjQuery.fn[ name ] = function( data, fn ) {\n\t\treturn arguments.length > 0 ?\n\t\t\tthis.on( name, null, data, fn ) :\n\t\t\tthis.trigger( name );\n\t};\n} );\n\njQuery.fn.extend( {\n\thover: function( fnOver, fnOut ) {\n\t\treturn this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\n\t}\n} );\n\n\n\n\nsupport.focusin = \"onfocusin\" in window;\n\n\n// Support: Firefox\n// Firefox doesn't have focus(in | out) events\n// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787\n//\n// Support: Chrome, Safari\n// focus(in | out) events fire after focus & blur events,\n// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order\n// Related ticket - https://code.google.com/p/chromium/issues/detail?id=449857\nif ( !support.focusin ) {\n\tjQuery.each( { focus: \"focusin\", blur: \"focusout\" }, function( orig, fix ) {\n\n\t\t// Attach a single capturing handler on the document while someone wants focusin/focusout\n\t\tvar handler = function( event ) {\n\t\t\tjQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );\n\t\t};\n\n\t\tjQuery.event.special[ fix ] = {\n\t\t\tsetup: function() {\n\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\tattaches = dataPriv.access( doc, fix );\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.addEventListener( orig, handler, true );\n\t\t\t\t}\n\t\t\t\tdataPriv.access( doc, fix, ( attaches || 0 ) + 1 );\n\t\t\t},\n\t\t\tteardown: function() {\n\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\tattaches = dataPriv.access( doc, fix ) - 1;\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.removeEventListener( orig, handler, true );\n\t\t\t\t\tdataPriv.remove( doc, fix );\n\n\t\t\t\t} else {\n\t\t\t\t\tdataPriv.access( doc, fix, attaches );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t} );\n}\nvar location = window.location;\n\nvar nonce = jQuery.now();\n\nvar rquery = ( /\\?/ );\n\n\n\n// Support: Android 2.3\n// Workaround failure to string-cast null input\njQuery.parseJSON = function( data ) {\n\treturn JSON.parse( data + \"\" );\n};\n\n\n// Cross-browser xml parsing\njQuery.parseXML = function( data ) {\n\tvar xml;\n\tif ( !data || typeof data !== \"string\" ) {\n\t\treturn null;\n\t}\n\n\t// Support: IE9\n\ttry {\n\t\txml = ( new window.DOMParser() ).parseFromString( data, \"text/xml\" );\n\t} catch ( e ) {\n\t\txml = undefined;\n\t}\n\n\tif ( !xml || xml.getElementsByTagName( \"parsererror\" ).length ) {\n\t\tjQuery.error( \"Invalid XML: \" + data );\n\t}\n\treturn xml;\n};\n\n\nvar\n\trhash = /#.*$/,\n\trts = /([?&])_=[^&]*/,\n\trheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,\n\n\t// #7653, #8125, #8152: local protocol detection\n\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n\trnoContent = /^(?:GET|HEAD)$/,\n\trprotocol = /^\\/\\//,\n\n\t/* Prefilters\n\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n\t * 2) These are called:\n\t *    - BEFORE asking for a transport\n\t *    - AFTER param serialization (s.data is a string if s.processData is true)\n\t * 3) key is the dataType\n\t * 4) the catchall symbol \"*\" can be used\n\t * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n\t */\n\tprefilters = {},\n\n\t/* Transports bindings\n\t * 1) key is the dataType\n\t * 2) the catchall symbol \"*\" can be used\n\t * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n\t */\n\ttransports = {},\n\n\t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n\tallTypes = \"*/\".concat( \"*\" ),\n\n\t// Anchor tag for parsing the document origin\n\toriginAnchor = document.createElement( \"a\" );\n\toriginAnchor.href = location.href;\n\n// Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\nfunction addToPrefiltersOrTransports( structure ) {\n\n\t// dataTypeExpression is optional and defaults to \"*\"\n\treturn function( dataTypeExpression, func ) {\n\n\t\tif ( typeof dataTypeExpression !== \"string\" ) {\n\t\t\tfunc = dataTypeExpression;\n\t\t\tdataTypeExpression = \"*\";\n\t\t}\n\n\t\tvar dataType,\n\t\t\ti = 0,\n\t\t\tdataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];\n\n\t\tif ( jQuery.isFunction( func ) ) {\n\n\t\t\t// For each dataType in the dataTypeExpression\n\t\t\twhile ( ( dataType = dataTypes[ i++ ] ) ) {\n\n\t\t\t\t// Prepend if requested\n\t\t\t\tif ( dataType[ 0 ] === \"+\" ) {\n\t\t\t\t\tdataType = dataType.slice( 1 ) || \"*\";\n\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );\n\n\t\t\t\t// Otherwise append\n\t\t\t\t} else {\n\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).push( func );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\n// Base inspection function for prefilters and transports\nfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\n\n\tvar inspected = {},\n\t\tseekingTransport = ( structure === transports );\n\n\tfunction inspect( dataType ) {\n\t\tvar selected;\n\t\tinspected[ dataType ] = true;\n\t\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\n\t\t\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\n\t\t\tif ( typeof dataTypeOrTransport === \"string\" &&\n\t\t\t\t!seekingTransport && !inspected[ dataTypeOrTransport ] ) {\n\n\t\t\t\toptions.dataTypes.unshift( dataTypeOrTransport );\n\t\t\t\tinspect( dataTypeOrTransport );\n\t\t\t\treturn false;\n\t\t\t} else if ( seekingTransport ) {\n\t\t\t\treturn !( selected = dataTypeOrTransport );\n\t\t\t}\n\t\t} );\n\t\treturn selected;\n\t}\n\n\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ \"*\" ] && inspect( \"*\" );\n}\n\n// A special extend for ajax options\n// that takes \"flat\" options (not to be deep extended)\n// Fixes #9887\nfunction ajaxExtend( target, src ) {\n\tvar key, deep,\n\t\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n\tfor ( key in src ) {\n\t\tif ( src[ key ] !== undefined ) {\n\t\t\t( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];\n\t\t}\n\t}\n\tif ( deep ) {\n\t\tjQuery.extend( true, target, deep );\n\t}\n\n\treturn target;\n}\n\n/* Handles responses to an ajax request:\n * - finds the right dataType (mediates between content-type and expected dataType)\n * - returns the corresponding response\n */\nfunction ajaxHandleResponses( s, jqXHR, responses ) {\n\n\tvar ct, type, finalDataType, firstDataType,\n\t\tcontents = s.contents,\n\t\tdataTypes = s.dataTypes;\n\n\t// Remove auto dataType and get content-type in the process\n\twhile ( dataTypes[ 0 ] === \"*\" ) {\n\t\tdataTypes.shift();\n\t\tif ( ct === undefined ) {\n\t\t\tct = s.mimeType || jqXHR.getResponseHeader( \"Content-Type\" );\n\t\t}\n\t}\n\n\t// Check if we're dealing with a known content-type\n\tif ( ct ) {\n\t\tfor ( type in contents ) {\n\t\t\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\n\t\t\t\tdataTypes.unshift( type );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check to see if we have a response for the expected dataType\n\tif ( dataTypes[ 0 ] in responses ) {\n\t\tfinalDataType = dataTypes[ 0 ];\n\t} else {\n\n\t\t// Try convertible dataTypes\n\t\tfor ( type in responses ) {\n\t\t\tif ( !dataTypes[ 0 ] || s.converters[ type + \" \" + dataTypes[ 0 ] ] ) {\n\t\t\t\tfinalDataType = type;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( !firstDataType ) {\n\t\t\t\tfirstDataType = type;\n\t\t\t}\n\t\t}\n\n\t\t// Or just use first one\n\t\tfinalDataType = finalDataType || firstDataType;\n\t}\n\n\t// If we found a dataType\n\t// We add the dataType to the list if needed\n\t// and return the corresponding response\n\tif ( finalDataType ) {\n\t\tif ( finalDataType !== dataTypes[ 0 ] ) {\n\t\t\tdataTypes.unshift( finalDataType );\n\t\t}\n\t\treturn responses[ finalDataType ];\n\t}\n}\n\n/* Chain conversions given the request and the original response\n * Also sets the responseXXX fields on the jqXHR instance\n */\nfunction ajaxConvert( s, response, jqXHR, isSuccess ) {\n\tvar conv2, current, conv, tmp, prev,\n\t\tconverters = {},\n\n\t\t// Work with a copy of dataTypes in case we need to modify it for conversion\n\t\tdataTypes = s.dataTypes.slice();\n\n\t// Create converters map with lowercased keys\n\tif ( dataTypes[ 1 ] ) {\n\t\tfor ( conv in s.converters ) {\n\t\t\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\n\t\t}\n\t}\n\n\tcurrent = dataTypes.shift();\n\n\t// Convert to each sequential dataType\n\twhile ( current ) {\n\n\t\tif ( s.responseFields[ current ] ) {\n\t\t\tjqXHR[ s.responseFields[ current ] ] = response;\n\t\t}\n\n\t\t// Apply the dataFilter if provided\n\t\tif ( !prev && isSuccess && s.dataFilter ) {\n\t\t\tresponse = s.dataFilter( response, s.dataType );\n\t\t}\n\n\t\tprev = current;\n\t\tcurrent = dataTypes.shift();\n\n\t\tif ( current ) {\n\n\t\t// There's only work to do if current dataType is non-auto\n\t\t\tif ( current === \"*\" ) {\n\n\t\t\t\tcurrent = prev;\n\n\t\t\t// Convert response if prev dataType is non-auto and differs from current\n\t\t\t} else if ( prev !== \"*\" && prev !== current ) {\n\n\t\t\t\t// Seek a direct converter\n\t\t\t\tconv = converters[ prev + \" \" + current ] || converters[ \"* \" + current ];\n\n\t\t\t\t// If none found, seek a pair\n\t\t\t\tif ( !conv ) {\n\t\t\t\t\tfor ( conv2 in converters ) {\n\n\t\t\t\t\t\t// If conv2 outputs current\n\t\t\t\t\t\ttmp = conv2.split( \" \" );\n\t\t\t\t\t\tif ( tmp[ 1 ] === current ) {\n\n\t\t\t\t\t\t\t// If prev can be converted to accepted input\n\t\t\t\t\t\t\tconv = converters[ prev + \" \" + tmp[ 0 ] ] ||\n\t\t\t\t\t\t\t\tconverters[ \"* \" + tmp[ 0 ] ];\n\t\t\t\t\t\t\tif ( conv ) {\n\n\t\t\t\t\t\t\t\t// Condense equivalence converters\n\t\t\t\t\t\t\t\tif ( conv === true ) {\n\t\t\t\t\t\t\t\t\tconv = converters[ conv2 ];\n\n\t\t\t\t\t\t\t\t// Otherwise, insert the intermediate dataType\n\t\t\t\t\t\t\t\t} else if ( converters[ conv2 ] !== true ) {\n\t\t\t\t\t\t\t\t\tcurrent = tmp[ 0 ];\n\t\t\t\t\t\t\t\t\tdataTypes.unshift( tmp[ 1 ] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Apply converter (if not an equivalence)\n\t\t\t\tif ( conv !== true ) {\n\n\t\t\t\t\t// Unless errors are allowed to bubble, catch and return them\n\t\t\t\t\tif ( conv && s.throws ) {\n\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tstate: \"parsererror\",\n\t\t\t\t\t\t\t\terror: conv ? e : \"No conversion from \" + prev + \" to \" + current\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { state: \"success\", data: response };\n}\n\njQuery.extend( {\n\n\t// Counter for holding the number of active queries\n\tactive: 0,\n\n\t// Last-Modified header cache for next request\n\tlastModified: {},\n\tetag: {},\n\n\tajaxSettings: {\n\t\turl: location.href,\n\t\ttype: \"GET\",\n\t\tisLocal: rlocalProtocol.test( location.protocol ),\n\t\tglobal: true,\n\t\tprocessData: true,\n\t\tasync: true,\n\t\tcontentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n\t\t/*\n\t\ttimeout: 0,\n\t\tdata: null,\n\t\tdataType: null,\n\t\tusername: null,\n\t\tpassword: null,\n\t\tcache: null,\n\t\tthrows: false,\n\t\ttraditional: false,\n\t\theaders: {},\n\t\t*/\n\n\t\taccepts: {\n\t\t\t\"*\": allTypes,\n\t\t\ttext: \"text/plain\",\n\t\t\thtml: \"text/html\",\n\t\t\txml: \"application/xml, text/xml\",\n\t\t\tjson: \"application/json, text/javascript\"\n\t\t},\n\n\t\tcontents: {\n\t\t\txml: /\\bxml\\b/,\n\t\t\thtml: /\\bhtml/,\n\t\t\tjson: /\\bjson\\b/\n\t\t},\n\n\t\tresponseFields: {\n\t\t\txml: \"responseXML\",\n\t\t\ttext: \"responseText\",\n\t\t\tjson: \"responseJSON\"\n\t\t},\n\n\t\t// Data converters\n\t\t// Keys separate source (or catchall \"*\") and destination types with a single space\n\t\tconverters: {\n\n\t\t\t// Convert anything to text\n\t\t\t\"* text\": String,\n\n\t\t\t// Text to html (true = no transformation)\n\t\t\t\"text html\": true,\n\n\t\t\t// Evaluate text as a json expression\n\t\t\t\"text json\": jQuery.parseJSON,\n\n\t\t\t// Parse text as xml\n\t\t\t\"text xml\": jQuery.parseXML\n\t\t},\n\n\t\t// For options that shouldn't be deep extended:\n\t\t// you can add your own custom options here if\n\t\t// and when you create one that shouldn't be\n\t\t// deep extended (see ajaxExtend)\n\t\tflatOptions: {\n\t\t\turl: true,\n\t\t\tcontext: true\n\t\t}\n\t},\n\n\t// Creates a full fledged settings object into target\n\t// with both ajaxSettings and settings fields.\n\t// If target is omitted, writes into ajaxSettings.\n\tajaxSetup: function( target, settings ) {\n\t\treturn settings ?\n\n\t\t\t// Building a settings object\n\t\t\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\n\n\t\t\t// Extending ajaxSettings\n\t\t\tajaxExtend( jQuery.ajaxSettings, target );\n\t},\n\n\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\n\tajaxTransport: addToPrefiltersOrTransports( transports ),\n\n\t// Main method\n\tajax: function( url, options ) {\n\n\t\t// If url is an object, simulate pre-1.5 signature\n\t\tif ( typeof url === \"object\" ) {\n\t\t\toptions = url;\n\t\t\turl = undefined;\n\t\t}\n\n\t\t// Force options to be an object\n\t\toptions = options || {};\n\n\t\tvar transport,\n\n\t\t\t// URL without anti-cache param\n\t\t\tcacheURL,\n\n\t\t\t// Response headers\n\t\t\tresponseHeadersString,\n\t\t\tresponseHeaders,\n\n\t\t\t// timeout handle\n\t\t\ttimeoutTimer,\n\n\t\t\t// Url cleanup var\n\t\t\turlAnchor,\n\n\t\t\t// To know if global events are to be dispatched\n\t\t\tfireGlobals,\n\n\t\t\t// Loop variable\n\t\t\ti,\n\n\t\t\t// Create the final options object\n\t\t\ts = jQuery.ajaxSetup( {}, options ),\n\n\t\t\t// Callbacks context\n\t\t\tcallbackContext = s.context || s,\n\n\t\t\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\n\t\t\tglobalEventContext = s.context &&\n\t\t\t\t( callbackContext.nodeType || callbackContext.jquery ) ?\n\t\t\t\t\tjQuery( callbackContext ) :\n\t\t\t\t\tjQuery.event,\n\n\t\t\t// Deferreds\n\t\t\tdeferred = jQuery.Deferred(),\n\t\t\tcompleteDeferred = jQuery.Callbacks( \"once memory\" ),\n\n\t\t\t// Status-dependent callbacks\n\t\t\tstatusCode = s.statusCode || {},\n\n\t\t\t// Headers (they are sent all at once)\n\t\t\trequestHeaders = {},\n\t\t\trequestHeadersNames = {},\n\n\t\t\t// The jqXHR state\n\t\t\tstate = 0,\n\n\t\t\t// Default abort message\n\t\t\tstrAbort = \"canceled\",\n\n\t\t\t// Fake xhr\n\t\t\tjqXHR = {\n\t\t\t\treadyState: 0,\n\n\t\t\t\t// Builds headers hashtable if needed\n\t\t\t\tgetResponseHeader: function( key ) {\n\t\t\t\t\tvar match;\n\t\t\t\t\tif ( state === 2 ) {\n\t\t\t\t\t\tif ( !responseHeaders ) {\n\t\t\t\t\t\t\tresponseHeaders = {};\n\t\t\t\t\t\t\twhile ( ( match = rheaders.exec( responseHeadersString ) ) ) {\n\t\t\t\t\t\t\t\tresponseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmatch = responseHeaders[ key.toLowerCase() ];\n\t\t\t\t\t}\n\t\t\t\t\treturn match == null ? null : match;\n\t\t\t\t},\n\n\t\t\t\t// Raw string\n\t\t\t\tgetAllResponseHeaders: function() {\n\t\t\t\t\treturn state === 2 ? responseHeadersString : null;\n\t\t\t\t},\n\n\t\t\t\t// Caches the header\n\t\t\t\tsetRequestHeader: function( name, value ) {\n\t\t\t\t\tvar lname = name.toLowerCase();\n\t\t\t\t\tif ( !state ) {\n\t\t\t\t\t\tname = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;\n\t\t\t\t\t\trequestHeaders[ name ] = value;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Overrides response content-type header\n\t\t\t\toverrideMimeType: function( type ) {\n\t\t\t\t\tif ( !state ) {\n\t\t\t\t\t\ts.mimeType = type;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Status-dependent callbacks\n\t\t\t\tstatusCode: function( map ) {\n\t\t\t\t\tvar code;\n\t\t\t\t\tif ( map ) {\n\t\t\t\t\t\tif ( state < 2 ) {\n\t\t\t\t\t\t\tfor ( code in map ) {\n\n\t\t\t\t\t\t\t\t// Lazy-add the new callback in a way that preserves old ones\n\t\t\t\t\t\t\t\tstatusCode[ code ] = [ statusCode[ code ], map[ code ] ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// Execute the appropriate callbacks\n\t\t\t\t\t\t\tjqXHR.always( map[ jqXHR.status ] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Cancel the request\n\t\t\t\tabort: function( statusText ) {\n\t\t\t\t\tvar finalText = statusText || strAbort;\n\t\t\t\t\tif ( transport ) {\n\t\t\t\t\t\ttransport.abort( finalText );\n\t\t\t\t\t}\n\t\t\t\t\tdone( 0, finalText );\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t};\n\n\t\t// Attach deferreds\n\t\tdeferred.promise( jqXHR ).complete = completeDeferred.add;\n\t\tjqXHR.success = jqXHR.done;\n\t\tjqXHR.error = jqXHR.fail;\n\n\t\t// Remove hash character (#7531: and string promotion)\n\t\t// Add protocol if not provided (prefilters might expect it)\n\t\t// Handle falsy url in the settings object (#10093: consistency with old signature)\n\t\t// We also use the url parameter if available\n\t\ts.url = ( ( url || s.url || location.href ) + \"\" ).replace( rhash, \"\" )\n\t\t\t.replace( rprotocol, location.protocol + \"//\" );\n\n\t\t// Alias method option to type as per ticket #12004\n\t\ts.type = options.method || options.type || s.method || s.type;\n\n\t\t// Extract dataTypes list\n\t\ts.dataTypes = jQuery.trim( s.dataType || \"*\" ).toLowerCase().match( rnotwhite ) || [ \"\" ];\n\n\t\t// A cross-domain request is in order when the origin doesn't match the current origin.\n\t\tif ( s.crossDomain == null ) {\n\t\t\turlAnchor = document.createElement( \"a\" );\n\n\t\t\t// Support: IE8-11+\n\t\t\t// IE throws exception if url is malformed, e.g. http://example.com:80x/\n\t\t\ttry {\n\t\t\t\turlAnchor.href = s.url;\n\n\t\t\t\t// Support: IE8-11+\n\t\t\t\t// Anchor's host property isn't correctly set when s.url is relative\n\t\t\t\turlAnchor.href = urlAnchor.href;\n\t\t\t\ts.crossDomain = originAnchor.protocol + \"//\" + originAnchor.host !==\n\t\t\t\t\turlAnchor.protocol + \"//\" + urlAnchor.host;\n\t\t\t} catch ( e ) {\n\n\t\t\t\t// If there is an error parsing the URL, assume it is crossDomain,\n\t\t\t\t// it can be rejected by the transport if it is invalid\n\t\t\t\ts.crossDomain = true;\n\t\t\t}\n\t\t}\n\n\t\t// Convert data if not already a string\n\t\tif ( s.data && s.processData && typeof s.data !== \"string\" ) {\n\t\t\ts.data = jQuery.param( s.data, s.traditional );\n\t\t}\n\n\t\t// Apply prefilters\n\t\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\n\n\t\t// If request was aborted inside a prefilter, stop there\n\t\tif ( state === 2 ) {\n\t\t\treturn jqXHR;\n\t\t}\n\n\t\t// We can fire global events as of now if asked to\n\t\t// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\n\t\tfireGlobals = jQuery.event && s.global;\n\n\t\t// Watch for a new set of requests\n\t\tif ( fireGlobals && jQuery.active++ === 0 ) {\n\t\t\tjQuery.event.trigger( \"ajaxStart\" );\n\t\t}\n\n\t\t// Uppercase the type\n\t\ts.type = s.type.toUpperCase();\n\n\t\t// Determine if request has content\n\t\ts.hasContent = !rnoContent.test( s.type );\n\n\t\t// Save the URL in case we're toying with the If-Modified-Since\n\t\t// and/or If-None-Match header later on\n\t\tcacheURL = s.url;\n\n\t\t// More options handling for requests with no content\n\t\tif ( !s.hasContent ) {\n\n\t\t\t// If data is available, append data to url\n\t\t\tif ( s.data ) {\n\t\t\t\tcacheURL = ( s.url += ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + s.data );\n\n\t\t\t\t// #9682: remove data so that it's not used in an eventual retry\n\t\t\t\tdelete s.data;\n\t\t\t}\n\n\t\t\t// Add anti-cache in url if needed\n\t\t\tif ( s.cache === false ) {\n\t\t\t\ts.url = rts.test( cacheURL ) ?\n\n\t\t\t\t\t// If there is already a '_' parameter, set its value\n\t\t\t\t\tcacheURL.replace( rts, \"$1_=\" + nonce++ ) :\n\n\t\t\t\t\t// Otherwise add one to the end\n\t\t\t\t\tcacheURL + ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + \"_=\" + nonce++;\n\t\t\t}\n\t\t}\n\n\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\tif ( s.ifModified ) {\n\t\t\tif ( jQuery.lastModified[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-Modified-Since\", jQuery.lastModified[ cacheURL ] );\n\t\t\t}\n\t\t\tif ( jQuery.etag[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-None-Match\", jQuery.etag[ cacheURL ] );\n\t\t\t}\n\t\t}\n\n\t\t// Set the correct header, if data is being sent\n\t\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\n\t\t\tjqXHR.setRequestHeader( \"Content-Type\", s.contentType );\n\t\t}\n\n\t\t// Set the Accepts header for the server, depending on the dataType\n\t\tjqXHR.setRequestHeader(\n\t\t\t\"Accept\",\n\t\t\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?\n\t\t\t\ts.accepts[ s.dataTypes[ 0 ] ] +\n\t\t\t\t\t( s.dataTypes[ 0 ] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\" ) :\n\t\t\t\ts.accepts[ \"*\" ]\n\t\t);\n\n\t\t// Check for headers option\n\t\tfor ( i in s.headers ) {\n\t\t\tjqXHR.setRequestHeader( i, s.headers[ i ] );\n\t\t}\n\n\t\t// Allow custom headers/mimetypes and early abort\n\t\tif ( s.beforeSend &&\n\t\t\t( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {\n\n\t\t\t// Abort if not done already and return\n\t\t\treturn jqXHR.abort();\n\t\t}\n\n\t\t// Aborting is no longer a cancellation\n\t\tstrAbort = \"abort\";\n\n\t\t// Install callbacks on deferreds\n\t\tfor ( i in { success: 1, error: 1, complete: 1 } ) {\n\t\t\tjqXHR[ i ]( s[ i ] );\n\t\t}\n\n\t\t// Get transport\n\t\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\n\n\t\t// If no transport, we auto-abort\n\t\tif ( !transport ) {\n\t\t\tdone( -1, \"No Transport\" );\n\t\t} else {\n\t\t\tjqXHR.readyState = 1;\n\n\t\t\t// Send global event\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxSend\", [ jqXHR, s ] );\n\t\t\t}\n\n\t\t\t// If request was aborted inside ajaxSend, stop there\n\t\t\tif ( state === 2 ) {\n\t\t\t\treturn jqXHR;\n\t\t\t}\n\n\t\t\t// Timeout\n\t\t\tif ( s.async && s.timeout > 0 ) {\n\t\t\t\ttimeoutTimer = window.setTimeout( function() {\n\t\t\t\t\tjqXHR.abort( \"timeout\" );\n\t\t\t\t}, s.timeout );\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tstate = 1;\n\t\t\t\ttransport.send( requestHeaders, done );\n\t\t\t} catch ( e ) {\n\n\t\t\t\t// Propagate exception as error if not done\n\t\t\t\tif ( state < 2 ) {\n\t\t\t\t\tdone( -1, e );\n\n\t\t\t\t// Simply rethrow otherwise\n\t\t\t\t} else {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Callback for when everything is done\n\t\tfunction done( status, nativeStatusText, responses, headers ) {\n\t\t\tvar isSuccess, success, error, response, modified,\n\t\t\t\tstatusText = nativeStatusText;\n\n\t\t\t// Called once\n\t\t\tif ( state === 2 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// State is \"done\" now\n\t\t\tstate = 2;\n\n\t\t\t// Clear timeout if it exists\n\t\t\tif ( timeoutTimer ) {\n\t\t\t\twindow.clearTimeout( timeoutTimer );\n\t\t\t}\n\n\t\t\t// Dereference transport for early garbage collection\n\t\t\t// (no matter how long the jqXHR object will be used)\n\t\t\ttransport = undefined;\n\n\t\t\t// Cache response headers\n\t\t\tresponseHeadersString = headers || \"\";\n\n\t\t\t// Set readyState\n\t\t\tjqXHR.readyState = status > 0 ? 4 : 0;\n\n\t\t\t// Determine if successful\n\t\t\tisSuccess = status >= 200 && status < 300 || status === 304;\n\n\t\t\t// Get response data\n\t\t\tif ( responses ) {\n\t\t\t\tresponse = ajaxHandleResponses( s, jqXHR, responses );\n\t\t\t}\n\n\t\t\t// Convert no matter what (that way responseXXX fields are always set)\n\t\t\tresponse = ajaxConvert( s, response, jqXHR, isSuccess );\n\n\t\t\t// If successful, handle type chaining\n\t\t\tif ( isSuccess ) {\n\n\t\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\t\tif ( s.ifModified ) {\n\t\t\t\t\tmodified = jqXHR.getResponseHeader( \"Last-Modified\" );\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.lastModified[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t\tmodified = jqXHR.getResponseHeader( \"etag\" );\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.etag[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// if no content\n\t\t\t\tif ( status === 204 || s.type === \"HEAD\" ) {\n\t\t\t\t\tstatusText = \"nocontent\";\n\n\t\t\t\t// if not modified\n\t\t\t\t} else if ( status === 304 ) {\n\t\t\t\t\tstatusText = \"notmodified\";\n\n\t\t\t\t// If we have data, let's convert it\n\t\t\t\t} else {\n\t\t\t\t\tstatusText = response.state;\n\t\t\t\t\tsuccess = response.data;\n\t\t\t\t\terror = response.error;\n\t\t\t\t\tisSuccess = !error;\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\t// Extract error from statusText and normalize for non-aborts\n\t\t\t\terror = statusText;\n\t\t\t\tif ( status || !statusText ) {\n\t\t\t\t\tstatusText = \"error\";\n\t\t\t\t\tif ( status < 0 ) {\n\t\t\t\t\t\tstatus = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set data for the fake xhr object\n\t\t\tjqXHR.status = status;\n\t\t\tjqXHR.statusText = ( nativeStatusText || statusText ) + \"\";\n\n\t\t\t// Success/Error\n\t\t\tif ( isSuccess ) {\n\t\t\t\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\n\t\t\t} else {\n\t\t\t\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\n\t\t\t}\n\n\t\t\t// Status-dependent callbacks\n\t\t\tjqXHR.statusCode( statusCode );\n\t\t\tstatusCode = undefined;\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( isSuccess ? \"ajaxSuccess\" : \"ajaxError\",\n\t\t\t\t\t[ jqXHR, s, isSuccess ? success : error ] );\n\t\t\t}\n\n\t\t\t// Complete\n\t\t\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxComplete\", [ jqXHR, s ] );\n\n\t\t\t\t// Handle the global AJAX counter\n\t\t\t\tif ( !( --jQuery.active ) ) {\n\t\t\t\t\tjQuery.event.trigger( \"ajaxStop\" );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn jqXHR;\n\t},\n\n\tgetJSON: function( url, data, callback ) {\n\t\treturn jQuery.get( url, data, callback, \"json\" );\n\t},\n\n\tgetScript: function( url, callback ) {\n\t\treturn jQuery.get( url, undefined, callback, \"script\" );\n\t}\n} );\n\njQuery.each( [ \"get\", \"post\" ], function( i, method ) {\n\tjQuery[ method ] = function( url, data, callback, type ) {\n\n\t\t// Shift arguments if data argument was omitted\n\t\tif ( jQuery.isFunction( data ) ) {\n\t\t\ttype = type || callback;\n\t\t\tcallback = data;\n\t\t\tdata = undefined;\n\t\t}\n\n\t\t// The url can be an options object (which then must have .url)\n\t\treturn jQuery.ajax( jQuery.extend( {\n\t\t\turl: url,\n\t\t\ttype: method,\n\t\t\tdataType: type,\n\t\t\tdata: data,\n\t\t\tsuccess: callback\n\t\t}, jQuery.isPlainObject( url ) && url ) );\n\t};\n} );\n\n\njQuery._evalUrl = function( url ) {\n\treturn jQuery.ajax( {\n\t\turl: url,\n\n\t\t// Make this explicit, since user can override this through ajaxSetup (#11264)\n\t\ttype: \"GET\",\n\t\tdataType: \"script\",\n\t\tasync: false,\n\t\tglobal: false,\n\t\t\"throws\": true\n\t} );\n};\n\n\njQuery.fn.extend( {\n\twrapAll: function( html ) {\n\t\tvar wrap;\n\n\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\treturn this.each( function( i ) {\n\t\t\t\tjQuery( this ).wrapAll( html.call( this, i ) );\n\t\t\t} );\n\t\t}\n\n\t\tif ( this[ 0 ] ) {\n\n\t\t\t// The elements to wrap the target around\n\t\t\twrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );\n\n\t\t\tif ( this[ 0 ].parentNode ) {\n\t\t\t\twrap.insertBefore( this[ 0 ] );\n\t\t\t}\n\n\t\t\twrap.map( function() {\n\t\t\t\tvar elem = this;\n\n\t\t\t\twhile ( elem.firstElementChild ) {\n\t\t\t\t\telem = elem.firstElementChild;\n\t\t\t\t}\n\n\t\t\t\treturn elem;\n\t\t\t} ).append( this );\n\t\t}\n\n\t\treturn this;\n\t},\n\n\twrapInner: function( html ) {\n\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\treturn this.each( function( i ) {\n\t\t\t\tjQuery( this ).wrapInner( html.call( this, i ) );\n\t\t\t} );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar self = jQuery( this ),\n\t\t\t\tcontents = self.contents();\n\n\t\t\tif ( contents.length ) {\n\t\t\t\tcontents.wrapAll( html );\n\n\t\t\t} else {\n\t\t\t\tself.append( html );\n\t\t\t}\n\t\t} );\n\t},\n\n\twrap: function( html ) {\n\t\tvar isFunction = jQuery.isFunction( html );\n\n\t\treturn this.each( function( i ) {\n\t\t\tjQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );\n\t\t} );\n\t},\n\n\tunwrap: function() {\n\t\treturn this.parent().each( function() {\n\t\t\tif ( !jQuery.nodeName( this, \"body\" ) ) {\n\t\t\t\tjQuery( this ).replaceWith( this.childNodes );\n\t\t\t}\n\t\t} ).end();\n\t}\n} );\n\n\njQuery.expr.filters.hidden = function( elem ) {\n\treturn !jQuery.expr.filters.visible( elem );\n};\njQuery.expr.filters.visible = function( elem ) {\n\n\t// Support: Opera <= 12.12\n\t// Opera reports offsetWidths and offsetHeights less than zero on some elements\n\t// Use OR instead of AND as the element is not visible if either is true\n\t// See tickets #10406 and #13132\n\treturn elem.offsetWidth > 0 || elem.offsetHeight > 0 || elem.getClientRects().length > 0;\n};\n\n\n\n\nvar r20 = /%20/g,\n\trbracket = /\\[\\]$/,\n\trCRLF = /\\r?\\n/g,\n\trsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n\trsubmittable = /^(?:input|select|textarea|keygen)/i;\n\nfunction buildParams( prefix, obj, traditional, add ) {\n\tvar name;\n\n\tif ( jQuery.isArray( obj ) ) {\n\n\t\t// Serialize array item.\n\t\tjQuery.each( obj, function( i, v ) {\n\t\t\tif ( traditional || rbracket.test( prefix ) ) {\n\n\t\t\t\t// Treat each array item as a scalar.\n\t\t\t\tadd( prefix, v );\n\n\t\t\t} else {\n\n\t\t\t\t// Item is non-scalar (array or object), encode its numeric index.\n\t\t\t\tbuildParams(\n\t\t\t\t\tprefix + \"[\" + ( typeof v === \"object\" && v != null ? i : \"\" ) + \"]\",\n\t\t\t\t\tv,\n\t\t\t\t\ttraditional,\n\t\t\t\t\tadd\n\t\t\t\t);\n\t\t\t}\n\t\t} );\n\n\t} else if ( !traditional && jQuery.type( obj ) === \"object\" ) {\n\n\t\t// Serialize object item.\n\t\tfor ( name in obj ) {\n\t\t\tbuildParams( prefix + \"[\" + name + \"]\", obj[ name ], traditional, add );\n\t\t}\n\n\t} else {\n\n\t\t// Serialize scalar item.\n\t\tadd( prefix, obj );\n\t}\n}\n\n// Serialize an array of form elements or a set of\n// key/values into a query string\njQuery.param = function( a, traditional ) {\n\tvar prefix,\n\t\ts = [],\n\t\tadd = function( key, value ) {\n\n\t\t\t// If value is a function, invoke it and return its value\n\t\t\tvalue = jQuery.isFunction( value ) ? value() : ( value == null ? \"\" : value );\n\t\t\ts[ s.length ] = encodeURIComponent( key ) + \"=\" + encodeURIComponent( value );\n\t\t};\n\n\t// Set traditional to true for jQuery <= 1.3.2 behavior.\n\tif ( traditional === undefined ) {\n\t\ttraditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;\n\t}\n\n\t// If an array was passed in, assume that it is an array of form elements.\n\tif ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\n\n\t\t// Serialize the form elements\n\t\tjQuery.each( a, function() {\n\t\t\tadd( this.name, this.value );\n\t\t} );\n\n\t} else {\n\n\t\t// If traditional, encode the \"old\" way (the way 1.3.2 or older\n\t\t// did it), otherwise encode params recursively.\n\t\tfor ( prefix in a ) {\n\t\t\tbuildParams( prefix, a[ prefix ], traditional, add );\n\t\t}\n\t}\n\n\t// Return the resulting serialization\n\treturn s.join( \"&\" ).replace( r20, \"+\" );\n};\n\njQuery.fn.extend( {\n\tserialize: function() {\n\t\treturn jQuery.param( this.serializeArray() );\n\t},\n\tserializeArray: function() {\n\t\treturn this.map( function() {\n\n\t\t\t// Can add propHook for \"elements\" to filter or add form elements\n\t\t\tvar elements = jQuery.prop( this, \"elements\" );\n\t\t\treturn elements ? jQuery.makeArray( elements ) : this;\n\t\t} )\n\t\t.filter( function() {\n\t\t\tvar type = this.type;\n\n\t\t\t// Use .is( \":disabled\" ) so that fieldset[disabled] works\n\t\t\treturn this.name && !jQuery( this ).is( \":disabled\" ) &&\n\t\t\t\trsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\n\t\t\t\t( this.checked || !rcheckableType.test( type ) );\n\t\t} )\n\t\t.map( function( i, elem ) {\n\t\t\tvar val = jQuery( this ).val();\n\n\t\t\treturn val == null ?\n\t\t\t\tnull :\n\t\t\t\tjQuery.isArray( val ) ?\n\t\t\t\t\tjQuery.map( val, function( val ) {\n\t\t\t\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t\t\t\t} ) :\n\t\t\t\t\t{ name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t} ).get();\n\t}\n} );\n\n\njQuery.ajaxSettings.xhr = function() {\n\ttry {\n\t\treturn new window.XMLHttpRequest();\n\t} catch ( e ) {}\n};\n\nvar xhrSuccessStatus = {\n\n\t\t// File protocol always yields status code 0, assume 200\n\t\t0: 200,\n\n\t\t// Support: IE9\n\t\t// #1450: sometimes IE returns 1223 when it should be 204\n\t\t1223: 204\n\t},\n\txhrSupported = jQuery.ajaxSettings.xhr();\n\nsupport.cors = !!xhrSupported && ( \"withCredentials\" in xhrSupported );\nsupport.ajax = xhrSupported = !!xhrSupported;\n\njQuery.ajaxTransport( function( options ) {\n\tvar callback, errorCallback;\n\n\t// Cross domain only allowed if supported through XMLHttpRequest\n\tif ( support.cors || xhrSupported && !options.crossDomain ) {\n\t\treturn {\n\t\t\tsend: function( headers, complete ) {\n\t\t\t\tvar i,\n\t\t\t\t\txhr = options.xhr();\n\n\t\t\t\txhr.open(\n\t\t\t\t\toptions.type,\n\t\t\t\t\toptions.url,\n\t\t\t\t\toptions.async,\n\t\t\t\t\toptions.username,\n\t\t\t\t\toptions.password\n\t\t\t\t);\n\n\t\t\t\t// Apply custom fields if provided\n\t\t\t\tif ( options.xhrFields ) {\n\t\t\t\t\tfor ( i in options.xhrFields ) {\n\t\t\t\t\t\txhr[ i ] = options.xhrFields[ i ];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Override mime type if needed\n\t\t\t\tif ( options.mimeType && xhr.overrideMimeType ) {\n\t\t\t\t\txhr.overrideMimeType( options.mimeType );\n\t\t\t\t}\n\n\t\t\t\t// X-Requested-With header\n\t\t\t\t// For cross-domain requests, seeing as conditions for a preflight are\n\t\t\t\t// akin to a jigsaw puzzle, we simply never set it to be sure.\n\t\t\t\t// (it can always be set on a per-request basis or even using ajaxSetup)\n\t\t\t\t// For same-domain requests, won't change header if already provided.\n\t\t\t\tif ( !options.crossDomain && !headers[ \"X-Requested-With\" ] ) {\n\t\t\t\t\theaders[ \"X-Requested-With\" ] = \"XMLHttpRequest\";\n\t\t\t\t}\n\n\t\t\t\t// Set headers\n\t\t\t\tfor ( i in headers ) {\n\t\t\t\t\txhr.setRequestHeader( i, headers[ i ] );\n\t\t\t\t}\n\n\t\t\t\t// Callback\n\t\t\t\tcallback = function( type ) {\n\t\t\t\t\treturn function() {\n\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\tcallback = errorCallback = xhr.onload =\n\t\t\t\t\t\t\t\txhr.onerror = xhr.onabort = xhr.onreadystatechange = null;\n\n\t\t\t\t\t\t\tif ( type === \"abort\" ) {\n\t\t\t\t\t\t\t\txhr.abort();\n\t\t\t\t\t\t\t} else if ( type === \"error\" ) {\n\n\t\t\t\t\t\t\t\t// Support: IE9\n\t\t\t\t\t\t\t\t// On a manual native abort, IE9 throws\n\t\t\t\t\t\t\t\t// errors on any property access that is not readyState\n\t\t\t\t\t\t\t\tif ( typeof xhr.status !== \"number\" ) {\n\t\t\t\t\t\t\t\t\tcomplete( 0, \"error\" );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcomplete(\n\n\t\t\t\t\t\t\t\t\t\t// File: protocol always yields status 0; see #8605, #14207\n\t\t\t\t\t\t\t\t\t\txhr.status,\n\t\t\t\t\t\t\t\t\t\txhr.statusText\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcomplete(\n\t\t\t\t\t\t\t\t\txhrSuccessStatus[ xhr.status ] || xhr.status,\n\t\t\t\t\t\t\t\t\txhr.statusText,\n\n\t\t\t\t\t\t\t\t\t// Support: IE9 only\n\t\t\t\t\t\t\t\t\t// IE9 has no XHR2 but throws on binary (trac-11426)\n\t\t\t\t\t\t\t\t\t// For XHR2 non-text, let the caller handle it (gh-2498)\n\t\t\t\t\t\t\t\t\t( xhr.responseType || \"text\" ) !== \"text\"  ||\n\t\t\t\t\t\t\t\t\ttypeof xhr.responseText !== \"string\" ?\n\t\t\t\t\t\t\t\t\t\t{ binary: xhr.response } :\n\t\t\t\t\t\t\t\t\t\t{ text: xhr.responseText },\n\t\t\t\t\t\t\t\t\txhr.getAllResponseHeaders()\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t};\n\n\t\t\t\t// Listen to events\n\t\t\t\txhr.onload = callback();\n\t\t\t\terrorCallback = xhr.onerror = callback( \"error\" );\n\n\t\t\t\t// Support: IE9\n\t\t\t\t// Use onreadystatechange to replace onabort\n\t\t\t\t// to handle uncaught aborts\n\t\t\t\tif ( xhr.onabort !== undefined ) {\n\t\t\t\t\txhr.onabort = errorCallback;\n\t\t\t\t} else {\n\t\t\t\t\txhr.onreadystatechange = function() {\n\n\t\t\t\t\t\t// Check readyState before timeout as it changes\n\t\t\t\t\t\tif ( xhr.readyState === 4 ) {\n\n\t\t\t\t\t\t\t// Allow onerror to be called first,\n\t\t\t\t\t\t\t// but that will not handle a native abort\n\t\t\t\t\t\t\t// Also, save errorCallback to a variable\n\t\t\t\t\t\t\t// as xhr.onerror cannot be accessed\n\t\t\t\t\t\t\twindow.setTimeout( function() {\n\t\t\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\t\t\terrorCallback();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// Create the abort callback\n\t\t\t\tcallback = callback( \"abort\" );\n\n\t\t\t\ttry {\n\n\t\t\t\t\t// Do send the request (this may raise an exception)\n\t\t\t\t\txhr.send( options.hasContent && options.data || null );\n\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t// #14683: Only rethrow if this hasn't been notified as an error yet\n\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n} );\n\n\n\n\n// Install script dataType\njQuery.ajaxSetup( {\n\taccepts: {\n\t\tscript: \"text/javascript, application/javascript, \" +\n\t\t\t\"application/ecmascript, application/x-ecmascript\"\n\t},\n\tcontents: {\n\t\tscript: /\\b(?:java|ecma)script\\b/\n\t},\n\tconverters: {\n\t\t\"text script\": function( text ) {\n\t\t\tjQuery.globalEval( text );\n\t\t\treturn text;\n\t\t}\n\t}\n} );\n\n// Handle cache's special case and crossDomain\njQuery.ajaxPrefilter( \"script\", function( s ) {\n\tif ( s.cache === undefined ) {\n\t\ts.cache = false;\n\t}\n\tif ( s.crossDomain ) {\n\t\ts.type = \"GET\";\n\t}\n} );\n\n// Bind script tag hack transport\njQuery.ajaxTransport( \"script\", function( s ) {\n\n\t// This transport only deals with cross domain requests\n\tif ( s.crossDomain ) {\n\t\tvar script, callback;\n\t\treturn {\n\t\t\tsend: function( _, complete ) {\n\t\t\t\tscript = jQuery( \"<script>\" ).prop( {\n\t\t\t\t\tcharset: s.scriptCharset,\n\t\t\t\t\tsrc: s.url\n\t\t\t\t} ).on(\n\t\t\t\t\t\"load error\",\n\t\t\t\t\tcallback = function( evt ) {\n\t\t\t\t\t\tscript.remove();\n\t\t\t\t\t\tcallback = null;\n\t\t\t\t\t\tif ( evt ) {\n\t\t\t\t\t\t\tcomplete( evt.type === \"error\" ? 404 : 200, evt.type );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\t// Use native DOM manipulation to avoid our domManip AJAX trickery\n\t\t\t\tdocument.head.appendChild( script[ 0 ] );\n\t\t\t},\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n} );\n\n\n\n\nvar oldCallbacks = [],\n\trjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n\n// Default jsonp settings\njQuery.ajaxSetup( {\n\tjsonp: \"callback\",\n\tjsonpCallback: function() {\n\t\tvar callback = oldCallbacks.pop() || ( jQuery.expando + \"_\" + ( nonce++ ) );\n\t\tthis[ callback ] = true;\n\t\treturn callback;\n\t}\n} );\n\n// Detect, normalize options and install callbacks for jsonp requests\njQuery.ajaxPrefilter( \"json jsonp\", function( s, originalSettings, jqXHR ) {\n\n\tvar callbackName, overwritten, responseContainer,\n\t\tjsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\n\t\t\t\"url\" :\n\t\t\ttypeof s.data === \"string\" &&\n\t\t\t\t( s.contentType || \"\" )\n\t\t\t\t\t.indexOf( \"application/x-www-form-urlencoded\" ) === 0 &&\n\t\t\t\trjsonp.test( s.data ) && \"data\"\n\t\t);\n\n\t// Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n\tif ( jsonProp || s.dataTypes[ 0 ] === \"jsonp\" ) {\n\n\t\t// Get callback name, remembering preexisting value associated with it\n\t\tcallbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?\n\t\t\ts.jsonpCallback() :\n\t\t\ts.jsonpCallback;\n\n\t\t// Insert callback into url or form data\n\t\tif ( jsonProp ) {\n\t\t\ts[ jsonProp ] = s[ jsonProp ].replace( rjsonp, \"$1\" + callbackName );\n\t\t} else if ( s.jsonp !== false ) {\n\t\t\ts.url += ( rquery.test( s.url ) ? \"&\" : \"?\" ) + s.jsonp + \"=\" + callbackName;\n\t\t}\n\n\t\t// Use data converter to retrieve json after script execution\n\t\ts.converters[ \"script json\" ] = function() {\n\t\t\tif ( !responseContainer ) {\n\t\t\t\tjQuery.error( callbackName + \" was not called\" );\n\t\t\t}\n\t\t\treturn responseContainer[ 0 ];\n\t\t};\n\n\t\t// Force json dataType\n\t\ts.dataTypes[ 0 ] = \"json\";\n\n\t\t// Install callback\n\t\toverwritten = window[ callbackName ];\n\t\twindow[ callbackName ] = function() {\n\t\t\tresponseContainer = arguments;\n\t\t};\n\n\t\t// Clean-up function (fires after converters)\n\t\tjqXHR.always( function() {\n\n\t\t\t// If previous value didn't exist - remove it\n\t\t\tif ( overwritten === undefined ) {\n\t\t\t\tjQuery( window ).removeProp( callbackName );\n\n\t\t\t// Otherwise restore preexisting value\n\t\t\t} else {\n\t\t\t\twindow[ callbackName ] = overwritten;\n\t\t\t}\n\n\t\t\t// Save back as free\n\t\t\tif ( s[ callbackName ] ) {\n\n\t\t\t\t// Make sure that re-using the options doesn't screw things around\n\t\t\t\ts.jsonpCallback = originalSettings.jsonpCallback;\n\n\t\t\t\t// Save the callback name for future use\n\t\t\t\toldCallbacks.push( callbackName );\n\t\t\t}\n\n\t\t\t// Call if it was a function and we have a response\n\t\t\tif ( responseContainer && jQuery.isFunction( overwritten ) ) {\n\t\t\t\toverwritten( responseContainer[ 0 ] );\n\t\t\t}\n\n\t\t\tresponseContainer = overwritten = undefined;\n\t\t} );\n\n\t\t// Delegate to script\n\t\treturn \"script\";\n\t}\n} );\n\n\n\n\n// Argument \"data\" should be string of html\n// context (optional): If specified, the fragment will be created in this context,\n// defaults to document\n// keepScripts (optional): If true, will include scripts passed in the html string\njQuery.parseHTML = function( data, context, keepScripts ) {\n\tif ( !data || typeof data !== \"string\" ) {\n\t\treturn null;\n\t}\n\tif ( typeof context === \"boolean\" ) {\n\t\tkeepScripts = context;\n\t\tcontext = false;\n\t}\n\tcontext = context || document;\n\n\tvar parsed = rsingleTag.exec( data ),\n\t\tscripts = !keepScripts && [];\n\n\t// Single tag\n\tif ( parsed ) {\n\t\treturn [ context.createElement( parsed[ 1 ] ) ];\n\t}\n\n\tparsed = buildFragment( [ data ], context, scripts );\n\n\tif ( scripts && scripts.length ) {\n\t\tjQuery( scripts ).remove();\n\t}\n\n\treturn jQuery.merge( [], parsed.childNodes );\n};\n\n\n// Keep a copy of the old load method\nvar _load = jQuery.fn.load;\n\n/**\n * Load a url into a page\n */\njQuery.fn.load = function( url, params, callback ) {\n\tif ( typeof url !== \"string\" && _load ) {\n\t\treturn _load.apply( this, arguments );\n\t}\n\n\tvar selector, type, response,\n\t\tself = this,\n\t\toff = url.indexOf( \" \" );\n\n\tif ( off > -1 ) {\n\t\tselector = jQuery.trim( url.slice( off ) );\n\t\turl = url.slice( 0, off );\n\t}\n\n\t// If it's a function\n\tif ( jQuery.isFunction( params ) ) {\n\n\t\t// We assume that it's the callback\n\t\tcallback = params;\n\t\tparams = undefined;\n\n\t// Otherwise, build a param string\n\t} else if ( params && typeof params === \"object\" ) {\n\t\ttype = \"POST\";\n\t}\n\n\t// If we have elements to modify, make the request\n\tif ( self.length > 0 ) {\n\t\tjQuery.ajax( {\n\t\t\turl: url,\n\n\t\t\t// If \"type\" variable is undefined, then \"GET\" method will be used.\n\t\t\t// Make value of this field explicit since\n\t\t\t// user can override it through ajaxSetup method\n\t\t\ttype: type || \"GET\",\n\t\t\tdataType: \"html\",\n\t\t\tdata: params\n\t\t} ).done( function( responseText ) {\n\n\t\t\t// Save response for use in complete callback\n\t\t\tresponse = arguments;\n\n\t\t\tself.html( selector ?\n\n\t\t\t\t// If a selector was specified, locate the right elements in a dummy div\n\t\t\t\t// Exclude scripts to avoid IE 'Permission Denied' errors\n\t\t\t\tjQuery( \"<div>\" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :\n\n\t\t\t\t// Otherwise use the full result\n\t\t\t\tresponseText );\n\n\t\t// If the request succeeds, this function gets \"data\", \"status\", \"jqXHR\"\n\t\t// but they are ignored because response was set above.\n\t\t// If it fails, this function gets \"jqXHR\", \"status\", \"error\"\n\t\t} ).always( callback && function( jqXHR, status ) {\n\t\t\tself.each( function() {\n\t\t\t\tcallback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );\n\t\t\t} );\n\t\t} );\n\t}\n\n\treturn this;\n};\n\n\n\n\n// Attach a bunch of functions for handling common AJAX events\njQuery.each( [\n\t\"ajaxStart\",\n\t\"ajaxStop\",\n\t\"ajaxComplete\",\n\t\"ajaxError\",\n\t\"ajaxSuccess\",\n\t\"ajaxSend\"\n], function( i, type ) {\n\tjQuery.fn[ type ] = function( fn ) {\n\t\treturn this.on( type, fn );\n\t};\n} );\n\n\n\n\njQuery.expr.filters.animated = function( elem ) {\n\treturn jQuery.grep( jQuery.timers, function( fn ) {\n\t\treturn elem === fn.elem;\n\t} ).length;\n};\n\n\n\n\n/**\n * Gets a window from an element\n */\nfunction getWindow( elem ) {\n\treturn jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;\n}\n\njQuery.offset = {\n\tsetOffset: function( elem, options, i ) {\n\t\tvar curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,\n\t\t\tposition = jQuery.css( elem, \"position\" ),\n\t\t\tcurElem = jQuery( elem ),\n\t\t\tprops = {};\n\n\t\t// Set position first, in-case top/left are set even on static elem\n\t\tif ( position === \"static\" ) {\n\t\t\telem.style.position = \"relative\";\n\t\t}\n\n\t\tcurOffset = curElem.offset();\n\t\tcurCSSTop = jQuery.css( elem, \"top\" );\n\t\tcurCSSLeft = jQuery.css( elem, \"left\" );\n\t\tcalculatePosition = ( position === \"absolute\" || position === \"fixed\" ) &&\n\t\t\t( curCSSTop + curCSSLeft ).indexOf( \"auto\" ) > -1;\n\n\t\t// Need to be able to calculate position if either\n\t\t// top or left is auto and position is either absolute or fixed\n\t\tif ( calculatePosition ) {\n\t\t\tcurPosition = curElem.position();\n\t\t\tcurTop = curPosition.top;\n\t\t\tcurLeft = curPosition.left;\n\n\t\t} else {\n\t\t\tcurTop = parseFloat( curCSSTop ) || 0;\n\t\t\tcurLeft = parseFloat( curCSSLeft ) || 0;\n\t\t}\n\n\t\tif ( jQuery.isFunction( options ) ) {\n\n\t\t\t// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)\n\t\t\toptions = options.call( elem, i, jQuery.extend( {}, curOffset ) );\n\t\t}\n\n\t\tif ( options.top != null ) {\n\t\t\tprops.top = ( options.top - curOffset.top ) + curTop;\n\t\t}\n\t\tif ( options.left != null ) {\n\t\t\tprops.left = ( options.left - curOffset.left ) + curLeft;\n\t\t}\n\n\t\tif ( \"using\" in options ) {\n\t\t\toptions.using.call( elem, props );\n\n\t\t} else {\n\t\t\tcurElem.css( props );\n\t\t}\n\t}\n};\n\njQuery.fn.extend( {\n\toffset: function( options ) {\n\t\tif ( arguments.length ) {\n\t\t\treturn options === undefined ?\n\t\t\t\tthis :\n\t\t\t\tthis.each( function( i ) {\n\t\t\t\t\tjQuery.offset.setOffset( this, options, i );\n\t\t\t\t} );\n\t\t}\n\n\t\tvar docElem, win,\n\t\t\telem = this[ 0 ],\n\t\t\tbox = { top: 0, left: 0 },\n\t\t\tdoc = elem && elem.ownerDocument;\n\n\t\tif ( !doc ) {\n\t\t\treturn;\n\t\t}\n\n\t\tdocElem = doc.documentElement;\n\n\t\t// Make sure it's not a disconnected DOM node\n\t\tif ( !jQuery.contains( docElem, elem ) ) {\n\t\t\treturn box;\n\t\t}\n\n\t\tbox = elem.getBoundingClientRect();\n\t\twin = getWindow( doc );\n\t\treturn {\n\t\t\ttop: box.top + win.pageYOffset - docElem.clientTop,\n\t\t\tleft: box.left + win.pageXOffset - docElem.clientLeft\n\t\t};\n\t},\n\n\tposition: function() {\n\t\tif ( !this[ 0 ] ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar offsetParent, offset,\n\t\t\telem = this[ 0 ],\n\t\t\tparentOffset = { top: 0, left: 0 };\n\n\t\t// Fixed elements are offset from window (parentOffset = {top:0, left: 0},\n\t\t// because it is its only offset parent\n\t\tif ( jQuery.css( elem, \"position\" ) === \"fixed\" ) {\n\n\t\t\t// Assume getBoundingClientRect is there when computed position is fixed\n\t\t\toffset = elem.getBoundingClientRect();\n\n\t\t} else {\n\n\t\t\t// Get *real* offsetParent\n\t\t\toffsetParent = this.offsetParent();\n\n\t\t\t// Get correct offsets\n\t\t\toffset = this.offset();\n\t\t\tif ( !jQuery.nodeName( offsetParent[ 0 ], \"html\" ) ) {\n\t\t\t\tparentOffset = offsetParent.offset();\n\t\t\t}\n\n\t\t\t// Add offsetParent borders\n\t\t\tparentOffset.top += jQuery.css( offsetParent[ 0 ], \"borderTopWidth\", true );\n\t\t\tparentOffset.left += jQuery.css( offsetParent[ 0 ], \"borderLeftWidth\", true );\n\t\t}\n\n\t\t// Subtract parent offsets and element margins\n\t\treturn {\n\t\t\ttop: offset.top - parentOffset.top - jQuery.css( elem, \"marginTop\", true ),\n\t\t\tleft: offset.left - parentOffset.left - jQuery.css( elem, \"marginLeft\", true )\n\t\t};\n\t},\n\n\t// This method will return documentElement in the following cases:\n\t// 1) For the element inside the iframe without offsetParent, this method will return\n\t//    documentElement of the parent window\n\t// 2) For the hidden or detached element\n\t// 3) For body or html element, i.e. in case of the html node - it will return itself\n\t//\n\t// but those exceptions were never presented as a real life use-cases\n\t// and might be considered as more preferable results.\n\t//\n\t// This logic, however, is not guaranteed and can change at any point in the future\n\toffsetParent: function() {\n\t\treturn this.map( function() {\n\t\t\tvar offsetParent = this.offsetParent;\n\n\t\t\twhile ( offsetParent && jQuery.css( offsetParent, \"position\" ) === \"static\" ) {\n\t\t\t\toffsetParent = offsetParent.offsetParent;\n\t\t\t}\n\n\t\t\treturn offsetParent || documentElement;\n\t\t} );\n\t}\n} );\n\n// Create scrollLeft and scrollTop methods\njQuery.each( { scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\" }, function( method, prop ) {\n\tvar top = \"pageYOffset\" === prop;\n\n\tjQuery.fn[ method ] = function( val ) {\n\t\treturn access( this, function( elem, method, val ) {\n\t\t\tvar win = getWindow( elem );\n\n\t\t\tif ( val === undefined ) {\n\t\t\t\treturn win ? win[ prop ] : elem[ method ];\n\t\t\t}\n\n\t\t\tif ( win ) {\n\t\t\t\twin.scrollTo(\n\t\t\t\t\t!top ? val : win.pageXOffset,\n\t\t\t\t\ttop ? val : win.pageYOffset\n\t\t\t\t);\n\n\t\t\t} else {\n\t\t\t\telem[ method ] = val;\n\t\t\t}\n\t\t}, method, val, arguments.length );\n\t};\n} );\n\n// Support: Safari<7-8+, Chrome<37-44+\n// Add the top/left cssHooks using jQuery.fn.position\n// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n// Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280\n// getComputedStyle returns percent when specified for top/left/bottom/right;\n// rather than make the css module depend on the offset module, just check for it here\njQuery.each( [ \"top\", \"left\" ], function( i, prop ) {\n\tjQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,\n\t\tfunction( elem, computed ) {\n\t\t\tif ( computed ) {\n\t\t\t\tcomputed = curCSS( elem, prop );\n\n\t\t\t\t// If curCSS returns percentage, fallback to offset\n\t\t\t\treturn rnumnonpx.test( computed ) ?\n\t\t\t\t\tjQuery( elem ).position()[ prop ] + \"px\" :\n\t\t\t\t\tcomputed;\n\t\t\t}\n\t\t}\n\t);\n} );\n\n\n// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\njQuery.each( { Height: \"height\", Width: \"width\" }, function( name, type ) {\n\tjQuery.each( { padding: \"inner\" + name, content: type, \"\": \"outer\" + name },\n\t\tfunction( defaultExtra, funcName ) {\n\n\t\t// Margin is only for outerHeight, outerWidth\n\t\tjQuery.fn[ funcName ] = function( margin, value ) {\n\t\t\tvar chainable = arguments.length && ( defaultExtra || typeof margin !== \"boolean\" ),\n\t\t\t\textra = defaultExtra || ( margin === true || value === true ? \"margin\" : \"border\" );\n\n\t\t\treturn access( this, function( elem, type, value ) {\n\t\t\t\tvar doc;\n\n\t\t\t\tif ( jQuery.isWindow( elem ) ) {\n\n\t\t\t\t\t// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there\n\t\t\t\t\t// isn't a whole lot we can do. See pull request at this URL for discussion:\n\t\t\t\t\t// https://github.com/jquery/jquery/pull/764\n\t\t\t\t\treturn elem.document.documentElement[ \"client\" + name ];\n\t\t\t\t}\n\n\t\t\t\t// Get document width or height\n\t\t\t\tif ( elem.nodeType === 9 ) {\n\t\t\t\t\tdoc = elem.documentElement;\n\n\t\t\t\t\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\n\t\t\t\t\t// whichever is greatest\n\t\t\t\t\treturn Math.max(\n\t\t\t\t\t\telem.body[ \"scroll\" + name ], doc[ \"scroll\" + name ],\n\t\t\t\t\t\telem.body[ \"offset\" + name ], doc[ \"offset\" + name ],\n\t\t\t\t\t\tdoc[ \"client\" + name ]\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn value === undefined ?\n\n\t\t\t\t\t// Get width or height on the element, requesting but not forcing parseFloat\n\t\t\t\t\tjQuery.css( elem, type, extra ) :\n\n\t\t\t\t\t// Set width or height on the element\n\t\t\t\t\tjQuery.style( elem, type, value, extra );\n\t\t\t}, type, chainable ? margin : undefined, chainable, null );\n\t\t};\n\t} );\n} );\n\n\njQuery.fn.extend( {\n\n\tbind: function( types, data, fn ) {\n\t\treturn this.on( types, null, data, fn );\n\t},\n\tunbind: function( types, fn ) {\n\t\treturn this.off( types, null, fn );\n\t},\n\n\tdelegate: function( selector, types, data, fn ) {\n\t\treturn this.on( types, selector, data, fn );\n\t},\n\tundelegate: function( selector, types, fn ) {\n\n\t\t// ( namespace ) or ( selector, types [, fn] )\n\t\treturn arguments.length === 1 ?\n\t\t\tthis.off( selector, \"**\" ) :\n\t\t\tthis.off( types, selector || \"**\", fn );\n\t},\n\tsize: function() {\n\t\treturn this.length;\n\t}\n} );\n\njQuery.fn.andSelf = jQuery.fn.addBack;\n\n\n\n\n// Register as a named AMD module, since jQuery can be concatenated with other\n// files that may use define, but not via a proper concatenation script that\n// understands anonymous AMD modules. A named AMD is safest and most robust\n// way to register. Lowercase jquery is used because AMD module names are\n// derived from file names, and jQuery is normally delivered in a lowercase\n// file name. Do this after creating the global so that if an AMD module wants\n// to call noConflict to hide this version of jQuery, it will work.\n\n// Note that for maximum portability, libraries that are not jQuery should\n// declare themselves as anonymous modules, and avoid setting a global if an\n// AMD loader is present. jQuery is a special case. For more information, see\n// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\n\nif ( true ) {\n\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n\t\treturn jQuery;\n\t}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n}\n\n\n\nvar\n\n\t// Map over jQuery in case of overwrite\n\t_jQuery = window.jQuery,\n\n\t// Map over the $ in case of overwrite\n\t_$ = window.$;\n\njQuery.noConflict = function( deep ) {\n\tif ( window.$ === jQuery ) {\n\t\twindow.$ = _$;\n\t}\n\n\tif ( deep && window.jQuery === jQuery ) {\n\t\twindow.jQuery = _jQuery;\n\t}\n\n\treturn jQuery;\n};\n\n// Expose jQuery and $ identifiers, even in AMD\n// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\n// and CommonJS for browser emulators (#13566)\nif ( !noGlobal ) {\n\twindow.jQuery = window.$ = jQuery;\n}\n\nreturn jQuery;\n}));\n\n\n//# sourceURL=webpack://parus/./node_modules/jquery/dist/jquery.js?");

/***/ }),

/***/ "./src/common.blocks/calendar/calendar.js":
/*!************************************************!*\
  !*** ./src/common.blocks/calendar/calendar.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _js_plugins_pickmeup__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../js/plugins/pickmeup */ \"./src/js/plugins/pickmeup.js\");\n/* harmony import */ var _js_plugins_pickmeup__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_js_plugins_pickmeup__WEBPACK_IMPORTED_MODULE_1__);\n\n\n\nconst CSS_CALENDAR = 'calendar';\nconst elCalendar = document.querySelector('.' + CSS_CALENDAR);\n\nfunction calendarInit () {\n    const localeObject = {\n        days: ['Воскресенье', 'Понедельник', 'Вторник', 'Среда', 'Четверг', 'Пятница', 'Суббота', 'Воскресенье'],\n        daysShort: ['Вс', 'Пн', 'Вт', 'Ср', 'Чт', 'Пт', 'Сб', 'Вс'],\n        daysMin: ['Вс', 'Пн', 'Вт', 'Ср', 'Чт', 'Пт', 'Сб', 'Вс'],\n        months: ['Январь', 'Февраль', 'Март', 'Апрель', 'Май', 'Июнь', 'Июль', 'Август', 'Сентябрь', 'Октябрь', 'Ноябрь', 'Декабрь'],\n        monthsShort: ['Янв', 'Фев', 'Мар', 'Апр', 'Май', 'Июн', 'Июл', 'Авг', 'Сен', 'Окт', 'Ноя', 'Дек']\n    };\n\n    var date = new Date();\n    date = new Date(date.setDate(date.getDate() + 1));\n    const $date = jquery__WEBPACK_IMPORTED_MODULE_0___default()('.gesh-date');\n\n    $date.find('.gesh-date-cal').pickmeup({\n        locale: localeObject,\n        format: 'd.m.Y',\n        mode: 'range',\n        flat: 'true',\n        calendars: 2,\n        hide_on_select: true,\n        date: [jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-data-start').val(), jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-data-end').val()],\n        min: date,\n        render: function (date) {\n            setTimeout(function () {\n                if (jquery__WEBPACK_IMPORTED_MODULE_0___default()('.pmu-days .pmu-selected').length > 1) {\n                    jquery__WEBPACK_IMPORTED_MODULE_0___default()('.pmu-days .pmu-selected:not(.pmu-not-in-month)').eq(0).addClass('first-child');\n                    jquery__WEBPACK_IMPORTED_MODULE_0___default()('.pmu-days .pmu-selected:not(.pmu-not-in-month)').eq(-1).addClass('last-child');\n                }\n            }, 10);\n\n            var r = {};\n            /**\n             * Объявлявляется в шапке\n             */\n\n            if ((typeof eventDates) !== 'undefined') {\n                jquery__WEBPACK_IMPORTED_MODULE_0___default().each(eventDates, function (i, el) {\n                    var tempDate = Date.parse(el),\n                        currDate = Date.parse(date);\n                    if (currDate == tempDate) {\n                        r.disabled = false;\n                        r.class_name = 'haveAction';\n                    }\n                });\n            }\n\n            if ((typeof weekendsArray) !== 'undefined') {\n                jquery__WEBPACK_IMPORTED_MODULE_0___default().each(weekendsArray, function (i, el) {\n                    var tempDate = Date.parse(el),\n                        currDate = Date.parse(date);\n                    if (currDate == tempDate) {\n                        r.disabled = false;\n                        r.class_name = 'isWeekend';\n                    }\n                });\n            }\n            return r;\n        },\n\n        change: function (formatted_date, date) {\n            var oldIn = $date.find('.gesh-date-cal').data('old-in') || false,\n                oldOut = $date.find('.gesh-date-cal').data('old-out') || false;\n\n            if (formatted_date[0]) {\n                jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-data-start').val(formatted_date[0]);\n                if (formatted_date[0] == formatted_date[1] && jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-data-end').val()) {\n                    var tempDate = new Date(date[0]),\n                        dateObj = {};\n\n                    tempDate = new Date(tempDate.setDate(tempDate.getDate() + 1));\n                    dateObj.day = tempDate.getDate();\n\n                    if (dateObj.day <= 9) {\n                        dateObj.day = '0' + dateObj.day;\n                    }\n\n                    dateObj.month = (tempDate.getMonth()) + 1;\n                    dateObj.year = tempDate.getFullYear();\n\n                    if (dateObj.month < 9) {\n                        dateObj.month = '0' + dateObj.month;\n                    }\n\n                    jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-data-end').val(dateObj.day + '.' + dateObj.month + '.' + dateObj.year);\n                }\n\n                $date.find('.gesh-date-cal').data('old-in', formatted_date[0]);\n                $date.find('.gesh-date-cal').data('old-out', formatted_date[1]);\n            }\n\n            setTimeout(function () {\n                if (jquery__WEBPACK_IMPORTED_MODULE_0___default()('.pmu-days .pmu-selected').length > 1) {\n                    jquery__WEBPACK_IMPORTED_MODULE_0___default()('.pmu-days .pmu-selected:not(.pmu-not-in-month)').eq(0).addClass('first-child');\n                    if (jquery__WEBPACK_IMPORTED_MODULE_0___default()('.pmu-days .pmu-selected:not(.pmu-not-in-month)').eq(-1).hasClass('first-child')) {\n                        return false;\n                    } else {\n                        jquery__WEBPACK_IMPORTED_MODULE_0___default()('.pmu-days .pmu-selected:not(.pmu-not-in-month)').eq(-1).addClass('last-child');\n                        jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-data-start').val(formatted_date[0]);\n                        jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-data-end').val(formatted_date[1]);\n                        if (jquery__WEBPACK_IMPORTED_MODULE_0___default()('.pmu-days .pmu-selected.last-child').length && jquery__WEBPACK_IMPORTED_MODULE_0___default()('.pmu-days .pmu-selected.first-child').length && !(jquery__WEBPACK_IMPORTED_MODULE_0___default()('.pmu-days .pmu-selected.first-child').hasClass('last-child'))) {\n                            setTimeout(function () {\n                                $date.fadeOut(280);\n                            }, 100);\n                        }\n                    }\n\n                }\n\n                if (jquery__WEBPACK_IMPORTED_MODULE_0___default()('.pmu-selected.pmu-button.first-child').length >= 1 && jquery__WEBPACK_IMPORTED_MODULE_0___default()('.pmu-selected.pmu-button.last-child').length >= 1) {\n                    document.body.style.removeProperty('padding-right');\n                    document.body.style.removeProperty('overflow');\n                }\n\n            }, 10);\n        }\n    }).end().on('mouseleave', function () {\n        // $date.fadeOut(280);\n        // $('.form-group.date').removeClass('active');\n        // $('.js-data-start, .js-data-end').trigger('blur');\n    });\n\n    jquery__WEBPACK_IMPORTED_MODULE_0___default()(document).on('click', function (e) {\n        if (jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).closest('.js-gesh,.js-data-start, .js-data-end').length === 0 && $date.is(':visible')) {\n            $date.fadeOut(260);\n            jquery__WEBPACK_IMPORTED_MODULE_0___default()('.form-group.date').removeClass('active');\n            jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-data-start, .js-data-end').trigger('blur');\n        }\n    });\n\n    jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-data-start, .js-data-end').on('click', function () {\n        $date.fadeIn(280);\n        jquery__WEBPACK_IMPORTED_MODULE_0___default()('.form-group.date').addClass('active');\n        if (window.matchMedia('(max-width: 1023px)').matches) {\n            document.body.style.setProperty('padding-right', window.innerWidth - document.documentElement.clientWidth + 'px');\n            document.body.style.setProperty('overflow', 'hidden');\n        }\n    }).on('blur', function () {\n        $date.fadeOut(260);\n        jquery__WEBPACK_IMPORTED_MODULE_0___default()('.form-group.date').removeClass('active');\n\n        document.body.style.removeProperty('padding-right');\n        document.body.style.removeProperty('overflow');\n    });\n    jquery__WEBPACK_IMPORTED_MODULE_0___default()('.control__close').on('click', function () {\n        $date.fadeOut(260);\n        jquery__WEBPACK_IMPORTED_MODULE_0___default()('.form-group.date').removeClass('active');\n\n        document.body.style.removeProperty('padding-right');\n        document.body.style.removeProperty('overflow');\n    });\n}\n\nif (elCalendar) {\n    calendarInit();\n}\n\n\n\n//# sourceURL=webpack://parus/./src/common.blocks/calendar/calendar.js?");

/***/ }),

/***/ "./src/js/pages/calendar.js":
/*!**********************************!*\
  !*** ./src/js/pages/calendar.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _common_blocks_calendar_calendar__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../common.blocks/calendar/calendar */ \"./src/common.blocks/calendar/calendar.js\");\n\n\n//# sourceURL=webpack://parus/./src/js/pages/calendar.js?");

/***/ }),

/***/ "./src/js/plugins/pickmeup.js":
/*!************************************!*\
  !*** ./src/js/plugins/pickmeup.js ***!
  \************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n(function (d) {\n    function getMaxDays() {\n        var tmpDate = new Date(this.toString()),\n            d = 28,\n            m = tmpDate.getMonth();\n        while (tmpDate.getMonth() == m) {\n            ++d;\n            tmpDate.setDate(d);\n        }\n        return d - 1;\n    }\n\n    d.addDays = function (n) {\n        this.setDate(this.getDate() + n);\n    };\n    d.addMonths = function (n) {\n        var day = this.getDate();\n        this.setDate(1);\n        this.setMonth(this.getMonth() + n);\n        this.setDate(Math.min(day, getMaxDays.apply(this)));\n    };\n    d.addYears = function (n) {\n        var day = this.getDate();\n        this.setDate(1);\n        this.setFullYear(this.getFullYear() + n);\n        this.setDate(Math.min(day, getMaxDays.apply(this)));\n    };\n    d.getDayOfYear = function () {\n        var now = new Date(this.getFullYear(), this.getMonth(), this.getDate(), 0, 0, 0);\n        var then = new Date(this.getFullYear(), 0, 0, 0, 0, 0);\n        var time = now - then;\n        return Math.floor(time / 24 * 60 * 60 * 1000);\n    };\n})(Date.prototype);\n\n(function (factory) {\n    if (true) {\n        // AMD\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n}(function ($) {\n    var instances_count = 0;\n    $.pickmeup = $.extend($.pickmeup || {}, {\n        current: null,\n        date: new Date,\n        default_date: new Date,\n        flat: false,\n        first_day: 1,\n        prev: '<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns:a=\"http://ns.adobe.com/AdobeSVGViewerExtensions/3.0/\" x=\"0px\" y=\"0px\" width=\"11px\" height=\"14px\" viewBox=\"0 0 11 14\" style=\"enable-background:new 0 0 11 14;\" xml:space=\"preserve\"> <defs></defs><path d=\"M11,14V0L0,7L11,14z\"/></svg>',\n        next: '<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns:a=\"http://ns.adobe.com/AdobeSVGViewerExtensions/3.0/\" x=\"0px\" y=\"0px\" width=\"11px\" height=\"14px\" viewBox=\"0 0 11 14\" style=\"enable-background:new 0 0 11 14;\" xml:space=\"preserve\"> <path d=\"M0,0v14l11-7L0,0z\"/></svg>',\n        mode: 'single',\n        select_year: true,\n        select_month: true,\n        select_day: true,\n        view: 'days',\n        calendars: 1,\n        format: 'd-m-Y',\n        title_format: 'B, Y',\n        position: 'bottom',\n        trigger_event: 'click touchstart',\n        class_name: '',\n        separator: ' - ',\n        hide_on_select: false,\n        min: null,\n        max: null,\n        render: function () {\n        },\n        change: function () {\n            return true;\n        },\n        before_show: function () {\n            return true;\n        },\n        show: function () {\n            return true;\n        },\n        hide: function () {\n            return true;\n        },\n        fill: function () {\n            return true;\n        },\n        locale: {\n            days: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'],\n            daysShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'],\n            daysMin: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa', 'Su'],\n            months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],\n            monthsShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']\n        }\n    });\n    var views = {\n            years: 'pmu-view-years',\n            months: 'pmu-view-months',\n            days: 'pmu-view-days'\n        },\n        tpl = {\n            wrapper: '<div class=\"pickmeup\" />',\n            head: function (d) {\n                var result = '';\n                for (var i = 0; i < 7; ++i) {\n                    result += '<div>' + d.day[i] + '</div>'\n                }\n                return '<div class=\"pmu-instance\">' +\n                    '<nav>' +\n                    '<div class=\"pmu-prev pmu-button\">' + d.prev + '</div>' +\n                    '<div class=\"pmu-month pmu-button\" />' +\n                    '<div class=\"pmu-next pmu-button\">' + d.next + '</div>' +\n                    '</nav>' +\n                    '<nav class=\"pmu-day-of-week\">' + result + '</nav>' +\n                    '</div>';\n            },\n            body: function (elements, container_class_name) {\n                var result = '';\n                for (var i = 0; i < elements.length; ++i) {\n                    result += '<div class=\"' + elements[i].class_name + ' pmu-button\">' + elements[i].text + '</div>'\n                }\n                return '<div class=\"' + container_class_name + '\">' + result + '</div>';\n            }\n        };\n\n    function namespaced_events(events, namespace) {\n        events = events.split(' ');\n        for (var i = 0; i < events.length; ++i) {\n            events[i] += namespace;\n        }\n        return events.join(' ');\n    }\n\n    function fill() {\n        var options = $(this).data('pickmeup-options'),\n            pickmeup = this.pickmeup,\n            current_cal = Math.floor(options.calendars / 2),\n            actual_date = options.date,\n            current_date = options.current,\n            min_date = options.min ? new Date(options.min) : null,\n            max_date = options.max ? new Date(options.max) : null,\n            local_date,\n            header,\n            html,\n            instance,\n            shown_date_from,\n            shown_date_to,\n            tmp_date;\n        if (min_date) {\n            min_date.setDate(1);\n            min_date.addMonths(1);\n            min_date.addDays(-1);\n        }\n        if (max_date) {\n            max_date.setDate(1);\n            max_date.addMonths(1);\n            max_date.addDays(-1);\n        }\n        /**\n         * Remove old content except header navigation\n         */\n        pickmeup.find('.pmu-instance > :not(nav)').remove();\n        /**\n         * If several calendars should be shown\n         */\n        for (var i = 0; i < options.calendars; i++) {\n            local_date = new Date(current_date);\n            reset_time(local_date);\n            instance = pickmeup.find('.pmu-instance').eq(i);\n            if (pickmeup.hasClass('pmu-view-years')) {\n                local_date.addYears((i - current_cal) * 12);\n                header = (local_date.getFullYear() - 6) + ' - ' + (local_date.getFullYear() + 5);\n            } else if (pickmeup.hasClass('pmu-view-months')) {\n                local_date.addYears(i - current_cal);\n                header = local_date.getFullYear();\n            } else if (pickmeup.hasClass('pmu-view-days')) {\n                local_date.addMonths(i - current_cal);\n                header = formatDate(local_date, options.title_format, options.locale);\n            }\n            if (!shown_date_to) {\n                if (max_date) {\n                    // If all dates in this month (months in year or years in years block) are after max option - set next month as current\n                    // in order not to show calendar with all disabled dates\n                    tmp_date = new Date(local_date);\n                    if (options.select_day) {\n                        tmp_date.addMonths(options.calendars - 1);\n                    } else if (options.select_month) {\n                        tmp_date.addYears(options.calendars - 1);\n                    } else {\n                        tmp_date.addYears((options.calendars - 1) * 12);\n                    }\n                    if (tmp_date > max_date) {\n                        --i;\n                        current_date.addMonths(-1);\n                        shown_date_to = undefined;\n                        continue;\n                    }\n                }\n            }\n            shown_date_to = new Date(local_date);\n            if (!shown_date_from) {\n                shown_date_from = new Date(local_date);\n                // If all dates in this month are before min option - set next month as current in order not to show calendar with all disabled dates\n                shown_date_from.setDate(1);\n                shown_date_from.addMonths(1);\n                shown_date_from.addDays(-1);\n                if (min_date && min_date > shown_date_from) {\n                    --i;\n                    current_date.addMonths(1);\n                    shown_date_from = undefined;\n                    continue;\n                }\n            }\n            instance\n                .find('.pmu-month')\n                .text(header);\n            html = '';\n            var is_year_selected = function (year) {\n                return (\n                        options.mode == 'range' &&\n                        year >= new Date(actual_date[0]).getFullYear() &&\n                        year <= new Date(actual_date[1]).getFullYear()\n                    ) ||\n                    (\n                        options.mode == 'multiple' &&\n                        actual_date.reduce(function (prev, current) {\n                            prev.push(new Date(current).getFullYear());\n                            return prev;\n                        }, []).indexOf(year) !== -1\n                    ) ||\n                    new Date(actual_date).getFullYear() == year;\n            };\n            var is_months_selected = function (year, month) {\n                var first_year = new Date(actual_date[0]).getFullYear(),\n                    lastyear = new Date(actual_date[1]).getFullYear(),\n                    first_month = new Date(actual_date[0]).getMonth(),\n                    last_month = new Date(actual_date[1]).getMonth();\n                return (\n                        options.mode == 'range' &&\n                        year > first_year &&\n                        year < lastyear\n                    ) ||\n                    (\n                        options.mode == 'range' &&\n                        year == first_year &&\n                        year < lastyear &&\n                        month >= first_month\n                    ) ||\n                    (\n                        options.mode == 'range' &&\n                        year > first_year &&\n                        year == lastyear &&\n                        month <= last_month\n                    ) ||\n                    (\n                        options.mode == 'range' &&\n                        year == first_year &&\n                        year == lastyear &&\n                        month >= first_month &&\n                        month <= last_month\n                    ) ||\n                    (\n                        options.mode == 'multiple' &&\n                        actual_date.reduce(function (prev, current) {\n                            current = new Date(current);\n                            prev.push(current.getFullYear() + '-' + current.getMonth());\n                            return prev;\n                        }, []).indexOf(year + '-' + month) !== -1\n                    ) ||\n                    (\n                        new Date(actual_date).getFullYear() == year &&\n                        new Date(actual_date).getMonth() == month\n                    )\n            };\n            (function () {\n                var years = [],\n                    start_from_year = local_date.getFullYear() - 6,\n                    min_year = new Date(options.min).getFullYear(),\n                    max_year = new Date(options.max).getFullYear(),\n                    year;\n                for (var j = 0; j < 12; ++j) {\n                    year = {\n                        text: start_from_year + j,\n                        class_name: []\n                    };\n                    if (\n                        (\n                            options.min && year.text < min_year\n                        ) ||\n                        (\n                            options.max && year.text > max_year\n                        )\n                    ) {\n                        year.class_name.push('pmu-disabled');\n                    } else if (is_year_selected(year.text)) {\n                        year.class_name.push('pmu-selected');\n                    }\n                    year.class_name = year.class_name.join(' ');\n                    years.push(year);\n                }\n                html += tpl.body(years, 'pmu-years');\n            })();\n            (function () {\n                var months = [],\n                    current_year = local_date.getFullYear(),\n                    min_year = new Date(options.min).getFullYear(),\n                    min_month = new Date(options.min).getMonth(),\n                    max_year = new Date(options.max).getFullYear(),\n                    max_month = new Date(options.max).getMonth(),\n                    month,\n                    j;\n                for (j = 0; j < 12; ++j) {\n                    month = {\n                        text: options.locale.monthsShort[j],\n                        class_name: []\n                    };\n                    if (\n                        (\n                            options.min &&\n                            (\n                                current_year < min_year ||\n                                (\n                                    j < min_month && current_year == min_year\n                                )\n                            )\n                        ) ||\n                        (\n                            options.max &&\n                            (\n                                current_year > max_year ||\n                                (\n                                    j > max_month && current_year >= max_year\n                                )\n                            )\n                        )\n                    ) {\n                        month.class_name.push('pmu-disabled');\n                    } else if (is_months_selected(current_year, j)) {\n                        month.class_name.push('pmu-selected');\n                    }\n                    month.class_name = month.class_name.join(' ');\n                    months.push(month);\n                }\n                html += tpl.body(months, 'pmu-months');\n            })();\n            (function () {\n                var days = [],\n                    current_month = local_date.getMonth(),\n                    today = reset_time(new Date).valueOf(),\n                    day,\n                    j,\n                    from_user,\n                    val,\n                    disabled;\n                // Correct first day in calendar taking into account first day of week (Sunday or Monday)\n                (function () {\n                    local_date.setDate(1);\n                    var day = (local_date.getDay() - options.first_day) % 7;\n                    local_date.addDays(-(day + (day < 0 ? 7 : 0)));\n                })();\n                for (j = 0; j < 42; ++j) {\n                    day = {\n                        text: local_date.getDate(),\n                        class_name: []\n                    };\n                    if (current_month != local_date.getMonth()) {\n                        day.class_name.push('pmu-not-in-month');\n                    }\n                    if (local_date.getDay() == 0) {\n                        day.class_name.push('pmu-sunday');\n                    } else if (local_date.getDay() == 6) {\n                        day.class_name.push('pmu-saturday');\n                    }\n                    from_user = options.render(new Date(local_date)) || {};\n                    val = local_date.valueOf();\n                    disabled = (options.min && options.min > local_date) || (options.max && options.max < local_date);\n                    if (from_user.disabled || disabled) {\n                        day.class_name.push('pmu-disabled');\n                    } else if (\n                        from_user.selected ||\n                        options.date.valueOf() == val ||\n                        (\n                            options.date instanceof Array &&\n                            options.date.reduce(function (prev, date) {\n                                return prev || val === date.valueOf();\n                            }, false)\n                        ) ||\n                        (\n                            options.mode == 'range' && val >= options.date[0] && val <= options.date[1]\n                        )\n                    ) {\n                        day.class_name.push('pmu-selected');\n                    }\n                    if (val == today) {\n                        day.class_name.push('pmu-today');\n                    }\n                    if (from_user.class_name) {\n                        day.class_name.push(from_user.class_name);\n                    }\n                    day.class_name = day.class_name.join(' ');\n                    days.push(day);\n                    // Move to next day\n                    local_date.addDays(1);\n                }\n                html += tpl.body(days, 'pmu-days');\n            })();\n            instance.append(html);\n        }\n        shown_date_from.setDate(1);\n        shown_date_to.setDate(1);\n        shown_date_to.addMonths(1);\n        shown_date_to.addDays(-1);\n        pickmeup.find('.pmu-prev').css(\n            'visibility',\n            options.min && options.min >= shown_date_from ? 'hidden' : 'visible'\n        );\n        pickmeup.find('.pmu-next').css(\n            'visibility',\n            options.max && options.max <= shown_date_to ? 'hidden' : 'visible'\n        );\n        options.fill.apply(this);\n    }\n\n    function parseDate(date, format, separator, locale) {\n        var i;\n        if (date instanceof Date || date instanceof Number) {\n            return reset_time(new Date(date));\n        } else if (!date) {\n            return reset_time(new Date);\n        } else if (date instanceof Array) {\n            date = date.slice();\n            for (i = 0; i < date.length; ++i) {\n                date[i] = parseDate(date[i], format, separator, locale);\n            }\n            return date;\n        }\n        var splitted_date = date.split(separator);\n        if (splitted_date.length > 1) {\n            splitted_date.forEach(function (element, index, array) {\n                array[index] = parseDate($.trim(element), format, separator, locale);\n            });\n            return splitted_date;\n        }\n        var months_text = locale.monthsShort.join(')(') + ')(' + locale.months.join(')(');\n        separator = new RegExp('[^0-9a-zA-Z(' + months_text + ')]+');\n        var parts = date.split(separator),\n            against = format.split(separator),\n            d,\n            m,\n            y,\n            h,\n            min,\n            now = new Date();\n        for (i = 0; i < parts.length; i++) {\n            switch (against[i]) {\n                case 'b':\n                    m = locale.monthsShort.indexOf(parts[i]);\n                    break;\n                case 'B':\n                    m = locale.months.indexOf(parts[i]);\n                    break;\n                case 'd':\n                case 'e':\n                    d = parseInt(parts[i], 10);\n                    break;\n                case 'm':\n                    m = parseInt(parts[i], 10) - 1;\n                    break;\n                case 'Y':\n                case 'y':\n                    y = parseInt(parts[i], 10);\n                    y += y > 100 ? 0 : (y < 29 ? 2000 : 1900);\n                    break;\n                case 'H':\n                case 'I':\n                case 'k':\n                case 'l':\n                    h = parseInt(parts[i], 10);\n                    break;\n                case 'P':\n                case 'p':\n                    if (/pm/i.test(parts[i]) && h < 12) {\n                        h += 12;\n                    } else if (/am/i.test(parts[i]) && h >= 12) {\n                        h -= 12;\n                    }\n                    break;\n                case 'M':\n                    min = parseInt(parts[i], 10);\n                    break;\n            }\n        }\n        var parsed_date = new Date(\n            y === undefined ? now.getFullYear() : y,\n            m === undefined ? now.getMonth() : m,\n            d === undefined ? now.getDate() : d,\n            h === undefined ? now.getHours() : h,\n            min === undefined ? now.getMinutes() : min,\n            0\n        );\n        if (isNaN(parsed_date * 1)) {\n            parsed_date = new Date;\n        }\n        return reset_time(parsed_date);\n    }\n\n    function reset_time(date) {\n        date.setHours(0, 0, 0, 0);\n        return date;\n    }\n\n    function formatDate(date, format, locale) {\n        var m = date.getMonth();\n        var d = date.getDate();\n        var y = date.getFullYear();\n        var w = date.getDay();\n        var s = {};\n        var hr = date.getHours();\n        var pm = (hr >= 12);\n        var ir = (pm) ? (hr - 12) : hr;\n        var dy = date.getDayOfYear();\n        if (ir == 0) {\n            ir = 12;\n        }\n        var min = date.getMinutes();\n        var sec = date.getSeconds();\n        var parts = format.split(''), part;\n        for (var i = 0; i < parts.length; i++) {\n            part = parts[i];\n            switch (part) {\n                case 'a':\n                    part = locale.daysShort[w];\n                    break;\n                case 'A':\n                    part = locale.days[w];\n                    break;\n                case 'b':\n                    part = locale.monthsShort[m];\n                    break;\n                case 'B':\n                    part = locale.months[m];\n                    break;\n                case 'C':\n                    part = 1 + Math.floor(y / 100);\n                    break;\n                case 'd':\n                    part = (d < 10) ? (\"0\" + d) : d;\n                    break;\n                case 'e':\n                    part = d;\n                    break;\n                case 'H':\n                    part = (hr < 10) ? (\"0\" + hr) : hr;\n                    break;\n                case 'I':\n                    part = (ir < 10) ? (\"0\" + ir) : ir;\n                    break;\n                case 'j':\n                    part = (dy < 100) ? ((dy < 10) ? (\"00\" + dy) : (\"0\" + dy)) : dy;\n                    break;\n                case 'k':\n                    part = hr;\n                    break;\n                case 'l':\n                    part = ir;\n                    break;\n                case 'm':\n                    part = (m < 9) ? (\"0\" + (1 + m)) : (1 + m);\n                    break;\n                case 'M':\n                    part = (min < 10) ? (\"0\" + min) : min;\n                    break;\n                case 'p':\n                case 'P':\n                    part = pm ? \"PM\" : \"AM\";\n                    break;\n                case 's':\n                    part = Math.floor(date.getTime() / 1000);\n                    break;\n                case 'S':\n                    part = (sec < 10) ? (\"0\" + sec) : sec;\n                    break;\n                case 'u':\n                    part = w + 1;\n                    break;\n                case 'w':\n                    part = w;\n                    break;\n                case 'y':\n                    part = ('' + y).substr(2, 2);\n                    break;\n                case 'Y':\n                    part = y;\n                    break;\n            }\n            parts[i] = part;\n        }\n        return parts.join('');\n    }\n\n    function update_date(new_date) {\n        var $this = $(this),\n            options = $this.data('pickmeup-options'),\n            i;\n        reset_time(new_date);\n        (function () {\n            var new_value;\n            switch (options.mode) {\n                case 'multiple':\n                    new_value = new_date.valueOf();\n                    for (i = 0; i < options.date.length; ++i) {\n                        if (options.date[i].valueOf() === new_value) {\n                            options.date.splice(i, 1);\n                            return;\n                        }\n                    }\n                    options.date.push(new_date);\n                    break;\n                case 'range':\n                    if (!options.lastSel) {\n                        options.date[0] = new_date;\n                    }\n                    if (new_date <= options.date[0]) {\n                        options.date[1] = options.date[0];\n                        options.date[0] = new_date;\n                    } else {\n                        options.date[1] = new_date;\n                    }\n                    options.lastSel = !options.lastSel;\n                    break;\n                default:\n                    options.date = new_date.valueOf();\n                    break;\n            }\n        })();\n        var prepared_date = prepareDate(options);\n        if ($this.is('input')) {\n            $this.val(options.mode == 'single' ? prepared_date[0] : prepared_date[0].join(options.separator));\n        }\n        options.change.apply(this, prepared_date);\n        if (\n            !options.flat &&\n            options.hide_on_select &&\n            (\n                options.mode != 'range' || !options.lastSel\n            )\n        ) {\n            options.binded.hide();\n            return false;\n        }\n    }\n\n    function click(e) {\n        var el = $(e.target);\n        if (!el.hasClass('pmu-button')) {\n            el = el.closest('.pmu-button');\n        }\n        if (el.length) {\n            if (el.hasClass('pmu-disabled')) {\n                return false;\n            }\n            var $this = $(this),\n                options = $this.data('pickmeup-options'),\n                instance = el.parents('.pmu-instance').eq(0),\n                root = instance.parent(),\n                instance_index = $('.pmu-instance', root).index(instance);\n            if (el.parent().is('nav')) {\n                if (el.hasClass('pmu-month')) {\n                    options.current.addMonths(instance_index - Math.floor(options.calendars / 2));\n                    if (root.hasClass('pmu-view-years')) {\n                        // Shift back to current date, otherwise with min value specified may jump on few (tens) years forward\n                        if (options.mode != 'single') {\n                            options.current = new Date(options.date[options.date.length - 1]);\n                        } else {\n                            options.current = new Date(options.date);\n                        }\n                        if (options.select_day) {\n                            root.removeClass('pmu-view-years').addClass('pmu-view-days');\n                        } else if (options.select_month) {\n                            root.removeClass('pmu-view-years').addClass('pmu-view-months');\n                        }\n                    } else if (root.hasClass('pmu-view-months')) {\n                        if (options.select_year) {\n                            root.removeClass('pmu-view-months').addClass('pmu-view-years');\n                        } else if (options.select_day) {\n                            root.removeClass('pmu-view-months').addClass('pmu-view-days');\n                        }\n                    } else if (root.hasClass('pmu-view-days')) {\n                        if (options.select_month) {\n                            root.removeClass('pmu-view-days').addClass('pmu-view-months');\n                        } else if (options.select_year) {\n                            root.removeClass('pmu-view-days').addClass('pmu-view-years');\n                        }\n                    }\n                } else {\n                    if (el.hasClass('pmu-prev')) {\n                        options.binded.prev(false);\n                    } else {\n                        options.binded.next(false);\n                    }\n                }\n            } else if (!el.hasClass('pmu-disabled')) {\n                if (root.hasClass('pmu-view-years')) {\n                    options.current.setFullYear(parseInt(el.text(), 10));\n                    if (options.select_month) {\n                        root.removeClass('pmu-view-years').addClass('pmu-view-months');\n                    } else if (options.select_day) {\n                        root.removeClass('pmu-view-years').addClass('pmu-view-days');\n                    } else {\n                        options.binded.update_date(options.current);\n                    }\n                } else if (root.hasClass('pmu-view-months')) {\n                    options.current.setMonth(instance.find('.pmu-months .pmu-button').index(el));\n                    options.current.setFullYear(parseInt(instance.find('.pmu-month').text(), 10));\n                    if (options.select_day) {\n                        root.removeClass('pmu-view-months').addClass('pmu-view-days');\n                    } else {\n                        options.binded.update_date(options.current);\n                    }\n                    // Move current month to the first place\n                    options.current.addMonths(Math.floor(options.calendars / 2) - instance_index);\n                } else {\n                    var val = parseInt(el.text(), 10), new_date;\n                    new_date = new Date(options.current);\n                    new_date.addMonths(instance_index - Math.floor(options.calendars / 2));\n                    if (el.hasClass('pmu-not-in-month')) {\n                        new_date.addMonths(val > 15 ? -1 : 1);\n                    }\n                    new_date.setDate(val);\n                    options.binded.update_date(new_date);\n                }\n            }\n            options.binded.fill();\n        }\n        return false;\n    }\n\n    function prepareDate(options) {\n        var result;\n        if (options.mode == 'single') {\n            result = new Date(options.date);\n            return [formatDate(result, options.format, options.locale), result];\n        } else {\n            result = [[], []];\n            $.each(options.date, function (nr, val) {\n                var date = new Date(val);\n                result[0].push(formatDate(date, options.format, options.locale));\n                result[1].push(date);\n            });\n            return result;\n        }\n    }\n\n    function show(force) {\n        var pickmeup = this.pickmeup,\n            value;\n        if (force || !pickmeup.is(':visible')) {\n            var $this = $(this),\n                options = $this.data('pickmeup-options'),\n                pos = $this.offset(),\n                viewport = {\n                    l: document.documentElement.scrollLeft,\n                    t: document.documentElement.scrollTop,\n                    w: document.documentElement.clientWidth,\n                    h: document.documentElement.clientHeight\n                },\n                top = pos.top,\n                left = pos.left;\n            options.binded.fill();\n            if ($this.is('input')) {\n                value = $this.val();\n                if (value) {\n                    $this.pickmeup('set_date', parseDate(value, options.format, options.separator, options.locale))\n                }\n                $this.keydown(function (e) {\n                    if (e.which == 9) {\n                        $this.pickmeup('hide');\n                    }\n                });\n                options.lastSel = false;\n            }\n            options.before_show();\n            if (options.show() == false) {\n                return;\n            }\n            if (!options.flat) {\n                switch (options.position) {\n                    case 'top':\n                        top -= pickmeup.outerHeight();\n                        break;\n                    case 'left':\n                        left -= pickmeup.outerWidth();\n                        break;\n                    case 'right':\n                        left += this.offsetWidth;\n                        break;\n                    case 'bottom':\n                        top += this.offsetHeight;\n                        break;\n                }\n                if (top + pickmeup.offsetHeight > viewport.t + viewport.h) {\n                    top = pos.top - pickmeup.offsetHeight;\n                }\n                if (top < viewport.t) {\n                    top = pos.top + this.offsetHeight + pickmeup.offsetHeight;\n                }\n                if (left + pickmeup.offsetWidth > viewport.l + viewport.w) {\n                    left = pos.left - pickmeup.offsetWidth;\n                }\n                if (left < viewport.l) {\n                    left = pos.left + this.offsetWidth\n                }\n\n                if (left + pickmeup.outerWidth() >= $(window).width()) {\n                    left = ($this.offset().left - pickmeup.outerWidth()) + $this.outerWidth();\n                }\n\n                pickmeup.css({\n                    display: 'inline-block',\n                    top: top + 'px',\n                    left: left + 'px'\n                });\n                $(document)\n                    .on(\n                        namespaced_events(options.trigger_event, options.events_namespace),\n                        options.binded.hide\n                    )\n                    .on(\n                        'resize' + options.events_namespace,\n                        [\n                            true\n                        ],\n                        options.binded.forced_show\n                    );\n            }\n        }\n    }\n\n    function forced_show() {\n        show.call(this, true);\n    }\n\n    function hide(e) {\n        //noinspection JSBitwiseOperatorUsage\n        if (\n            !e || !e.target ||\t\t\t\t\t\t\t\t\t\t\t\t\t\t//Called directly\n            (\n                e.target != this &&\t\t\t\t\t\t\t\t\t\t\t\t//Clicked not on element itself\n                !(this.pickmeup.get(0).compareDocumentPosition(e.target) & 16)\t//And not on its children\n            )\n        ) {\n            var pickmeup = this.pickmeup,\n                options = $(this).data('pickmeup-options');\n            if (options.hide() != false) {\n                pickmeup.hide();\n                $(document)\n                    .off(namespaced_events(options.trigger_event, options.events_namespace), options.binded.hide)\n                    .off('resize', options.binded.forced_show);\n                options.lastSel = false;\n            }\n        }\n    }\n\n    function update() {\n        var options = $(this).data('pickmeup-options');\n        $(document)\n            .off(namespaced_events(options.trigger_event, options.events_namespace), options.binded.hide)\n            .off('resize', options.binded.forced_show);\n        options.binded.forced_show();\n    }\n\n    function clear() {\n        var options = $(this).data('pickmeup-options');\n        if (options.mode != 'single') {\n            options.date = [];\n            options.lastSel = false;\n            options.binded.fill();\n        }\n    }\n\n    function prev(fill) {\n        if (typeof fill == 'undefined') {\n            fill = true;\n        }\n        var root = this.pickmeup;\n        var options = $(this).data('pickmeup-options');\n        if (root.hasClass('pmu-view-years')) {\n            options.current.addYears(-12);\n        } else if (root.hasClass('pmu-view-months')) {\n            options.current.addYears(-1);\n        } else if (root.hasClass('pmu-view-days')) {\n            options.current.addMonths(-1);\n        }\n        if (fill) {\n            options.binded.fill();\n        }\n    }\n\n    function next(fill) {\n        if (typeof fill == 'undefined') {\n            fill = true;\n        }\n        var root = this.pickmeup;\n        var options = $(this).data('pickmeup-options');\n        if (root.hasClass('pmu-view-years')) {\n            options.current.addYears(12);\n        } else if (root.hasClass('pmu-view-months')) {\n            options.current.addYears(1);\n        } else if (root.hasClass('pmu-view-days')) {\n            options.current.addMonths(1);\n        }\n        if (fill) {\n            options.binded.fill();\n        }\n    }\n\n    function get_date(formatted) {\n        var options = $(this).data('pickmeup-options'),\n            prepared_date = prepareDate(options);\n        if (typeof formatted === 'string') {\n            var date = prepared_date[1];\n            if (date.constructor == Date) {\n                return formatDate(date, formatted, options.locale)\n            } else {\n                return date.map(function (value) {\n                    return formatDate(value, formatted, options.locale);\n                });\n            }\n        } else {\n            return prepared_date[formatted ? 0 : 1];\n        }\n    }\n\n    function set_date(date, current) {\n        var $this = $(this),\n            options = $this.data('pickmeup-options'),\n            i;\n        if (!(date instanceof Array) || date.length > 0) {\n            options.date = parseDate(date, options.format, options.separator, options.locale);\n            if (options.mode != 'single') {\n                if (options.date instanceof Array) {\n                    options.date[0] = options.date[0] || parseDate(new Date, options.format, options.separator, options.locale);\n                    if (options.mode == 'range') {\n                        options.date[1] = options.date[1] || parseDate(options.date[0], options.format, options.separator, options.locale);\n                    }\n                } else {\n                    options.date = [options.date];\n                    if (options.mode == 'range') {\n                        options.date.push(parseDate(options.date[0], options.format, options.separator, options.locale));\n                    }\n                }\n                for (i = 0; i < options.date.length; ++i) {\n                    options.date[i] = correct_date_outside_of_limit(options.date[i], options.min, options.max);\n                }\n            } else {\n                if (options.date instanceof Array) {\n                    options.date = options.date[0];\n                }\n                options.date = correct_date_outside_of_limit(options.date, options.min, options.max);\n            }\n        } else {\n            options.date = [];\n        }\n        if (!options.select_day) {\n            if (options.date instanceof Array) {\n                for (i = 0; i < options.date.length; ++i) {\n                    options.date[i].setDate(1);\n                }\n            } else {\n                options.date.setDate(1);\n            }\n        }\n        // Remove duplicates\n        if (options.mode == 'multiple') {\n            for (i = 0; i < options.date.length; ++i) {\n                if (options.date.indexOf(options.date[i]) !== i) {\n                    options.date.splice(i, 1);\n                    --i;\n                }\n            }\n        }\n        if (current) {\n            options.current = parseDate(current, options.format, options.separator, options.locale);\n        } else {\n            current = options.mode === 'single' ? options.date : options.date[options.date.length - 1];\n            options.current = current ? new Date(current) : new Date;\n        }\n        options.current.setDate(1);\n        options.binded.fill();\n        if ($this.is('input') && options.default_date !== false) {\n            var prepared_date = prepareDate(options),\n                current_value = $this.val(),\n                new_value = options.mode == 'single' ? prepared_date[0] : prepared_date[0].join(options.separator);\n            if (!current_value) {\n                options.change.apply(this, prepared_date);\n            }\n            if (current_value != new_value) {\n                $this.val(new_value);\n            }\n        }\n    }\n\n    function destroy() {\n        var $this = $(this),\n            options = $this.data('pickmeup-options');\n        $this.removeData('pickmeup-options');\n        $this.off(options.events_namespace);\n        $(document).off(options.events_namespace);\n        $(this.pickmeup).remove();\n    }\n\n    function correct_date_outside_of_limit(date, min, max) {\n        if (min && min > date) {\n            return new Date(min);\n        } else if (max && max < date) {\n            return new Date(max);\n        }\n        return date;\n    }\n\n    $.fn.pickmeup = function (initial_options) {\n        if (typeof initial_options === 'string') {\n            var data,\n                parameters = Array.prototype.slice.call(arguments, 1);\n            switch (initial_options) {\n                case 'hide':\n                case 'show':\n                case 'clear':\n                case 'update':\n                case 'prev':\n                case 'next':\n                case 'destroy':\n                    this.each(function () {\n                        data = $(this).data('pickmeup-options');\n                        if (data) {\n                            data.binded[initial_options]();\n                        }\n                    });\n                    break;\n                case 'get_date':\n                    data = this.data('pickmeup-options');\n                    if (data) {\n                        return data.binded.get_date(parameters[0]);\n                    } else {\n                        return null;\n                    }\n                    break;\n                case 'set_date':\n                    this.each(function () {\n                        data = $(this).data('pickmeup-options');\n                        if (data) {\n                            data.binded[initial_options].apply(this, parameters);\n                        }\n                    });\n            }\n            return this;\n        }\n        return this.each(function () {\n            var $this = $(this);\n            if ($this.data('pickmeup-options')) {\n                return;\n            }\n            var i,\n                option,\n                options = $.extend(true, {}, $.pickmeup, initial_options || {});\n            for (i in options) {\n                option = $this.data('pmu-' + i);\n                if (typeof option !== 'undefined') {\n                    options[i] = option;\n                }\n            }\n            // 4 conditional statements in order to account all cases\n            if (options.view == 'days' && !options.select_day) {\n                options.view = 'months';\n            }\n            if (options.view == 'months' && !options.select_month) {\n                options.view = 'years';\n            }\n            if (options.view == 'years' && !options.select_year) {\n                options.view = 'days';\n            }\n            if (options.view == 'days' && !options.select_day) {\n                options.view = 'months';\n            }\n            options.calendars = Math.max(1, parseInt(options.calendars, 10) || 1);\n            options.mode = /single|multiple|range/.test(options.mode) ? options.mode : 'single';\n            if (options.min) {\n                options.min = parseDate(options.min, options.format, options.separator, options.locale);\n                if (!options.select_day) {\n                    options.min.setDate(1);\n                }\n            }\n            if (options.max) {\n                options.max = parseDate(options.max, options.format, options.separator, options.locale);\n                if (!options.select_day) {\n                    options.max.setDate(1);\n                }\n            }\n            var cnt,\n                pickmeup = $(tpl.wrapper);\n            this.pickmeup = pickmeup;\n            if (options.class_name) {\n                pickmeup.addClass(options.class_name);\n            }\n            var html = '';\n            for (i = 0; i < options.calendars; i++) {\n                cnt = options.first_day;\n                html += tpl.head({\n                    prev: options.prev,\n                    next: options.next,\n                    day: [\n                        options.locale.daysMin[(cnt++) % 7],\n                        options.locale.daysMin[(cnt++) % 7],\n                        options.locale.daysMin[(cnt++) % 7],\n                        options.locale.daysMin[(cnt++) % 7],\n                        options.locale.daysMin[(cnt++) % 7],\n                        options.locale.daysMin[(cnt++) % 7],\n                        options.locale.daysMin[(cnt++) % 7]\n                    ]\n                });\n            }\n            $this.data('pickmeup-options', options);\n            for (i in options) {\n                if (['render', 'change', 'before_show', 'show', 'hide'].indexOf(i) != -1) {\n                    options[i] = options[i].bind(this);\n                }\n            }\n            options.binded = {\n                fill: fill.bind(this),\n                update_date: update_date.bind(this),\n                click: click.bind(this),\n                show: show.bind(this),\n                forced_show: forced_show.bind(this),\n                hide: hide.bind(this),\n                update: update.bind(this),\n                clear: clear.bind(this),\n                prev: prev.bind(this),\n                next: next.bind(this),\n                get_date: get_date.bind(this),\n                set_date: set_date.bind(this),\n                destroy: destroy.bind(this)\n            };\n            options.events_namespace = '.pickmeup-' + (++instances_count);\n            pickmeup\n                .on(namespaced_events(options.trigger_event, options.events_namespace), options.binded.click)\n                .addClass(views[options.view])\n                .append(html)\n                .on(\n                    $.support.selectstart ? 'selectstart' : 'mousedown',\n                    function (e) {\n                        e.preventDefault();\n                    }\n                );\n            if (options.flat) {\n                pickmeup.appendTo(this).css({\n                    position: 'relative',\n                    display: 'inline-block'\n                });\n            } else {\n                pickmeup.appendTo(document.body);\n                $this.on(\n                    namespaced_events(options.trigger_event, options.events_namespace),\n                    function () {\n                        options.binded.show();\n                    }\n                );\n            }\n            options.binded.set_date(options.date, options.current);\n        });\n    };\n}));\n\n//# sourceURL=webpack://parus/./src/js/plugins/pickmeup.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/js/pages/calendar.js");
/******/ 	
/******/ })()
;
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/dom7/dom7.esm.js":
/*!***************************************!*\
  !*** ./node_modules/dom7/dom7.esm.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $: () => (/* binding */ $),\n/* harmony export */   add: () => (/* binding */ add),\n/* harmony export */   addClass: () => (/* binding */ addClass),\n/* harmony export */   animate: () => (/* binding */ animate),\n/* harmony export */   animationEnd: () => (/* binding */ animationEnd),\n/* harmony export */   append: () => (/* binding */ append),\n/* harmony export */   appendTo: () => (/* binding */ appendTo),\n/* harmony export */   attr: () => (/* binding */ attr),\n/* harmony export */   blur: () => (/* binding */ blur),\n/* harmony export */   change: () => (/* binding */ change),\n/* harmony export */   children: () => (/* binding */ children),\n/* harmony export */   click: () => (/* binding */ click),\n/* harmony export */   closest: () => (/* binding */ closest),\n/* harmony export */   css: () => (/* binding */ css),\n/* harmony export */   data: () => (/* binding */ data),\n/* harmony export */   dataset: () => (/* binding */ dataset),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   detach: () => (/* binding */ detach),\n/* harmony export */   each: () => (/* binding */ each),\n/* harmony export */   empty: () => (/* binding */ empty),\n/* harmony export */   eq: () => (/* binding */ eq),\n/* harmony export */   filter: () => (/* binding */ filter),\n/* harmony export */   find: () => (/* binding */ find),\n/* harmony export */   focus: () => (/* binding */ focus),\n/* harmony export */   focusin: () => (/* binding */ focusin),\n/* harmony export */   focusout: () => (/* binding */ focusout),\n/* harmony export */   hasClass: () => (/* binding */ hasClass),\n/* harmony export */   height: () => (/* binding */ height),\n/* harmony export */   hide: () => (/* binding */ hide),\n/* harmony export */   html: () => (/* binding */ html),\n/* harmony export */   index: () => (/* binding */ index),\n/* harmony export */   insertAfter: () => (/* binding */ insertAfter),\n/* harmony export */   insertBefore: () => (/* binding */ insertBefore),\n/* harmony export */   is: () => (/* binding */ is),\n/* harmony export */   keydown: () => (/* binding */ keydown),\n/* harmony export */   keypress: () => (/* binding */ keypress),\n/* harmony export */   keyup: () => (/* binding */ keyup),\n/* harmony export */   mousedown: () => (/* binding */ mousedown),\n/* harmony export */   mouseenter: () => (/* binding */ mouseenter),\n/* harmony export */   mouseleave: () => (/* binding */ mouseleave),\n/* harmony export */   mousemove: () => (/* binding */ mousemove),\n/* harmony export */   mouseout: () => (/* binding */ mouseout),\n/* harmony export */   mouseover: () => (/* binding */ mouseover),\n/* harmony export */   mouseup: () => (/* binding */ mouseup),\n/* harmony export */   next: () => (/* binding */ next),\n/* harmony export */   nextAll: () => (/* binding */ nextAll),\n/* harmony export */   off: () => (/* binding */ off),\n/* harmony export */   offset: () => (/* binding */ offset),\n/* harmony export */   on: () => (/* binding */ on),\n/* harmony export */   once: () => (/* binding */ once),\n/* harmony export */   outerHeight: () => (/* binding */ outerHeight),\n/* harmony export */   outerWidth: () => (/* binding */ outerWidth),\n/* harmony export */   parent: () => (/* binding */ parent),\n/* harmony export */   parents: () => (/* binding */ parents),\n/* harmony export */   prepend: () => (/* binding */ prepend),\n/* harmony export */   prependTo: () => (/* binding */ prependTo),\n/* harmony export */   prev: () => (/* binding */ prev),\n/* harmony export */   prevAll: () => (/* binding */ prevAll),\n/* harmony export */   prop: () => (/* binding */ prop),\n/* harmony export */   remove: () => (/* binding */ remove),\n/* harmony export */   removeAttr: () => (/* binding */ removeAttr),\n/* harmony export */   removeClass: () => (/* binding */ removeClass),\n/* harmony export */   removeData: () => (/* binding */ removeData),\n/* harmony export */   resize: () => (/* binding */ resize),\n/* harmony export */   scroll: () => (/* binding */ scroll),\n/* harmony export */   scrollLeft: () => (/* binding */ scrollLeft),\n/* harmony export */   scrollTo: () => (/* binding */ scrollTo),\n/* harmony export */   scrollTop: () => (/* binding */ scrollTop),\n/* harmony export */   show: () => (/* binding */ show),\n/* harmony export */   siblings: () => (/* binding */ siblings),\n/* harmony export */   stop: () => (/* binding */ stop),\n/* harmony export */   styles: () => (/* binding */ styles),\n/* harmony export */   submit: () => (/* binding */ submit),\n/* harmony export */   text: () => (/* binding */ text),\n/* harmony export */   toggleClass: () => (/* binding */ toggleClass),\n/* harmony export */   touchend: () => (/* binding */ touchend),\n/* harmony export */   touchmove: () => (/* binding */ touchmove),\n/* harmony export */   touchstart: () => (/* binding */ touchstart),\n/* harmony export */   transform: () => (/* binding */ transform),\n/* harmony export */   transition: () => (/* binding */ transition),\n/* harmony export */   transitionEnd: () => (/* binding */ transitionEnd),\n/* harmony export */   trigger: () => (/* binding */ trigger),\n/* harmony export */   val: () => (/* binding */ val),\n/* harmony export */   value: () => (/* binding */ value),\n/* harmony export */   width: () => (/* binding */ width)\n/* harmony export */ });\n/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ \"./node_modules/ssr-window/ssr-window.esm.js\");\n/**\n * Dom7 3.0.0\n * Minimalistic JavaScript library for DOM manipulation, with a jQuery-compatible API\n * https://framework7.io/docs/dom7.html\n *\n * Copyright 2020, Vladimir Kharlampidi\n *\n * Licensed under MIT\n *\n * Released on: November 9, 2020\n */\n\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _construct(Parent, args, Class) {\n  if (_isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) _setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}\n\nfunction _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\n\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !_isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return _setPrototypeOf(Wrapper, Class);\n  };\n\n  return _wrapNativeSuper(Class);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\n/* eslint-disable no-proto */\nfunction makeReactive(obj) {\n  var proto = obj.__proto__;\n  Object.defineProperty(obj, '__proto__', {\n    get: function get() {\n      return proto;\n    },\n    set: function set(value) {\n      proto.__proto__ = value;\n    }\n  });\n}\n\nvar Dom7 = /*#__PURE__*/function (_Array) {\n  _inheritsLoose(Dom7, _Array);\n\n  function Dom7(items) {\n    var _this;\n\n    _this = _Array.call.apply(_Array, [this].concat(items)) || this;\n    makeReactive(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  return Dom7;\n}( /*#__PURE__*/_wrapNativeSuper(Array));\n\nfunction arrayFlat(arr) {\n  if (arr === void 0) {\n    arr = [];\n  }\n\n  var res = [];\n  arr.forEach(function (el) {\n    if (Array.isArray(el)) {\n      res.push.apply(res, arrayFlat(el));\n    } else {\n      res.push(el);\n    }\n  });\n  return res;\n}\nfunction arrayFilter(arr, callback) {\n  return Array.prototype.filter.call(arr, callback);\n}\nfunction arrayUnique(arr) {\n  var uniqueArray = [];\n\n  for (var i = 0; i < arr.length; i += 1) {\n    if (uniqueArray.indexOf(arr[i]) === -1) uniqueArray.push(arr[i]);\n  }\n\n  return uniqueArray;\n}\nfunction toCamelCase(string) {\n  return string.toLowerCase().replace(/-(.)/g, function (match, group) {\n    return group.toUpperCase();\n  });\n}\n\nfunction qsa(selector, context) {\n  if (typeof selector !== 'string') {\n    return [selector];\n  }\n\n  var a = [];\n  var res = context.querySelectorAll(selector);\n\n  for (var i = 0; i < res.length; i += 1) {\n    a.push(res[i]);\n  }\n\n  return a;\n}\n\nfunction $(selector, context) {\n  var window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();\n  var document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();\n  var arr = [];\n\n  if (!context && selector instanceof Dom7) {\n    return selector;\n  }\n\n  if (!selector) {\n    return new Dom7(arr);\n  }\n\n  if (typeof selector === 'string') {\n    var html = selector.trim();\n\n    if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {\n      var toCreate = 'div';\n      if (html.indexOf('<li') === 0) toCreate = 'ul';\n      if (html.indexOf('<tr') === 0) toCreate = 'tbody';\n      if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) toCreate = 'tr';\n      if (html.indexOf('<tbody') === 0) toCreate = 'table';\n      if (html.indexOf('<option') === 0) toCreate = 'select';\n      var tempParent = document.createElement(toCreate);\n      tempParent.innerHTML = html;\n\n      for (var i = 0; i < tempParent.childNodes.length; i += 1) {\n        arr.push(tempParent.childNodes[i]);\n      }\n    } else {\n      arr = qsa(selector.trim(), context || document);\n    } // arr = qsa(selector, document);\n\n  } else if (selector.nodeType || selector === window || selector === document) {\n    arr.push(selector);\n  } else if (Array.isArray(selector)) {\n    if (selector instanceof Dom7) return selector;\n    arr = selector;\n  }\n\n  return new Dom7(arrayUnique(arr));\n}\n\n$.fn = Dom7.prototype;\n\nfunction addClass() {\n  for (var _len = arguments.length, classes = new Array(_len), _key = 0; _key < _len; _key++) {\n    classes[_key] = arguments[_key];\n  }\n\n  var classNames = arrayFlat(classes.map(function (c) {\n    return c.split(' ');\n  }));\n  this.forEach(function (el) {\n    var _el$classList;\n\n    (_el$classList = el.classList).add.apply(_el$classList, classNames);\n  });\n  return this;\n}\n\nfunction removeClass() {\n  for (var _len2 = arguments.length, classes = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    classes[_key2] = arguments[_key2];\n  }\n\n  var classNames = arrayFlat(classes.map(function (c) {\n    return c.split(' ');\n  }));\n  this.forEach(function (el) {\n    var _el$classList2;\n\n    (_el$classList2 = el.classList).remove.apply(_el$classList2, classNames);\n  });\n  return this;\n}\n\nfunction toggleClass() {\n  for (var _len3 = arguments.length, classes = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    classes[_key3] = arguments[_key3];\n  }\n\n  var classNames = arrayFlat(classes.map(function (c) {\n    return c.split(' ');\n  }));\n  this.forEach(function (el) {\n    classNames.forEach(function (className) {\n      el.classList.toggle(className);\n    });\n  });\n}\n\nfunction hasClass() {\n  for (var _len4 = arguments.length, classes = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n    classes[_key4] = arguments[_key4];\n  }\n\n  var classNames = arrayFlat(classes.map(function (c) {\n    return c.split(' ');\n  }));\n  return arrayFilter(this, function (el) {\n    return classNames.filter(function (className) {\n      return el.classList.contains(className);\n    }).length > 0;\n  }).length > 0;\n}\n\nfunction attr(attrs, value) {\n  if (arguments.length === 1 && typeof attrs === 'string') {\n    // Get attr\n    if (this[0]) return this[0].getAttribute(attrs);\n    return undefined;\n  } // Set attrs\n\n\n  for (var i = 0; i < this.length; i += 1) {\n    if (arguments.length === 2) {\n      // String\n      this[i].setAttribute(attrs, value);\n    } else {\n      // Object\n      for (var attrName in attrs) {\n        this[i][attrName] = attrs[attrName];\n        this[i].setAttribute(attrName, attrs[attrName]);\n      }\n    }\n  }\n\n  return this;\n}\n\nfunction removeAttr(attr) {\n  for (var i = 0; i < this.length; i += 1) {\n    this[i].removeAttribute(attr);\n  }\n\n  return this;\n}\n\nfunction prop(props, value) {\n  if (arguments.length === 1 && typeof props === 'string') {\n    // Get prop\n    if (this[0]) return this[0][props];\n  } else {\n    // Set props\n    for (var i = 0; i < this.length; i += 1) {\n      if (arguments.length === 2) {\n        // String\n        this[i][props] = value;\n      } else {\n        // Object\n        for (var propName in props) {\n          this[i][propName] = props[propName];\n        }\n      }\n    }\n\n    return this;\n  }\n\n  return this;\n}\n\nfunction data(key, value) {\n  var el;\n\n  if (typeof value === 'undefined') {\n    el = this[0];\n    if (!el) return undefined; // Get value\n\n    if (el.dom7ElementDataStorage && key in el.dom7ElementDataStorage) {\n      return el.dom7ElementDataStorage[key];\n    }\n\n    var dataKey = el.getAttribute(\"data-\" + key);\n\n    if (dataKey) {\n      return dataKey;\n    }\n\n    return undefined;\n  } // Set value\n\n\n  for (var i = 0; i < this.length; i += 1) {\n    el = this[i];\n    if (!el.dom7ElementDataStorage) el.dom7ElementDataStorage = {};\n    el.dom7ElementDataStorage[key] = value;\n  }\n\n  return this;\n}\n\nfunction removeData(key) {\n  for (var i = 0; i < this.length; i += 1) {\n    var el = this[i];\n\n    if (el.dom7ElementDataStorage && el.dom7ElementDataStorage[key]) {\n      el.dom7ElementDataStorage[key] = null;\n      delete el.dom7ElementDataStorage[key];\n    }\n  }\n}\n\nfunction dataset() {\n  var el = this[0];\n  if (!el) return undefined;\n  var dataset = {}; // eslint-disable-line\n\n  if (el.dataset) {\n    for (var dataKey in el.dataset) {\n      dataset[dataKey] = el.dataset[dataKey];\n    }\n  } else {\n    for (var i = 0; i < el.attributes.length; i += 1) {\n      var _attr = el.attributes[i];\n\n      if (_attr.name.indexOf('data-') >= 0) {\n        dataset[toCamelCase(_attr.name.split('data-')[1])] = _attr.value;\n      }\n    }\n  }\n\n  for (var key in dataset) {\n    if (dataset[key] === 'false') dataset[key] = false;else if (dataset[key] === 'true') dataset[key] = true;else if (parseFloat(dataset[key]) === dataset[key] * 1) dataset[key] *= 1;\n  }\n\n  return dataset;\n}\n\nfunction val(value) {\n  if (typeof value === 'undefined') {\n    // get value\n    var el = this[0];\n    if (!el) return undefined;\n\n    if (el.multiple && el.nodeName.toLowerCase() === 'select') {\n      var values = [];\n\n      for (var i = 0; i < el.selectedOptions.length; i += 1) {\n        values.push(el.selectedOptions[i].value);\n      }\n\n      return values;\n    }\n\n    return el.value;\n  } // set value\n\n\n  for (var _i = 0; _i < this.length; _i += 1) {\n    var _el = this[_i];\n\n    if (Array.isArray(value) && _el.multiple && _el.nodeName.toLowerCase() === 'select') {\n      for (var j = 0; j < _el.options.length; j += 1) {\n        _el.options[j].selected = value.indexOf(_el.options[j].value) >= 0;\n      }\n    } else {\n      _el.value = value;\n    }\n  }\n\n  return this;\n}\n\nfunction value(value) {\n  return this.val(value);\n}\n\nfunction transform(transform) {\n  for (var i = 0; i < this.length; i += 1) {\n    this[i].style.transform = transform;\n  }\n\n  return this;\n}\n\nfunction transition(duration) {\n  for (var i = 0; i < this.length; i += 1) {\n    this[i].style.transitionDuration = typeof duration !== 'string' ? duration + \"ms\" : duration;\n  }\n\n  return this;\n}\n\nfunction on() {\n  for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n    args[_key5] = arguments[_key5];\n  }\n\n  var eventType = args[0],\n      targetSelector = args[1],\n      listener = args[2],\n      capture = args[3];\n\n  if (typeof args[1] === 'function') {\n    eventType = args[0];\n    listener = args[1];\n    capture = args[2];\n    targetSelector = undefined;\n  }\n\n  if (!capture) capture = false;\n\n  function handleLiveEvent(e) {\n    var target = e.target;\n    if (!target) return;\n    var eventData = e.target.dom7EventData || [];\n\n    if (eventData.indexOf(e) < 0) {\n      eventData.unshift(e);\n    }\n\n    if ($(target).is(targetSelector)) listener.apply(target, eventData);else {\n      var _parents = $(target).parents(); // eslint-disable-line\n\n\n      for (var k = 0; k < _parents.length; k += 1) {\n        if ($(_parents[k]).is(targetSelector)) listener.apply(_parents[k], eventData);\n      }\n    }\n  }\n\n  function handleEvent(e) {\n    var eventData = e && e.target ? e.target.dom7EventData || [] : [];\n\n    if (eventData.indexOf(e) < 0) {\n      eventData.unshift(e);\n    }\n\n    listener.apply(this, eventData);\n  }\n\n  var events = eventType.split(' ');\n  var j;\n\n  for (var i = 0; i < this.length; i += 1) {\n    var el = this[i];\n\n    if (!targetSelector) {\n      for (j = 0; j < events.length; j += 1) {\n        var event = events[j];\n        if (!el.dom7Listeners) el.dom7Listeners = {};\n        if (!el.dom7Listeners[event]) el.dom7Listeners[event] = [];\n        el.dom7Listeners[event].push({\n          listener: listener,\n          proxyListener: handleEvent\n        });\n        el.addEventListener(event, handleEvent, capture);\n      }\n    } else {\n      // Live events\n      for (j = 0; j < events.length; j += 1) {\n        var _event = events[j];\n        if (!el.dom7LiveListeners) el.dom7LiveListeners = {};\n        if (!el.dom7LiveListeners[_event]) el.dom7LiveListeners[_event] = [];\n\n        el.dom7LiveListeners[_event].push({\n          listener: listener,\n          proxyListener: handleLiveEvent\n        });\n\n        el.addEventListener(_event, handleLiveEvent, capture);\n      }\n    }\n  }\n\n  return this;\n}\n\nfunction off() {\n  for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n    args[_key6] = arguments[_key6];\n  }\n\n  var eventType = args[0],\n      targetSelector = args[1],\n      listener = args[2],\n      capture = args[3];\n\n  if (typeof args[1] === 'function') {\n    eventType = args[0];\n    listener = args[1];\n    capture = args[2];\n    targetSelector = undefined;\n  }\n\n  if (!capture) capture = false;\n  var events = eventType.split(' ');\n\n  for (var i = 0; i < events.length; i += 1) {\n    var event = events[i];\n\n    for (var j = 0; j < this.length; j += 1) {\n      var el = this[j];\n      var handlers = void 0;\n\n      if (!targetSelector && el.dom7Listeners) {\n        handlers = el.dom7Listeners[event];\n      } else if (targetSelector && el.dom7LiveListeners) {\n        handlers = el.dom7LiveListeners[event];\n      }\n\n      if (handlers && handlers.length) {\n        for (var k = handlers.length - 1; k >= 0; k -= 1) {\n          var handler = handlers[k];\n\n          if (listener && handler.listener === listener) {\n            el.removeEventListener(event, handler.proxyListener, capture);\n            handlers.splice(k, 1);\n          } else if (listener && handler.listener && handler.listener.dom7proxy && handler.listener.dom7proxy === listener) {\n            el.removeEventListener(event, handler.proxyListener, capture);\n            handlers.splice(k, 1);\n          } else if (!listener) {\n            el.removeEventListener(event, handler.proxyListener, capture);\n            handlers.splice(k, 1);\n          }\n        }\n      }\n    }\n  }\n\n  return this;\n}\n\nfunction once() {\n  var dom = this;\n\n  for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n    args[_key7] = arguments[_key7];\n  }\n\n  var eventName = args[0],\n      targetSelector = args[1],\n      listener = args[2],\n      capture = args[3];\n\n  if (typeof args[1] === 'function') {\n    eventName = args[0];\n    listener = args[1];\n    capture = args[2];\n    targetSelector = undefined;\n  }\n\n  function onceHandler() {\n    for (var _len8 = arguments.length, eventArgs = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n      eventArgs[_key8] = arguments[_key8];\n    }\n\n    listener.apply(this, eventArgs);\n    dom.off(eventName, targetSelector, onceHandler, capture);\n\n    if (onceHandler.dom7proxy) {\n      delete onceHandler.dom7proxy;\n    }\n  }\n\n  onceHandler.dom7proxy = listener;\n  return dom.on(eventName, targetSelector, onceHandler, capture);\n}\n\nfunction trigger() {\n  var window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();\n\n  for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n    args[_key9] = arguments[_key9];\n  }\n\n  var events = args[0].split(' ');\n  var eventData = args[1];\n\n  for (var i = 0; i < events.length; i += 1) {\n    var event = events[i];\n\n    for (var j = 0; j < this.length; j += 1) {\n      var el = this[j];\n\n      if (window.CustomEvent) {\n        var evt = new window.CustomEvent(event, {\n          detail: eventData,\n          bubbles: true,\n          cancelable: true\n        });\n        el.dom7EventData = args.filter(function (data, dataIndex) {\n          return dataIndex > 0;\n        });\n        el.dispatchEvent(evt);\n        el.dom7EventData = [];\n        delete el.dom7EventData;\n      }\n    }\n  }\n\n  return this;\n}\n\nfunction transitionEnd(callback) {\n  var dom = this;\n\n  function fireCallBack(e) {\n    if (e.target !== this) return;\n    callback.call(this, e);\n    dom.off('transitionend', fireCallBack);\n  }\n\n  if (callback) {\n    dom.on('transitionend', fireCallBack);\n  }\n\n  return this;\n}\n\nfunction animationEnd(callback) {\n  var dom = this;\n\n  function fireCallBack(e) {\n    if (e.target !== this) return;\n    callback.call(this, e);\n    dom.off('animationend', fireCallBack);\n  }\n\n  if (callback) {\n    dom.on('animationend', fireCallBack);\n  }\n\n  return this;\n}\n\nfunction width() {\n  var window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();\n\n  if (this[0] === window) {\n    return window.innerWidth;\n  }\n\n  if (this.length > 0) {\n    return parseFloat(this.css('width'));\n  }\n\n  return null;\n}\n\nfunction outerWidth(includeMargins) {\n  if (this.length > 0) {\n    if (includeMargins) {\n      var _styles = this.styles();\n\n      return this[0].offsetWidth + parseFloat(_styles.getPropertyValue('margin-right')) + parseFloat(_styles.getPropertyValue('margin-left'));\n    }\n\n    return this[0].offsetWidth;\n  }\n\n  return null;\n}\n\nfunction height() {\n  var window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();\n\n  if (this[0] === window) {\n    return window.innerHeight;\n  }\n\n  if (this.length > 0) {\n    return parseFloat(this.css('height'));\n  }\n\n  return null;\n}\n\nfunction outerHeight(includeMargins) {\n  if (this.length > 0) {\n    if (includeMargins) {\n      var _styles2 = this.styles();\n\n      return this[0].offsetHeight + parseFloat(_styles2.getPropertyValue('margin-top')) + parseFloat(_styles2.getPropertyValue('margin-bottom'));\n    }\n\n    return this[0].offsetHeight;\n  }\n\n  return null;\n}\n\nfunction offset() {\n  if (this.length > 0) {\n    var window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();\n    var document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();\n    var el = this[0];\n    var box = el.getBoundingClientRect();\n    var body = document.body;\n    var clientTop = el.clientTop || body.clientTop || 0;\n    var clientLeft = el.clientLeft || body.clientLeft || 0;\n    var scrollTop = el === window ? window.scrollY : el.scrollTop;\n    var scrollLeft = el === window ? window.scrollX : el.scrollLeft;\n    return {\n      top: box.top + scrollTop - clientTop,\n      left: box.left + scrollLeft - clientLeft\n    };\n  }\n\n  return null;\n}\n\nfunction hide() {\n  for (var i = 0; i < this.length; i += 1) {\n    this[i].style.display = 'none';\n  }\n\n  return this;\n}\n\nfunction show() {\n  var window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();\n\n  for (var i = 0; i < this.length; i += 1) {\n    var el = this[i];\n\n    if (el.style.display === 'none') {\n      el.style.display = '';\n    }\n\n    if (window.getComputedStyle(el, null).getPropertyValue('display') === 'none') {\n      // Still not visible\n      el.style.display = 'block';\n    }\n  }\n\n  return this;\n}\n\nfunction styles() {\n  var window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();\n  if (this[0]) return window.getComputedStyle(this[0], null);\n  return {};\n}\n\nfunction css(props, value) {\n  var window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();\n  var i;\n\n  if (arguments.length === 1) {\n    if (typeof props === 'string') {\n      // .css('width')\n      if (this[0]) return window.getComputedStyle(this[0], null).getPropertyValue(props);\n    } else {\n      // .css({ width: '100px' })\n      for (i = 0; i < this.length; i += 1) {\n        for (var _prop in props) {\n          this[i].style[_prop] = props[_prop];\n        }\n      }\n\n      return this;\n    }\n  }\n\n  if (arguments.length === 2 && typeof props === 'string') {\n    // .css('width', '100px')\n    for (i = 0; i < this.length; i += 1) {\n      this[i].style[props] = value;\n    }\n\n    return this;\n  }\n\n  return this;\n}\n\nfunction each(callback) {\n  if (!callback) return this;\n  this.forEach(function (el, index) {\n    callback.apply(el, [el, index]);\n  });\n  return this;\n}\n\nfunction filter(callback) {\n  var result = arrayFilter(this, callback);\n  return $(result);\n}\n\nfunction html(html) {\n  if (typeof html === 'undefined') {\n    return this[0] ? this[0].innerHTML : null;\n  }\n\n  for (var i = 0; i < this.length; i += 1) {\n    this[i].innerHTML = html;\n  }\n\n  return this;\n}\n\nfunction text(text) {\n  if (typeof text === 'undefined') {\n    return this[0] ? this[0].textContent.trim() : null;\n  }\n\n  for (var i = 0; i < this.length; i += 1) {\n    this[i].textContent = text;\n  }\n\n  return this;\n}\n\nfunction is(selector) {\n  var window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();\n  var document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();\n  var el = this[0];\n  var compareWith;\n  var i;\n  if (!el || typeof selector === 'undefined') return false;\n\n  if (typeof selector === 'string') {\n    if (el.matches) return el.matches(selector);\n    if (el.webkitMatchesSelector) return el.webkitMatchesSelector(selector);\n    if (el.msMatchesSelector) return el.msMatchesSelector(selector);\n    compareWith = $(selector);\n\n    for (i = 0; i < compareWith.length; i += 1) {\n      if (compareWith[i] === el) return true;\n    }\n\n    return false;\n  }\n\n  if (selector === document) {\n    return el === document;\n  }\n\n  if (selector === window) {\n    return el === window;\n  }\n\n  if (selector.nodeType || selector instanceof Dom7) {\n    compareWith = selector.nodeType ? [selector] : selector;\n\n    for (i = 0; i < compareWith.length; i += 1) {\n      if (compareWith[i] === el) return true;\n    }\n\n    return false;\n  }\n\n  return false;\n}\n\nfunction index() {\n  var child = this[0];\n  var i;\n\n  if (child) {\n    i = 0; // eslint-disable-next-line\n\n    while ((child = child.previousSibling) !== null) {\n      if (child.nodeType === 1) i += 1;\n    }\n\n    return i;\n  }\n\n  return undefined;\n}\n\nfunction eq(index) {\n  if (typeof index === 'undefined') return this;\n  var length = this.length;\n\n  if (index > length - 1) {\n    return $([]);\n  }\n\n  if (index < 0) {\n    var returnIndex = length + index;\n    if (returnIndex < 0) return $([]);\n    return $([this[returnIndex]]);\n  }\n\n  return $([this[index]]);\n}\n\nfunction append() {\n  var newChild;\n  var document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();\n\n  for (var k = 0; k < arguments.length; k += 1) {\n    newChild = k < 0 || arguments.length <= k ? undefined : arguments[k];\n\n    for (var i = 0; i < this.length; i += 1) {\n      if (typeof newChild === 'string') {\n        var tempDiv = document.createElement('div');\n        tempDiv.innerHTML = newChild;\n\n        while (tempDiv.firstChild) {\n          this[i].appendChild(tempDiv.firstChild);\n        }\n      } else if (newChild instanceof Dom7) {\n        for (var j = 0; j < newChild.length; j += 1) {\n          this[i].appendChild(newChild[j]);\n        }\n      } else {\n        this[i].appendChild(newChild);\n      }\n    }\n  }\n\n  return this;\n}\n\nfunction appendTo(parent) {\n  $(parent).append(this);\n  return this;\n}\n\nfunction prepend(newChild) {\n  var document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();\n  var i;\n  var j;\n\n  for (i = 0; i < this.length; i += 1) {\n    if (typeof newChild === 'string') {\n      var tempDiv = document.createElement('div');\n      tempDiv.innerHTML = newChild;\n\n      for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {\n        this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);\n      }\n    } else if (newChild instanceof Dom7) {\n      for (j = 0; j < newChild.length; j += 1) {\n        this[i].insertBefore(newChild[j], this[i].childNodes[0]);\n      }\n    } else {\n      this[i].insertBefore(newChild, this[i].childNodes[0]);\n    }\n  }\n\n  return this;\n}\n\nfunction prependTo(parent) {\n  $(parent).prepend(this);\n  return this;\n}\n\nfunction insertBefore(selector) {\n  var before = $(selector);\n\n  for (var i = 0; i < this.length; i += 1) {\n    if (before.length === 1) {\n      before[0].parentNode.insertBefore(this[i], before[0]);\n    } else if (before.length > 1) {\n      for (var j = 0; j < before.length; j += 1) {\n        before[j].parentNode.insertBefore(this[i].cloneNode(true), before[j]);\n      }\n    }\n  }\n}\n\nfunction insertAfter(selector) {\n  var after = $(selector);\n\n  for (var i = 0; i < this.length; i += 1) {\n    if (after.length === 1) {\n      after[0].parentNode.insertBefore(this[i], after[0].nextSibling);\n    } else if (after.length > 1) {\n      for (var j = 0; j < after.length; j += 1) {\n        after[j].parentNode.insertBefore(this[i].cloneNode(true), after[j].nextSibling);\n      }\n    }\n  }\n}\n\nfunction next(selector) {\n  if (this.length > 0) {\n    if (selector) {\n      if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) {\n        return $([this[0].nextElementSibling]);\n      }\n\n      return $([]);\n    }\n\n    if (this[0].nextElementSibling) return $([this[0].nextElementSibling]);\n    return $([]);\n  }\n\n  return $([]);\n}\n\nfunction nextAll(selector) {\n  var nextEls = [];\n  var el = this[0];\n  if (!el) return $([]);\n\n  while (el.nextElementSibling) {\n    var _next = el.nextElementSibling; // eslint-disable-line\n\n    if (selector) {\n      if ($(_next).is(selector)) nextEls.push(_next);\n    } else nextEls.push(_next);\n\n    el = _next;\n  }\n\n  return $(nextEls);\n}\n\nfunction prev(selector) {\n  if (this.length > 0) {\n    var el = this[0];\n\n    if (selector) {\n      if (el.previousElementSibling && $(el.previousElementSibling).is(selector)) {\n        return $([el.previousElementSibling]);\n      }\n\n      return $([]);\n    }\n\n    if (el.previousElementSibling) return $([el.previousElementSibling]);\n    return $([]);\n  }\n\n  return $([]);\n}\n\nfunction prevAll(selector) {\n  var prevEls = [];\n  var el = this[0];\n  if (!el) return $([]);\n\n  while (el.previousElementSibling) {\n    var _prev = el.previousElementSibling; // eslint-disable-line\n\n    if (selector) {\n      if ($(_prev).is(selector)) prevEls.push(_prev);\n    } else prevEls.push(_prev);\n\n    el = _prev;\n  }\n\n  return $(prevEls);\n}\n\nfunction siblings(selector) {\n  return this.nextAll(selector).add(this.prevAll(selector));\n}\n\nfunction parent(selector) {\n  var parents = []; // eslint-disable-line\n\n  for (var i = 0; i < this.length; i += 1) {\n    if (this[i].parentNode !== null) {\n      if (selector) {\n        if ($(this[i].parentNode).is(selector)) parents.push(this[i].parentNode);\n      } else {\n        parents.push(this[i].parentNode);\n      }\n    }\n  }\n\n  return $(parents);\n}\n\nfunction parents(selector) {\n  var parents = []; // eslint-disable-line\n\n  for (var i = 0; i < this.length; i += 1) {\n    var _parent = this[i].parentNode; // eslint-disable-line\n\n    while (_parent) {\n      if (selector) {\n        if ($(_parent).is(selector)) parents.push(_parent);\n      } else {\n        parents.push(_parent);\n      }\n\n      _parent = _parent.parentNode;\n    }\n  }\n\n  return $(parents);\n}\n\nfunction closest(selector) {\n  var closest = this; // eslint-disable-line\n\n  if (typeof selector === 'undefined') {\n    return $([]);\n  }\n\n  if (!closest.is(selector)) {\n    closest = closest.parents(selector).eq(0);\n  }\n\n  return closest;\n}\n\nfunction find(selector) {\n  var foundElements = [];\n\n  for (var i = 0; i < this.length; i += 1) {\n    var found = this[i].querySelectorAll(selector);\n\n    for (var j = 0; j < found.length; j += 1) {\n      foundElements.push(found[j]);\n    }\n  }\n\n  return $(foundElements);\n}\n\nfunction children(selector) {\n  var children = []; // eslint-disable-line\n\n  for (var i = 0; i < this.length; i += 1) {\n    var childNodes = this[i].children;\n\n    for (var j = 0; j < childNodes.length; j += 1) {\n      if (!selector || $(childNodes[j]).is(selector)) {\n        children.push(childNodes[j]);\n      }\n    }\n  }\n\n  return $(children);\n}\n\nfunction remove() {\n  for (var i = 0; i < this.length; i += 1) {\n    if (this[i].parentNode) this[i].parentNode.removeChild(this[i]);\n  }\n\n  return this;\n}\n\nfunction detach() {\n  return this.remove();\n}\n\nfunction add() {\n  var dom = this;\n  var i;\n  var j;\n\n  for (var _len10 = arguments.length, els = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n    els[_key10] = arguments[_key10];\n  }\n\n  for (i = 0; i < els.length; i += 1) {\n    var toAdd = $(els[i]);\n\n    for (j = 0; j < toAdd.length; j += 1) {\n      dom.push(toAdd[j]);\n    }\n  }\n\n  return dom;\n}\n\nfunction empty() {\n  for (var i = 0; i < this.length; i += 1) {\n    var el = this[i];\n\n    if (el.nodeType === 1) {\n      for (var j = 0; j < el.childNodes.length; j += 1) {\n        if (el.childNodes[j].parentNode) {\n          el.childNodes[j].parentNode.removeChild(el.childNodes[j]);\n        }\n      }\n\n      el.textContent = '';\n    }\n  }\n\n  return this;\n}\n\nfunction scrollTo() {\n  var window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();\n\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  var left = args[0],\n      top = args[1],\n      duration = args[2],\n      easing = args[3],\n      callback = args[4];\n\n  if (args.length === 4 && typeof easing === 'function') {\n    callback = easing;\n    left = args[0];\n    top = args[1];\n    duration = args[2];\n    callback = args[3];\n    easing = args[4];\n  }\n\n  if (typeof easing === 'undefined') easing = 'swing';\n  return this.each(function animate() {\n    var el = this;\n    var currentTop;\n    var currentLeft;\n    var maxTop;\n    var maxLeft;\n    var newTop;\n    var newLeft;\n    var scrollTop; // eslint-disable-line\n\n    var scrollLeft; // eslint-disable-line\n\n    var animateTop = top > 0 || top === 0;\n    var animateLeft = left > 0 || left === 0;\n\n    if (typeof easing === 'undefined') {\n      easing = 'swing';\n    }\n\n    if (animateTop) {\n      currentTop = el.scrollTop;\n\n      if (!duration) {\n        el.scrollTop = top;\n      }\n    }\n\n    if (animateLeft) {\n      currentLeft = el.scrollLeft;\n\n      if (!duration) {\n        el.scrollLeft = left;\n      }\n    }\n\n    if (!duration) return;\n\n    if (animateTop) {\n      maxTop = el.scrollHeight - el.offsetHeight;\n      newTop = Math.max(Math.min(top, maxTop), 0);\n    }\n\n    if (animateLeft) {\n      maxLeft = el.scrollWidth - el.offsetWidth;\n      newLeft = Math.max(Math.min(left, maxLeft), 0);\n    }\n\n    var startTime = null;\n    if (animateTop && newTop === currentTop) animateTop = false;\n    if (animateLeft && newLeft === currentLeft) animateLeft = false;\n\n    function render(time) {\n      if (time === void 0) {\n        time = new Date().getTime();\n      }\n\n      if (startTime === null) {\n        startTime = time;\n      }\n\n      var progress = Math.max(Math.min((time - startTime) / duration, 1), 0);\n      var easeProgress = easing === 'linear' ? progress : 0.5 - Math.cos(progress * Math.PI) / 2;\n      var done;\n      if (animateTop) scrollTop = currentTop + easeProgress * (newTop - currentTop);\n      if (animateLeft) scrollLeft = currentLeft + easeProgress * (newLeft - currentLeft);\n\n      if (animateTop && newTop > currentTop && scrollTop >= newTop) {\n        el.scrollTop = newTop;\n        done = true;\n      }\n\n      if (animateTop && newTop < currentTop && scrollTop <= newTop) {\n        el.scrollTop = newTop;\n        done = true;\n      }\n\n      if (animateLeft && newLeft > currentLeft && scrollLeft >= newLeft) {\n        el.scrollLeft = newLeft;\n        done = true;\n      }\n\n      if (animateLeft && newLeft < currentLeft && scrollLeft <= newLeft) {\n        el.scrollLeft = newLeft;\n        done = true;\n      }\n\n      if (done) {\n        if (callback) callback();\n        return;\n      }\n\n      if (animateTop) el.scrollTop = scrollTop;\n      if (animateLeft) el.scrollLeft = scrollLeft;\n      window.requestAnimationFrame(render);\n    }\n\n    window.requestAnimationFrame(render);\n  });\n} // scrollTop(top, duration, easing, callback) {\n\n\nfunction scrollTop() {\n  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n\n  var top = args[0],\n      duration = args[1],\n      easing = args[2],\n      callback = args[3];\n\n  if (args.length === 3 && typeof easing === 'function') {\n    top = args[0];\n    duration = args[1];\n    callback = args[2];\n    easing = args[3];\n  }\n\n  var dom = this;\n\n  if (typeof top === 'undefined') {\n    if (dom.length > 0) return dom[0].scrollTop;\n    return null;\n  }\n\n  return dom.scrollTo(undefined, top, duration, easing, callback);\n}\n\nfunction scrollLeft() {\n  for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    args[_key3] = arguments[_key3];\n  }\n\n  var left = args[0],\n      duration = args[1],\n      easing = args[2],\n      callback = args[3];\n\n  if (args.length === 3 && typeof easing === 'function') {\n    left = args[0];\n    duration = args[1];\n    callback = args[2];\n    easing = args[3];\n  }\n\n  var dom = this;\n\n  if (typeof left === 'undefined') {\n    if (dom.length > 0) return dom[0].scrollLeft;\n    return null;\n  }\n\n  return dom.scrollTo(left, undefined, duration, easing, callback);\n}\n\nfunction animate(initialProps, initialParams) {\n  var window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();\n  var els = this;\n  var a = {\n    props: Object.assign({}, initialProps),\n    params: Object.assign({\n      duration: 300,\n      easing: 'swing' // or 'linear'\n\n      /* Callbacks\n      begin(elements)\n      complete(elements)\n      progress(elements, complete, remaining, start, tweenValue)\n      */\n\n    }, initialParams),\n    elements: els,\n    animating: false,\n    que: [],\n    easingProgress: function easingProgress(easing, progress) {\n      if (easing === 'swing') {\n        return 0.5 - Math.cos(progress * Math.PI) / 2;\n      }\n\n      if (typeof easing === 'function') {\n        return easing(progress);\n      }\n\n      return progress;\n    },\n    stop: function stop() {\n      if (a.frameId) {\n        window.cancelAnimationFrame(a.frameId);\n      }\n\n      a.animating = false;\n      a.elements.each(function (el) {\n        var element = el;\n        delete element.dom7AnimateInstance;\n      });\n      a.que = [];\n    },\n    done: function done(complete) {\n      a.animating = false;\n      a.elements.each(function (el) {\n        var element = el;\n        delete element.dom7AnimateInstance;\n      });\n      if (complete) complete(els);\n\n      if (a.que.length > 0) {\n        var que = a.que.shift();\n        a.animate(que[0], que[1]);\n      }\n    },\n    animate: function animate(props, params) {\n      if (a.animating) {\n        a.que.push([props, params]);\n        return a;\n      }\n\n      var elements = []; // Define & Cache Initials & Units\n\n      a.elements.each(function (el, index) {\n        var initialFullValue;\n        var initialValue;\n        var unit;\n        var finalValue;\n        var finalFullValue;\n        if (!el.dom7AnimateInstance) a.elements[index].dom7AnimateInstance = a;\n        elements[index] = {\n          container: el\n        };\n        Object.keys(props).forEach(function (prop) {\n          initialFullValue = window.getComputedStyle(el, null).getPropertyValue(prop).replace(',', '.');\n          initialValue = parseFloat(initialFullValue);\n          unit = initialFullValue.replace(initialValue, '');\n          finalValue = parseFloat(props[prop]);\n          finalFullValue = props[prop] + unit;\n          elements[index][prop] = {\n            initialFullValue: initialFullValue,\n            initialValue: initialValue,\n            unit: unit,\n            finalValue: finalValue,\n            finalFullValue: finalFullValue,\n            currentValue: initialValue\n          };\n        });\n      });\n      var startTime = null;\n      var time;\n      var elementsDone = 0;\n      var propsDone = 0;\n      var done;\n      var began = false;\n      a.animating = true;\n\n      function render() {\n        time = new Date().getTime();\n        var progress;\n        var easeProgress; // let el;\n\n        if (!began) {\n          began = true;\n          if (params.begin) params.begin(els);\n        }\n\n        if (startTime === null) {\n          startTime = time;\n        }\n\n        if (params.progress) {\n          // eslint-disable-next-line\n          params.progress(els, Math.max(Math.min((time - startTime) / params.duration, 1), 0), startTime + params.duration - time < 0 ? 0 : startTime + params.duration - time, startTime);\n        }\n\n        elements.forEach(function (element) {\n          var el = element;\n          if (done || el.done) return;\n          Object.keys(props).forEach(function (prop) {\n            if (done || el.done) return;\n            progress = Math.max(Math.min((time - startTime) / params.duration, 1), 0);\n            easeProgress = a.easingProgress(params.easing, progress);\n            var _el$prop = el[prop],\n                initialValue = _el$prop.initialValue,\n                finalValue = _el$prop.finalValue,\n                unit = _el$prop.unit;\n            el[prop].currentValue = initialValue + easeProgress * (finalValue - initialValue);\n            var currentValue = el[prop].currentValue;\n\n            if (finalValue > initialValue && currentValue >= finalValue || finalValue < initialValue && currentValue <= finalValue) {\n              el.container.style[prop] = finalValue + unit;\n              propsDone += 1;\n\n              if (propsDone === Object.keys(props).length) {\n                el.done = true;\n                elementsDone += 1;\n              }\n\n              if (elementsDone === elements.length) {\n                done = true;\n              }\n            }\n\n            if (done) {\n              a.done(params.complete);\n              return;\n            }\n\n            el.container.style[prop] = currentValue + unit;\n          });\n        });\n        if (done) return; // Then call\n\n        a.frameId = window.requestAnimationFrame(render);\n      }\n\n      a.frameId = window.requestAnimationFrame(render);\n      return a;\n    }\n  };\n\n  if (a.elements.length === 0) {\n    return els;\n  }\n\n  var animateInstance;\n\n  for (var i = 0; i < a.elements.length; i += 1) {\n    if (a.elements[i].dom7AnimateInstance) {\n      animateInstance = a.elements[i].dom7AnimateInstance;\n    } else a.elements[i].dom7AnimateInstance = a;\n  }\n\n  if (!animateInstance) {\n    animateInstance = a;\n  }\n\n  if (initialProps === 'stop') {\n    animateInstance.stop();\n  } else {\n    animateInstance.animate(a.props, a.params);\n  }\n\n  return els;\n}\n\nfunction stop() {\n  var els = this;\n\n  for (var i = 0; i < els.length; i += 1) {\n    if (els[i].dom7AnimateInstance) {\n      els[i].dom7AnimateInstance.stop();\n    }\n  }\n}\n\nvar noTrigger = 'resize scroll'.split(' ');\n\nfunction shortcut(name) {\n  function eventHandler() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    if (typeof args[0] === 'undefined') {\n      for (var i = 0; i < this.length; i += 1) {\n        if (noTrigger.indexOf(name) < 0) {\n          if (name in this[i]) this[i][name]();else {\n            $(this[i]).trigger(name);\n          }\n        }\n      }\n\n      return this;\n    }\n\n    return this.on.apply(this, [name].concat(args));\n  }\n\n  return eventHandler;\n}\n\nvar click = shortcut('click');\nvar blur = shortcut('blur');\nvar focus = shortcut('focus');\nvar focusin = shortcut('focusin');\nvar focusout = shortcut('focusout');\nvar keyup = shortcut('keyup');\nvar keydown = shortcut('keydown');\nvar keypress = shortcut('keypress');\nvar submit = shortcut('submit');\nvar change = shortcut('change');\nvar mousedown = shortcut('mousedown');\nvar mousemove = shortcut('mousemove');\nvar mouseup = shortcut('mouseup');\nvar mouseenter = shortcut('mouseenter');\nvar mouseleave = shortcut('mouseleave');\nvar mouseout = shortcut('mouseout');\nvar mouseover = shortcut('mouseover');\nvar touchstart = shortcut('touchstart');\nvar touchend = shortcut('touchend');\nvar touchmove = shortcut('touchmove');\nvar resize = shortcut('resize');\nvar scroll = shortcut('scroll');\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ($);\n\n\n\n//# sourceURL=webpack://parus/./node_modules/dom7/dom7.esm.js?");

/***/ }),

/***/ "./node_modules/ssr-window/ssr-window.esm.js":
/*!***************************************************!*\
  !*** ./node_modules/ssr-window/ssr-window.esm.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   extend: () => (/* binding */ extend),\n/* harmony export */   getDocument: () => (/* binding */ getDocument),\n/* harmony export */   getWindow: () => (/* binding */ getWindow),\n/* harmony export */   ssrDocument: () => (/* binding */ ssrDocument),\n/* harmony export */   ssrWindow: () => (/* binding */ ssrWindow)\n/* harmony export */ });\n/**\n * SSR Window 3.0.0\n * Better handling for window object in SSR environment\n * https://github.com/nolimits4web/ssr-window\n *\n * Copyright 2020, Vladimir Kharlampidi\n *\n * Licensed under MIT\n *\n * Released on: November 9, 2020\n */\n/* eslint-disable no-param-reassign */\nfunction isObject(obj) {\n    return (obj !== null &&\n        typeof obj === 'object' &&\n        'constructor' in obj &&\n        obj.constructor === Object);\n}\nfunction extend(target, src) {\n    if (target === void 0) { target = {}; }\n    if (src === void 0) { src = {}; }\n    Object.keys(src).forEach(function (key) {\n        if (typeof target[key] === 'undefined')\n            target[key] = src[key];\n        else if (isObject(src[key]) &&\n            isObject(target[key]) &&\n            Object.keys(src[key]).length > 0) {\n            extend(target[key], src[key]);\n        }\n    });\n}\n\nvar ssrDocument = {\n    body: {},\n    addEventListener: function () { },\n    removeEventListener: function () { },\n    activeElement: {\n        blur: function () { },\n        nodeName: '',\n    },\n    querySelector: function () {\n        return null;\n    },\n    querySelectorAll: function () {\n        return [];\n    },\n    getElementById: function () {\n        return null;\n    },\n    createEvent: function () {\n        return {\n            initEvent: function () { },\n        };\n    },\n    createElement: function () {\n        return {\n            children: [],\n            childNodes: [],\n            style: {},\n            setAttribute: function () { },\n            getElementsByTagName: function () {\n                return [];\n            },\n        };\n    },\n    createElementNS: function () {\n        return {};\n    },\n    importNode: function () {\n        return null;\n    },\n    location: {\n        hash: '',\n        host: '',\n        hostname: '',\n        href: '',\n        origin: '',\n        pathname: '',\n        protocol: '',\n        search: '',\n    },\n};\nfunction getDocument() {\n    var doc = typeof document !== 'undefined' ? document : {};\n    extend(doc, ssrDocument);\n    return doc;\n}\n\nvar ssrWindow = {\n    document: ssrDocument,\n    navigator: {\n        userAgent: '',\n    },\n    location: {\n        hash: '',\n        host: '',\n        hostname: '',\n        href: '',\n        origin: '',\n        pathname: '',\n        protocol: '',\n        search: '',\n    },\n    history: {\n        replaceState: function () { },\n        pushState: function () { },\n        go: function () { },\n        back: function () { },\n    },\n    CustomEvent: function CustomEvent() {\n        return this;\n    },\n    addEventListener: function () { },\n    removeEventListener: function () { },\n    getComputedStyle: function () {\n        return {\n            getPropertyValue: function () {\n                return '';\n            },\n        };\n    },\n    Image: function () { },\n    Date: function () { },\n    screen: {},\n    setTimeout: function () { },\n    clearTimeout: function () { },\n    matchMedia: function () {\n        return {};\n    },\n    requestAnimationFrame: function (callback) {\n        if (typeof setTimeout === 'undefined') {\n            callback();\n            return null;\n        }\n        return setTimeout(callback, 0);\n    },\n    cancelAnimationFrame: function (id) {\n        if (typeof setTimeout === 'undefined') {\n            return;\n        }\n        clearTimeout(id);\n    },\n};\nfunction getWindow() {\n    var win = typeof window !== 'undefined' ? window : {};\n    extend(win, ssrWindow);\n    return win;\n}\n\n\n\n\n//# sourceURL=webpack://parus/./node_modules/ssr-window/ssr-window.esm.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/components/autoplay/autoplay.js":
/*!*****************************************************************!*\
  !*** ./node_modules/swiper/esm/components/autoplay/autoplay.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ \"./node_modules/ssr-window/ssr-window.esm.js\");\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/utils */ \"./node_modules/swiper/esm/utils/utils.js\");\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\n/* eslint no-underscore-dangle: \"off\" */\n\n\nvar Autoplay = {\n  run: function run() {\n    var swiper = this;\n    var $activeSlideEl = swiper.slides.eq(swiper.activeIndex);\n    var delay = swiper.params.autoplay.delay;\n\n    if ($activeSlideEl.attr('data-swiper-autoplay')) {\n      delay = $activeSlideEl.attr('data-swiper-autoplay') || swiper.params.autoplay.delay;\n    }\n\n    clearTimeout(swiper.autoplay.timeout);\n    swiper.autoplay.timeout = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.nextTick)(function () {\n      var autoplayResult;\n\n      if (swiper.params.autoplay.reverseDirection) {\n        if (swiper.params.loop) {\n          swiper.loopFix();\n          autoplayResult = swiper.slidePrev(swiper.params.speed, true, true);\n          swiper.emit('autoplay');\n        } else if (!swiper.isBeginning) {\n          autoplayResult = swiper.slidePrev(swiper.params.speed, true, true);\n          swiper.emit('autoplay');\n        } else if (!swiper.params.autoplay.stopOnLastSlide) {\n          autoplayResult = swiper.slideTo(swiper.slides.length - 1, swiper.params.speed, true, true);\n          swiper.emit('autoplay');\n        } else {\n          swiper.autoplay.stop();\n        }\n      } else if (swiper.params.loop) {\n        swiper.loopFix();\n        autoplayResult = swiper.slideNext(swiper.params.speed, true, true);\n        swiper.emit('autoplay');\n      } else if (!swiper.isEnd) {\n        autoplayResult = swiper.slideNext(swiper.params.speed, true, true);\n        swiper.emit('autoplay');\n      } else if (!swiper.params.autoplay.stopOnLastSlide) {\n        autoplayResult = swiper.slideTo(0, swiper.params.speed, true, true);\n        swiper.emit('autoplay');\n      } else {\n        swiper.autoplay.stop();\n      }\n\n      if (swiper.params.cssMode && swiper.autoplay.running) swiper.autoplay.run();else if (autoplayResult === false) {\n        swiper.autoplay.run();\n      }\n    }, delay);\n  },\n  start: function start() {\n    var swiper = this;\n    if (typeof swiper.autoplay.timeout !== 'undefined') return false;\n    if (swiper.autoplay.running) return false;\n    swiper.autoplay.running = true;\n    swiper.emit('autoplayStart');\n    swiper.autoplay.run();\n    return true;\n  },\n  stop: function stop() {\n    var swiper = this;\n    if (!swiper.autoplay.running) return false;\n    if (typeof swiper.autoplay.timeout === 'undefined') return false;\n\n    if (swiper.autoplay.timeout) {\n      clearTimeout(swiper.autoplay.timeout);\n      swiper.autoplay.timeout = undefined;\n    }\n\n    swiper.autoplay.running = false;\n    swiper.emit('autoplayStop');\n    return true;\n  },\n  pause: function pause(speed) {\n    var swiper = this;\n    if (!swiper.autoplay.running) return;\n    if (swiper.autoplay.paused) return;\n    if (swiper.autoplay.timeout) clearTimeout(swiper.autoplay.timeout);\n    swiper.autoplay.paused = true;\n\n    if (speed === 0 || !swiper.params.autoplay.waitForTransition) {\n      swiper.autoplay.paused = false;\n      swiper.autoplay.run();\n    } else {\n      ['transitionend', 'webkitTransitionEnd'].forEach(function (event) {\n        swiper.$wrapperEl[0].addEventListener(event, swiper.autoplay.onTransitionEnd);\n      });\n    }\n  },\n  onVisibilityChange: function onVisibilityChange() {\n    var swiper = this;\n    var document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();\n\n    if (document.visibilityState === 'hidden' && swiper.autoplay.running) {\n      swiper.autoplay.pause();\n    }\n\n    if (document.visibilityState === 'visible' && swiper.autoplay.paused) {\n      swiper.autoplay.run();\n      swiper.autoplay.paused = false;\n    }\n  },\n  onTransitionEnd: function onTransitionEnd(e) {\n    var swiper = this;\n    if (!swiper || swiper.destroyed || !swiper.$wrapperEl) return;\n    if (e.target !== swiper.$wrapperEl[0]) return;\n    ['transitionend', 'webkitTransitionEnd'].forEach(function (event) {\n      swiper.$wrapperEl[0].removeEventListener(event, swiper.autoplay.onTransitionEnd);\n    });\n    swiper.autoplay.paused = false;\n\n    if (!swiper.autoplay.running) {\n      swiper.autoplay.stop();\n    } else {\n      swiper.autoplay.run();\n    }\n  },\n  onMouseEnter: function onMouseEnter() {\n    var swiper = this;\n\n    if (swiper.params.autoplay.disableOnInteraction) {\n      swiper.autoplay.stop();\n    } else {\n      swiper.autoplay.pause();\n    }\n\n    ['transitionend', 'webkitTransitionEnd'].forEach(function (event) {\n      swiper.$wrapperEl[0].removeEventListener(event, swiper.autoplay.onTransitionEnd);\n    });\n  },\n  onMouseLeave: function onMouseLeave() {\n    var swiper = this;\n\n    if (swiper.params.autoplay.disableOnInteraction) {\n      return;\n    }\n\n    swiper.autoplay.paused = false;\n    swiper.autoplay.run();\n  },\n  attachMouseEvents: function attachMouseEvents() {\n    var swiper = this;\n\n    if (swiper.params.autoplay.pauseOnMouseEnter) {\n      swiper.$el.on('mouseenter', swiper.autoplay.onMouseEnter);\n      swiper.$el.on('mouseleave', swiper.autoplay.onMouseLeave);\n    }\n  },\n  detachMouseEvents: function detachMouseEvents() {\n    var swiper = this;\n    swiper.$el.off('mouseenter', swiper.autoplay.onMouseEnter);\n    swiper.$el.off('mouseleave', swiper.autoplay.onMouseLeave);\n  }\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  name: 'autoplay',\n  params: {\n    autoplay: {\n      enabled: false,\n      delay: 3000,\n      waitForTransition: true,\n      disableOnInteraction: true,\n      stopOnLastSlide: false,\n      reverseDirection: false,\n      pauseOnMouseEnter: false\n    }\n  },\n  create: function create() {\n    var swiper = this;\n    (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.bindModuleMethods)(swiper, {\n      autoplay: _extends({}, Autoplay, {\n        running: false,\n        paused: false\n      })\n    });\n  },\n  on: {\n    init: function init(swiper) {\n      if (swiper.params.autoplay.enabled) {\n        swiper.autoplay.start();\n        var document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();\n        document.addEventListener('visibilitychange', swiper.autoplay.onVisibilityChange);\n        swiper.autoplay.attachMouseEvents();\n      }\n    },\n    beforeTransitionStart: function beforeTransitionStart(swiper, speed, internal) {\n      if (swiper.autoplay.running) {\n        if (internal || !swiper.params.autoplay.disableOnInteraction) {\n          swiper.autoplay.pause(speed);\n        } else {\n          swiper.autoplay.stop();\n        }\n      }\n    },\n    sliderFirstMove: function sliderFirstMove(swiper) {\n      if (swiper.autoplay.running) {\n        if (swiper.params.autoplay.disableOnInteraction) {\n          swiper.autoplay.stop();\n        } else {\n          swiper.autoplay.pause();\n        }\n      }\n    },\n    touchEnd: function touchEnd(swiper) {\n      if (swiper.params.cssMode && swiper.autoplay.paused && !swiper.params.autoplay.disableOnInteraction) {\n        swiper.autoplay.run();\n      }\n    },\n    destroy: function destroy(swiper) {\n      swiper.autoplay.detachMouseEvents();\n\n      if (swiper.autoplay.running) {\n        swiper.autoplay.stop();\n      }\n\n      var document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();\n      document.removeEventListener('visibilitychange', swiper.autoplay.onVisibilityChange);\n    }\n  }\n});\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/components/autoplay/autoplay.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/components/core/breakpoints/getBreakpoint.js":
/*!******************************************************************************!*\
  !*** ./node_modules/swiper/esm/components/core/breakpoints/getBreakpoint.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getBreakpoint)\n/* harmony export */ });\n/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ \"./node_modules/ssr-window/ssr-window.esm.js\");\n\nfunction getBreakpoint(breakpoints, base, containerEl) {\n  if (base === void 0) {\n    base = 'window';\n  }\n\n  if (!breakpoints || base === 'container' && !containerEl) return undefined;\n  var breakpoint = false;\n  var window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();\n  var currentHeight = base === 'window' ? window.innerHeight : containerEl.clientHeight;\n  var points = Object.keys(breakpoints).map(function (point) {\n    if (typeof point === 'string' && point.indexOf('@') === 0) {\n      var minRatio = parseFloat(point.substr(1));\n      var value = currentHeight * minRatio;\n      return {\n        value: value,\n        point: point\n      };\n    }\n\n    return {\n      value: point,\n      point: point\n    };\n  });\n  points.sort(function (a, b) {\n    return parseInt(a.value, 10) - parseInt(b.value, 10);\n  });\n\n  for (var i = 0; i < points.length; i += 1) {\n    var _points$i = points[i],\n        point = _points$i.point,\n        value = _points$i.value;\n\n    if (base === 'window') {\n      if (window.matchMedia(\"(min-width: \" + value + \"px)\").matches) {\n        breakpoint = point;\n      }\n    } else if (value <= containerEl.clientWidth) {\n      breakpoint = point;\n    }\n  }\n\n  return breakpoint || 'max';\n}\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/components/core/breakpoints/getBreakpoint.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/components/core/breakpoints/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/swiper/esm/components/core/breakpoints/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _setBreakpoint__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./setBreakpoint */ \"./node_modules/swiper/esm/components/core/breakpoints/setBreakpoint.js\");\n/* harmony import */ var _getBreakpoint__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getBreakpoint */ \"./node_modules/swiper/esm/components/core/breakpoints/getBreakpoint.js\");\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  setBreakpoint: _setBreakpoint__WEBPACK_IMPORTED_MODULE_0__[\"default\"],\n  getBreakpoint: _getBreakpoint__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\n});\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/components/core/breakpoints/index.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/components/core/breakpoints/setBreakpoint.js":
/*!******************************************************************************!*\
  !*** ./node_modules/swiper/esm/components/core/breakpoints/setBreakpoint.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ setBreakpoint)\n/* harmony export */ });\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../utils/utils */ \"./node_modules/swiper/esm/utils/utils.js\");\n\nfunction setBreakpoint() {\n  var swiper = this;\n  var activeIndex = swiper.activeIndex,\n      initialized = swiper.initialized,\n      _swiper$loopedSlides = swiper.loopedSlides,\n      loopedSlides = _swiper$loopedSlides === void 0 ? 0 : _swiper$loopedSlides,\n      params = swiper.params,\n      $el = swiper.$el;\n  var breakpoints = params.breakpoints;\n  if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0) return; // Get breakpoint for window width and update parameters\n\n  var breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);\n  if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;\n  var breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;\n\n  if (breakpointOnlyParams) {\n    ['slidesPerView', 'spaceBetween', 'slidesPerGroup', 'slidesPerGroupSkip', 'slidesPerColumn'].forEach(function (param) {\n      var paramValue = breakpointOnlyParams[param];\n      if (typeof paramValue === 'undefined') return;\n\n      if (param === 'slidesPerView' && (paramValue === 'AUTO' || paramValue === 'auto')) {\n        breakpointOnlyParams[param] = 'auto';\n      } else if (param === 'slidesPerView') {\n        breakpointOnlyParams[param] = parseFloat(paramValue);\n      } else {\n        breakpointOnlyParams[param] = parseInt(paramValue, 10);\n      }\n    });\n  }\n\n  var breakpointParams = breakpointOnlyParams || swiper.originalParams;\n  var wasMultiRow = params.slidesPerColumn > 1;\n  var isMultiRow = breakpointParams.slidesPerColumn > 1;\n  var wasEnabled = params.enabled;\n\n  if (wasMultiRow && !isMultiRow) {\n    $el.removeClass(params.containerModifierClass + \"multirow \" + params.containerModifierClass + \"multirow-column\");\n    swiper.emitContainerClasses();\n  } else if (!wasMultiRow && isMultiRow) {\n    $el.addClass(params.containerModifierClass + \"multirow\");\n\n    if (breakpointParams.slidesPerColumnFill && breakpointParams.slidesPerColumnFill === 'column' || !breakpointParams.slidesPerColumnFill && params.slidesPerColumnFill === 'column') {\n      $el.addClass(params.containerModifierClass + \"multirow-column\");\n    }\n\n    swiper.emitContainerClasses();\n  }\n\n  var directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;\n  var needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);\n\n  if (directionChanged && initialized) {\n    swiper.changeDirection();\n  }\n\n  (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.extend)(swiper.params, breakpointParams);\n  var isEnabled = swiper.params.enabled;\n  (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.extend)(swiper, {\n    allowTouchMove: swiper.params.allowTouchMove,\n    allowSlideNext: swiper.params.allowSlideNext,\n    allowSlidePrev: swiper.params.allowSlidePrev\n  });\n\n  if (wasEnabled && !isEnabled) {\n    swiper.disable();\n  } else if (!wasEnabled && isEnabled) {\n    swiper.enable();\n  }\n\n  swiper.currentBreakpoint = breakpoint;\n  swiper.emit('_beforeBreakpoint', breakpointParams);\n\n  if (needsReLoop && initialized) {\n    swiper.loopDestroy();\n    swiper.loopCreate();\n    swiper.updateSlides();\n    swiper.slideTo(activeIndex - loopedSlides + swiper.loopedSlides, 0, false);\n  }\n\n  swiper.emit('breakpoint', breakpointParams);\n}\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/components/core/breakpoints/setBreakpoint.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/components/core/check-overflow/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/swiper/esm/components/core/check-overflow/index.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction checkOverflow() {\n  var swiper = this;\n  var params = swiper.params;\n  var wasLocked = swiper.isLocked;\n  var lastSlidePosition = swiper.slides.length > 0 && params.slidesOffsetBefore + params.spaceBetween * (swiper.slides.length - 1) + swiper.slides[0].offsetWidth * swiper.slides.length;\n\n  if (params.slidesOffsetBefore && params.slidesOffsetAfter && lastSlidePosition) {\n    swiper.isLocked = lastSlidePosition <= swiper.size;\n  } else {\n    swiper.isLocked = swiper.snapGrid.length === 1;\n  }\n\n  swiper.allowSlideNext = !swiper.isLocked;\n  swiper.allowSlidePrev = !swiper.isLocked; // events\n\n  if (wasLocked !== swiper.isLocked) swiper.emit(swiper.isLocked ? 'lock' : 'unlock');\n\n  if (wasLocked && wasLocked !== swiper.isLocked) {\n    swiper.isEnd = false;\n    if (swiper.navigation) swiper.navigation.update();\n  }\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  checkOverflow: checkOverflow\n});\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/components/core/check-overflow/index.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/components/core/classes/addClasses.js":
/*!***********************************************************************!*\
  !*** ./node_modules/swiper/esm/components/core/classes/addClasses.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ addClasses)\n/* harmony export */ });\nfunction prepareClasses(entries, prefix) {\n  var resultClasses = [];\n  entries.forEach(function (item) {\n    if (typeof item === 'object') {\n      Object.keys(item).forEach(function (classNames) {\n        if (item[classNames]) {\n          resultClasses.push(prefix + classNames);\n        }\n      });\n    } else if (typeof item === 'string') {\n      resultClasses.push(prefix + item);\n    }\n  });\n  return resultClasses;\n}\n\nfunction addClasses() {\n  var swiper = this;\n  var classNames = swiper.classNames,\n      params = swiper.params,\n      rtl = swiper.rtl,\n      $el = swiper.$el,\n      device = swiper.device,\n      support = swiper.support; // prettier-ignore\n\n  var suffixes = prepareClasses(['initialized', params.direction, {\n    'pointer-events': support.pointerEvents && !support.touch\n  }, {\n    'free-mode': params.freeMode\n  }, {\n    'autoheight': params.autoHeight\n  }, {\n    'rtl': rtl\n  }, {\n    'multirow': params.slidesPerColumn > 1\n  }, {\n    'multirow-column': params.slidesPerColumn > 1 && params.slidesPerColumnFill === 'column'\n  }, {\n    'android': device.android\n  }, {\n    'ios': device.ios\n  }, {\n    'css-mode': params.cssMode\n  }], params.containerModifierClass);\n  classNames.push.apply(classNames, suffixes);\n  $el.addClass([].concat(classNames).join(' '));\n  swiper.emitContainerClasses();\n}\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/components/core/classes/addClasses.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/components/core/classes/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/swiper/esm/components/core/classes/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _addClasses__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./addClasses */ \"./node_modules/swiper/esm/components/core/classes/addClasses.js\");\n/* harmony import */ var _removeClasses__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./removeClasses */ \"./node_modules/swiper/esm/components/core/classes/removeClasses.js\");\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  addClasses: _addClasses__WEBPACK_IMPORTED_MODULE_0__[\"default\"],\n  removeClasses: _removeClasses__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\n});\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/components/core/classes/index.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/components/core/classes/removeClasses.js":
/*!**************************************************************************!*\
  !*** ./node_modules/swiper/esm/components/core/classes/removeClasses.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ removeClasses)\n/* harmony export */ });\nfunction removeClasses() {\n  var swiper = this;\n  var $el = swiper.$el,\n      classNames = swiper.classNames;\n  $el.removeClass(classNames.join(' '));\n  swiper.emitContainerClasses();\n}\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/components/core/classes/removeClasses.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/components/core/core-class.js":
/*!***************************************************************!*\
  !*** ./node_modules/swiper/esm/components/core/core-class.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ \"./node_modules/ssr-window/ssr-window.esm.js\");\n/* harmony import */ var _utils_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/dom */ \"./node_modules/swiper/esm/utils/dom.js\");\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../../utils/utils */ \"./node_modules/swiper/esm/utils/utils.js\");\n/* harmony import */ var _utils_get_support__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../../utils/get-support */ \"./node_modules/swiper/esm/utils/get-support.js\");\n/* harmony import */ var _utils_get_device__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../../utils/get-device */ \"./node_modules/swiper/esm/utils/get-device.js\");\n/* harmony import */ var _utils_get_browser__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../../utils/get-browser */ \"./node_modules/swiper/esm/utils/get-browser.js\");\n/* harmony import */ var _modules_resize_resize__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../../modules/resize/resize */ \"./node_modules/swiper/esm/modules/resize/resize.js\");\n/* harmony import */ var _modules_observer_observer__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../../modules/observer/observer */ \"./node_modules/swiper/esm/modules/observer/observer.js\");\n/* harmony import */ var _modular__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modular */ \"./node_modules/swiper/esm/components/core/modular.js\");\n/* harmony import */ var _events_emitter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./events-emitter */ \"./node_modules/swiper/esm/components/core/events-emitter.js\");\n/* harmony import */ var _update_index__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./update/index */ \"./node_modules/swiper/esm/components/core/update/index.js\");\n/* harmony import */ var _translate_index__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./translate/index */ \"./node_modules/swiper/esm/components/core/translate/index.js\");\n/* harmony import */ var _transition_index__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./transition/index */ \"./node_modules/swiper/esm/components/core/transition/index.js\");\n/* harmony import */ var _slide_index__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./slide/index */ \"./node_modules/swiper/esm/components/core/slide/index.js\");\n/* harmony import */ var _loop_index__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./loop/index */ \"./node_modules/swiper/esm/components/core/loop/index.js\");\n/* harmony import */ var _grab_cursor_index__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./grab-cursor/index */ \"./node_modules/swiper/esm/components/core/grab-cursor/index.js\");\n/* harmony import */ var _manipulation_index__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./manipulation/index */ \"./node_modules/swiper/esm/components/core/manipulation/index.js\");\n/* harmony import */ var _events_index__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./events/index */ \"./node_modules/swiper/esm/components/core/events/index.js\");\n/* harmony import */ var _breakpoints_index__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./breakpoints/index */ \"./node_modules/swiper/esm/components/core/breakpoints/index.js\");\n/* harmony import */ var _classes_index__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./classes/index */ \"./node_modules/swiper/esm/components/core/classes/index.js\");\n/* harmony import */ var _images_index__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./images/index */ \"./node_modules/swiper/esm/components/core/images/index.js\");\n/* harmony import */ var _check_overflow_index__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./check-overflow/index */ \"./node_modules/swiper/esm/components/core/check-overflow/index.js\");\n/* harmony import */ var _defaults__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./defaults */ \"./node_modules/swiper/esm/components/core/defaults.js\");\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/* eslint no-param-reassign: \"off\" */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar prototypes = {\n  modular: _modular__WEBPACK_IMPORTED_MODULE_2__[\"default\"],\n  eventsEmitter: _events_emitter__WEBPACK_IMPORTED_MODULE_3__[\"default\"],\n  update: _update_index__WEBPACK_IMPORTED_MODULE_4__[\"default\"],\n  translate: _translate_index__WEBPACK_IMPORTED_MODULE_5__[\"default\"],\n  transition: _transition_index__WEBPACK_IMPORTED_MODULE_6__[\"default\"],\n  slide: _slide_index__WEBPACK_IMPORTED_MODULE_7__[\"default\"],\n  loop: _loop_index__WEBPACK_IMPORTED_MODULE_8__[\"default\"],\n  grabCursor: _grab_cursor_index__WEBPACK_IMPORTED_MODULE_9__[\"default\"],\n  manipulation: _manipulation_index__WEBPACK_IMPORTED_MODULE_10__[\"default\"],\n  events: _events_index__WEBPACK_IMPORTED_MODULE_11__[\"default\"],\n  breakpoints: _breakpoints_index__WEBPACK_IMPORTED_MODULE_12__[\"default\"],\n  checkOverflow: _check_overflow_index__WEBPACK_IMPORTED_MODULE_13__[\"default\"],\n  classes: _classes_index__WEBPACK_IMPORTED_MODULE_14__[\"default\"],\n  images: _images_index__WEBPACK_IMPORTED_MODULE_15__[\"default\"]\n};\nvar extendedDefaults = {};\n\nvar Swiper = /*#__PURE__*/function () {\n  function Swiper() {\n    var el;\n    var params;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === 'Object') {\n      params = args[0];\n    } else {\n      el = args[0];\n      params = args[1];\n    }\n\n    if (!params) params = {};\n    params = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_16__.extend)({}, params);\n    if (el && !params.el) params.el = el;\n\n    if (params.el && (0,_utils_dom__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(params.el).length > 1) {\n      var swipers = [];\n      (0,_utils_dom__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(params.el).each(function (containerEl) {\n        var newParams = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_16__.extend)({}, params, {\n          el: containerEl\n        });\n        swipers.push(new Swiper(newParams));\n      });\n      return swipers;\n    } // Swiper Instance\n\n\n    var swiper = this;\n    swiper.__swiper__ = true;\n    swiper.support = (0,_utils_get_support__WEBPACK_IMPORTED_MODULE_17__.getSupport)();\n    swiper.device = (0,_utils_get_device__WEBPACK_IMPORTED_MODULE_18__.getDevice)({\n      userAgent: params.userAgent\n    });\n    swiper.browser = (0,_utils_get_browser__WEBPACK_IMPORTED_MODULE_19__.getBrowser)();\n    swiper.eventsListeners = {};\n    swiper.eventsAnyListeners = [];\n\n    if (typeof swiper.modules === 'undefined') {\n      swiper.modules = {};\n    }\n\n    Object.keys(swiper.modules).forEach(function (moduleName) {\n      var module = swiper.modules[moduleName];\n\n      if (module.params) {\n        var moduleParamName = Object.keys(module.params)[0];\n        var moduleParams = module.params[moduleParamName];\n        if (typeof moduleParams !== 'object' || moduleParams === null) return;\n\n        if (['navigation', 'pagination', 'scrollbar'].indexOf(moduleParamName) >= 0 && params[moduleParamName] === true) {\n          params[moduleParamName] = {\n            auto: true\n          };\n        }\n\n        if (!(moduleParamName in params && 'enabled' in moduleParams)) return;\n\n        if (params[moduleParamName] === true) {\n          params[moduleParamName] = {\n            enabled: true\n          };\n        }\n\n        if (typeof params[moduleParamName] === 'object' && !('enabled' in params[moduleParamName])) {\n          params[moduleParamName].enabled = true;\n        }\n\n        if (!params[moduleParamName]) params[moduleParamName] = {\n          enabled: false\n        };\n      }\n    }); // Extend defaults with modules params\n\n    var swiperParams = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_16__.extend)({}, _defaults__WEBPACK_IMPORTED_MODULE_20__[\"default\"]);\n    swiper.useParams(swiperParams); // Extend defaults with passed params\n\n    swiper.params = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_16__.extend)({}, swiperParams, extendedDefaults, params);\n    swiper.originalParams = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_16__.extend)({}, swiper.params);\n    swiper.passedParams = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_16__.extend)({}, params); // add event listeners\n\n    if (swiper.params && swiper.params.on) {\n      Object.keys(swiper.params.on).forEach(function (eventName) {\n        swiper.on(eventName, swiper.params.on[eventName]);\n      });\n    }\n\n    if (swiper.params && swiper.params.onAny) {\n      swiper.onAny(swiper.params.onAny);\n    } // Save Dom lib\n\n\n    swiper.$ = _utils_dom__WEBPACK_IMPORTED_MODULE_1__[\"default\"]; // Extend Swiper\n\n    (0,_utils_utils__WEBPACK_IMPORTED_MODULE_16__.extend)(swiper, {\n      enabled: swiper.params.enabled,\n      el: el,\n      // Classes\n      classNames: [],\n      // Slides\n      slides: (0,_utils_dom__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(),\n      slidesGrid: [],\n      snapGrid: [],\n      slidesSizesGrid: [],\n      // isDirection\n      isHorizontal: function isHorizontal() {\n        return swiper.params.direction === 'horizontal';\n      },\n      isVertical: function isVertical() {\n        return swiper.params.direction === 'vertical';\n      },\n      // Indexes\n      activeIndex: 0,\n      realIndex: 0,\n      //\n      isBeginning: true,\n      isEnd: false,\n      // Props\n      translate: 0,\n      previousTranslate: 0,\n      progress: 0,\n      velocity: 0,\n      animating: false,\n      // Locks\n      allowSlideNext: swiper.params.allowSlideNext,\n      allowSlidePrev: swiper.params.allowSlidePrev,\n      // Touch Events\n      touchEvents: function touchEvents() {\n        var touch = ['touchstart', 'touchmove', 'touchend', 'touchcancel'];\n        var desktop = ['mousedown', 'mousemove', 'mouseup'];\n\n        if (swiper.support.pointerEvents) {\n          desktop = ['pointerdown', 'pointermove', 'pointerup'];\n        }\n\n        swiper.touchEventsTouch = {\n          start: touch[0],\n          move: touch[1],\n          end: touch[2],\n          cancel: touch[3]\n        };\n        swiper.touchEventsDesktop = {\n          start: desktop[0],\n          move: desktop[1],\n          end: desktop[2]\n        };\n        return swiper.support.touch || !swiper.params.simulateTouch ? swiper.touchEventsTouch : swiper.touchEventsDesktop;\n      }(),\n      touchEventsData: {\n        isTouched: undefined,\n        isMoved: undefined,\n        allowTouchCallbacks: undefined,\n        touchStartTime: undefined,\n        isScrolling: undefined,\n        currentTranslate: undefined,\n        startTranslate: undefined,\n        allowThresholdMove: undefined,\n        // Form elements to match\n        focusableElements: swiper.params.focusableElements,\n        // Last click time\n        lastClickTime: (0,_utils_utils__WEBPACK_IMPORTED_MODULE_16__.now)(),\n        clickTimeout: undefined,\n        // Velocities\n        velocities: [],\n        allowMomentumBounce: undefined,\n        isTouchEvent: undefined,\n        startMoving: undefined\n      },\n      // Clicks\n      allowClick: true,\n      // Touches\n      allowTouchMove: swiper.params.allowTouchMove,\n      touches: {\n        startX: 0,\n        startY: 0,\n        currentX: 0,\n        currentY: 0,\n        diff: 0\n      },\n      // Images\n      imagesToLoad: [],\n      imagesLoaded: 0\n    }); // Install Modules\n\n    swiper.useModules();\n    swiper.emit('_swiper'); // Init\n\n    if (swiper.params.init) {\n      swiper.init();\n    } // Return app instance\n\n\n    return swiper;\n  }\n\n  var _proto = Swiper.prototype;\n\n  _proto.enable = function enable() {\n    var swiper = this;\n    if (swiper.enabled) return;\n    swiper.enabled = true;\n\n    if (swiper.params.grabCursor) {\n      swiper.setGrabCursor();\n    }\n\n    swiper.emit('enable');\n  };\n\n  _proto.disable = function disable() {\n    var swiper = this;\n    if (!swiper.enabled) return;\n    swiper.enabled = false;\n\n    if (swiper.params.grabCursor) {\n      swiper.unsetGrabCursor();\n    }\n\n    swiper.emit('disable');\n  };\n\n  _proto.setProgress = function setProgress(progress, speed) {\n    var swiper = this;\n    progress = Math.min(Math.max(progress, 0), 1);\n    var min = swiper.minTranslate();\n    var max = swiper.maxTranslate();\n    var current = (max - min) * progress + min;\n    swiper.translateTo(current, typeof speed === 'undefined' ? 0 : speed);\n    swiper.updateActiveIndex();\n    swiper.updateSlidesClasses();\n  };\n\n  _proto.emitContainerClasses = function emitContainerClasses() {\n    var swiper = this;\n    if (!swiper.params._emitClasses || !swiper.el) return;\n    var classes = swiper.el.className.split(' ').filter(function (className) {\n      return className.indexOf('swiper-container') === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;\n    });\n    swiper.emit('_containerClasses', classes.join(' '));\n  };\n\n  _proto.getSlideClasses = function getSlideClasses(slideEl) {\n    var swiper = this;\n    return slideEl.className.split(' ').filter(function (className) {\n      return className.indexOf('swiper-slide') === 0 || className.indexOf(swiper.params.slideClass) === 0;\n    }).join(' ');\n  };\n\n  _proto.emitSlidesClasses = function emitSlidesClasses() {\n    var swiper = this;\n    if (!swiper.params._emitClasses || !swiper.el) return;\n    var updates = [];\n    swiper.slides.each(function (slideEl) {\n      var classNames = swiper.getSlideClasses(slideEl);\n      updates.push({\n        slideEl: slideEl,\n        classNames: classNames\n      });\n      swiper.emit('_slideClass', slideEl, classNames);\n    });\n    swiper.emit('_slideClasses', updates);\n  };\n\n  _proto.slidesPerViewDynamic = function slidesPerViewDynamic() {\n    var swiper = this;\n    var params = swiper.params,\n        slides = swiper.slides,\n        slidesGrid = swiper.slidesGrid,\n        swiperSize = swiper.size,\n        activeIndex = swiper.activeIndex;\n    var spv = 1;\n\n    if (params.centeredSlides) {\n      var slideSize = slides[activeIndex].swiperSlideSize;\n      var breakLoop;\n\n      for (var i = activeIndex + 1; i < slides.length; i += 1) {\n        if (slides[i] && !breakLoop) {\n          slideSize += slides[i].swiperSlideSize;\n          spv += 1;\n          if (slideSize > swiperSize) breakLoop = true;\n        }\n      }\n\n      for (var _i = activeIndex - 1; _i >= 0; _i -= 1) {\n        if (slides[_i] && !breakLoop) {\n          slideSize += slides[_i].swiperSlideSize;\n          spv += 1;\n          if (slideSize > swiperSize) breakLoop = true;\n        }\n      }\n    } else {\n      for (var _i2 = activeIndex + 1; _i2 < slides.length; _i2 += 1) {\n        if (slidesGrid[_i2] - slidesGrid[activeIndex] < swiperSize) {\n          spv += 1;\n        }\n      }\n    }\n\n    return spv;\n  };\n\n  _proto.update = function update() {\n    var swiper = this;\n    if (!swiper || swiper.destroyed) return;\n    var snapGrid = swiper.snapGrid,\n        params = swiper.params; // Breakpoints\n\n    if (params.breakpoints) {\n      swiper.setBreakpoint();\n    }\n\n    swiper.updateSize();\n    swiper.updateSlides();\n    swiper.updateProgress();\n    swiper.updateSlidesClasses();\n\n    function setTranslate() {\n      var translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;\n      var newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());\n      swiper.setTranslate(newTranslate);\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    }\n\n    var translated;\n\n    if (swiper.params.freeMode) {\n      setTranslate();\n\n      if (swiper.params.autoHeight) {\n        swiper.updateAutoHeight();\n      }\n    } else {\n      if ((swiper.params.slidesPerView === 'auto' || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {\n        translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true);\n      } else {\n        translated = swiper.slideTo(swiper.activeIndex, 0, false, true);\n      }\n\n      if (!translated) {\n        setTranslate();\n      }\n    }\n\n    if (params.watchOverflow && snapGrid !== swiper.snapGrid) {\n      swiper.checkOverflow();\n    }\n\n    swiper.emit('update');\n  };\n\n  _proto.changeDirection = function changeDirection(newDirection, needUpdate) {\n    if (needUpdate === void 0) {\n      needUpdate = true;\n    }\n\n    var swiper = this;\n    var currentDirection = swiper.params.direction;\n\n    if (!newDirection) {\n      // eslint-disable-next-line\n      newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';\n    }\n\n    if (newDirection === currentDirection || newDirection !== 'horizontal' && newDirection !== 'vertical') {\n      return swiper;\n    }\n\n    swiper.$el.removeClass(\"\" + swiper.params.containerModifierClass + currentDirection).addClass(\"\" + swiper.params.containerModifierClass + newDirection);\n    swiper.emitContainerClasses();\n    swiper.params.direction = newDirection;\n    swiper.slides.each(function (slideEl) {\n      if (newDirection === 'vertical') {\n        slideEl.style.width = '';\n      } else {\n        slideEl.style.height = '';\n      }\n    });\n    swiper.emit('changeDirection');\n    if (needUpdate) swiper.update();\n    return swiper;\n  };\n\n  _proto.mount = function mount(el) {\n    var swiper = this;\n    if (swiper.mounted) return true; // Find el\n\n    var $el = (0,_utils_dom__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(el || swiper.params.el);\n    el = $el[0];\n\n    if (!el) {\n      return false;\n    }\n\n    el.swiper = swiper;\n\n    var getWrapperSelector = function getWrapperSelector() {\n      return \".\" + (swiper.params.wrapperClass || '').trim().split(' ').join('.');\n    };\n\n    var getWrapper = function getWrapper() {\n      if (el && el.shadowRoot && el.shadowRoot.querySelector) {\n        var res = (0,_utils_dom__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(el.shadowRoot.querySelector(getWrapperSelector())); // Children needs to return slot items\n\n        res.children = function (options) {\n          return $el.children(options);\n        };\n\n        return res;\n      }\n\n      return $el.children(getWrapperSelector());\n    }; // Find Wrapper\n\n\n    var $wrapperEl = getWrapper();\n\n    if ($wrapperEl.length === 0 && swiper.params.createElements) {\n      var document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();\n      var wrapper = document.createElement('div');\n      $wrapperEl = (0,_utils_dom__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(wrapper);\n      wrapper.className = swiper.params.wrapperClass;\n      $el.append(wrapper);\n      $el.children(\".\" + swiper.params.slideClass).each(function (slideEl) {\n        $wrapperEl.append(slideEl);\n      });\n    }\n\n    (0,_utils_utils__WEBPACK_IMPORTED_MODULE_16__.extend)(swiper, {\n      $el: $el,\n      el: el,\n      $wrapperEl: $wrapperEl,\n      wrapperEl: $wrapperEl[0],\n      mounted: true,\n      // RTL\n      rtl: el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl',\n      rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),\n      wrongRTL: $wrapperEl.css('display') === '-webkit-box'\n    });\n    return true;\n  };\n\n  _proto.init = function init(el) {\n    var swiper = this;\n    if (swiper.initialized) return swiper;\n    var mounted = swiper.mount(el);\n    if (mounted === false) return swiper;\n    swiper.emit('beforeInit'); // Set breakpoint\n\n    if (swiper.params.breakpoints) {\n      swiper.setBreakpoint();\n    } // Add Classes\n\n\n    swiper.addClasses(); // Create loop\n\n    if (swiper.params.loop) {\n      swiper.loopCreate();\n    } // Update size\n\n\n    swiper.updateSize(); // Update slides\n\n    swiper.updateSlides();\n\n    if (swiper.params.watchOverflow) {\n      swiper.checkOverflow();\n    } // Set Grab Cursor\n\n\n    if (swiper.params.grabCursor && swiper.enabled) {\n      swiper.setGrabCursor();\n    }\n\n    if (swiper.params.preloadImages) {\n      swiper.preloadImages();\n    } // Slide To Initial Slide\n\n\n    if (swiper.params.loop) {\n      swiper.slideTo(swiper.params.initialSlide + swiper.loopedSlides, 0, swiper.params.runCallbacksOnInit, false, true);\n    } else {\n      swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);\n    } // Attach events\n\n\n    swiper.attachEvents(); // Init Flag\n\n    swiper.initialized = true; // Emit\n\n    swiper.emit('init');\n    swiper.emit('afterInit');\n    return swiper;\n  };\n\n  _proto.destroy = function destroy(deleteInstance, cleanStyles) {\n    if (deleteInstance === void 0) {\n      deleteInstance = true;\n    }\n\n    if (cleanStyles === void 0) {\n      cleanStyles = true;\n    }\n\n    var swiper = this;\n    var params = swiper.params,\n        $el = swiper.$el,\n        $wrapperEl = swiper.$wrapperEl,\n        slides = swiper.slides;\n\n    if (typeof swiper.params === 'undefined' || swiper.destroyed) {\n      return null;\n    }\n\n    swiper.emit('beforeDestroy'); // Init Flag\n\n    swiper.initialized = false; // Detach events\n\n    swiper.detachEvents(); // Destroy loop\n\n    if (params.loop) {\n      swiper.loopDestroy();\n    } // Cleanup styles\n\n\n    if (cleanStyles) {\n      swiper.removeClasses();\n      $el.removeAttr('style');\n      $wrapperEl.removeAttr('style');\n\n      if (slides && slides.length) {\n        slides.removeClass([params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass].join(' ')).removeAttr('style').removeAttr('data-swiper-slide-index');\n      }\n    }\n\n    swiper.emit('destroy'); // Detach emitter events\n\n    Object.keys(swiper.eventsListeners).forEach(function (eventName) {\n      swiper.off(eventName);\n    });\n\n    if (deleteInstance !== false) {\n      swiper.$el[0].swiper = null;\n      (0,_utils_utils__WEBPACK_IMPORTED_MODULE_16__.deleteProps)(swiper);\n    }\n\n    swiper.destroyed = true;\n    return null;\n  };\n\n  Swiper.extendDefaults = function extendDefaults(newDefaults) {\n    (0,_utils_utils__WEBPACK_IMPORTED_MODULE_16__.extend)(extendedDefaults, newDefaults);\n  };\n\n  Swiper.installModule = function installModule(module) {\n    if (!Swiper.prototype.modules) Swiper.prototype.modules = {};\n    var name = module.name || Object.keys(Swiper.prototype.modules).length + \"_\" + (0,_utils_utils__WEBPACK_IMPORTED_MODULE_16__.now)();\n    Swiper.prototype.modules[name] = module;\n  };\n\n  Swiper.use = function use(module) {\n    if (Array.isArray(module)) {\n      module.forEach(function (m) {\n        return Swiper.installModule(m);\n      });\n      return Swiper;\n    }\n\n    Swiper.installModule(module);\n    return Swiper;\n  };\n\n  _createClass(Swiper, null, [{\n    key: \"extendedDefaults\",\n    get: function get() {\n      return extendedDefaults;\n    }\n  }, {\n    key: \"defaults\",\n    get: function get() {\n      return _defaults__WEBPACK_IMPORTED_MODULE_20__[\"default\"];\n    }\n  }]);\n\n  return Swiper;\n}();\n\nObject.keys(prototypes).forEach(function (prototypeGroup) {\n  Object.keys(prototypes[prototypeGroup]).forEach(function (protoMethod) {\n    Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];\n  });\n});\nSwiper.use([_modules_resize_resize__WEBPACK_IMPORTED_MODULE_21__[\"default\"], _modules_observer_observer__WEBPACK_IMPORTED_MODULE_22__[\"default\"]]);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Swiper);\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/components/core/core-class.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/components/core/defaults.js":
/*!*************************************************************!*\
  !*** ./node_modules/swiper/esm/components/core/defaults.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  init: true,\n  direction: 'horizontal',\n  touchEventsTarget: 'container',\n  initialSlide: 0,\n  speed: 300,\n  cssMode: false,\n  updateOnWindowResize: true,\n  resizeObserver: false,\n  nested: false,\n  createElements: false,\n  enabled: true,\n  focusableElements: 'input, select, option, textarea, button, video, label',\n  // Overrides\n  width: null,\n  height: null,\n  //\n  preventInteractionOnTransition: false,\n  // ssr\n  userAgent: null,\n  url: null,\n  // To support iOS's swipe-to-go-back gesture (when being used in-app).\n  edgeSwipeDetection: false,\n  edgeSwipeThreshold: 20,\n  // Free mode\n  freeMode: false,\n  freeModeMomentum: true,\n  freeModeMomentumRatio: 1,\n  freeModeMomentumBounce: true,\n  freeModeMomentumBounceRatio: 1,\n  freeModeMomentumVelocityRatio: 1,\n  freeModeSticky: false,\n  freeModeMinimumVelocity: 0.02,\n  // Autoheight\n  autoHeight: false,\n  // Set wrapper width\n  setWrapperSize: false,\n  // Virtual Translate\n  virtualTranslate: false,\n  // Effects\n  effect: 'slide',\n  // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'\n  // Breakpoints\n  breakpoints: undefined,\n  breakpointsBase: 'window',\n  // Slides grid\n  spaceBetween: 0,\n  slidesPerView: 1,\n  slidesPerColumn: 1,\n  slidesPerColumnFill: 'column',\n  slidesPerGroup: 1,\n  slidesPerGroupSkip: 0,\n  centeredSlides: false,\n  centeredSlidesBounds: false,\n  slidesOffsetBefore: 0,\n  // in px\n  slidesOffsetAfter: 0,\n  // in px\n  normalizeSlideIndex: true,\n  centerInsufficientSlides: false,\n  // Disable swiper and hide navigation when container not overflow\n  watchOverflow: false,\n  // Round length\n  roundLengths: false,\n  // Touches\n  touchRatio: 1,\n  touchAngle: 45,\n  simulateTouch: true,\n  shortSwipes: true,\n  longSwipes: true,\n  longSwipesRatio: 0.5,\n  longSwipesMs: 300,\n  followFinger: true,\n  allowTouchMove: true,\n  threshold: 0,\n  touchMoveStopPropagation: false,\n  touchStartPreventDefault: true,\n  touchStartForcePreventDefault: false,\n  touchReleaseOnEdges: false,\n  // Unique Navigation Elements\n  uniqueNavElements: true,\n  // Resistance\n  resistance: true,\n  resistanceRatio: 0.85,\n  // Progress\n  watchSlidesProgress: false,\n  watchSlidesVisibility: false,\n  // Cursor\n  grabCursor: false,\n  // Clicks\n  preventClicks: true,\n  preventClicksPropagation: true,\n  slideToClickedSlide: false,\n  // Images\n  preloadImages: true,\n  updateOnImagesReady: true,\n  // loop\n  loop: false,\n  loopAdditionalSlides: 0,\n  loopedSlides: null,\n  loopFillGroupWithBlank: false,\n  loopPreventsSlide: true,\n  // Swiping/no swiping\n  allowSlidePrev: true,\n  allowSlideNext: true,\n  swipeHandler: null,\n  // '.swipe-handler',\n  noSwiping: true,\n  noSwipingClass: 'swiper-no-swiping',\n  noSwipingSelector: null,\n  // Passive Listeners\n  passiveListeners: true,\n  // NS\n  containerModifierClass: 'swiper-container-',\n  // NEW\n  slideClass: 'swiper-slide',\n  slideBlankClass: 'swiper-slide-invisible-blank',\n  slideActiveClass: 'swiper-slide-active',\n  slideDuplicateActiveClass: 'swiper-slide-duplicate-active',\n  slideVisibleClass: 'swiper-slide-visible',\n  slideDuplicateClass: 'swiper-slide-duplicate',\n  slideNextClass: 'swiper-slide-next',\n  slideDuplicateNextClass: 'swiper-slide-duplicate-next',\n  slidePrevClass: 'swiper-slide-prev',\n  slideDuplicatePrevClass: 'swiper-slide-duplicate-prev',\n  wrapperClass: 'swiper-wrapper',\n  // Callbacks\n  runCallbacksOnInit: true,\n  // Internals\n  _emitClasses: false\n});\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/components/core/defaults.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/components/core/events-emitter.js":
/*!*******************************************************************!*\
  !*** ./node_modules/swiper/esm/components/core/events-emitter.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* eslint-disable no-underscore-dangle */\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  on: function on(events, handler, priority) {\n    var self = this;\n    if (typeof handler !== 'function') return self;\n    var method = priority ? 'unshift' : 'push';\n    events.split(' ').forEach(function (event) {\n      if (!self.eventsListeners[event]) self.eventsListeners[event] = [];\n      self.eventsListeners[event][method](handler);\n    });\n    return self;\n  },\n  once: function once(events, handler, priority) {\n    var self = this;\n    if (typeof handler !== 'function') return self;\n\n    function onceHandler() {\n      self.off(events, onceHandler);\n\n      if (onceHandler.__emitterProxy) {\n        delete onceHandler.__emitterProxy;\n      }\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      handler.apply(self, args);\n    }\n\n    onceHandler.__emitterProxy = handler;\n    return self.on(events, onceHandler, priority);\n  },\n  onAny: function onAny(handler, priority) {\n    var self = this;\n    if (typeof handler !== 'function') return self;\n    var method = priority ? 'unshift' : 'push';\n\n    if (self.eventsAnyListeners.indexOf(handler) < 0) {\n      self.eventsAnyListeners[method](handler);\n    }\n\n    return self;\n  },\n  offAny: function offAny(handler) {\n    var self = this;\n    if (!self.eventsAnyListeners) return self;\n    var index = self.eventsAnyListeners.indexOf(handler);\n\n    if (index >= 0) {\n      self.eventsAnyListeners.splice(index, 1);\n    }\n\n    return self;\n  },\n  off: function off(events, handler) {\n    var self = this;\n    if (!self.eventsListeners) return self;\n    events.split(' ').forEach(function (event) {\n      if (typeof handler === 'undefined') {\n        self.eventsListeners[event] = [];\n      } else if (self.eventsListeners[event]) {\n        self.eventsListeners[event].forEach(function (eventHandler, index) {\n          if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {\n            self.eventsListeners[event].splice(index, 1);\n          }\n        });\n      }\n    });\n    return self;\n  },\n  emit: function emit() {\n    var self = this;\n    if (!self.eventsListeners) return self;\n    var events;\n    var data;\n    var context;\n\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    if (typeof args[0] === 'string' || Array.isArray(args[0])) {\n      events = args[0];\n      data = args.slice(1, args.length);\n      context = self;\n    } else {\n      events = args[0].events;\n      data = args[0].data;\n      context = args[0].context || self;\n    }\n\n    data.unshift(context);\n    var eventsArray = Array.isArray(events) ? events : events.split(' ');\n    eventsArray.forEach(function (event) {\n      if (self.eventsAnyListeners && self.eventsAnyListeners.length) {\n        self.eventsAnyListeners.forEach(function (eventHandler) {\n          eventHandler.apply(context, [event].concat(data));\n        });\n      }\n\n      if (self.eventsListeners && self.eventsListeners[event]) {\n        self.eventsListeners[event].forEach(function (eventHandler) {\n          eventHandler.apply(context, data);\n        });\n      }\n    });\n    return self;\n  }\n});\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/components/core/events-emitter.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/components/core/events/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/swiper/esm/components/core/events/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ \"./node_modules/ssr-window/ssr-window.esm.js\");\n/* harmony import */ var _onTouchStart__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./onTouchStart */ \"./node_modules/swiper/esm/components/core/events/onTouchStart.js\");\n/* harmony import */ var _onTouchMove__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./onTouchMove */ \"./node_modules/swiper/esm/components/core/events/onTouchMove.js\");\n/* harmony import */ var _onTouchEnd__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./onTouchEnd */ \"./node_modules/swiper/esm/components/core/events/onTouchEnd.js\");\n/* harmony import */ var _onResize__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./onResize */ \"./node_modules/swiper/esm/components/core/events/onResize.js\");\n/* harmony import */ var _onClick__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./onClick */ \"./node_modules/swiper/esm/components/core/events/onClick.js\");\n/* harmony import */ var _onScroll__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./onScroll */ \"./node_modules/swiper/esm/components/core/events/onScroll.js\");\n\n\n\n\n\n\n\nvar dummyEventAttached = false;\n\nfunction dummyEventListener() {}\n\nfunction attachEvents() {\n  var swiper = this;\n  var document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();\n  var params = swiper.params,\n      touchEvents = swiper.touchEvents,\n      el = swiper.el,\n      wrapperEl = swiper.wrapperEl,\n      device = swiper.device,\n      support = swiper.support;\n  swiper.onTouchStart = _onTouchStart__WEBPACK_IMPORTED_MODULE_1__[\"default\"].bind(swiper);\n  swiper.onTouchMove = _onTouchMove__WEBPACK_IMPORTED_MODULE_2__[\"default\"].bind(swiper);\n  swiper.onTouchEnd = _onTouchEnd__WEBPACK_IMPORTED_MODULE_3__[\"default\"].bind(swiper);\n\n  if (params.cssMode) {\n    swiper.onScroll = _onScroll__WEBPACK_IMPORTED_MODULE_4__[\"default\"].bind(swiper);\n  }\n\n  swiper.onClick = _onClick__WEBPACK_IMPORTED_MODULE_5__[\"default\"].bind(swiper);\n  var capture = !!params.nested; // Touch Events\n\n  if (!support.touch && support.pointerEvents) {\n    el.addEventListener(touchEvents.start, swiper.onTouchStart, false);\n    document.addEventListener(touchEvents.move, swiper.onTouchMove, capture);\n    document.addEventListener(touchEvents.end, swiper.onTouchEnd, false);\n  } else {\n    if (support.touch) {\n      var passiveListener = touchEvents.start === 'touchstart' && support.passiveListener && params.passiveListeners ? {\n        passive: true,\n        capture: false\n      } : false;\n      el.addEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);\n      el.addEventListener(touchEvents.move, swiper.onTouchMove, support.passiveListener ? {\n        passive: false,\n        capture: capture\n      } : capture);\n      el.addEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);\n\n      if (touchEvents.cancel) {\n        el.addEventListener(touchEvents.cancel, swiper.onTouchEnd, passiveListener);\n      }\n\n      if (!dummyEventAttached) {\n        document.addEventListener('touchstart', dummyEventListener);\n        dummyEventAttached = true;\n      }\n    }\n\n    if (params.simulateTouch && !device.ios && !device.android || params.simulateTouch && !support.touch && device.ios) {\n      el.addEventListener('mousedown', swiper.onTouchStart, false);\n      document.addEventListener('mousemove', swiper.onTouchMove, capture);\n      document.addEventListener('mouseup', swiper.onTouchEnd, false);\n    }\n  } // Prevent Links Clicks\n\n\n  if (params.preventClicks || params.preventClicksPropagation) {\n    el.addEventListener('click', swiper.onClick, true);\n  }\n\n  if (params.cssMode) {\n    wrapperEl.addEventListener('scroll', swiper.onScroll);\n  } // Resize handler\n\n\n  if (params.updateOnWindowResize) {\n    swiper.on(device.ios || device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', _onResize__WEBPACK_IMPORTED_MODULE_6__[\"default\"], true);\n  } else {\n    swiper.on('observerUpdate', _onResize__WEBPACK_IMPORTED_MODULE_6__[\"default\"], true);\n  }\n}\n\nfunction detachEvents() {\n  var swiper = this;\n  var document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();\n  var params = swiper.params,\n      touchEvents = swiper.touchEvents,\n      el = swiper.el,\n      wrapperEl = swiper.wrapperEl,\n      device = swiper.device,\n      support = swiper.support;\n  var capture = !!params.nested; // Touch Events\n\n  if (!support.touch && support.pointerEvents) {\n    el.removeEventListener(touchEvents.start, swiper.onTouchStart, false);\n    document.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);\n    document.removeEventListener(touchEvents.end, swiper.onTouchEnd, false);\n  } else {\n    if (support.touch) {\n      var passiveListener = touchEvents.start === 'onTouchStart' && support.passiveListener && params.passiveListeners ? {\n        passive: true,\n        capture: false\n      } : false;\n      el.removeEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);\n      el.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);\n      el.removeEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);\n\n      if (touchEvents.cancel) {\n        el.removeEventListener(touchEvents.cancel, swiper.onTouchEnd, passiveListener);\n      }\n    }\n\n    if (params.simulateTouch && !device.ios && !device.android || params.simulateTouch && !support.touch && device.ios) {\n      el.removeEventListener('mousedown', swiper.onTouchStart, false);\n      document.removeEventListener('mousemove', swiper.onTouchMove, capture);\n      document.removeEventListener('mouseup', swiper.onTouchEnd, false);\n    }\n  } // Prevent Links Clicks\n\n\n  if (params.preventClicks || params.preventClicksPropagation) {\n    el.removeEventListener('click', swiper.onClick, true);\n  }\n\n  if (params.cssMode) {\n    wrapperEl.removeEventListener('scroll', swiper.onScroll);\n  } // Resize handler\n\n\n  swiper.off(device.ios || device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', _onResize__WEBPACK_IMPORTED_MODULE_6__[\"default\"]);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  attachEvents: attachEvents,\n  detachEvents: detachEvents\n});\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/components/core/events/index.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/components/core/events/onClick.js":
/*!*******************************************************************!*\
  !*** ./node_modules/swiper/esm/components/core/events/onClick.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ onClick)\n/* harmony export */ });\nfunction onClick(e) {\n  var swiper = this;\n  if (!swiper.enabled) return;\n\n  if (!swiper.allowClick) {\n    if (swiper.params.preventClicks) e.preventDefault();\n\n    if (swiper.params.preventClicksPropagation && swiper.animating) {\n      e.stopPropagation();\n      e.stopImmediatePropagation();\n    }\n  }\n}\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/components/core/events/onClick.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/components/core/events/onResize.js":
/*!********************************************************************!*\
  !*** ./node_modules/swiper/esm/components/core/events/onResize.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ onResize)\n/* harmony export */ });\nfunction onResize() {\n  var swiper = this;\n  var params = swiper.params,\n      el = swiper.el;\n  if (el && el.offsetWidth === 0) return; // Breakpoints\n\n  if (params.breakpoints) {\n    swiper.setBreakpoint();\n  } // Save locks\n\n\n  var allowSlideNext = swiper.allowSlideNext,\n      allowSlidePrev = swiper.allowSlidePrev,\n      snapGrid = swiper.snapGrid; // Disable locks on resize\n\n  swiper.allowSlideNext = true;\n  swiper.allowSlidePrev = true;\n  swiper.updateSize();\n  swiper.updateSlides();\n  swiper.updateSlidesClasses();\n\n  if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides) {\n    swiper.slideTo(swiper.slides.length - 1, 0, false, true);\n  } else {\n    swiper.slideTo(swiper.activeIndex, 0, false, true);\n  }\n\n  if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {\n    swiper.autoplay.run();\n  } // Return locks after resize\n\n\n  swiper.allowSlidePrev = allowSlidePrev;\n  swiper.allowSlideNext = allowSlideNext;\n\n  if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {\n    swiper.checkOverflow();\n  }\n}\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/components/core/events/onResize.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/components/core/events/onScroll.js":
/*!********************************************************************!*\
  !*** ./node_modules/swiper/esm/components/core/events/onScroll.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ onScroll)\n/* harmony export */ });\nfunction onScroll() {\n  var swiper = this;\n  var wrapperEl = swiper.wrapperEl,\n      rtlTranslate = swiper.rtlTranslate,\n      enabled = swiper.enabled;\n  if (!enabled) return;\n  swiper.previousTranslate = swiper.translate;\n\n  if (swiper.isHorizontal()) {\n    if (rtlTranslate) {\n      swiper.translate = wrapperEl.scrollWidth - wrapperEl.offsetWidth - wrapperEl.scrollLeft;\n    } else {\n      swiper.translate = -wrapperEl.scrollLeft;\n    }\n  } else {\n    swiper.translate = -wrapperEl.scrollTop;\n  } // eslint-disable-next-line\n\n\n  if (swiper.translate === -0) swiper.translate = 0;\n  swiper.updateActiveIndex();\n  swiper.updateSlidesClasses();\n  var newProgress;\n  var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n\n  if (translatesDiff === 0) {\n    newProgress = 0;\n  } else {\n    newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;\n  }\n\n  if (newProgress !== swiper.progress) {\n    swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);\n  }\n\n  swiper.emit('setTranslate', swiper.translate, false);\n}\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/components/core/events/onScroll.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/components/core/events/onTouchEnd.js":
/*!**********************************************************************!*\
  !*** ./node_modules/swiper/esm/components/core/events/onTouchEnd.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ onTouchEnd)\n/* harmony export */ });\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../utils/utils */ \"./node_modules/swiper/esm/utils/utils.js\");\n\nfunction onTouchEnd(event) {\n  var swiper = this;\n  var data = swiper.touchEventsData;\n  var params = swiper.params,\n      touches = swiper.touches,\n      rtl = swiper.rtlTranslate,\n      $wrapperEl = swiper.$wrapperEl,\n      slidesGrid = swiper.slidesGrid,\n      snapGrid = swiper.snapGrid,\n      enabled = swiper.enabled;\n  if (!enabled) return;\n  var e = event;\n  if (e.originalEvent) e = e.originalEvent;\n\n  if (data.allowTouchCallbacks) {\n    swiper.emit('touchEnd', e);\n  }\n\n  data.allowTouchCallbacks = false;\n\n  if (!data.isTouched) {\n    if (data.isMoved && params.grabCursor) {\n      swiper.setGrabCursor(false);\n    }\n\n    data.isMoved = false;\n    data.startMoving = false;\n    return;\n  } // Return Grab Cursor\n\n\n  if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {\n    swiper.setGrabCursor(false);\n  } // Time diff\n\n\n  var touchEndTime = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.now)();\n  var timeDiff = touchEndTime - data.touchStartTime; // Tap, doubleTap, Click\n\n  if (swiper.allowClick) {\n    swiper.updateClickedSlide(e);\n    swiper.emit('tap click', e);\n\n    if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {\n      swiper.emit('doubleTap doubleClick', e);\n    }\n  }\n\n  data.lastClickTime = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.now)();\n  (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.nextTick)(function () {\n    if (!swiper.destroyed) swiper.allowClick = true;\n  });\n\n  if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {\n    data.isTouched = false;\n    data.isMoved = false;\n    data.startMoving = false;\n    return;\n  }\n\n  data.isTouched = false;\n  data.isMoved = false;\n  data.startMoving = false;\n  var currentPos;\n\n  if (params.followFinger) {\n    currentPos = rtl ? swiper.translate : -swiper.translate;\n  } else {\n    currentPos = -data.currentTranslate;\n  }\n\n  if (params.cssMode) {\n    return;\n  }\n\n  if (params.freeMode) {\n    if (currentPos < -swiper.minTranslate()) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n\n    if (currentPos > -swiper.maxTranslate()) {\n      if (swiper.slides.length < snapGrid.length) {\n        swiper.slideTo(snapGrid.length - 1);\n      } else {\n        swiper.slideTo(swiper.slides.length - 1);\n      }\n\n      return;\n    }\n\n    if (params.freeModeMomentum) {\n      if (data.velocities.length > 1) {\n        var lastMoveEvent = data.velocities.pop();\n        var velocityEvent = data.velocities.pop();\n        var distance = lastMoveEvent.position - velocityEvent.position;\n        var time = lastMoveEvent.time - velocityEvent.time;\n        swiper.velocity = distance / time;\n        swiper.velocity /= 2;\n\n        if (Math.abs(swiper.velocity) < params.freeModeMinimumVelocity) {\n          swiper.velocity = 0;\n        } // this implies that the user stopped moving a finger then released.\n        // There would be no events with distance zero, so the last event is stale.\n\n\n        if (time > 150 || (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.now)() - lastMoveEvent.time > 300) {\n          swiper.velocity = 0;\n        }\n      } else {\n        swiper.velocity = 0;\n      }\n\n      swiper.velocity *= params.freeModeMomentumVelocityRatio;\n      data.velocities.length = 0;\n      var momentumDuration = 1000 * params.freeModeMomentumRatio;\n      var momentumDistance = swiper.velocity * momentumDuration;\n      var newPosition = swiper.translate + momentumDistance;\n      if (rtl) newPosition = -newPosition;\n      var doBounce = false;\n      var afterBouncePosition;\n      var bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeModeMomentumBounceRatio;\n      var needsLoopFix;\n\n      if (newPosition < swiper.maxTranslate()) {\n        if (params.freeModeMomentumBounce) {\n          if (newPosition + swiper.maxTranslate() < -bounceAmount) {\n            newPosition = swiper.maxTranslate() - bounceAmount;\n          }\n\n          afterBouncePosition = swiper.maxTranslate();\n          doBounce = true;\n          data.allowMomentumBounce = true;\n        } else {\n          newPosition = swiper.maxTranslate();\n        }\n\n        if (params.loop && params.centeredSlides) needsLoopFix = true;\n      } else if (newPosition > swiper.minTranslate()) {\n        if (params.freeModeMomentumBounce) {\n          if (newPosition - swiper.minTranslate() > bounceAmount) {\n            newPosition = swiper.minTranslate() + bounceAmount;\n          }\n\n          afterBouncePosition = swiper.minTranslate();\n          doBounce = true;\n          data.allowMomentumBounce = true;\n        } else {\n          newPosition = swiper.minTranslate();\n        }\n\n        if (params.loop && params.centeredSlides) needsLoopFix = true;\n      } else if (params.freeModeSticky) {\n        var nextSlide;\n\n        for (var j = 0; j < snapGrid.length; j += 1) {\n          if (snapGrid[j] > -newPosition) {\n            nextSlide = j;\n            break;\n          }\n        }\n\n        if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {\n          newPosition = snapGrid[nextSlide];\n        } else {\n          newPosition = snapGrid[nextSlide - 1];\n        }\n\n        newPosition = -newPosition;\n      }\n\n      if (needsLoopFix) {\n        swiper.once('transitionEnd', function () {\n          swiper.loopFix();\n        });\n      } // Fix duration\n\n\n      if (swiper.velocity !== 0) {\n        if (rtl) {\n          momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);\n        } else {\n          momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);\n        }\n\n        if (params.freeModeSticky) {\n          // If freeModeSticky is active and the user ends a swipe with a slow-velocity\n          // event, then durations can be 20+ seconds to slide one (or zero!) slides.\n          // It's easy to see this when simulating touch with mouse events. To fix this,\n          // limit single-slide swipes to the default slide duration. This also has the\n          // nice side effect of matching slide speed if the user stopped moving before\n          // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.\n          // For faster swipes, also apply limits (albeit higher ones).\n          var moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);\n          var currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];\n\n          if (moveDistance < currentSlideSize) {\n            momentumDuration = params.speed;\n          } else if (moveDistance < 2 * currentSlideSize) {\n            momentumDuration = params.speed * 1.5;\n          } else {\n            momentumDuration = params.speed * 2.5;\n          }\n        }\n      } else if (params.freeModeSticky) {\n        swiper.slideToClosest();\n        return;\n      }\n\n      if (params.freeModeMomentumBounce && doBounce) {\n        swiper.updateProgress(afterBouncePosition);\n        swiper.setTransition(momentumDuration);\n        swiper.setTranslate(newPosition);\n        swiper.transitionStart(true, swiper.swipeDirection);\n        swiper.animating = true;\n        $wrapperEl.transitionEnd(function () {\n          if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;\n          swiper.emit('momentumBounce');\n          swiper.setTransition(params.speed);\n          setTimeout(function () {\n            swiper.setTranslate(afterBouncePosition);\n            $wrapperEl.transitionEnd(function () {\n              if (!swiper || swiper.destroyed) return;\n              swiper.transitionEnd();\n            });\n          }, 0);\n        });\n      } else if (swiper.velocity) {\n        swiper.updateProgress(newPosition);\n        swiper.setTransition(momentumDuration);\n        swiper.setTranslate(newPosition);\n        swiper.transitionStart(true, swiper.swipeDirection);\n\n        if (!swiper.animating) {\n          swiper.animating = true;\n          $wrapperEl.transitionEnd(function () {\n            if (!swiper || swiper.destroyed) return;\n            swiper.transitionEnd();\n          });\n        }\n      } else {\n        swiper.emit('_freeModeNoMomentumRelease');\n        swiper.updateProgress(newPosition);\n      }\n\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    } else if (params.freeModeSticky) {\n      swiper.slideToClosest();\n      return;\n    } else if (params.freeMode) {\n      swiper.emit('_freeModeNoMomentumRelease');\n    }\n\n    if (!params.freeModeMomentum || timeDiff >= params.longSwipesMs) {\n      swiper.updateProgress();\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    }\n\n    return;\n  } // Find current slide\n\n\n  var stopIndex = 0;\n  var groupSize = swiper.slidesSizesGrid[0];\n\n  for (var i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {\n    var _increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n\n    if (typeof slidesGrid[i + _increment] !== 'undefined') {\n      if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + _increment]) {\n        stopIndex = i;\n        groupSize = slidesGrid[i + _increment] - slidesGrid[i];\n      }\n    } else if (currentPos >= slidesGrid[i]) {\n      stopIndex = i;\n      groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];\n    }\n  } // Find current slide size\n\n\n  var ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;\n  var increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n\n  if (timeDiff > params.longSwipesMs) {\n    // Long touches\n    if (!params.longSwipes) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n\n    if (swiper.swipeDirection === 'next') {\n      if (ratio >= params.longSwipesRatio) swiper.slideTo(stopIndex + increment);else swiper.slideTo(stopIndex);\n    }\n\n    if (swiper.swipeDirection === 'prev') {\n      if (ratio > 1 - params.longSwipesRatio) swiper.slideTo(stopIndex + increment);else swiper.slideTo(stopIndex);\n    }\n  } else {\n    // Short swipes\n    if (!params.shortSwipes) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n\n    var isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);\n\n    if (!isNavButtonTarget) {\n      if (swiper.swipeDirection === 'next') {\n        swiper.slideTo(stopIndex + increment);\n      }\n\n      if (swiper.swipeDirection === 'prev') {\n        swiper.slideTo(stopIndex);\n      }\n    } else if (e.target === swiper.navigation.nextEl) {\n      swiper.slideTo(stopIndex + increment);\n    } else {\n      swiper.slideTo(stopIndex);\n    }\n  }\n}\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/components/core/events/onTouchEnd.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/components/core/events/onTouchMove.js":
/*!***********************************************************************!*\
  !*** ./node_modules/swiper/esm/components/core/events/onTouchMove.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ onTouchMove)\n/* harmony export */ });\n/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ \"./node_modules/ssr-window/ssr-window.esm.js\");\n/* harmony import */ var _utils_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../utils/dom */ \"./node_modules/swiper/esm/utils/dom.js\");\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../utils/utils */ \"./node_modules/swiper/esm/utils/utils.js\");\n\n\n\nfunction onTouchMove(event) {\n  var document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();\n  var swiper = this;\n  var data = swiper.touchEventsData;\n  var params = swiper.params,\n      touches = swiper.touches,\n      rtl = swiper.rtlTranslate,\n      enabled = swiper.enabled;\n  if (!enabled) return;\n  var e = event;\n  if (e.originalEvent) e = e.originalEvent;\n\n  if (!data.isTouched) {\n    if (data.startMoving && data.isScrolling) {\n      swiper.emit('touchMoveOpposite', e);\n    }\n\n    return;\n  }\n\n  if (data.isTouchEvent && e.type !== 'touchmove') return;\n  var targetTouch = e.type === 'touchmove' && e.targetTouches && (e.targetTouches[0] || e.changedTouches[0]);\n  var pageX = e.type === 'touchmove' ? targetTouch.pageX : e.pageX;\n  var pageY = e.type === 'touchmove' ? targetTouch.pageY : e.pageY;\n\n  if (e.preventedByNestedSwiper) {\n    touches.startX = pageX;\n    touches.startY = pageY;\n    return;\n  }\n\n  if (!swiper.allowTouchMove) {\n    // isMoved = true;\n    swiper.allowClick = false;\n\n    if (data.isTouched) {\n      (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.extend)(touches, {\n        startX: pageX,\n        startY: pageY,\n        currentX: pageX,\n        currentY: pageY\n      });\n      data.touchStartTime = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.now)();\n    }\n\n    return;\n  }\n\n  if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {\n    if (swiper.isVertical()) {\n      // Vertical\n      if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {\n        data.isTouched = false;\n        data.isMoved = false;\n        return;\n      }\n    } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {\n      return;\n    }\n  }\n\n  if (data.isTouchEvent && document.activeElement) {\n    if (e.target === document.activeElement && (0,_utils_dom__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(e.target).is(data.focusableElements)) {\n      data.isMoved = true;\n      swiper.allowClick = false;\n      return;\n    }\n  }\n\n  if (data.allowTouchCallbacks) {\n    swiper.emit('touchMove', e);\n  }\n\n  if (e.targetTouches && e.targetTouches.length > 1) return;\n  touches.currentX = pageX;\n  touches.currentY = pageY;\n  var diffX = touches.currentX - touches.startX;\n  var diffY = touches.currentY - touches.startY;\n  if (swiper.params.threshold && Math.sqrt(Math.pow(diffX, 2) + Math.pow(diffY, 2)) < swiper.params.threshold) return;\n\n  if (typeof data.isScrolling === 'undefined') {\n    var touchAngle;\n\n    if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {\n      data.isScrolling = false;\n    } else {\n      // eslint-disable-next-line\n      if (diffX * diffX + diffY * diffY >= 25) {\n        touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;\n        data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;\n      }\n    }\n  }\n\n  if (data.isScrolling) {\n    swiper.emit('touchMoveOpposite', e);\n  }\n\n  if (typeof data.startMoving === 'undefined') {\n    if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {\n      data.startMoving = true;\n    }\n  }\n\n  if (data.isScrolling) {\n    data.isTouched = false;\n    return;\n  }\n\n  if (!data.startMoving) {\n    return;\n  }\n\n  swiper.allowClick = false;\n\n  if (!params.cssMode && e.cancelable) {\n    e.preventDefault();\n  }\n\n  if (params.touchMoveStopPropagation && !params.nested) {\n    e.stopPropagation();\n  }\n\n  if (!data.isMoved) {\n    if (params.loop) {\n      swiper.loopFix();\n    }\n\n    data.startTranslate = swiper.getTranslate();\n    swiper.setTransition(0);\n\n    if (swiper.animating) {\n      swiper.$wrapperEl.trigger('webkitTransitionEnd transitionend');\n    }\n\n    data.allowMomentumBounce = false; // Grab Cursor\n\n    if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {\n      swiper.setGrabCursor(true);\n    }\n\n    swiper.emit('sliderFirstMove', e);\n  }\n\n  swiper.emit('sliderMove', e);\n  data.isMoved = true;\n  var diff = swiper.isHorizontal() ? diffX : diffY;\n  touches.diff = diff;\n  diff *= params.touchRatio;\n  if (rtl) diff = -diff;\n  swiper.swipeDirection = diff > 0 ? 'prev' : 'next';\n  data.currentTranslate = diff + data.startTranslate;\n  var disableParentSwiper = true;\n  var resistanceRatio = params.resistanceRatio;\n\n  if (params.touchReleaseOnEdges) {\n    resistanceRatio = 0;\n  }\n\n  if (diff > 0 && data.currentTranslate > swiper.minTranslate()) {\n    disableParentSwiper = false;\n    if (params.resistance) data.currentTranslate = swiper.minTranslate() - 1 + Math.pow(-swiper.minTranslate() + data.startTranslate + diff, resistanceRatio);\n  } else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {\n    disableParentSwiper = false;\n    if (params.resistance) data.currentTranslate = swiper.maxTranslate() + 1 - Math.pow(swiper.maxTranslate() - data.startTranslate - diff, resistanceRatio);\n  }\n\n  if (disableParentSwiper) {\n    e.preventedByNestedSwiper = true;\n  } // Directions locks\n\n\n  if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {\n    data.currentTranslate = data.startTranslate;\n  }\n\n  if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {\n    data.currentTranslate = data.startTranslate;\n  }\n\n  if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {\n    data.currentTranslate = data.startTranslate;\n  } // Threshold\n\n\n  if (params.threshold > 0) {\n    if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {\n      if (!data.allowThresholdMove) {\n        data.allowThresholdMove = true;\n        touches.startX = touches.currentX;\n        touches.startY = touches.currentY;\n        data.currentTranslate = data.startTranslate;\n        touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;\n        return;\n      }\n    } else {\n      data.currentTranslate = data.startTranslate;\n      return;\n    }\n  }\n\n  if (!params.followFinger || params.cssMode) return; // Update active index in free mode\n\n  if (params.freeMode || params.watchSlidesProgress || params.watchSlidesVisibility) {\n    swiper.updateActiveIndex();\n    swiper.updateSlidesClasses();\n  }\n\n  if (params.freeMode) {\n    // Velocity\n    if (data.velocities.length === 0) {\n      data.velocities.push({\n        position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],\n        time: data.touchStartTime\n      });\n    }\n\n    data.velocities.push({\n      position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],\n      time: (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.now)()\n    });\n  } // Update progress\n\n\n  swiper.updateProgress(data.currentTranslate); // Update translate\n\n  swiper.setTranslate(data.currentTranslate);\n}\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/components/core/events/onTouchMove.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/components/core/events/onTouchStart.js":
/*!************************************************************************!*\
  !*** ./node_modules/swiper/esm/components/core/events/onTouchStart.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ onTouchStart)\n/* harmony export */ });\n/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ \"./node_modules/ssr-window/ssr-window.esm.js\");\n/* harmony import */ var _utils_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../utils/dom */ \"./node_modules/swiper/esm/utils/dom.js\");\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../utils/utils */ \"./node_modules/swiper/esm/utils/utils.js\");\n\n\n // Modified from https://stackoverflow.com/questions/54520554/custom-element-getrootnode-closest-function-crossing-multiple-parent-shadowd\n\nfunction closestElement(selector, base) {\n  if (base === void 0) {\n    base = this;\n  }\n\n  function __closestFrom(el) {\n    if (!el || el === (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)() || el === (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)()) return null;\n    if (el.assignedSlot) el = el.assignedSlot;\n    var found = el.closest(selector);\n    return found || __closestFrom(el.getRootNode().host);\n  }\n\n  return __closestFrom(base);\n}\n\nfunction onTouchStart(event) {\n  var swiper = this;\n  var document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();\n  var window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();\n  var data = swiper.touchEventsData;\n  var params = swiper.params,\n      touches = swiper.touches,\n      enabled = swiper.enabled;\n  if (!enabled) return;\n\n  if (swiper.animating && params.preventInteractionOnTransition) {\n    return;\n  }\n\n  var e = event;\n  if (e.originalEvent) e = e.originalEvent;\n  var $targetEl = (0,_utils_dom__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(e.target);\n\n  if (params.touchEventsTarget === 'wrapper') {\n    if (!$targetEl.closest(swiper.wrapperEl).length) return;\n  }\n\n  data.isTouchEvent = e.type === 'touchstart';\n  if (!data.isTouchEvent && 'which' in e && e.which === 3) return;\n  if (!data.isTouchEvent && 'button' in e && e.button > 0) return;\n  if (data.isTouched && data.isMoved) return; // change target el for shadow root component\n\n  var swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== '';\n\n  if (swipingClassHasValue && e.target && e.target.shadowRoot && event.path && event.path[0]) {\n    $targetEl = (0,_utils_dom__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(event.path[0]);\n  }\n\n  var noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : \".\" + params.noSwipingClass;\n  var isTargetShadow = !!(e.target && e.target.shadowRoot); // use closestElement for shadow root element to get the actual closest for nested shadow root element\n\n  if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, e.target) : $targetEl.closest(noSwipingSelector)[0])) {\n    swiper.allowClick = true;\n    return;\n  }\n\n  if (params.swipeHandler) {\n    if (!$targetEl.closest(params.swipeHandler)[0]) return;\n  }\n\n  touches.currentX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;\n  touches.currentY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;\n  var startX = touches.currentX;\n  var startY = touches.currentY; // Do NOT start if iOS edge swipe is detected. Otherwise iOS app cannot swipe-to-go-back anymore\n\n  var edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;\n  var edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;\n\n  if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window.innerWidth - edgeSwipeThreshold)) {\n    if (edgeSwipeDetection === 'prevent') {\n      event.preventDefault();\n    } else {\n      return;\n    }\n  }\n\n  (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.extend)(data, {\n    isTouched: true,\n    isMoved: false,\n    allowTouchCallbacks: true,\n    isScrolling: undefined,\n    startMoving: undefined\n  });\n  touches.startX = startX;\n  touches.startY = startY;\n  data.touchStartTime = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.now)();\n  swiper.allowClick = true;\n  swiper.updateSize();\n  swiper.swipeDirection = undefined;\n  if (params.threshold > 0) data.allowThresholdMove = false;\n\n  if (e.type !== 'touchstart') {\n    var preventDefault = true;\n    if ($targetEl.is(data.focusableElements)) preventDefault = false;\n\n    if (document.activeElement && (0,_utils_dom__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(document.activeElement).is(data.focusableElements) && document.activeElement !== $targetEl[0]) {\n      document.activeElement.blur();\n    }\n\n    var shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;\n\n    if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !$targetEl[0].isContentEditable) {\n      e.preventDefault();\n    }\n  }\n\n  swiper.emit('touchStart', e);\n}\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/components/core/events/onTouchStart.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/components/core/grab-cursor/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/swiper/esm/components/core/grab-cursor/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _setGrabCursor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./setGrabCursor */ \"./node_modules/swiper/esm/components/core/grab-cursor/setGrabCursor.js\");\n/* harmony import */ var _unsetGrabCursor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./unsetGrabCursor */ \"./node_modules/swiper/esm/components/core/grab-cursor/unsetGrabCursor.js\");\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  setGrabCursor: _setGrabCursor__WEBPACK_IMPORTED_MODULE_0__[\"default\"],\n  unsetGrabCursor: _unsetGrabCursor__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\n});\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/components/core/grab-cursor/index.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/components/core/grab-cursor/setGrabCursor.js":
/*!******************************************************************************!*\
  !*** ./node_modules/swiper/esm/components/core/grab-cursor/setGrabCursor.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ setGrabCursor)\n/* harmony export */ });\nfunction setGrabCursor(moving) {\n  var swiper = this;\n  if (swiper.support.touch || !swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;\n  var el = swiper.el;\n  el.style.cursor = 'move';\n  el.style.cursor = moving ? '-webkit-grabbing' : '-webkit-grab';\n  el.style.cursor = moving ? '-moz-grabbin' : '-moz-grab';\n  el.style.cursor = moving ? 'grabbing' : 'grab';\n}\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/components/core/grab-cursor/setGrabCursor.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/components/core/grab-cursor/unsetGrabCursor.js":
/*!********************************************************************************!*\
  !*** ./node_modules/swiper/esm/components/core/grab-cursor/unsetGrabCursor.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ unsetGrabCursor)\n/* harmony export */ });\nfunction unsetGrabCursor() {\n  var swiper = this;\n\n  if (swiper.support.touch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {\n    return;\n  }\n\n  swiper.el.style.cursor = '';\n}\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/components/core/grab-cursor/unsetGrabCursor.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/components/core/images/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/swiper/esm/components/core/images/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _loadImage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./loadImage */ \"./node_modules/swiper/esm/components/core/images/loadImage.js\");\n/* harmony import */ var _preloadImages__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./preloadImages */ \"./node_modules/swiper/esm/components/core/images/preloadImages.js\");\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  loadImage: _loadImage__WEBPACK_IMPORTED_MODULE_0__[\"default\"],\n  preloadImages: _preloadImages__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\n});\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/components/core/images/index.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/components/core/images/loadImage.js":
/*!*********************************************************************!*\
  !*** ./node_modules/swiper/esm/components/core/images/loadImage.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ loadImage)\n/* harmony export */ });\n/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ \"./node_modules/ssr-window/ssr-window.esm.js\");\n/* harmony import */ var _utils_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../utils/dom */ \"./node_modules/swiper/esm/utils/dom.js\");\n\n\nfunction loadImage(imageEl, src, srcset, sizes, checkForComplete, callback) {\n  var window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();\n  var image;\n\n  function onReady() {\n    if (callback) callback();\n  }\n\n  var isPicture = (0,_utils_dom__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(imageEl).parent('picture')[0];\n\n  if (!isPicture && (!imageEl.complete || !checkForComplete)) {\n    if (src) {\n      image = new window.Image();\n      image.onload = onReady;\n      image.onerror = onReady;\n\n      if (sizes) {\n        image.sizes = sizes;\n      }\n\n      if (srcset) {\n        image.srcset = srcset;\n      }\n\n      if (src) {\n        image.src = src;\n      }\n    } else {\n      onReady();\n    }\n  } else {\n    // image already loaded...\n    onReady();\n  }\n}\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/components/core/images/loadImage.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/components/core/images/preloadImages.js":
/*!*************************************************************************!*\
  !*** ./node_modules/swiper/esm/components/core/images/preloadImages.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ preloadImages)\n/* harmony export */ });\nfunction preloadImages() {\n  var swiper = this;\n  swiper.imagesToLoad = swiper.$el.find('img');\n\n  function onReady() {\n    if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper.destroyed) return;\n    if (swiper.imagesLoaded !== undefined) swiper.imagesLoaded += 1;\n\n    if (swiper.imagesLoaded === swiper.imagesToLoad.length) {\n      if (swiper.params.updateOnImagesReady) swiper.update();\n      swiper.emit('imagesReady');\n    }\n  }\n\n  for (var i = 0; i < swiper.imagesToLoad.length; i += 1) {\n    var imageEl = swiper.imagesToLoad[i];\n    swiper.loadImage(imageEl, imageEl.currentSrc || imageEl.getAttribute('src'), imageEl.srcset || imageEl.getAttribute('srcset'), imageEl.sizes || imageEl.getAttribute('sizes'), true, onReady);\n  }\n}\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/components/core/images/preloadImages.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/components/core/loop/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/swiper/esm/components/core/loop/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _loopCreate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./loopCreate */ \"./node_modules/swiper/esm/components/core/loop/loopCreate.js\");\n/* harmony import */ var _loopFix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./loopFix */ \"./node_modules/swiper/esm/components/core/loop/loopFix.js\");\n/* harmony import */ var _loopDestroy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./loopDestroy */ \"./node_modules/swiper/esm/components/core/loop/loopDestroy.js\");\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  loopCreate: _loopCreate__WEBPACK_IMPORTED_MODULE_0__[\"default\"],\n  loopFix: _loopFix__WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n  loopDestroy: _loopDestroy__WEBPACK_IMPORTED_MODULE_2__[\"default\"]\n});\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/components/core/loop/index.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/components/core/loop/loopCreate.js":
/*!********************************************************************!*\
  !*** ./node_modules/swiper/esm/components/core/loop/loopCreate.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ loopCreate)\n/* harmony export */ });\n/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ \"./node_modules/ssr-window/ssr-window.esm.js\");\n/* harmony import */ var _utils_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../utils/dom */ \"./node_modules/swiper/esm/utils/dom.js\");\n\n\nfunction loopCreate() {\n  var swiper = this;\n  var document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();\n  var params = swiper.params,\n      $wrapperEl = swiper.$wrapperEl; // Remove duplicated slides\n\n  $wrapperEl.children(\".\" + params.slideClass + \".\" + params.slideDuplicateClass).remove();\n  var slides = $wrapperEl.children(\".\" + params.slideClass);\n\n  if (params.loopFillGroupWithBlank) {\n    var blankSlidesNum = params.slidesPerGroup - slides.length % params.slidesPerGroup;\n\n    if (blankSlidesNum !== params.slidesPerGroup) {\n      for (var i = 0; i < blankSlidesNum; i += 1) {\n        var blankNode = (0,_utils_dom__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(document.createElement('div')).addClass(params.slideClass + \" \" + params.slideBlankClass);\n        $wrapperEl.append(blankNode);\n      }\n\n      slides = $wrapperEl.children(\".\" + params.slideClass);\n    }\n  }\n\n  if (params.slidesPerView === 'auto' && !params.loopedSlides) params.loopedSlides = slides.length;\n  swiper.loopedSlides = Math.ceil(parseFloat(params.loopedSlides || params.slidesPerView, 10));\n  swiper.loopedSlides += params.loopAdditionalSlides;\n\n  if (swiper.loopedSlides > slides.length) {\n    swiper.loopedSlides = slides.length;\n  }\n\n  var prependSlides = [];\n  var appendSlides = [];\n  slides.each(function (el, index) {\n    var slide = (0,_utils_dom__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(el);\n\n    if (index < swiper.loopedSlides) {\n      appendSlides.push(el);\n    }\n\n    if (index < slides.length && index >= slides.length - swiper.loopedSlides) {\n      prependSlides.push(el);\n    }\n\n    slide.attr('data-swiper-slide-index', index);\n  });\n\n  for (var _i = 0; _i < appendSlides.length; _i += 1) {\n    $wrapperEl.append((0,_utils_dom__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(appendSlides[_i].cloneNode(true)).addClass(params.slideDuplicateClass));\n  }\n\n  for (var _i2 = prependSlides.length - 1; _i2 >= 0; _i2 -= 1) {\n    $wrapperEl.prepend((0,_utils_dom__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(prependSlides[_i2].cloneNode(true)).addClass(params.slideDuplicateClass));\n  }\n}\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/components/core/loop/loopCreate.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/components/core/loop/loopDestroy.js":
/*!*********************************************************************!*\
  !*** ./node_modules/swiper/esm/components/core/loop/loopDestroy.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ loopDestroy)\n/* harmony export */ });\nfunction loopDestroy() {\n  var swiper = this;\n  var $wrapperEl = swiper.$wrapperEl,\n      params = swiper.params,\n      slides = swiper.slides;\n  $wrapperEl.children(\".\" + params.slideClass + \".\" + params.slideDuplicateClass + \",.\" + params.slideClass + \".\" + params.slideBlankClass).remove();\n  slides.removeAttr('data-swiper-slide-index');\n}\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/components/core/loop/loopDestroy.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/components/core/loop/loopFix.js":
/*!*****************************************************************!*\
  !*** ./node_modules/swiper/esm/components/core/loop/loopFix.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ loopFix)\n/* harmony export */ });\nfunction loopFix() {\n  var swiper = this;\n  swiper.emit('beforeLoopFix');\n  var activeIndex = swiper.activeIndex,\n      slides = swiper.slides,\n      loopedSlides = swiper.loopedSlides,\n      allowSlidePrev = swiper.allowSlidePrev,\n      allowSlideNext = swiper.allowSlideNext,\n      snapGrid = swiper.snapGrid,\n      rtl = swiper.rtlTranslate;\n  var newIndex;\n  swiper.allowSlidePrev = true;\n  swiper.allowSlideNext = true;\n  var snapTranslate = -snapGrid[activeIndex];\n  var diff = snapTranslate - swiper.getTranslate(); // Fix For Negative Oversliding\n\n  if (activeIndex < loopedSlides) {\n    newIndex = slides.length - loopedSlides * 3 + activeIndex;\n    newIndex += loopedSlides;\n    var slideChanged = swiper.slideTo(newIndex, 0, false, true);\n\n    if (slideChanged && diff !== 0) {\n      swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);\n    }\n  } else if (activeIndex >= slides.length - loopedSlides) {\n    // Fix For Positive Oversliding\n    newIndex = -slides.length + activeIndex + loopedSlides;\n    newIndex += loopedSlides;\n\n    var _slideChanged = swiper.slideTo(newIndex, 0, false, true);\n\n    if (_slideChanged && diff !== 0) {\n      swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);\n    }\n  }\n\n  swiper.allowSlidePrev = allowSlidePrev;\n  swiper.allowSlideNext = allowSlideNext;\n  swiper.emit('loopFix');\n}\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/components/core/loop/loopFix.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/components/core/manipulation/addSlide.js":
/*!**************************************************************************!*\
  !*** ./node_modules/swiper/esm/components/core/manipulation/addSlide.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ addSlide)\n/* harmony export */ });\nfunction addSlide(index, slides) {\n  var swiper = this;\n  var $wrapperEl = swiper.$wrapperEl,\n      params = swiper.params,\n      activeIndex = swiper.activeIndex;\n  var activeIndexBuffer = activeIndex;\n\n  if (params.loop) {\n    activeIndexBuffer -= swiper.loopedSlides;\n    swiper.loopDestroy();\n    swiper.slides = $wrapperEl.children(\".\" + params.slideClass);\n  }\n\n  var baseLength = swiper.slides.length;\n\n  if (index <= 0) {\n    swiper.prependSlide(slides);\n    return;\n  }\n\n  if (index >= baseLength) {\n    swiper.appendSlide(slides);\n    return;\n  }\n\n  var newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;\n  var slidesBuffer = [];\n\n  for (var i = baseLength - 1; i >= index; i -= 1) {\n    var currentSlide = swiper.slides.eq(i);\n    currentSlide.remove();\n    slidesBuffer.unshift(currentSlide);\n  }\n\n  if (typeof slides === 'object' && 'length' in slides) {\n    for (var _i = 0; _i < slides.length; _i += 1) {\n      if (slides[_i]) $wrapperEl.append(slides[_i]);\n    }\n\n    newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;\n  } else {\n    $wrapperEl.append(slides);\n  }\n\n  for (var _i2 = 0; _i2 < slidesBuffer.length; _i2 += 1) {\n    $wrapperEl.append(slidesBuffer[_i2]);\n  }\n\n  if (params.loop) {\n    swiper.loopCreate();\n  }\n\n  if (!(params.observer && swiper.support.observer)) {\n    swiper.update();\n  }\n\n  if (params.loop) {\n    swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);\n  } else {\n    swiper.slideTo(newActiveIndex, 0, false);\n  }\n}\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/components/core/manipulation/addSlide.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/components/core/manipulation/appendSlide.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/swiper/esm/components/core/manipulation/appendSlide.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ appendSlide)\n/* harmony export */ });\nfunction appendSlide(slides) {\n  var swiper = this;\n  var $wrapperEl = swiper.$wrapperEl,\n      params = swiper.params;\n\n  if (params.loop) {\n    swiper.loopDestroy();\n  }\n\n  if (typeof slides === 'object' && 'length' in slides) {\n    for (var i = 0; i < slides.length; i += 1) {\n      if (slides[i]) $wrapperEl.append(slides[i]);\n    }\n  } else {\n    $wrapperEl.append(slides);\n  }\n\n  if (params.loop) {\n    swiper.loopCreate();\n  }\n\n  if (!(params.observer && swiper.support.observer)) {\n    swiper.update();\n  }\n}\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/components/core/manipulation/appendSlide.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/components/core/manipulation/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/swiper/esm/components/core/manipulation/index.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _appendSlide__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./appendSlide */ \"./node_modules/swiper/esm/components/core/manipulation/appendSlide.js\");\n/* harmony import */ var _prependSlide__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./prependSlide */ \"./node_modules/swiper/esm/components/core/manipulation/prependSlide.js\");\n/* harmony import */ var _addSlide__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./addSlide */ \"./node_modules/swiper/esm/components/core/manipulation/addSlide.js\");\n/* harmony import */ var _removeSlide__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./removeSlide */ \"./node_modules/swiper/esm/components/core/manipulation/removeSlide.js\");\n/* harmony import */ var _removeAllSlides__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./removeAllSlides */ \"./node_modules/swiper/esm/components/core/manipulation/removeAllSlides.js\");\n\n\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  appendSlide: _appendSlide__WEBPACK_IMPORTED_MODULE_0__[\"default\"],\n  prependSlide: _prependSlide__WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n  addSlide: _addSlide__WEBPACK_IMPORTED_MODULE_2__[\"default\"],\n  removeSlide: _removeSlide__WEBPACK_IMPORTED_MODULE_3__[\"default\"],\n  removeAllSlides: _removeAllSlides__WEBPACK_IMPORTED_MODULE_4__[\"default\"]\n});\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/components/core/manipulation/index.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/components/core/manipulation/prependSlide.js":
/*!******************************************************************************!*\
  !*** ./node_modules/swiper/esm/components/core/manipulation/prependSlide.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ prependSlide)\n/* harmony export */ });\nfunction prependSlide(slides) {\n  var swiper = this;\n  var params = swiper.params,\n      $wrapperEl = swiper.$wrapperEl,\n      activeIndex = swiper.activeIndex;\n\n  if (params.loop) {\n    swiper.loopDestroy();\n  }\n\n  var newActiveIndex = activeIndex + 1;\n\n  if (typeof slides === 'object' && 'length' in slides) {\n    for (var i = 0; i < slides.length; i += 1) {\n      if (slides[i]) $wrapperEl.prepend(slides[i]);\n    }\n\n    newActiveIndex = activeIndex + slides.length;\n  } else {\n    $wrapperEl.prepend(slides);\n  }\n\n  if (params.loop) {\n    swiper.loopCreate();\n  }\n\n  if (!(params.observer && swiper.support.observer)) {\n    swiper.update();\n  }\n\n  swiper.slideTo(newActiveIndex, 0, false);\n}\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/components/core/manipulation/prependSlide.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/components/core/manipulation/removeAllSlides.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/swiper/esm/components/core/manipulation/removeAllSlides.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ removeAllSlides)\n/* harmony export */ });\nfunction removeAllSlides() {\n  var swiper = this;\n  var slidesIndexes = [];\n\n  for (var i = 0; i < swiper.slides.length; i += 1) {\n    slidesIndexes.push(i);\n  }\n\n  swiper.removeSlide(slidesIndexes);\n}\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/components/core/manipulation/removeAllSlides.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/components/core/manipulation/removeSlide.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/swiper/esm/components/core/manipulation/removeSlide.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ removeSlide)\n/* harmony export */ });\nfunction removeSlide(slidesIndexes) {\n  var swiper = this;\n  var params = swiper.params,\n      $wrapperEl = swiper.$wrapperEl,\n      activeIndex = swiper.activeIndex;\n  var activeIndexBuffer = activeIndex;\n\n  if (params.loop) {\n    activeIndexBuffer -= swiper.loopedSlides;\n    swiper.loopDestroy();\n    swiper.slides = $wrapperEl.children(\".\" + params.slideClass);\n  }\n\n  var newActiveIndex = activeIndexBuffer;\n  var indexToRemove;\n\n  if (typeof slidesIndexes === 'object' && 'length' in slidesIndexes) {\n    for (var i = 0; i < slidesIndexes.length; i += 1) {\n      indexToRemove = slidesIndexes[i];\n      if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();\n      if (indexToRemove < newActiveIndex) newActiveIndex -= 1;\n    }\n\n    newActiveIndex = Math.max(newActiveIndex, 0);\n  } else {\n    indexToRemove = slidesIndexes;\n    if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();\n    if (indexToRemove < newActiveIndex) newActiveIndex -= 1;\n    newActiveIndex = Math.max(newActiveIndex, 0);\n  }\n\n  if (params.loop) {\n    swiper.loopCreate();\n  }\n\n  if (!(params.observer && swiper.support.observer)) {\n    swiper.update();\n  }\n\n  if (params.loop) {\n    swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);\n  } else {\n    swiper.slideTo(newActiveIndex, 0, false);\n  }\n}\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/components/core/manipulation/removeSlide.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/components/core/modular.js":
/*!************************************************************!*\
  !*** ./node_modules/swiper/esm/components/core/modular.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/utils */ \"./node_modules/swiper/esm/utils/utils.js\");\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  useParams: function useParams(instanceParams) {\n    var instance = this;\n    if (!instance.modules) return;\n    Object.keys(instance.modules).forEach(function (moduleName) {\n      var module = instance.modules[moduleName]; // Extend params\n\n      if (module.params) {\n        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.extend)(instanceParams, module.params);\n      }\n    });\n  },\n  useModules: function useModules(modulesParams) {\n    if (modulesParams === void 0) {\n      modulesParams = {};\n    }\n\n    var instance = this;\n    if (!instance.modules) return;\n    Object.keys(instance.modules).forEach(function (moduleName) {\n      var module = instance.modules[moduleName];\n      var moduleParams = modulesParams[moduleName] || {}; // Add event listeners\n\n      if (module.on && instance.on) {\n        Object.keys(module.on).forEach(function (moduleEventName) {\n          instance.on(moduleEventName, module.on[moduleEventName]);\n        });\n      } // Module create callback\n\n\n      if (module.create) {\n        module.create.bind(instance)(moduleParams);\n      }\n    });\n  }\n});\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/components/core/modular.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/components/core/slide/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/swiper/esm/components/core/slide/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _slideTo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./slideTo */ \"./node_modules/swiper/esm/components/core/slide/slideTo.js\");\n/* harmony import */ var _slideToLoop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./slideToLoop */ \"./node_modules/swiper/esm/components/core/slide/slideToLoop.js\");\n/* harmony import */ var _slideNext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./slideNext */ \"./node_modules/swiper/esm/components/core/slide/slideNext.js\");\n/* harmony import */ var _slidePrev__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./slidePrev */ \"./node_modules/swiper/esm/components/core/slide/slidePrev.js\");\n/* harmony import */ var _slideReset__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./slideReset */ \"./node_modules/swiper/esm/components/core/slide/slideReset.js\");\n/* harmony import */ var _slideToClosest__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./slideToClosest */ \"./node_modules/swiper/esm/components/core/slide/slideToClosest.js\");\n/* harmony import */ var _slideToClickedSlide__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./slideToClickedSlide */ \"./node_modules/swiper/esm/components/core/slide/slideToClickedSlide.js\");\n\n\n\n\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  slideTo: _slideTo__WEBPACK_IMPORTED_MODULE_0__[\"default\"],\n  slideToLoop: _slideToLoop__WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n  slideNext: _slideNext__WEBPACK_IMPORTED_MODULE_2__[\"default\"],\n  slidePrev: _slidePrev__WEBPACK_IMPORTED_MODULE_3__[\"default\"],\n  slideReset: _slideReset__WEBPACK_IMPORTED_MODULE_4__[\"default\"],\n  slideToClosest: _slideToClosest__WEBPACK_IMPORTED_MODULE_5__[\"default\"],\n  slideToClickedSlide: _slideToClickedSlide__WEBPACK_IMPORTED_MODULE_6__[\"default\"]\n});\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/components/core/slide/index.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/components/core/slide/slideNext.js":
/*!********************************************************************!*\
  !*** ./node_modules/swiper/esm/components/core/slide/slideNext.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ slideNext)\n/* harmony export */ });\n/* eslint no-unused-vars: \"off\" */\nfunction slideNext(speed, runCallbacks, internal) {\n  if (speed === void 0) {\n    speed = this.params.speed;\n  }\n\n  if (runCallbacks === void 0) {\n    runCallbacks = true;\n  }\n\n  var swiper = this;\n  var params = swiper.params,\n      animating = swiper.animating,\n      enabled = swiper.enabled;\n  if (!enabled) return swiper;\n  var increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup;\n\n  if (params.loop) {\n    if (animating && params.loopPreventsSlide) return false;\n    swiper.loopFix(); // eslint-disable-next-line\n\n    swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;\n  }\n\n  return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);\n}\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/components/core/slide/slideNext.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/components/core/slide/slidePrev.js":
/*!********************************************************************!*\
  !*** ./node_modules/swiper/esm/components/core/slide/slidePrev.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ slidePrev)\n/* harmony export */ });\n/* eslint no-unused-vars: \"off\" */\nfunction slidePrev(speed, runCallbacks, internal) {\n  if (speed === void 0) {\n    speed = this.params.speed;\n  }\n\n  if (runCallbacks === void 0) {\n    runCallbacks = true;\n  }\n\n  var swiper = this;\n  var params = swiper.params,\n      animating = swiper.animating,\n      snapGrid = swiper.snapGrid,\n      slidesGrid = swiper.slidesGrid,\n      rtlTranslate = swiper.rtlTranslate,\n      enabled = swiper.enabled;\n  if (!enabled) return swiper;\n\n  if (params.loop) {\n    if (animating && params.loopPreventsSlide) return false;\n    swiper.loopFix(); // eslint-disable-next-line\n\n    swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;\n  }\n\n  var translate = rtlTranslate ? swiper.translate : -swiper.translate;\n\n  function normalize(val) {\n    if (val < 0) return -Math.floor(Math.abs(val));\n    return Math.floor(val);\n  }\n\n  var normalizedTranslate = normalize(translate);\n  var normalizedSnapGrid = snapGrid.map(function (val) {\n    return normalize(val);\n  });\n  var prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];\n\n  if (typeof prevSnap === 'undefined' && params.cssMode) {\n    snapGrid.forEach(function (snap) {\n      if (!prevSnap && normalizedTranslate >= snap) prevSnap = snap;\n    });\n  }\n\n  var prevIndex;\n\n  if (typeof prevSnap !== 'undefined') {\n    prevIndex = slidesGrid.indexOf(prevSnap);\n    if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;\n  }\n\n  return swiper.slideTo(prevIndex, speed, runCallbacks, internal);\n}\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/components/core/slide/slidePrev.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/components/core/slide/slideReset.js":
/*!*********************************************************************!*\
  !*** ./node_modules/swiper/esm/components/core/slide/slideReset.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ slideReset)\n/* harmony export */ });\n/* eslint no-unused-vars: \"off\" */\nfunction slideReset(speed, runCallbacks, internal) {\n  if (speed === void 0) {\n    speed = this.params.speed;\n  }\n\n  if (runCallbacks === void 0) {\n    runCallbacks = true;\n  }\n\n  var swiper = this;\n  return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);\n}\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/components/core/slide/slideReset.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/components/core/slide/slideTo.js":
/*!******************************************************************!*\
  !*** ./node_modules/swiper/esm/components/core/slide/slideTo.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ slideTo)\n/* harmony export */ });\nfunction slideTo(index, speed, runCallbacks, internal, initial) {\n  if (index === void 0) {\n    index = 0;\n  }\n\n  if (speed === void 0) {\n    speed = this.params.speed;\n  }\n\n  if (runCallbacks === void 0) {\n    runCallbacks = true;\n  }\n\n  if (typeof index !== 'number' && typeof index !== 'string') {\n    throw new Error(\"The 'index' argument cannot have type other than 'number' or 'string'. [\" + typeof index + \"] given.\");\n  }\n\n  if (typeof index === 'string') {\n    /**\n     * The `index` argument converted from `string` to `number`.\n     * @type {number}\n     */\n    var indexAsNumber = parseInt(index, 10);\n    /**\n     * Determines whether the `index` argument is a valid `number`\n     * after being converted from the `string` type.\n     * @type {boolean}\n     */\n\n    var isValidNumber = isFinite(indexAsNumber);\n\n    if (!isValidNumber) {\n      throw new Error(\"The passed-in 'index' (string) couldn't be converted to 'number'. [\" + index + \"] given.\");\n    } // Knowing that the converted `index` is a valid number,\n    // we can update the original argument's value.\n\n\n    index = indexAsNumber;\n  }\n\n  var swiper = this;\n  var slideIndex = index;\n  if (slideIndex < 0) slideIndex = 0;\n  var params = swiper.params,\n      snapGrid = swiper.snapGrid,\n      slidesGrid = swiper.slidesGrid,\n      previousIndex = swiper.previousIndex,\n      activeIndex = swiper.activeIndex,\n      rtl = swiper.rtlTranslate,\n      wrapperEl = swiper.wrapperEl,\n      enabled = swiper.enabled;\n\n  if (swiper.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial) {\n    return false;\n  }\n\n  var skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);\n  var snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);\n  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;\n\n  if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) {\n    swiper.emit('beforeSlideChangeStart');\n  }\n\n  var translate = -snapGrid[snapIndex]; // Update progress\n\n  swiper.updateProgress(translate); // Normalize slideIndex\n\n  if (params.normalizeSlideIndex) {\n    for (var i = 0; i < slidesGrid.length; i += 1) {\n      var normalizedTranslate = -Math.floor(translate * 100);\n      var normalizedGird = Math.floor(slidesGrid[i] * 100);\n      var normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);\n\n      if (typeof slidesGrid[i + 1] !== 'undefined') {\n        if (normalizedTranslate >= normalizedGird && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGird) / 2) {\n          slideIndex = i;\n        } else if (normalizedTranslate >= normalizedGird && normalizedTranslate < normalizedGridNext) {\n          slideIndex = i + 1;\n        }\n      } else if (normalizedTranslate >= normalizedGird) {\n        slideIndex = i;\n      }\n    }\n  } // Directions locks\n\n\n  if (swiper.initialized && slideIndex !== activeIndex) {\n    if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {\n      return false;\n    }\n\n    if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {\n      if ((activeIndex || 0) !== slideIndex) return false;\n    }\n  }\n\n  var direction;\n  if (slideIndex > activeIndex) direction = 'next';else if (slideIndex < activeIndex) direction = 'prev';else direction = 'reset'; // Update Index\n\n  if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {\n    swiper.updateActiveIndex(slideIndex); // Update Height\n\n    if (params.autoHeight) {\n      swiper.updateAutoHeight();\n    }\n\n    swiper.updateSlidesClasses();\n\n    if (params.effect !== 'slide') {\n      swiper.setTranslate(translate);\n    }\n\n    if (direction !== 'reset') {\n      swiper.transitionStart(runCallbacks, direction);\n      swiper.transitionEnd(runCallbacks, direction);\n    }\n\n    return false;\n  }\n\n  if (params.cssMode) {\n    var isH = swiper.isHorizontal();\n    var t = -translate;\n\n    if (rtl) {\n      t = wrapperEl.scrollWidth - wrapperEl.offsetWidth - t;\n    }\n\n    if (speed === 0) {\n      wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;\n    } else {\n      // eslint-disable-next-line\n      if (wrapperEl.scrollTo) {\n        var _wrapperEl$scrollTo;\n\n        wrapperEl.scrollTo((_wrapperEl$scrollTo = {}, _wrapperEl$scrollTo[isH ? 'left' : 'top'] = t, _wrapperEl$scrollTo.behavior = 'smooth', _wrapperEl$scrollTo));\n      } else {\n        wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;\n      }\n    }\n\n    return true;\n  }\n\n  if (speed === 0) {\n    swiper.setTransition(0);\n    swiper.setTranslate(translate);\n    swiper.updateActiveIndex(slideIndex);\n    swiper.updateSlidesClasses();\n    swiper.emit('beforeTransitionStart', speed, internal);\n    swiper.transitionStart(runCallbacks, direction);\n    swiper.transitionEnd(runCallbacks, direction);\n  } else {\n    swiper.setTransition(speed);\n    swiper.setTranslate(translate);\n    swiper.updateActiveIndex(slideIndex);\n    swiper.updateSlidesClasses();\n    swiper.emit('beforeTransitionStart', speed, internal);\n    swiper.transitionStart(runCallbacks, direction);\n\n    if (!swiper.animating) {\n      swiper.animating = true;\n\n      if (!swiper.onSlideToWrapperTransitionEnd) {\n        swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {\n          if (!swiper || swiper.destroyed) return;\n          if (e.target !== this) return;\n          swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);\n          swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);\n          swiper.onSlideToWrapperTransitionEnd = null;\n          delete swiper.onSlideToWrapperTransitionEnd;\n          swiper.transitionEnd(runCallbacks, direction);\n        };\n      }\n\n      swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);\n      swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);\n    }\n  }\n\n  return true;\n}\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/components/core/slide/slideTo.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/components/core/slide/slideToClickedSlide.js":
/*!******************************************************************************!*\
  !*** ./node_modules/swiper/esm/components/core/slide/slideToClickedSlide.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ slideToClickedSlide)\n/* harmony export */ });\n/* harmony import */ var _utils_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../utils/dom */ \"./node_modules/swiper/esm/utils/dom.js\");\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../utils/utils */ \"./node_modules/swiper/esm/utils/utils.js\");\n\n\nfunction slideToClickedSlide() {\n  var swiper = this;\n  var params = swiper.params,\n      $wrapperEl = swiper.$wrapperEl;\n  var slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;\n  var slideToIndex = swiper.clickedIndex;\n  var realIndex;\n\n  if (params.loop) {\n    if (swiper.animating) return;\n    realIndex = parseInt((0,_utils_dom__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(swiper.clickedSlide).attr('data-swiper-slide-index'), 10);\n\n    if (params.centeredSlides) {\n      if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {\n        swiper.loopFix();\n        slideToIndex = $wrapperEl.children(\".\" + params.slideClass + \"[data-swiper-slide-index=\\\"\" + realIndex + \"\\\"]:not(.\" + params.slideDuplicateClass + \")\").eq(0).index();\n        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.nextTick)(function () {\n          swiper.slideTo(slideToIndex);\n        });\n      } else {\n        swiper.slideTo(slideToIndex);\n      }\n    } else if (slideToIndex > swiper.slides.length - slidesPerView) {\n      swiper.loopFix();\n      slideToIndex = $wrapperEl.children(\".\" + params.slideClass + \"[data-swiper-slide-index=\\\"\" + realIndex + \"\\\"]:not(.\" + params.slideDuplicateClass + \")\").eq(0).index();\n      (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.nextTick)(function () {\n        swiper.slideTo(slideToIndex);\n      });\n    } else {\n      swiper.slideTo(slideToIndex);\n    }\n  } else {\n    swiper.slideTo(slideToIndex);\n  }\n}\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/components/core/slide/slideToClickedSlide.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/components/core/slide/slideToClosest.js":
/*!*************************************************************************!*\
  !*** ./node_modules/swiper/esm/components/core/slide/slideToClosest.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ slideToClosest)\n/* harmony export */ });\n/* eslint no-unused-vars: \"off\" */\nfunction slideToClosest(speed, runCallbacks, internal, threshold) {\n  if (speed === void 0) {\n    speed = this.params.speed;\n  }\n\n  if (runCallbacks === void 0) {\n    runCallbacks = true;\n  }\n\n  if (threshold === void 0) {\n    threshold = 0.5;\n  }\n\n  var swiper = this;\n  var index = swiper.activeIndex;\n  var skip = Math.min(swiper.params.slidesPerGroupSkip, index);\n  var snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);\n  var translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n\n  if (translate >= swiper.snapGrid[snapIndex]) {\n    // The current translate is on or after the current snap index, so the choice\n    // is between the current index and the one after it.\n    var currentSnap = swiper.snapGrid[snapIndex];\n    var nextSnap = swiper.snapGrid[snapIndex + 1];\n\n    if (translate - currentSnap > (nextSnap - currentSnap) * threshold) {\n      index += swiper.params.slidesPerGroup;\n    }\n  } else {\n    // The current translate is before the current snap index, so the choice\n    // is between the current index and the one before it.\n    var prevSnap = swiper.snapGrid[snapIndex - 1];\n    var _currentSnap = swiper.snapGrid[snapIndex];\n\n    if (translate - prevSnap <= (_currentSnap - prevSnap) * threshold) {\n      index -= swiper.params.slidesPerGroup;\n    }\n  }\n\n  index = Math.max(index, 0);\n  index = Math.min(index, swiper.slidesGrid.length - 1);\n  return swiper.slideTo(index, speed, runCallbacks, internal);\n}\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/components/core/slide/slideToClosest.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/components/core/slide/slideToLoop.js":
/*!**********************************************************************!*\
  !*** ./node_modules/swiper/esm/components/core/slide/slideToLoop.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ slideToLoop)\n/* harmony export */ });\nfunction slideToLoop(index, speed, runCallbacks, internal) {\n  if (index === void 0) {\n    index = 0;\n  }\n\n  if (speed === void 0) {\n    speed = this.params.speed;\n  }\n\n  if (runCallbacks === void 0) {\n    runCallbacks = true;\n  }\n\n  var swiper = this;\n  var newIndex = index;\n\n  if (swiper.params.loop) {\n    newIndex += swiper.loopedSlides;\n  }\n\n  return swiper.slideTo(newIndex, speed, runCallbacks, internal);\n}\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/components/core/slide/slideToLoop.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/components/core/transition/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/swiper/esm/components/core/transition/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _setTransition__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./setTransition */ \"./node_modules/swiper/esm/components/core/transition/setTransition.js\");\n/* harmony import */ var _transitionStart__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transitionStart */ \"./node_modules/swiper/esm/components/core/transition/transitionStart.js\");\n/* harmony import */ var _transitionEnd__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./transitionEnd */ \"./node_modules/swiper/esm/components/core/transition/transitionEnd.js\");\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  setTransition: _setTransition__WEBPACK_IMPORTED_MODULE_0__[\"default\"],\n  transitionStart: _transitionStart__WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n  transitionEnd: _transitionEnd__WEBPACK_IMPORTED_MODULE_2__[\"default\"]\n});\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/components/core/transition/index.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/components/core/transition/setTransition.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/swiper/esm/components/core/transition/setTransition.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ setTransition)\n/* harmony export */ });\nfunction setTransition(duration, byController) {\n  var swiper = this;\n\n  if (!swiper.params.cssMode) {\n    swiper.$wrapperEl.transition(duration);\n  }\n\n  swiper.emit('setTransition', duration, byController);\n}\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/components/core/transition/setTransition.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/components/core/transition/transitionEnd.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/swiper/esm/components/core/transition/transitionEnd.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ transitionEnd)\n/* harmony export */ });\nfunction transitionEnd(runCallbacks, direction) {\n  if (runCallbacks === void 0) {\n    runCallbacks = true;\n  }\n\n  var swiper = this;\n  var activeIndex = swiper.activeIndex,\n      previousIndex = swiper.previousIndex,\n      params = swiper.params;\n  swiper.animating = false;\n  if (params.cssMode) return;\n  swiper.setTransition(0);\n  var dir = direction;\n\n  if (!dir) {\n    if (activeIndex > previousIndex) dir = 'next';else if (activeIndex < previousIndex) dir = 'prev';else dir = 'reset';\n  }\n\n  swiper.emit('transitionEnd');\n\n  if (runCallbacks && activeIndex !== previousIndex) {\n    if (dir === 'reset') {\n      swiper.emit('slideResetTransitionEnd');\n      return;\n    }\n\n    swiper.emit('slideChangeTransitionEnd');\n\n    if (dir === 'next') {\n      swiper.emit('slideNextTransitionEnd');\n    } else {\n      swiper.emit('slidePrevTransitionEnd');\n    }\n  }\n}\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/components/core/transition/transitionEnd.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/components/core/transition/transitionStart.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/swiper/esm/components/core/transition/transitionStart.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ transitionStart)\n/* harmony export */ });\nfunction transitionStart(runCallbacks, direction) {\n  if (runCallbacks === void 0) {\n    runCallbacks = true;\n  }\n\n  var swiper = this;\n  var activeIndex = swiper.activeIndex,\n      params = swiper.params,\n      previousIndex = swiper.previousIndex;\n  if (params.cssMode) return;\n\n  if (params.autoHeight) {\n    swiper.updateAutoHeight();\n  }\n\n  var dir = direction;\n\n  if (!dir) {\n    if (activeIndex > previousIndex) dir = 'next';else if (activeIndex < previousIndex) dir = 'prev';else dir = 'reset';\n  }\n\n  swiper.emit('transitionStart');\n\n  if (runCallbacks && activeIndex !== previousIndex) {\n    if (dir === 'reset') {\n      swiper.emit('slideResetTransitionStart');\n      return;\n    }\n\n    swiper.emit('slideChangeTransitionStart');\n\n    if (dir === 'next') {\n      swiper.emit('slideNextTransitionStart');\n    } else {\n      swiper.emit('slidePrevTransitionStart');\n    }\n  }\n}\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/components/core/transition/transitionStart.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/components/core/translate/getTranslate.js":
/*!***************************************************************************!*\
  !*** ./node_modules/swiper/esm/components/core/translate/getTranslate.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getSwiperTranslate)\n/* harmony export */ });\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../utils/utils */ \"./node_modules/swiper/esm/utils/utils.js\");\n\nfunction getSwiperTranslate(axis) {\n  if (axis === void 0) {\n    axis = this.isHorizontal() ? 'x' : 'y';\n  }\n\n  var swiper = this;\n  var params = swiper.params,\n      rtl = swiper.rtlTranslate,\n      translate = swiper.translate,\n      $wrapperEl = swiper.$wrapperEl;\n\n  if (params.virtualTranslate) {\n    return rtl ? -translate : translate;\n  }\n\n  if (params.cssMode) {\n    return translate;\n  }\n\n  var currentTranslate = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.getTranslate)($wrapperEl[0], axis);\n  if (rtl) currentTranslate = -currentTranslate;\n  return currentTranslate || 0;\n}\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/components/core/translate/getTranslate.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/components/core/translate/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/swiper/esm/components/core/translate/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _getTranslate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getTranslate */ \"./node_modules/swiper/esm/components/core/translate/getTranslate.js\");\n/* harmony import */ var _setTranslate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./setTranslate */ \"./node_modules/swiper/esm/components/core/translate/setTranslate.js\");\n/* harmony import */ var _minTranslate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./minTranslate */ \"./node_modules/swiper/esm/components/core/translate/minTranslate.js\");\n/* harmony import */ var _maxTranslate__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./maxTranslate */ \"./node_modules/swiper/esm/components/core/translate/maxTranslate.js\");\n/* harmony import */ var _translateTo__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./translateTo */ \"./node_modules/swiper/esm/components/core/translate/translateTo.js\");\n\n\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  getTranslate: _getTranslate__WEBPACK_IMPORTED_MODULE_0__[\"default\"],\n  setTranslate: _setTranslate__WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n  minTranslate: _minTranslate__WEBPACK_IMPORTED_MODULE_2__[\"default\"],\n  maxTranslate: _maxTranslate__WEBPACK_IMPORTED_MODULE_3__[\"default\"],\n  translateTo: _translateTo__WEBPACK_IMPORTED_MODULE_4__[\"default\"]\n});\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/components/core/translate/index.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/components/core/translate/maxTranslate.js":
/*!***************************************************************************!*\
  !*** ./node_modules/swiper/esm/components/core/translate/maxTranslate.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ maxTranslate)\n/* harmony export */ });\nfunction maxTranslate() {\n  return -this.snapGrid[this.snapGrid.length - 1];\n}\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/components/core/translate/maxTranslate.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/components/core/translate/minTranslate.js":
/*!***************************************************************************!*\
  !*** ./node_modules/swiper/esm/components/core/translate/minTranslate.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ minTranslate)\n/* harmony export */ });\nfunction minTranslate() {\n  return -this.snapGrid[0];\n}\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/components/core/translate/minTranslate.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/components/core/translate/setTranslate.js":
/*!***************************************************************************!*\
  !*** ./node_modules/swiper/esm/components/core/translate/setTranslate.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ setTranslate)\n/* harmony export */ });\nfunction setTranslate(translate, byController) {\n  var swiper = this;\n  var rtl = swiper.rtlTranslate,\n      params = swiper.params,\n      $wrapperEl = swiper.$wrapperEl,\n      wrapperEl = swiper.wrapperEl,\n      progress = swiper.progress;\n  var x = 0;\n  var y = 0;\n  var z = 0;\n\n  if (swiper.isHorizontal()) {\n    x = rtl ? -translate : translate;\n  } else {\n    y = translate;\n  }\n\n  if (params.roundLengths) {\n    x = Math.floor(x);\n    y = Math.floor(y);\n  }\n\n  if (params.cssMode) {\n    wrapperEl[swiper.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = swiper.isHorizontal() ? -x : -y;\n  } else if (!params.virtualTranslate) {\n    $wrapperEl.transform(\"translate3d(\" + x + \"px, \" + y + \"px, \" + z + \"px)\");\n  }\n\n  swiper.previousTranslate = swiper.translate;\n  swiper.translate = swiper.isHorizontal() ? x : y; // Check if we need to update progress\n\n  var newProgress;\n  var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n\n  if (translatesDiff === 0) {\n    newProgress = 0;\n  } else {\n    newProgress = (translate - swiper.minTranslate()) / translatesDiff;\n  }\n\n  if (newProgress !== progress) {\n    swiper.updateProgress(translate);\n  }\n\n  swiper.emit('setTranslate', swiper.translate, byController);\n}\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/components/core/translate/setTranslate.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/components/core/translate/translateTo.js":
/*!**************************************************************************!*\
  !*** ./node_modules/swiper/esm/components/core/translate/translateTo.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ translateTo)\n/* harmony export */ });\nfunction translateTo(translate, speed, runCallbacks, translateBounds, internal) {\n  if (translate === void 0) {\n    translate = 0;\n  }\n\n  if (speed === void 0) {\n    speed = this.params.speed;\n  }\n\n  if (runCallbacks === void 0) {\n    runCallbacks = true;\n  }\n\n  if (translateBounds === void 0) {\n    translateBounds = true;\n  }\n\n  var swiper = this;\n  var params = swiper.params,\n      wrapperEl = swiper.wrapperEl;\n\n  if (swiper.animating && params.preventInteractionOnTransition) {\n    return false;\n  }\n\n  var minTranslate = swiper.minTranslate();\n  var maxTranslate = swiper.maxTranslate();\n  var newTranslate;\n  if (translateBounds && translate > minTranslate) newTranslate = minTranslate;else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate;else newTranslate = translate; // Update progress\n\n  swiper.updateProgress(newTranslate);\n\n  if (params.cssMode) {\n    var isH = swiper.isHorizontal();\n\n    if (speed === 0) {\n      wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;\n    } else {\n      // eslint-disable-next-line\n      if (wrapperEl.scrollTo) {\n        var _wrapperEl$scrollTo;\n\n        wrapperEl.scrollTo((_wrapperEl$scrollTo = {}, _wrapperEl$scrollTo[isH ? 'left' : 'top'] = -newTranslate, _wrapperEl$scrollTo.behavior = 'smooth', _wrapperEl$scrollTo));\n      } else {\n        wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;\n      }\n    }\n\n    return true;\n  }\n\n  if (speed === 0) {\n    swiper.setTransition(0);\n    swiper.setTranslate(newTranslate);\n\n    if (runCallbacks) {\n      swiper.emit('beforeTransitionStart', speed, internal);\n      swiper.emit('transitionEnd');\n    }\n  } else {\n    swiper.setTransition(speed);\n    swiper.setTranslate(newTranslate);\n\n    if (runCallbacks) {\n      swiper.emit('beforeTransitionStart', speed, internal);\n      swiper.emit('transitionStart');\n    }\n\n    if (!swiper.animating) {\n      swiper.animating = true;\n\n      if (!swiper.onTranslateToWrapperTransitionEnd) {\n        swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {\n          if (!swiper || swiper.destroyed) return;\n          if (e.target !== this) return;\n          swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);\n          swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);\n          swiper.onTranslateToWrapperTransitionEnd = null;\n          delete swiper.onTranslateToWrapperTransitionEnd;\n\n          if (runCallbacks) {\n            swiper.emit('transitionEnd');\n          }\n        };\n      }\n\n      swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);\n      swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);\n    }\n  }\n\n  return true;\n}\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/components/core/translate/translateTo.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/components/core/update/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/swiper/esm/components/core/update/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _updateSize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./updateSize */ \"./node_modules/swiper/esm/components/core/update/updateSize.js\");\n/* harmony import */ var _updateSlides__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./updateSlides */ \"./node_modules/swiper/esm/components/core/update/updateSlides.js\");\n/* harmony import */ var _updateAutoHeight__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./updateAutoHeight */ \"./node_modules/swiper/esm/components/core/update/updateAutoHeight.js\");\n/* harmony import */ var _updateSlidesOffset__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./updateSlidesOffset */ \"./node_modules/swiper/esm/components/core/update/updateSlidesOffset.js\");\n/* harmony import */ var _updateSlidesProgress__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./updateSlidesProgress */ \"./node_modules/swiper/esm/components/core/update/updateSlidesProgress.js\");\n/* harmony import */ var _updateProgress__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./updateProgress */ \"./node_modules/swiper/esm/components/core/update/updateProgress.js\");\n/* harmony import */ var _updateSlidesClasses__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./updateSlidesClasses */ \"./node_modules/swiper/esm/components/core/update/updateSlidesClasses.js\");\n/* harmony import */ var _updateActiveIndex__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./updateActiveIndex */ \"./node_modules/swiper/esm/components/core/update/updateActiveIndex.js\");\n/* harmony import */ var _updateClickedSlide__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./updateClickedSlide */ \"./node_modules/swiper/esm/components/core/update/updateClickedSlide.js\");\n\n\n\n\n\n\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  updateSize: _updateSize__WEBPACK_IMPORTED_MODULE_0__[\"default\"],\n  updateSlides: _updateSlides__WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n  updateAutoHeight: _updateAutoHeight__WEBPACK_IMPORTED_MODULE_2__[\"default\"],\n  updateSlidesOffset: _updateSlidesOffset__WEBPACK_IMPORTED_MODULE_3__[\"default\"],\n  updateSlidesProgress: _updateSlidesProgress__WEBPACK_IMPORTED_MODULE_4__[\"default\"],\n  updateProgress: _updateProgress__WEBPACK_IMPORTED_MODULE_5__[\"default\"],\n  updateSlidesClasses: _updateSlidesClasses__WEBPACK_IMPORTED_MODULE_6__[\"default\"],\n  updateActiveIndex: _updateActiveIndex__WEBPACK_IMPORTED_MODULE_7__[\"default\"],\n  updateClickedSlide: _updateClickedSlide__WEBPACK_IMPORTED_MODULE_8__[\"default\"]\n});\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/components/core/update/index.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/components/core/update/updateActiveIndex.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/swiper/esm/components/core/update/updateActiveIndex.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ updateActiveIndex)\n/* harmony export */ });\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../utils/utils */ \"./node_modules/swiper/esm/utils/utils.js\");\n\nfunction updateActiveIndex(newActiveIndex) {\n  var swiper = this;\n  var translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n  var slidesGrid = swiper.slidesGrid,\n      snapGrid = swiper.snapGrid,\n      params = swiper.params,\n      previousIndex = swiper.activeIndex,\n      previousRealIndex = swiper.realIndex,\n      previousSnapIndex = swiper.snapIndex;\n  var activeIndex = newActiveIndex;\n  var snapIndex;\n\n  if (typeof activeIndex === 'undefined') {\n    for (var i = 0; i < slidesGrid.length; i += 1) {\n      if (typeof slidesGrid[i + 1] !== 'undefined') {\n        if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {\n          activeIndex = i;\n        } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {\n          activeIndex = i + 1;\n        }\n      } else if (translate >= slidesGrid[i]) {\n        activeIndex = i;\n      }\n    } // Normalize slideIndex\n\n\n    if (params.normalizeSlideIndex) {\n      if (activeIndex < 0 || typeof activeIndex === 'undefined') activeIndex = 0;\n    }\n  }\n\n  if (snapGrid.indexOf(translate) >= 0) {\n    snapIndex = snapGrid.indexOf(translate);\n  } else {\n    var skip = Math.min(params.slidesPerGroupSkip, activeIndex);\n    snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);\n  }\n\n  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;\n\n  if (activeIndex === previousIndex) {\n    if (snapIndex !== previousSnapIndex) {\n      swiper.snapIndex = snapIndex;\n      swiper.emit('snapIndexChange');\n    }\n\n    return;\n  } // Get real index\n\n\n  var realIndex = parseInt(swiper.slides.eq(activeIndex).attr('data-swiper-slide-index') || activeIndex, 10);\n  (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.extend)(swiper, {\n    snapIndex: snapIndex,\n    realIndex: realIndex,\n    previousIndex: previousIndex,\n    activeIndex: activeIndex\n  });\n  swiper.emit('activeIndexChange');\n  swiper.emit('snapIndexChange');\n\n  if (previousRealIndex !== realIndex) {\n    swiper.emit('realIndexChange');\n  }\n\n  if (swiper.initialized || swiper.params.runCallbacksOnInit) {\n    swiper.emit('slideChange');\n  }\n}\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/components/core/update/updateActiveIndex.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/components/core/update/updateAutoHeight.js":
/*!****************************************************************************!*\
  !*** ./node_modules/swiper/esm/components/core/update/updateAutoHeight.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ updateAutoHeight)\n/* harmony export */ });\nfunction updateAutoHeight(speed) {\n  var swiper = this;\n  var activeSlides = [];\n  var isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n  var newHeight = 0;\n  var i;\n\n  if (typeof speed === 'number') {\n    swiper.setTransition(speed);\n  } else if (speed === true) {\n    swiper.setTransition(swiper.params.speed);\n  }\n\n  var getSlideByIndex = function getSlideByIndex(index) {\n    if (isVirtual) {\n      return swiper.slides.filter(function (el) {\n        return parseInt(el.getAttribute('data-swiper-slide-index'), 10) === index;\n      })[0];\n    }\n\n    return swiper.slides.eq(index)[0];\n  }; // Find slides currently in view\n\n\n  if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {\n    if (swiper.params.centeredSlides) {\n      swiper.visibleSlides.each(function (slide) {\n        activeSlides.push(slide);\n      });\n    } else {\n      for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {\n        var index = swiper.activeIndex + i;\n        if (index > swiper.slides.length && !isVirtual) break;\n        activeSlides.push(getSlideByIndex(index));\n      }\n    }\n  } else {\n    activeSlides.push(getSlideByIndex(swiper.activeIndex));\n  } // Find new height from highest slide in view\n\n\n  for (i = 0; i < activeSlides.length; i += 1) {\n    if (typeof activeSlides[i] !== 'undefined') {\n      var height = activeSlides[i].offsetHeight;\n      newHeight = height > newHeight ? height : newHeight;\n    }\n  } // Update Height\n\n\n  if (newHeight) swiper.$wrapperEl.css('height', newHeight + \"px\");\n}\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/components/core/update/updateAutoHeight.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/components/core/update/updateClickedSlide.js":
/*!******************************************************************************!*\
  !*** ./node_modules/swiper/esm/components/core/update/updateClickedSlide.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ updateClickedSlide)\n/* harmony export */ });\n/* harmony import */ var _utils_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../utils/dom */ \"./node_modules/swiper/esm/utils/dom.js\");\n\nfunction updateClickedSlide(e) {\n  var swiper = this;\n  var params = swiper.params;\n  var slide = (0,_utils_dom__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(e.target).closest(\".\" + params.slideClass)[0];\n  var slideFound = false;\n  var slideIndex;\n\n  if (slide) {\n    for (var i = 0; i < swiper.slides.length; i += 1) {\n      if (swiper.slides[i] === slide) {\n        slideFound = true;\n        slideIndex = i;\n        break;\n      }\n    }\n  }\n\n  if (slide && slideFound) {\n    swiper.clickedSlide = slide;\n\n    if (swiper.virtual && swiper.params.virtual.enabled) {\n      swiper.clickedIndex = parseInt((0,_utils_dom__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(slide).attr('data-swiper-slide-index'), 10);\n    } else {\n      swiper.clickedIndex = slideIndex;\n    }\n  } else {\n    swiper.clickedSlide = undefined;\n    swiper.clickedIndex = undefined;\n    return;\n  }\n\n  if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {\n    swiper.slideToClickedSlide();\n  }\n}\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/components/core/update/updateClickedSlide.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/components/core/update/updateProgress.js":
/*!**************************************************************************!*\
  !*** ./node_modules/swiper/esm/components/core/update/updateProgress.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ updateProgress)\n/* harmony export */ });\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../utils/utils */ \"./node_modules/swiper/esm/utils/utils.js\");\n\nfunction updateProgress(translate) {\n  var swiper = this;\n\n  if (typeof translate === 'undefined') {\n    var multiplier = swiper.rtlTranslate ? -1 : 1; // eslint-disable-next-line\n\n    translate = swiper && swiper.translate && swiper.translate * multiplier || 0;\n  }\n\n  var params = swiper.params;\n  var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n  var progress = swiper.progress,\n      isBeginning = swiper.isBeginning,\n      isEnd = swiper.isEnd;\n  var wasBeginning = isBeginning;\n  var wasEnd = isEnd;\n\n  if (translatesDiff === 0) {\n    progress = 0;\n    isBeginning = true;\n    isEnd = true;\n  } else {\n    progress = (translate - swiper.minTranslate()) / translatesDiff;\n    isBeginning = progress <= 0;\n    isEnd = progress >= 1;\n  }\n\n  (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.extend)(swiper, {\n    progress: progress,\n    isBeginning: isBeginning,\n    isEnd: isEnd\n  });\n  if (params.watchSlidesProgress || params.watchSlidesVisibility || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate);\n\n  if (isBeginning && !wasBeginning) {\n    swiper.emit('reachBeginning toEdge');\n  }\n\n  if (isEnd && !wasEnd) {\n    swiper.emit('reachEnd toEdge');\n  }\n\n  if (wasBeginning && !isBeginning || wasEnd && !isEnd) {\n    swiper.emit('fromEdge');\n  }\n\n  swiper.emit('progress', progress);\n}\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/components/core/update/updateProgress.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/components/core/update/updateSize.js":
/*!**********************************************************************!*\
  !*** ./node_modules/swiper/esm/components/core/update/updateSize.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ updateSize)\n/* harmony export */ });\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../utils/utils */ \"./node_modules/swiper/esm/utils/utils.js\");\n\nfunction updateSize() {\n  var swiper = this;\n  var width;\n  var height;\n  var $el = swiper.$el;\n\n  if (typeof swiper.params.width !== 'undefined' && swiper.params.width !== null) {\n    width = swiper.params.width;\n  } else {\n    width = $el[0].clientWidth;\n  }\n\n  if (typeof swiper.params.height !== 'undefined' && swiper.params.height !== null) {\n    height = swiper.params.height;\n  } else {\n    height = $el[0].clientHeight;\n  }\n\n  if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {\n    return;\n  } // Subtract paddings\n\n\n  width = width - parseInt($el.css('padding-left') || 0, 10) - parseInt($el.css('padding-right') || 0, 10);\n  height = height - parseInt($el.css('padding-top') || 0, 10) - parseInt($el.css('padding-bottom') || 0, 10);\n  if (Number.isNaN(width)) width = 0;\n  if (Number.isNaN(height)) height = 0;\n  (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.extend)(swiper, {\n    width: width,\n    height: height,\n    size: swiper.isHorizontal() ? width : height\n  });\n}\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/components/core/update/updateSize.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/components/core/update/updateSlides.js":
/*!************************************************************************!*\
  !*** ./node_modules/swiper/esm/components/core/update/updateSlides.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ updateSlides)\n/* harmony export */ });\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../utils/utils */ \"./node_modules/swiper/esm/utils/utils.js\");\n\nfunction updateSlides() {\n  var swiper = this;\n\n  function getDirectionLabel(property) {\n    if (swiper.isHorizontal()) {\n      return property;\n    } // prettier-ignore\n\n\n    return {\n      'width': 'height',\n      'margin-top': 'margin-left',\n      'margin-bottom ': 'margin-right',\n      'margin-left': 'margin-top',\n      'margin-right': 'margin-bottom',\n      'padding-left': 'padding-top',\n      'padding-right': 'padding-bottom',\n      'marginRight': 'marginBottom'\n    }[property];\n  }\n\n  function getDirectionPropertyValue(node, label) {\n    return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);\n  }\n\n  var params = swiper.params;\n  var $wrapperEl = swiper.$wrapperEl,\n      swiperSize = swiper.size,\n      rtl = swiper.rtlTranslate,\n      wrongRTL = swiper.wrongRTL;\n  var isVirtual = swiper.virtual && params.virtual.enabled;\n  var previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;\n  var slides = $wrapperEl.children(\".\" + swiper.params.slideClass);\n  var slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;\n  var snapGrid = [];\n  var slidesGrid = [];\n  var slidesSizesGrid = [];\n  var offsetBefore = params.slidesOffsetBefore;\n\n  if (typeof offsetBefore === 'function') {\n    offsetBefore = params.slidesOffsetBefore.call(swiper);\n  }\n\n  var offsetAfter = params.slidesOffsetAfter;\n\n  if (typeof offsetAfter === 'function') {\n    offsetAfter = params.slidesOffsetAfter.call(swiper);\n  }\n\n  var previousSnapGridLength = swiper.snapGrid.length;\n  var previousSlidesGridLength = swiper.slidesGrid.length;\n  var spaceBetween = params.spaceBetween;\n  var slidePosition = -offsetBefore;\n  var prevSlideSize = 0;\n  var index = 0;\n\n  if (typeof swiperSize === 'undefined') {\n    return;\n  }\n\n  if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {\n    spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiperSize;\n  }\n\n  swiper.virtualSize = -spaceBetween; // reset margins\n\n  if (rtl) slides.css({\n    marginLeft: '',\n    marginBottom: '',\n    marginTop: ''\n  });else slides.css({\n    marginRight: '',\n    marginBottom: '',\n    marginTop: ''\n  });\n  var slidesNumberEvenToRows;\n\n  if (params.slidesPerColumn > 1) {\n    if (Math.floor(slidesLength / params.slidesPerColumn) === slidesLength / swiper.params.slidesPerColumn) {\n      slidesNumberEvenToRows = slidesLength;\n    } else {\n      slidesNumberEvenToRows = Math.ceil(slidesLength / params.slidesPerColumn) * params.slidesPerColumn;\n    }\n\n    if (params.slidesPerView !== 'auto' && params.slidesPerColumnFill === 'row') {\n      slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, params.slidesPerView * params.slidesPerColumn);\n    }\n  } // Calc slides\n\n\n  var slideSize;\n  var slidesPerColumn = params.slidesPerColumn;\n  var slidesPerRow = slidesNumberEvenToRows / slidesPerColumn;\n  var numFullColumns = Math.floor(slidesLength / params.slidesPerColumn);\n\n  for (var i = 0; i < slidesLength; i += 1) {\n    slideSize = 0;\n    var slide = slides.eq(i);\n\n    if (params.slidesPerColumn > 1) {\n      // Set slides order\n      var newSlideOrderIndex = void 0;\n      var column = void 0;\n      var row = void 0;\n\n      if (params.slidesPerColumnFill === 'row' && params.slidesPerGroup > 1) {\n        var groupIndex = Math.floor(i / (params.slidesPerGroup * params.slidesPerColumn));\n        var slideIndexInGroup = i - params.slidesPerColumn * params.slidesPerGroup * groupIndex;\n        var columnsInGroup = groupIndex === 0 ? params.slidesPerGroup : Math.min(Math.ceil((slidesLength - groupIndex * slidesPerColumn * params.slidesPerGroup) / slidesPerColumn), params.slidesPerGroup);\n        row = Math.floor(slideIndexInGroup / columnsInGroup);\n        column = slideIndexInGroup - row * columnsInGroup + groupIndex * params.slidesPerGroup;\n        newSlideOrderIndex = column + row * slidesNumberEvenToRows / slidesPerColumn;\n        slide.css({\n          '-webkit-box-ordinal-group': newSlideOrderIndex,\n          '-moz-box-ordinal-group': newSlideOrderIndex,\n          '-ms-flex-order': newSlideOrderIndex,\n          '-webkit-order': newSlideOrderIndex,\n          order: newSlideOrderIndex\n        });\n      } else if (params.slidesPerColumnFill === 'column') {\n        column = Math.floor(i / slidesPerColumn);\n        row = i - column * slidesPerColumn;\n\n        if (column > numFullColumns || column === numFullColumns && row === slidesPerColumn - 1) {\n          row += 1;\n\n          if (row >= slidesPerColumn) {\n            row = 0;\n            column += 1;\n          }\n        }\n      } else {\n        row = Math.floor(i / slidesPerRow);\n        column = i - row * slidesPerRow;\n      }\n\n      slide.css(getDirectionLabel('margin-top'), row !== 0 ? params.spaceBetween && params.spaceBetween + \"px\" : '');\n    }\n\n    if (slide.css('display') === 'none') continue; // eslint-disable-line\n\n    if (params.slidesPerView === 'auto') {\n      var slideStyles = getComputedStyle(slide[0]);\n      var currentTransform = slide[0].style.transform;\n      var currentWebKitTransform = slide[0].style.webkitTransform;\n\n      if (currentTransform) {\n        slide[0].style.transform = 'none';\n      }\n\n      if (currentWebKitTransform) {\n        slide[0].style.webkitTransform = 'none';\n      }\n\n      if (params.roundLengths) {\n        slideSize = swiper.isHorizontal() ? slide.outerWidth(true) : slide.outerHeight(true);\n      } else {\n        // eslint-disable-next-line\n        var width = getDirectionPropertyValue(slideStyles, 'width');\n        var paddingLeft = getDirectionPropertyValue(slideStyles, 'padding-left');\n        var paddingRight = getDirectionPropertyValue(slideStyles, 'padding-right');\n        var marginLeft = getDirectionPropertyValue(slideStyles, 'margin-left');\n        var marginRight = getDirectionPropertyValue(slideStyles, 'margin-right');\n        var boxSizing = slideStyles.getPropertyValue('box-sizing');\n\n        if (boxSizing && boxSizing === 'border-box') {\n          slideSize = width + marginLeft + marginRight;\n        } else {\n          var _slide$ = slide[0],\n              clientWidth = _slide$.clientWidth,\n              offsetWidth = _slide$.offsetWidth;\n          slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);\n        }\n      }\n\n      if (currentTransform) {\n        slide[0].style.transform = currentTransform;\n      }\n\n      if (currentWebKitTransform) {\n        slide[0].style.webkitTransform = currentWebKitTransform;\n      }\n\n      if (params.roundLengths) slideSize = Math.floor(slideSize);\n    } else {\n      slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;\n      if (params.roundLengths) slideSize = Math.floor(slideSize);\n\n      if (slides[i]) {\n        slides[i].style[getDirectionLabel('width')] = slideSize + \"px\";\n      }\n    }\n\n    if (slides[i]) {\n      slides[i].swiperSlideSize = slideSize;\n    }\n\n    slidesSizesGrid.push(slideSize);\n\n    if (params.centeredSlides) {\n      slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;\n      if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;\n      if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;\n      if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;\n      if (params.roundLengths) slidePosition = Math.floor(slidePosition);\n      if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);\n      slidesGrid.push(slidePosition);\n    } else {\n      if (params.roundLengths) slidePosition = Math.floor(slidePosition);\n      if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);\n      slidesGrid.push(slidePosition);\n      slidePosition = slidePosition + slideSize + spaceBetween;\n    }\n\n    swiper.virtualSize += slideSize + spaceBetween;\n    prevSlideSize = slideSize;\n    index += 1;\n  }\n\n  swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;\n  var newSlidesGrid;\n\n  if (rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {\n    $wrapperEl.css({\n      width: swiper.virtualSize + params.spaceBetween + \"px\"\n    });\n  }\n\n  if (params.setWrapperSize) {\n    var _$wrapperEl$css;\n\n    $wrapperEl.css((_$wrapperEl$css = {}, _$wrapperEl$css[getDirectionLabel('width')] = swiper.virtualSize + params.spaceBetween + \"px\", _$wrapperEl$css));\n  }\n\n  if (params.slidesPerColumn > 1) {\n    var _$wrapperEl$css2;\n\n    swiper.virtualSize = (slideSize + params.spaceBetween) * slidesNumberEvenToRows;\n    swiper.virtualSize = Math.ceil(swiper.virtualSize / params.slidesPerColumn) - params.spaceBetween;\n    $wrapperEl.css((_$wrapperEl$css2 = {}, _$wrapperEl$css2[getDirectionLabel('width')] = swiper.virtualSize + params.spaceBetween + \"px\", _$wrapperEl$css2));\n\n    if (params.centeredSlides) {\n      newSlidesGrid = [];\n\n      for (var _i = 0; _i < snapGrid.length; _i += 1) {\n        var slidesGridItem = snapGrid[_i];\n        if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);\n        if (snapGrid[_i] < swiper.virtualSize + snapGrid[0]) newSlidesGrid.push(slidesGridItem);\n      }\n\n      snapGrid = newSlidesGrid;\n    }\n  } // Remove last grid elements depending on width\n\n\n  if (!params.centeredSlides) {\n    newSlidesGrid = [];\n\n    for (var _i2 = 0; _i2 < snapGrid.length; _i2 += 1) {\n      var _slidesGridItem = snapGrid[_i2];\n      if (params.roundLengths) _slidesGridItem = Math.floor(_slidesGridItem);\n\n      if (snapGrid[_i2] <= swiper.virtualSize - swiperSize) {\n        newSlidesGrid.push(_slidesGridItem);\n      }\n    }\n\n    snapGrid = newSlidesGrid;\n\n    if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {\n      snapGrid.push(swiper.virtualSize - swiperSize);\n    }\n  }\n\n  if (snapGrid.length === 0) snapGrid = [0];\n\n  if (params.spaceBetween !== 0) {\n    var _slides$filter$css;\n\n    var key = swiper.isHorizontal() && rtl ? 'marginLeft' : getDirectionLabel('marginRight');\n    slides.filter(function (_, slideIndex) {\n      if (!params.cssMode) return true;\n\n      if (slideIndex === slides.length - 1) {\n        return false;\n      }\n\n      return true;\n    }).css((_slides$filter$css = {}, _slides$filter$css[key] = spaceBetween + \"px\", _slides$filter$css));\n  }\n\n  if (params.centeredSlides && params.centeredSlidesBounds) {\n    var allSlidesSize = 0;\n    slidesSizesGrid.forEach(function (slideSizeValue) {\n      allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);\n    });\n    allSlidesSize -= params.spaceBetween;\n    var maxSnap = allSlidesSize - swiperSize;\n    snapGrid = snapGrid.map(function (snap) {\n      if (snap < 0) return -offsetBefore;\n      if (snap > maxSnap) return maxSnap + offsetAfter;\n      return snap;\n    });\n  }\n\n  if (params.centerInsufficientSlides) {\n    var _allSlidesSize = 0;\n    slidesSizesGrid.forEach(function (slideSizeValue) {\n      _allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);\n    });\n    _allSlidesSize -= params.spaceBetween;\n\n    if (_allSlidesSize < swiperSize) {\n      var allSlidesOffset = (swiperSize - _allSlidesSize) / 2;\n      snapGrid.forEach(function (snap, snapIndex) {\n        snapGrid[snapIndex] = snap - allSlidesOffset;\n      });\n      slidesGrid.forEach(function (snap, snapIndex) {\n        slidesGrid[snapIndex] = snap + allSlidesOffset;\n      });\n    }\n  }\n\n  (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.extend)(swiper, {\n    slides: slides,\n    snapGrid: snapGrid,\n    slidesGrid: slidesGrid,\n    slidesSizesGrid: slidesSizesGrid\n  });\n\n  if (slidesLength !== previousSlidesLength) {\n    swiper.emit('slidesLengthChange');\n  }\n\n  if (snapGrid.length !== previousSnapGridLength) {\n    if (swiper.params.watchOverflow) swiper.checkOverflow();\n    swiper.emit('snapGridLengthChange');\n  }\n\n  if (slidesGrid.length !== previousSlidesGridLength) {\n    swiper.emit('slidesGridLengthChange');\n  }\n\n  if (params.watchSlidesProgress || params.watchSlidesVisibility) {\n    swiper.updateSlidesOffset();\n  }\n}\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/components/core/update/updateSlides.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/components/core/update/updateSlidesClasses.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/swiper/esm/components/core/update/updateSlidesClasses.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ updateSlidesClasses)\n/* harmony export */ });\nfunction updateSlidesClasses() {\n  var swiper = this;\n  var slides = swiper.slides,\n      params = swiper.params,\n      $wrapperEl = swiper.$wrapperEl,\n      activeIndex = swiper.activeIndex,\n      realIndex = swiper.realIndex;\n  var isVirtual = swiper.virtual && params.virtual.enabled;\n  slides.removeClass(params.slideActiveClass + \" \" + params.slideNextClass + \" \" + params.slidePrevClass + \" \" + params.slideDuplicateActiveClass + \" \" + params.slideDuplicateNextClass + \" \" + params.slideDuplicatePrevClass);\n  var activeSlide;\n\n  if (isVirtual) {\n    activeSlide = swiper.$wrapperEl.find(\".\" + params.slideClass + \"[data-swiper-slide-index=\\\"\" + activeIndex + \"\\\"]\");\n  } else {\n    activeSlide = slides.eq(activeIndex);\n  } // Active classes\n\n\n  activeSlide.addClass(params.slideActiveClass);\n\n  if (params.loop) {\n    // Duplicate to all looped slides\n    if (activeSlide.hasClass(params.slideDuplicateClass)) {\n      $wrapperEl.children(\".\" + params.slideClass + \":not(.\" + params.slideDuplicateClass + \")[data-swiper-slide-index=\\\"\" + realIndex + \"\\\"]\").addClass(params.slideDuplicateActiveClass);\n    } else {\n      $wrapperEl.children(\".\" + params.slideClass + \".\" + params.slideDuplicateClass + \"[data-swiper-slide-index=\\\"\" + realIndex + \"\\\"]\").addClass(params.slideDuplicateActiveClass);\n    }\n  } // Next Slide\n\n\n  var nextSlide = activeSlide.nextAll(\".\" + params.slideClass).eq(0).addClass(params.slideNextClass);\n\n  if (params.loop && nextSlide.length === 0) {\n    nextSlide = slides.eq(0);\n    nextSlide.addClass(params.slideNextClass);\n  } // Prev Slide\n\n\n  var prevSlide = activeSlide.prevAll(\".\" + params.slideClass).eq(0).addClass(params.slidePrevClass);\n\n  if (params.loop && prevSlide.length === 0) {\n    prevSlide = slides.eq(-1);\n    prevSlide.addClass(params.slidePrevClass);\n  }\n\n  if (params.loop) {\n    // Duplicate to all looped slides\n    if (nextSlide.hasClass(params.slideDuplicateClass)) {\n      $wrapperEl.children(\".\" + params.slideClass + \":not(.\" + params.slideDuplicateClass + \")[data-swiper-slide-index=\\\"\" + nextSlide.attr('data-swiper-slide-index') + \"\\\"]\").addClass(params.slideDuplicateNextClass);\n    } else {\n      $wrapperEl.children(\".\" + params.slideClass + \".\" + params.slideDuplicateClass + \"[data-swiper-slide-index=\\\"\" + nextSlide.attr('data-swiper-slide-index') + \"\\\"]\").addClass(params.slideDuplicateNextClass);\n    }\n\n    if (prevSlide.hasClass(params.slideDuplicateClass)) {\n      $wrapperEl.children(\".\" + params.slideClass + \":not(.\" + params.slideDuplicateClass + \")[data-swiper-slide-index=\\\"\" + prevSlide.attr('data-swiper-slide-index') + \"\\\"]\").addClass(params.slideDuplicatePrevClass);\n    } else {\n      $wrapperEl.children(\".\" + params.slideClass + \".\" + params.slideDuplicateClass + \"[data-swiper-slide-index=\\\"\" + prevSlide.attr('data-swiper-slide-index') + \"\\\"]\").addClass(params.slideDuplicatePrevClass);\n    }\n  }\n\n  swiper.emitSlidesClasses();\n}\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/components/core/update/updateSlidesClasses.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/components/core/update/updateSlidesOffset.js":
/*!******************************************************************************!*\
  !*** ./node_modules/swiper/esm/components/core/update/updateSlidesOffset.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ updateSlidesOffset)\n/* harmony export */ });\nfunction updateSlidesOffset() {\n  var swiper = this;\n  var slides = swiper.slides;\n\n  for (var i = 0; i < slides.length; i += 1) {\n    slides[i].swiperSlideOffset = swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop;\n  }\n}\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/components/core/update/updateSlidesOffset.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/components/core/update/updateSlidesProgress.js":
/*!********************************************************************************!*\
  !*** ./node_modules/swiper/esm/components/core/update/updateSlidesProgress.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ updateSlidesProgress)\n/* harmony export */ });\n/* harmony import */ var _utils_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../utils/dom */ \"./node_modules/swiper/esm/utils/dom.js\");\n\nfunction updateSlidesProgress(translate) {\n  if (translate === void 0) {\n    translate = this && this.translate || 0;\n  }\n\n  var swiper = this;\n  var params = swiper.params;\n  var slides = swiper.slides,\n      rtl = swiper.rtlTranslate;\n  if (slides.length === 0) return;\n  if (typeof slides[0].swiperSlideOffset === 'undefined') swiper.updateSlidesOffset();\n  var offsetCenter = -translate;\n  if (rtl) offsetCenter = translate; // Visible Slides\n\n  slides.removeClass(params.slideVisibleClass);\n  swiper.visibleSlidesIndexes = [];\n  swiper.visibleSlides = [];\n\n  for (var i = 0; i < slides.length; i += 1) {\n    var slide = slides[i];\n    var slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slide.swiperSlideOffset) / (slide.swiperSlideSize + params.spaceBetween);\n\n    if (params.watchSlidesVisibility || params.centeredSlides && params.autoHeight) {\n      var slideBefore = -(offsetCenter - slide.swiperSlideOffset);\n      var slideAfter = slideBefore + swiper.slidesSizesGrid[i];\n      var isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;\n\n      if (isVisible) {\n        swiper.visibleSlides.push(slide);\n        swiper.visibleSlidesIndexes.push(i);\n        slides.eq(i).addClass(params.slideVisibleClass);\n      }\n    }\n\n    slide.progress = rtl ? -slideProgress : slideProgress;\n  }\n\n  swiper.visibleSlides = (0,_utils_dom__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(swiper.visibleSlides);\n}\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/components/core/update/updateSlidesProgress.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/components/navigation/navigation.js":
/*!*********************************************************************!*\
  !*** ./node_modules/swiper/esm/components/navigation/navigation.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _utils_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/dom */ \"./node_modules/swiper/esm/utils/dom.js\");\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/utils */ \"./node_modules/swiper/esm/utils/utils.js\");\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\n\n\nvar Navigation = {\n  toggleEl: function toggleEl($el, disabled) {\n    $el[disabled ? 'addClass' : 'removeClass'](this.params.navigation.disabledClass);\n    if ($el[0] && $el[0].tagName === 'BUTTON') $el[0].disabled = disabled;\n  },\n  update: function update() {\n    // Update Navigation Buttons\n    var swiper = this;\n    var params = swiper.params.navigation;\n    var toggleEl = swiper.navigation.toggleEl;\n    if (swiper.params.loop) return;\n    var _swiper$navigation = swiper.navigation,\n        $nextEl = _swiper$navigation.$nextEl,\n        $prevEl = _swiper$navigation.$prevEl;\n\n    if ($prevEl && $prevEl.length > 0) {\n      if (swiper.isBeginning) {\n        toggleEl($prevEl, true);\n      } else {\n        toggleEl($prevEl, false);\n      }\n\n      if (swiper.params.watchOverflow && swiper.enabled) {\n        $prevEl[swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);\n      }\n    }\n\n    if ($nextEl && $nextEl.length > 0) {\n      if (swiper.isEnd) {\n        toggleEl($nextEl, true);\n      } else {\n        toggleEl($nextEl, false);\n      }\n\n      if (swiper.params.watchOverflow && swiper.enabled) {\n        $nextEl[swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);\n      }\n    }\n  },\n  onPrevClick: function onPrevClick(e) {\n    var swiper = this;\n    e.preventDefault();\n    if (swiper.isBeginning && !swiper.params.loop) return;\n    swiper.slidePrev();\n  },\n  onNextClick: function onNextClick(e) {\n    var swiper = this;\n    e.preventDefault();\n    if (swiper.isEnd && !swiper.params.loop) return;\n    swiper.slideNext();\n  },\n  init: function init() {\n    var swiper = this;\n    var params = swiper.params.navigation;\n    swiper.params.navigation = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.createElementIfNotDefined)(swiper.$el, swiper.params.navigation, swiper.params.createElements, {\n      nextEl: 'swiper-button-next',\n      prevEl: 'swiper-button-prev'\n    });\n    if (!(params.nextEl || params.prevEl)) return;\n    var $nextEl;\n    var $prevEl;\n\n    if (params.nextEl) {\n      $nextEl = (0,_utils_dom__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(params.nextEl);\n\n      if (swiper.params.uniqueNavElements && typeof params.nextEl === 'string' && $nextEl.length > 1 && swiper.$el.find(params.nextEl).length === 1) {\n        $nextEl = swiper.$el.find(params.nextEl);\n      }\n    }\n\n    if (params.prevEl) {\n      $prevEl = (0,_utils_dom__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(params.prevEl);\n\n      if (swiper.params.uniqueNavElements && typeof params.prevEl === 'string' && $prevEl.length > 1 && swiper.$el.find(params.prevEl).length === 1) {\n        $prevEl = swiper.$el.find(params.prevEl);\n      }\n    }\n\n    if ($nextEl && $nextEl.length > 0) {\n      $nextEl.on('click', swiper.navigation.onNextClick);\n    }\n\n    if ($prevEl && $prevEl.length > 0) {\n      $prevEl.on('click', swiper.navigation.onPrevClick);\n    }\n\n    (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.extend)(swiper.navigation, {\n      $nextEl: $nextEl,\n      nextEl: $nextEl && $nextEl[0],\n      $prevEl: $prevEl,\n      prevEl: $prevEl && $prevEl[0]\n    });\n\n    if (!swiper.enabled) {\n      if ($nextEl) $nextEl.addClass(params.lockClass);\n      if ($prevEl) $prevEl.addClass(params.lockClass);\n    }\n  },\n  destroy: function destroy() {\n    var swiper = this;\n    var _swiper$navigation2 = swiper.navigation,\n        $nextEl = _swiper$navigation2.$nextEl,\n        $prevEl = _swiper$navigation2.$prevEl;\n\n    if ($nextEl && $nextEl.length) {\n      $nextEl.off('click', swiper.navigation.onNextClick);\n      $nextEl.removeClass(swiper.params.navigation.disabledClass);\n    }\n\n    if ($prevEl && $prevEl.length) {\n      $prevEl.off('click', swiper.navigation.onPrevClick);\n      $prevEl.removeClass(swiper.params.navigation.disabledClass);\n    }\n  }\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  name: 'navigation',\n  params: {\n    navigation: {\n      nextEl: null,\n      prevEl: null,\n      hideOnClick: false,\n      disabledClass: 'swiper-button-disabled',\n      hiddenClass: 'swiper-button-hidden',\n      lockClass: 'swiper-button-lock'\n    }\n  },\n  create: function create() {\n    var swiper = this;\n    (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.bindModuleMethods)(swiper, {\n      navigation: _extends({}, Navigation)\n    });\n  },\n  on: {\n    init: function init(swiper) {\n      swiper.navigation.init();\n      swiper.navigation.update();\n    },\n    toEdge: function toEdge(swiper) {\n      swiper.navigation.update();\n    },\n    fromEdge: function fromEdge(swiper) {\n      swiper.navigation.update();\n    },\n    destroy: function destroy(swiper) {\n      swiper.navigation.destroy();\n    },\n    'enable disable': function enableDisable(swiper) {\n      var _swiper$navigation3 = swiper.navigation,\n          $nextEl = _swiper$navigation3.$nextEl,\n          $prevEl = _swiper$navigation3.$prevEl;\n\n      if ($nextEl) {\n        $nextEl[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.navigation.lockClass);\n      }\n\n      if ($prevEl) {\n        $prevEl[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.navigation.lockClass);\n      }\n    },\n    click: function click(swiper, e) {\n      var _swiper$navigation4 = swiper.navigation,\n          $nextEl = _swiper$navigation4.$nextEl,\n          $prevEl = _swiper$navigation4.$prevEl;\n      var targetEl = e.target;\n\n      if (swiper.params.navigation.hideOnClick && !(0,_utils_dom__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(targetEl).is($prevEl) && !(0,_utils_dom__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(targetEl).is($nextEl)) {\n        if (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl))) return;\n        var isHidden;\n\n        if ($nextEl) {\n          isHidden = $nextEl.hasClass(swiper.params.navigation.hiddenClass);\n        } else if ($prevEl) {\n          isHidden = $prevEl.hasClass(swiper.params.navigation.hiddenClass);\n        }\n\n        if (isHidden === true) {\n          swiper.emit('navigationShow');\n        } else {\n          swiper.emit('navigationHide');\n        }\n\n        if ($nextEl) {\n          $nextEl.toggleClass(swiper.params.navigation.hiddenClass);\n        }\n\n        if ($prevEl) {\n          $prevEl.toggleClass(swiper.params.navigation.hiddenClass);\n        }\n      }\n    }\n  }\n});\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/components/navigation/navigation.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/components/pagination/pagination.js":
/*!*********************************************************************!*\
  !*** ./node_modules/swiper/esm/components/pagination/pagination.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _utils_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/dom */ \"./node_modules/swiper/esm/utils/dom.js\");\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/utils */ \"./node_modules/swiper/esm/utils/utils.js\");\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\n\n\nvar Pagination = {\n  update: function update() {\n    // Render || Update Pagination bullets/items\n    var swiper = this;\n    var rtl = swiper.rtl;\n    var params = swiper.params.pagination;\n    if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;\n    var slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;\n    var $el = swiper.pagination.$el; // Current/Total\n\n    var current;\n    var total = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;\n\n    if (swiper.params.loop) {\n      current = Math.ceil((swiper.activeIndex - swiper.loopedSlides) / swiper.params.slidesPerGroup);\n\n      if (current > slidesLength - 1 - swiper.loopedSlides * 2) {\n        current -= slidesLength - swiper.loopedSlides * 2;\n      }\n\n      if (current > total - 1) current -= total;\n      if (current < 0 && swiper.params.paginationType !== 'bullets') current = total + current;\n    } else if (typeof swiper.snapIndex !== 'undefined') {\n      current = swiper.snapIndex;\n    } else {\n      current = swiper.activeIndex || 0;\n    } // Types\n\n\n    if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {\n      var bullets = swiper.pagination.bullets;\n      var firstIndex;\n      var lastIndex;\n      var midIndex;\n\n      if (params.dynamicBullets) {\n        swiper.pagination.bulletSize = bullets.eq(0)[swiper.isHorizontal() ? 'outerWidth' : 'outerHeight'](true);\n        $el.css(swiper.isHorizontal() ? 'width' : 'height', swiper.pagination.bulletSize * (params.dynamicMainBullets + 4) + \"px\");\n\n        if (params.dynamicMainBullets > 1 && swiper.previousIndex !== undefined) {\n          swiper.pagination.dynamicBulletIndex += current - swiper.previousIndex;\n\n          if (swiper.pagination.dynamicBulletIndex > params.dynamicMainBullets - 1) {\n            swiper.pagination.dynamicBulletIndex = params.dynamicMainBullets - 1;\n          } else if (swiper.pagination.dynamicBulletIndex < 0) {\n            swiper.pagination.dynamicBulletIndex = 0;\n          }\n        }\n\n        firstIndex = current - swiper.pagination.dynamicBulletIndex;\n        lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);\n        midIndex = (lastIndex + firstIndex) / 2;\n      }\n\n      bullets.removeClass(params.bulletActiveClass + \" \" + params.bulletActiveClass + \"-next \" + params.bulletActiveClass + \"-next-next \" + params.bulletActiveClass + \"-prev \" + params.bulletActiveClass + \"-prev-prev \" + params.bulletActiveClass + \"-main\");\n\n      if ($el.length > 1) {\n        bullets.each(function (bullet) {\n          var $bullet = (0,_utils_dom__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(bullet);\n          var bulletIndex = $bullet.index();\n\n          if (bulletIndex === current) {\n            $bullet.addClass(params.bulletActiveClass);\n          }\n\n          if (params.dynamicBullets) {\n            if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {\n              $bullet.addClass(params.bulletActiveClass + \"-main\");\n            }\n\n            if (bulletIndex === firstIndex) {\n              $bullet.prev().addClass(params.bulletActiveClass + \"-prev\").prev().addClass(params.bulletActiveClass + \"-prev-prev\");\n            }\n\n            if (bulletIndex === lastIndex) {\n              $bullet.next().addClass(params.bulletActiveClass + \"-next\").next().addClass(params.bulletActiveClass + \"-next-next\");\n            }\n          }\n        });\n      } else {\n        var $bullet = bullets.eq(current);\n        var bulletIndex = $bullet.index();\n        $bullet.addClass(params.bulletActiveClass);\n\n        if (params.dynamicBullets) {\n          var $firstDisplayedBullet = bullets.eq(firstIndex);\n          var $lastDisplayedBullet = bullets.eq(lastIndex);\n\n          for (var i = firstIndex; i <= lastIndex; i += 1) {\n            bullets.eq(i).addClass(params.bulletActiveClass + \"-main\");\n          }\n\n          if (swiper.params.loop) {\n            if (bulletIndex >= bullets.length - params.dynamicMainBullets) {\n              for (var _i = params.dynamicMainBullets; _i >= 0; _i -= 1) {\n                bullets.eq(bullets.length - _i).addClass(params.bulletActiveClass + \"-main\");\n              }\n\n              bullets.eq(bullets.length - params.dynamicMainBullets - 1).addClass(params.bulletActiveClass + \"-prev\");\n            } else {\n              $firstDisplayedBullet.prev().addClass(params.bulletActiveClass + \"-prev\").prev().addClass(params.bulletActiveClass + \"-prev-prev\");\n              $lastDisplayedBullet.next().addClass(params.bulletActiveClass + \"-next\").next().addClass(params.bulletActiveClass + \"-next-next\");\n            }\n          } else {\n            $firstDisplayedBullet.prev().addClass(params.bulletActiveClass + \"-prev\").prev().addClass(params.bulletActiveClass + \"-prev-prev\");\n            $lastDisplayedBullet.next().addClass(params.bulletActiveClass + \"-next\").next().addClass(params.bulletActiveClass + \"-next-next\");\n          }\n        }\n      }\n\n      if (params.dynamicBullets) {\n        var dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);\n        var bulletsOffset = (swiper.pagination.bulletSize * dynamicBulletsLength - swiper.pagination.bulletSize) / 2 - midIndex * swiper.pagination.bulletSize;\n        var offsetProp = rtl ? 'right' : 'left';\n        bullets.css(swiper.isHorizontal() ? offsetProp : 'top', bulletsOffset + \"px\");\n      }\n    }\n\n    if (params.type === 'fraction') {\n      $el.find((0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.classesToSelector)(params.currentClass)).text(params.formatFractionCurrent(current + 1));\n      $el.find((0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.classesToSelector)(params.totalClass)).text(params.formatFractionTotal(total));\n    }\n\n    if (params.type === 'progressbar') {\n      var progressbarDirection;\n\n      if (params.progressbarOpposite) {\n        progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';\n      } else {\n        progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';\n      }\n\n      var scale = (current + 1) / total;\n      var scaleX = 1;\n      var scaleY = 1;\n\n      if (progressbarDirection === 'horizontal') {\n        scaleX = scale;\n      } else {\n        scaleY = scale;\n      }\n\n      $el.find((0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.classesToSelector)(params.progressbarFillClass)).transform(\"translate3d(0,0,0) scaleX(\" + scaleX + \") scaleY(\" + scaleY + \")\").transition(swiper.params.speed);\n    }\n\n    if (params.type === 'custom' && params.renderCustom) {\n      $el.html(params.renderCustom(swiper, current + 1, total));\n      swiper.emit('paginationRender', $el[0]);\n    } else {\n      swiper.emit('paginationUpdate', $el[0]);\n    }\n\n    if (swiper.params.watchOverflow && swiper.enabled) {\n      $el[swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);\n    }\n  },\n  render: function render() {\n    // Render Container\n    var swiper = this;\n    var params = swiper.params.pagination;\n    if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;\n    var slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;\n    var $el = swiper.pagination.$el;\n    var paginationHTML = '';\n\n    if (params.type === 'bullets') {\n      var numberOfBullets = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;\n\n      if (swiper.params.freeMode && !swiper.params.loop && numberOfBullets > slidesLength) {\n        numberOfBullets = slidesLength;\n      }\n\n      for (var i = 0; i < numberOfBullets; i += 1) {\n        if (params.renderBullet) {\n          paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);\n        } else {\n          paginationHTML += \"<\" + params.bulletElement + \" class=\\\"\" + params.bulletClass + \"\\\"></\" + params.bulletElement + \">\";\n        }\n      }\n\n      $el.html(paginationHTML);\n      swiper.pagination.bullets = $el.find((0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.classesToSelector)(params.bulletClass));\n    }\n\n    if (params.type === 'fraction') {\n      if (params.renderFraction) {\n        paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);\n      } else {\n        paginationHTML = \"<span class=\\\"\" + params.currentClass + \"\\\"></span>\" + ' / ' + (\"<span class=\\\"\" + params.totalClass + \"\\\"></span>\");\n      }\n\n      $el.html(paginationHTML);\n    }\n\n    if (params.type === 'progressbar') {\n      if (params.renderProgressbar) {\n        paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);\n      } else {\n        paginationHTML = \"<span class=\\\"\" + params.progressbarFillClass + \"\\\"></span>\";\n      }\n\n      $el.html(paginationHTML);\n    }\n\n    if (params.type !== 'custom') {\n      swiper.emit('paginationRender', swiper.pagination.$el[0]);\n    }\n  },\n  init: function init() {\n    var swiper = this;\n    swiper.params.pagination = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.createElementIfNotDefined)(swiper.$el, swiper.params.pagination, swiper.params.createElements, {\n      el: 'swiper-pagination'\n    });\n    var params = swiper.params.pagination;\n    if (!params.el) return;\n    var $el = (0,_utils_dom__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(params.el);\n    if ($el.length === 0) return;\n\n    if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1) {\n      $el = swiper.$el.find(params.el);\n    }\n\n    if (params.type === 'bullets' && params.clickable) {\n      $el.addClass(params.clickableClass);\n    }\n\n    $el.addClass(params.modifierClass + params.type);\n\n    if (params.type === 'bullets' && params.dynamicBullets) {\n      $el.addClass(\"\" + params.modifierClass + params.type + \"-dynamic\");\n      swiper.pagination.dynamicBulletIndex = 0;\n\n      if (params.dynamicMainBullets < 1) {\n        params.dynamicMainBullets = 1;\n      }\n    }\n\n    if (params.type === 'progressbar' && params.progressbarOpposite) {\n      $el.addClass(params.progressbarOppositeClass);\n    }\n\n    if (params.clickable) {\n      $el.on('click', (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.classesToSelector)(params.bulletClass), function onClick(e) {\n        e.preventDefault();\n        var index = (0,_utils_dom__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this).index() * swiper.params.slidesPerGroup;\n        if (swiper.params.loop) index += swiper.loopedSlides;\n        swiper.slideTo(index);\n      });\n    }\n\n    (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.extend)(swiper.pagination, {\n      $el: $el,\n      el: $el[0]\n    });\n\n    if (!swiper.enabled) {\n      $el.addClass(params.lockClass);\n    }\n  },\n  destroy: function destroy() {\n    var swiper = this;\n    var params = swiper.params.pagination;\n    if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;\n    var $el = swiper.pagination.$el;\n    $el.removeClass(params.hiddenClass);\n    $el.removeClass(params.modifierClass + params.type);\n    if (swiper.pagination.bullets) swiper.pagination.bullets.removeClass(params.bulletActiveClass);\n\n    if (params.clickable) {\n      $el.off('click', (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.classesToSelector)(params.bulletClass));\n    }\n  }\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  name: 'pagination',\n  params: {\n    pagination: {\n      el: null,\n      bulletElement: 'span',\n      clickable: false,\n      hideOnClick: false,\n      renderBullet: null,\n      renderProgressbar: null,\n      renderFraction: null,\n      renderCustom: null,\n      progressbarOpposite: false,\n      type: 'bullets',\n      // 'bullets' or 'progressbar' or 'fraction' or 'custom'\n      dynamicBullets: false,\n      dynamicMainBullets: 1,\n      formatFractionCurrent: function formatFractionCurrent(number) {\n        return number;\n      },\n      formatFractionTotal: function formatFractionTotal(number) {\n        return number;\n      },\n      bulletClass: 'swiper-pagination-bullet',\n      bulletActiveClass: 'swiper-pagination-bullet-active',\n      modifierClass: 'swiper-pagination-',\n      // NEW\n      currentClass: 'swiper-pagination-current',\n      totalClass: 'swiper-pagination-total',\n      hiddenClass: 'swiper-pagination-hidden',\n      progressbarFillClass: 'swiper-pagination-progressbar-fill',\n      progressbarOppositeClass: 'swiper-pagination-progressbar-opposite',\n      clickableClass: 'swiper-pagination-clickable',\n      // NEW\n      lockClass: 'swiper-pagination-lock'\n    }\n  },\n  create: function create() {\n    var swiper = this;\n    (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.bindModuleMethods)(swiper, {\n      pagination: _extends({\n        dynamicBulletIndex: 0\n      }, Pagination)\n    });\n  },\n  on: {\n    init: function init(swiper) {\n      swiper.pagination.init();\n      swiper.pagination.render();\n      swiper.pagination.update();\n    },\n    activeIndexChange: function activeIndexChange(swiper) {\n      if (swiper.params.loop) {\n        swiper.pagination.update();\n      } else if (typeof swiper.snapIndex === 'undefined') {\n        swiper.pagination.update();\n      }\n    },\n    snapIndexChange: function snapIndexChange(swiper) {\n      if (!swiper.params.loop) {\n        swiper.pagination.update();\n      }\n    },\n    slidesLengthChange: function slidesLengthChange(swiper) {\n      if (swiper.params.loop) {\n        swiper.pagination.render();\n        swiper.pagination.update();\n      }\n    },\n    snapGridLengthChange: function snapGridLengthChange(swiper) {\n      if (!swiper.params.loop) {\n        swiper.pagination.render();\n        swiper.pagination.update();\n      }\n    },\n    destroy: function destroy(swiper) {\n      swiper.pagination.destroy();\n    },\n    'enable disable': function enableDisable(swiper) {\n      var $el = swiper.pagination.$el;\n\n      if ($el) {\n        $el[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.pagination.lockClass);\n      }\n    },\n    click: function click(swiper, e) {\n      var targetEl = e.target;\n\n      if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && swiper.pagination.$el.length > 0 && !(0,_utils_dom__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(targetEl).hasClass(swiper.params.pagination.bulletClass)) {\n        if (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl)) return;\n        var isHidden = swiper.pagination.$el.hasClass(swiper.params.pagination.hiddenClass);\n\n        if (isHidden === true) {\n          swiper.emit('paginationShow');\n        } else {\n          swiper.emit('paginationHide');\n        }\n\n        swiper.pagination.$el.toggleClass(swiper.params.pagination.hiddenClass);\n      }\n    }\n  }\n});\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/components/pagination/pagination.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/components/thumbs/thumbs.js":
/*!*************************************************************!*\
  !*** ./node_modules/swiper/esm/components/thumbs/thumbs.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/utils */ \"./node_modules/swiper/esm/utils/utils.js\");\n/* harmony import */ var _utils_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/dom */ \"./node_modules/swiper/esm/utils/dom.js\");\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\n\n\nvar Thumbs = {\n  init: function init() {\n    var swiper = this;\n    var thumbsParams = swiper.params.thumbs;\n    if (swiper.thumbs.initialized) return false;\n    swiper.thumbs.initialized = true;\n    var SwiperClass = swiper.constructor;\n\n    if (thumbsParams.swiper instanceof SwiperClass) {\n      swiper.thumbs.swiper = thumbsParams.swiper;\n      (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.extend)(swiper.thumbs.swiper.originalParams, {\n        watchSlidesProgress: true,\n        slideToClickedSlide: false\n      });\n      (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.extend)(swiper.thumbs.swiper.params, {\n        watchSlidesProgress: true,\n        slideToClickedSlide: false\n      });\n    } else if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.isObject)(thumbsParams.swiper)) {\n      swiper.thumbs.swiper = new SwiperClass((0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.extend)({}, thumbsParams.swiper, {\n        watchSlidesVisibility: true,\n        watchSlidesProgress: true,\n        slideToClickedSlide: false\n      }));\n      swiper.thumbs.swiperCreated = true;\n    }\n\n    swiper.thumbs.swiper.$el.addClass(swiper.params.thumbs.thumbsContainerClass);\n    swiper.thumbs.swiper.on('tap', swiper.thumbs.onThumbClick);\n    return true;\n  },\n  onThumbClick: function onThumbClick() {\n    var swiper = this;\n    var thumbsSwiper = swiper.thumbs.swiper;\n    if (!thumbsSwiper) return;\n    var clickedIndex = thumbsSwiper.clickedIndex;\n    var clickedSlide = thumbsSwiper.clickedSlide;\n    if (clickedSlide && (0,_utils_dom__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(clickedSlide).hasClass(swiper.params.thumbs.slideThumbActiveClass)) return;\n    if (typeof clickedIndex === 'undefined' || clickedIndex === null) return;\n    var slideToIndex;\n\n    if (thumbsSwiper.params.loop) {\n      slideToIndex = parseInt((0,_utils_dom__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(thumbsSwiper.clickedSlide).attr('data-swiper-slide-index'), 10);\n    } else {\n      slideToIndex = clickedIndex;\n    }\n\n    if (swiper.params.loop) {\n      var currentIndex = swiper.activeIndex;\n\n      if (swiper.slides.eq(currentIndex).hasClass(swiper.params.slideDuplicateClass)) {\n        swiper.loopFix(); // eslint-disable-next-line\n\n        swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;\n        currentIndex = swiper.activeIndex;\n      }\n\n      var prevIndex = swiper.slides.eq(currentIndex).prevAll(\"[data-swiper-slide-index=\\\"\" + slideToIndex + \"\\\"]\").eq(0).index();\n      var nextIndex = swiper.slides.eq(currentIndex).nextAll(\"[data-swiper-slide-index=\\\"\" + slideToIndex + \"\\\"]\").eq(0).index();\n      if (typeof prevIndex === 'undefined') slideToIndex = nextIndex;else if (typeof nextIndex === 'undefined') slideToIndex = prevIndex;else if (nextIndex - currentIndex < currentIndex - prevIndex) slideToIndex = nextIndex;else slideToIndex = prevIndex;\n    }\n\n    swiper.slideTo(slideToIndex);\n  },\n  update: function update(initial) {\n    var swiper = this;\n    var thumbsSwiper = swiper.thumbs.swiper;\n    if (!thumbsSwiper) return;\n    var slidesPerView = thumbsSwiper.params.slidesPerView === 'auto' ? thumbsSwiper.slidesPerViewDynamic() : thumbsSwiper.params.slidesPerView;\n    var autoScrollOffset = swiper.params.thumbs.autoScrollOffset;\n    var useOffset = autoScrollOffset && !thumbsSwiper.params.loop;\n\n    if (swiper.realIndex !== thumbsSwiper.realIndex || useOffset) {\n      var currentThumbsIndex = thumbsSwiper.activeIndex;\n      var newThumbsIndex;\n      var direction;\n\n      if (thumbsSwiper.params.loop) {\n        if (thumbsSwiper.slides.eq(currentThumbsIndex).hasClass(thumbsSwiper.params.slideDuplicateClass)) {\n          thumbsSwiper.loopFix(); // eslint-disable-next-line\n\n          thumbsSwiper._clientLeft = thumbsSwiper.$wrapperEl[0].clientLeft;\n          currentThumbsIndex = thumbsSwiper.activeIndex;\n        } // Find actual thumbs index to slide to\n\n\n        var prevThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).prevAll(\"[data-swiper-slide-index=\\\"\" + swiper.realIndex + \"\\\"]\").eq(0).index();\n        var nextThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).nextAll(\"[data-swiper-slide-index=\\\"\" + swiper.realIndex + \"\\\"]\").eq(0).index();\n\n        if (typeof prevThumbsIndex === 'undefined') {\n          newThumbsIndex = nextThumbsIndex;\n        } else if (typeof nextThumbsIndex === 'undefined') {\n          newThumbsIndex = prevThumbsIndex;\n        } else if (nextThumbsIndex - currentThumbsIndex === currentThumbsIndex - prevThumbsIndex) {\n          newThumbsIndex = thumbsSwiper.params.slidesPerGroup > 1 ? nextThumbsIndex : currentThumbsIndex;\n        } else if (nextThumbsIndex - currentThumbsIndex < currentThumbsIndex - prevThumbsIndex) {\n          newThumbsIndex = nextThumbsIndex;\n        } else {\n          newThumbsIndex = prevThumbsIndex;\n        }\n\n        direction = swiper.activeIndex > swiper.previousIndex ? 'next' : 'prev';\n      } else {\n        newThumbsIndex = swiper.realIndex;\n        direction = newThumbsIndex > swiper.previousIndex ? 'next' : 'prev';\n      }\n\n      if (useOffset) {\n        newThumbsIndex += direction === 'next' ? autoScrollOffset : -1 * autoScrollOffset;\n      }\n\n      if (thumbsSwiper.visibleSlidesIndexes && thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {\n        if (thumbsSwiper.params.centeredSlides) {\n          if (newThumbsIndex > currentThumbsIndex) {\n            newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;\n          } else {\n            newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;\n          }\n        } else if (newThumbsIndex > currentThumbsIndex && thumbsSwiper.params.slidesPerGroup === 1) {// newThumbsIndex = newThumbsIndex - slidesPerView + 1;\n        }\n\n        thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : undefined);\n      }\n    } // Activate thumbs\n\n\n    var thumbsToActivate = 1;\n    var thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;\n\n    if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) {\n      thumbsToActivate = swiper.params.slidesPerView;\n    }\n\n    if (!swiper.params.thumbs.multipleActiveThumbs) {\n      thumbsToActivate = 1;\n    }\n\n    thumbsToActivate = Math.floor(thumbsToActivate);\n    thumbsSwiper.slides.removeClass(thumbActiveClass);\n\n    if (thumbsSwiper.params.loop || thumbsSwiper.params.virtual && thumbsSwiper.params.virtual.enabled) {\n      for (var i = 0; i < thumbsToActivate; i += 1) {\n        thumbsSwiper.$wrapperEl.children(\"[data-swiper-slide-index=\\\"\" + (swiper.realIndex + i) + \"\\\"]\").addClass(thumbActiveClass);\n      }\n    } else {\n      for (var _i = 0; _i < thumbsToActivate; _i += 1) {\n        thumbsSwiper.slides.eq(swiper.realIndex + _i).addClass(thumbActiveClass);\n      }\n    }\n  }\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  name: 'thumbs',\n  params: {\n    thumbs: {\n      swiper: null,\n      multipleActiveThumbs: true,\n      autoScrollOffset: 0,\n      slideThumbActiveClass: 'swiper-slide-thumb-active',\n      thumbsContainerClass: 'swiper-container-thumbs'\n    }\n  },\n  create: function create() {\n    var swiper = this;\n    (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.bindModuleMethods)(swiper, {\n      thumbs: _extends({\n        swiper: null,\n        initialized: false\n      }, Thumbs)\n    });\n  },\n  on: {\n    beforeInit: function beforeInit(swiper) {\n      var thumbs = swiper.params.thumbs;\n      if (!thumbs || !thumbs.swiper) return;\n      swiper.thumbs.init();\n      swiper.thumbs.update(true);\n    },\n    slideChange: function slideChange(swiper) {\n      if (!swiper.thumbs.swiper) return;\n      swiper.thumbs.update();\n    },\n    update: function update(swiper) {\n      if (!swiper.thumbs.swiper) return;\n      swiper.thumbs.update();\n    },\n    resize: function resize(swiper) {\n      if (!swiper.thumbs.swiper) return;\n      swiper.thumbs.update();\n    },\n    observerUpdate: function observerUpdate(swiper) {\n      if (!swiper.thumbs.swiper) return;\n      swiper.thumbs.update();\n    },\n    setTransition: function setTransition(swiper, duration) {\n      var thumbsSwiper = swiper.thumbs.swiper;\n      if (!thumbsSwiper) return;\n      thumbsSwiper.setTransition(duration);\n    },\n    beforeDestroy: function beforeDestroy(swiper) {\n      var thumbsSwiper = swiper.thumbs.swiper;\n      if (!thumbsSwiper) return;\n\n      if (swiper.thumbs.swiperCreated && thumbsSwiper) {\n        thumbsSwiper.destroy();\n      }\n    }\n  }\n});\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/components/thumbs/thumbs.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/modules/observer/observer.js":
/*!**************************************************************!*\
  !*** ./node_modules/swiper/esm/modules/observer/observer.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ \"./node_modules/ssr-window/ssr-window.esm.js\");\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/utils */ \"./node_modules/swiper/esm/utils/utils.js\");\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\n\n\nvar Observer = {\n  attach: function attach(target, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();\n    var swiper = this;\n    var ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;\n    var observer = new ObserverFunc(function (mutations) {\n      // The observerUpdate event should only be triggered\n      // once despite the number of mutations.  Additional\n      // triggers are redundant and are very costly\n      if (mutations.length === 1) {\n        swiper.emit('observerUpdate', mutations[0]);\n        return;\n      }\n\n      var observerUpdate = function observerUpdate() {\n        swiper.emit('observerUpdate', mutations[0]);\n      };\n\n      if (window.requestAnimationFrame) {\n        window.requestAnimationFrame(observerUpdate);\n      } else {\n        window.setTimeout(observerUpdate, 0);\n      }\n    });\n    observer.observe(target, {\n      attributes: typeof options.attributes === 'undefined' ? true : options.attributes,\n      childList: typeof options.childList === 'undefined' ? true : options.childList,\n      characterData: typeof options.characterData === 'undefined' ? true : options.characterData\n    });\n    swiper.observer.observers.push(observer);\n  },\n  init: function init() {\n    var swiper = this;\n    if (!swiper.support.observer || !swiper.params.observer) return;\n\n    if (swiper.params.observeParents) {\n      var containerParents = swiper.$el.parents();\n\n      for (var i = 0; i < containerParents.length; i += 1) {\n        swiper.observer.attach(containerParents[i]);\n      }\n    } // Observe container\n\n\n    swiper.observer.attach(swiper.$el[0], {\n      childList: swiper.params.observeSlideChildren\n    }); // Observe wrapper\n\n    swiper.observer.attach(swiper.$wrapperEl[0], {\n      attributes: false\n    });\n  },\n  destroy: function destroy() {\n    var swiper = this;\n    swiper.observer.observers.forEach(function (observer) {\n      observer.disconnect();\n    });\n    swiper.observer.observers = [];\n  }\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  name: 'observer',\n  params: {\n    observer: false,\n    observeParents: false,\n    observeSlideChildren: false\n  },\n  create: function create() {\n    var swiper = this;\n    (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.bindModuleMethods)(swiper, {\n      observer: _extends({}, Observer, {\n        observers: []\n      })\n    });\n  },\n  on: {\n    init: function init(swiper) {\n      swiper.observer.init();\n    },\n    destroy: function destroy(swiper) {\n      swiper.observer.destroy();\n    }\n  }\n});\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/modules/observer/observer.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/modules/resize/resize.js":
/*!**********************************************************!*\
  !*** ./node_modules/swiper/esm/modules/resize/resize.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ \"./node_modules/ssr-window/ssr-window.esm.js\");\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/utils */ \"./node_modules/swiper/esm/utils/utils.js\");\n\n\n\nvar supportsResizeObserver = function supportsResizeObserver() {\n  var window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();\n  return typeof window.ResizeObserver !== 'undefined';\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  name: 'resize',\n  create: function create() {\n    var swiper = this;\n    (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.extend)(swiper, {\n      resize: {\n        observer: null,\n        createObserver: function createObserver() {\n          if (!swiper || swiper.destroyed || !swiper.initialized) return;\n          swiper.resize.observer = new ResizeObserver(function (entries) {\n            var width = swiper.width,\n                height = swiper.height;\n            var newWidth = width;\n            var newHeight = height;\n            entries.forEach(function (_ref) {\n              var contentBoxSize = _ref.contentBoxSize,\n                  contentRect = _ref.contentRect,\n                  target = _ref.target;\n              if (target && target !== swiper.el) return;\n              newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;\n              newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;\n            });\n\n            if (newWidth !== width || newHeight !== height) {\n              swiper.resize.resizeHandler();\n            }\n          });\n          swiper.resize.observer.observe(swiper.el);\n        },\n        removeObserver: function removeObserver() {\n          if (swiper.resize.observer && swiper.resize.observer.unobserve && swiper.el) {\n            swiper.resize.observer.unobserve(swiper.el);\n            swiper.resize.observer = null;\n          }\n        },\n        resizeHandler: function resizeHandler() {\n          if (!swiper || swiper.destroyed || !swiper.initialized) return;\n          swiper.emit('beforeResize');\n          swiper.emit('resize');\n        },\n        orientationChangeHandler: function orientationChangeHandler() {\n          if (!swiper || swiper.destroyed || !swiper.initialized) return;\n          swiper.emit('orientationchange');\n        }\n      }\n    });\n  },\n  on: {\n    init: function init(swiper) {\n      var window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();\n\n      if (swiper.params.resizeObserver && supportsResizeObserver()) {\n        swiper.resize.createObserver();\n        return;\n      } // Emit resize\n\n\n      window.addEventListener('resize', swiper.resize.resizeHandler); // Emit orientationchange\n\n      window.addEventListener('orientationchange', swiper.resize.orientationChangeHandler);\n    },\n    destroy: function destroy(swiper) {\n      var window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();\n      swiper.resize.removeObserver();\n      window.removeEventListener('resize', swiper.resize.resizeHandler);\n      window.removeEventListener('orientationchange', swiper.resize.orientationChangeHandler);\n    }\n  }\n});\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/modules/resize/resize.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/utils/dom.js":
/*!**********************************************!*\
  !*** ./node_modules/swiper/esm/utils/dom.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var dom7__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dom7 */ \"./node_modules/dom7/dom7.esm.js\");\n\nvar Methods = {\n  addClass: dom7__WEBPACK_IMPORTED_MODULE_0__.addClass,\n  removeClass: dom7__WEBPACK_IMPORTED_MODULE_0__.removeClass,\n  hasClass: dom7__WEBPACK_IMPORTED_MODULE_0__.hasClass,\n  toggleClass: dom7__WEBPACK_IMPORTED_MODULE_0__.toggleClass,\n  attr: dom7__WEBPACK_IMPORTED_MODULE_0__.attr,\n  removeAttr: dom7__WEBPACK_IMPORTED_MODULE_0__.removeAttr,\n  transform: dom7__WEBPACK_IMPORTED_MODULE_0__.transform,\n  transition: dom7__WEBPACK_IMPORTED_MODULE_0__.transition,\n  on: dom7__WEBPACK_IMPORTED_MODULE_0__.on,\n  off: dom7__WEBPACK_IMPORTED_MODULE_0__.off,\n  trigger: dom7__WEBPACK_IMPORTED_MODULE_0__.trigger,\n  transitionEnd: dom7__WEBPACK_IMPORTED_MODULE_0__.transitionEnd,\n  outerWidth: dom7__WEBPACK_IMPORTED_MODULE_0__.outerWidth,\n  outerHeight: dom7__WEBPACK_IMPORTED_MODULE_0__.outerHeight,\n  styles: dom7__WEBPACK_IMPORTED_MODULE_0__.styles,\n  offset: dom7__WEBPACK_IMPORTED_MODULE_0__.offset,\n  css: dom7__WEBPACK_IMPORTED_MODULE_0__.css,\n  each: dom7__WEBPACK_IMPORTED_MODULE_0__.each,\n  html: dom7__WEBPACK_IMPORTED_MODULE_0__.html,\n  text: dom7__WEBPACK_IMPORTED_MODULE_0__.text,\n  is: dom7__WEBPACK_IMPORTED_MODULE_0__.is,\n  index: dom7__WEBPACK_IMPORTED_MODULE_0__.index,\n  eq: dom7__WEBPACK_IMPORTED_MODULE_0__.eq,\n  append: dom7__WEBPACK_IMPORTED_MODULE_0__.append,\n  prepend: dom7__WEBPACK_IMPORTED_MODULE_0__.prepend,\n  next: dom7__WEBPACK_IMPORTED_MODULE_0__.next,\n  nextAll: dom7__WEBPACK_IMPORTED_MODULE_0__.nextAll,\n  prev: dom7__WEBPACK_IMPORTED_MODULE_0__.prev,\n  prevAll: dom7__WEBPACK_IMPORTED_MODULE_0__.prevAll,\n  parent: dom7__WEBPACK_IMPORTED_MODULE_0__.parent,\n  parents: dom7__WEBPACK_IMPORTED_MODULE_0__.parents,\n  closest: dom7__WEBPACK_IMPORTED_MODULE_0__.closest,\n  find: dom7__WEBPACK_IMPORTED_MODULE_0__.find,\n  children: dom7__WEBPACK_IMPORTED_MODULE_0__.children,\n  filter: dom7__WEBPACK_IMPORTED_MODULE_0__.filter,\n  remove: dom7__WEBPACK_IMPORTED_MODULE_0__.remove\n};\nObject.keys(Methods).forEach(function (methodName) {\n  Object.defineProperty(dom7__WEBPACK_IMPORTED_MODULE_0__.$.fn, methodName, {\n    value: Methods[methodName],\n    writable: true\n  });\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (dom7__WEBPACK_IMPORTED_MODULE_0__.$);\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/utils/dom.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/utils/get-browser.js":
/*!******************************************************!*\
  !*** ./node_modules/swiper/esm/utils/get-browser.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getBrowser: () => (/* binding */ getBrowser)\n/* harmony export */ });\n/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ \"./node_modules/ssr-window/ssr-window.esm.js\");\n\nvar browser;\n\nfunction calcBrowser() {\n  var window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();\n\n  function isSafari() {\n    var ua = window.navigator.userAgent.toLowerCase();\n    return ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0;\n  }\n\n  return {\n    isEdge: !!window.navigator.userAgent.match(/Edge/g),\n    isSafari: isSafari(),\n    isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent)\n  };\n}\n\nfunction getBrowser() {\n  if (!browser) {\n    browser = calcBrowser();\n  }\n\n  return browser;\n}\n\n\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/utils/get-browser.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/utils/get-device.js":
/*!*****************************************************!*\
  !*** ./node_modules/swiper/esm/utils/get-device.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getDevice: () => (/* binding */ getDevice)\n/* harmony export */ });\n/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ \"./node_modules/ssr-window/ssr-window.esm.js\");\n/* harmony import */ var _get_support__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-support */ \"./node_modules/swiper/esm/utils/get-support.js\");\n\n\nvar device;\n\nfunction calcDevice(_temp) {\n  var _ref = _temp === void 0 ? {} : _temp,\n      userAgent = _ref.userAgent;\n\n  var support = (0,_get_support__WEBPACK_IMPORTED_MODULE_1__.getSupport)();\n  var window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();\n  var platform = window.navigator.platform;\n  var ua = userAgent || window.navigator.userAgent;\n  var device = {\n    ios: false,\n    android: false\n  };\n  var screenWidth = window.screen.width;\n  var screenHeight = window.screen.height;\n  var android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/); // eslint-disable-line\n\n  var ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n  var ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n  var iphone = !ipad && ua.match(/(iPhone\\sOS|iOS)\\s([\\d_]+)/);\n  var windows = platform === 'Win32';\n  var macos = platform === 'MacIntel'; // iPadOs 13 fix\n\n  var iPadScreens = ['1024x1366', '1366x1024', '834x1194', '1194x834', '834x1112', '1112x834', '768x1024', '1024x768', '820x1180', '1180x820', '810x1080', '1080x810'];\n\n  if (!ipad && macos && support.touch && iPadScreens.indexOf(screenWidth + \"x\" + screenHeight) >= 0) {\n    ipad = ua.match(/(Version)\\/([\\d.]+)/);\n    if (!ipad) ipad = [0, 1, '13_0_0'];\n    macos = false;\n  } // Android\n\n\n  if (android && !windows) {\n    device.os = 'android';\n    device.android = true;\n  }\n\n  if (ipad || iphone || ipod) {\n    device.os = 'ios';\n    device.ios = true;\n  } // Export object\n\n\n  return device;\n}\n\nfunction getDevice(overrides) {\n  if (overrides === void 0) {\n    overrides = {};\n  }\n\n  if (!device) {\n    device = calcDevice(overrides);\n  }\n\n  return device;\n}\n\n\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/utils/get-device.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/utils/get-support.js":
/*!******************************************************!*\
  !*** ./node_modules/swiper/esm/utils/get-support.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getSupport: () => (/* binding */ getSupport)\n/* harmony export */ });\n/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ \"./node_modules/ssr-window/ssr-window.esm.js\");\n\nvar support;\n\nfunction calcSupport() {\n  var window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();\n  var document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();\n  return {\n    touch: !!('ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch),\n    pointerEvents: !!window.PointerEvent && 'maxTouchPoints' in window.navigator && window.navigator.maxTouchPoints >= 0,\n    observer: function checkObserver() {\n      return 'MutationObserver' in window || 'WebkitMutationObserver' in window;\n    }(),\n    passiveListener: function checkPassiveListener() {\n      var supportsPassive = false;\n\n      try {\n        var opts = Object.defineProperty({}, 'passive', {\n          // eslint-disable-next-line\n          get: function get() {\n            supportsPassive = true;\n          }\n        });\n        window.addEventListener('testPassiveListener', null, opts);\n      } catch (e) {// No support\n      }\n\n      return supportsPassive;\n    }(),\n    gestures: function checkGestures() {\n      return 'ongesturestart' in window;\n    }()\n  };\n}\n\nfunction getSupport() {\n  if (!support) {\n    support = calcSupport();\n  }\n\n  return support;\n}\n\n\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/utils/get-support.js?");

/***/ }),

/***/ "./node_modules/swiper/esm/utils/utils.js":
/*!************************************************!*\
  !*** ./node_modules/swiper/esm/utils/utils.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bindModuleMethods: () => (/* binding */ bindModuleMethods),\n/* harmony export */   classesToSelector: () => (/* binding */ classesToSelector),\n/* harmony export */   createElementIfNotDefined: () => (/* binding */ createElementIfNotDefined),\n/* harmony export */   deleteProps: () => (/* binding */ deleteProps),\n/* harmony export */   extend: () => (/* binding */ extend),\n/* harmony export */   getComputedStyle: () => (/* binding */ getComputedStyle),\n/* harmony export */   getTranslate: () => (/* binding */ getTranslate),\n/* harmony export */   isObject: () => (/* binding */ isObject),\n/* harmony export */   nextTick: () => (/* binding */ nextTick),\n/* harmony export */   now: () => (/* binding */ now)\n/* harmony export */ });\n/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ \"./node_modules/ssr-window/ssr-window.esm.js\");\n\n\nfunction deleteProps(obj) {\n  var object = obj;\n  Object.keys(object).forEach(function (key) {\n    try {\n      object[key] = null;\n    } catch (e) {// no getter for object\n    }\n\n    try {\n      delete object[key];\n    } catch (e) {// something got wrong\n    }\n  });\n}\n\nfunction nextTick(callback, delay) {\n  if (delay === void 0) {\n    delay = 0;\n  }\n\n  return setTimeout(callback, delay);\n}\n\nfunction now() {\n  return Date.now();\n}\n\nfunction getComputedStyle(el) {\n  var window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();\n  var style;\n\n  if (window.getComputedStyle) {\n    style = window.getComputedStyle(el, null);\n  }\n\n  if (!style && el.currentStyle) {\n    style = el.currentStyle;\n  }\n\n  if (!style) {\n    style = el.style;\n  }\n\n  return style;\n}\n\nfunction getTranslate(el, axis) {\n  if (axis === void 0) {\n    axis = 'x';\n  }\n\n  var window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();\n  var matrix;\n  var curTransform;\n  var transformMatrix;\n  var curStyle = getComputedStyle(el, null);\n\n  if (window.WebKitCSSMatrix) {\n    curTransform = curStyle.transform || curStyle.webkitTransform;\n\n    if (curTransform.split(',').length > 6) {\n      curTransform = curTransform.split(', ').map(function (a) {\n        return a.replace(',', '.');\n      }).join(', ');\n    } // Some old versions of Webkit choke when 'none' is passed; pass\n    // empty string instead in this case\n\n\n    transformMatrix = new window.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);\n  } else {\n    transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');\n    matrix = transformMatrix.toString().split(',');\n  }\n\n  if (axis === 'x') {\n    // Latest Chrome and webkits Fix\n    if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41; // Crazy IE10 Matrix\n    else if (matrix.length === 16) curTransform = parseFloat(matrix[12]); // Normal Browsers\n      else curTransform = parseFloat(matrix[4]);\n  }\n\n  if (axis === 'y') {\n    // Latest Chrome and webkits Fix\n    if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42; // Crazy IE10 Matrix\n    else if (matrix.length === 16) curTransform = parseFloat(matrix[13]); // Normal Browsers\n      else curTransform = parseFloat(matrix[5]);\n  }\n\n  return curTransform || 0;\n}\n\nfunction isObject(o) {\n  return typeof o === 'object' && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === 'Object';\n}\n\nfunction isNode(node) {\n  // eslint-disable-next-line\n  if (typeof window !== 'undefined' && typeof window.HTMLElement !== 'undefined') {\n    return node instanceof HTMLElement;\n  }\n\n  return node && (node.nodeType === 1 || node.nodeType === 11);\n}\n\nfunction extend() {\n  var to = Object(arguments.length <= 0 ? undefined : arguments[0]);\n  var noExtend = ['__proto__', 'constructor', 'prototype'];\n\n  for (var i = 1; i < arguments.length; i += 1) {\n    var nextSource = i < 0 || arguments.length <= i ? undefined : arguments[i];\n\n    if (nextSource !== undefined && nextSource !== null && !isNode(nextSource)) {\n      var keysArray = Object.keys(Object(nextSource)).filter(function (key) {\n        return noExtend.indexOf(key) < 0;\n      });\n\n      for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {\n        var nextKey = keysArray[nextIndex];\n        var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);\n\n        if (desc !== undefined && desc.enumerable) {\n          if (isObject(to[nextKey]) && isObject(nextSource[nextKey])) {\n            if (nextSource[nextKey].__swiper__) {\n              to[nextKey] = nextSource[nextKey];\n            } else {\n              extend(to[nextKey], nextSource[nextKey]);\n            }\n          } else if (!isObject(to[nextKey]) && isObject(nextSource[nextKey])) {\n            to[nextKey] = {};\n\n            if (nextSource[nextKey].__swiper__) {\n              to[nextKey] = nextSource[nextKey];\n            } else {\n              extend(to[nextKey], nextSource[nextKey]);\n            }\n          } else {\n            to[nextKey] = nextSource[nextKey];\n          }\n        }\n      }\n    }\n  }\n\n  return to;\n}\n\nfunction bindModuleMethods(instance, obj) {\n  Object.keys(obj).forEach(function (key) {\n    if (isObject(obj[key])) {\n      Object.keys(obj[key]).forEach(function (subKey) {\n        if (typeof obj[key][subKey] === 'function') {\n          obj[key][subKey] = obj[key][subKey].bind(instance);\n        }\n      });\n    }\n\n    instance[key] = obj[key];\n  });\n}\n\nfunction classesToSelector(classes) {\n  if (classes === void 0) {\n    classes = '';\n  }\n\n  return \".\" + classes.trim().replace(/([\\.:!\\/])/g, '\\\\$1') // eslint-disable-line\n  .replace(/ /g, '.');\n}\n\nfunction createElementIfNotDefined($container, params, createElements, checkProps) {\n  var document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();\n\n  if (createElements) {\n    Object.keys(checkProps).forEach(function (key) {\n      if (!params[key] && params.auto === true) {\n        var element = document.createElement('div');\n        element.className = checkProps[key];\n        $container.append(element);\n        params[key] = element;\n      }\n    });\n  }\n\n  return params;\n}\n\n\n\n//# sourceURL=webpack://parus/./node_modules/swiper/esm/utils/utils.js?");

/***/ }),

/***/ "./src/common.blocks/burger/burger.js":
/*!********************************************!*\
  !*** ./src/common.blocks/burger/burger.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _header_header__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../header/header */ \"./src/common.blocks/header/header.js\");\n\n\nconst CSS_BURGER = 'burger';\nconst elBurger = document.querySelector('.' + CSS_BURGER);\n\nif (!elBurger) {\n    throw new Error(`Selector \\'.${CSS_BURGER}\\' not available.`);\n}\n\nfunction toggleMenu () {\n    (0,_header_header__WEBPACK_IMPORTED_MODULE_0__.toggleMobileMenu)();\n    elBurger.classList.toggle(CSS_BURGER + '_is-show-menu');\n}\n\ndocument.querySelector('.' + CSS_BURGER).addEventListener('click', toggleMenu);\n\n\n//# sourceURL=webpack://parus/./src/common.blocks/burger/burger.js?");

/***/ }),

/***/ "./src/common.blocks/gallery-slider/gallery-slider.js":
/*!************************************************************!*\
  !*** ./src/common.blocks/gallery-slider/gallery-slider.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _service_gallery_service_gallery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../service-gallery/service-gallery */ \"./src/common.blocks/service-gallery/service-gallery.js\");\n/* harmony import */ var _service_slider_service_slider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../service-slider/service-slider */ \"./src/common.blocks/service-slider/service-slider.js\");\n\n\n\nconst CSS_GALLERY_SLIDER = 'gallery-slider';\nconst elGallerySlider = document.querySelectorAll('.' + CSS_GALLERY_SLIDER);\n\nif (elGallerySlider.length > 0) {\n    elGallerySlider.forEach(gallerySlider => {\n        const gallery = (0,_service_gallery_service_gallery__WEBPACK_IMPORTED_MODULE_0__.serviceGalleryInit)(gallerySlider.querySelector('.service-gallery'));\n\n        (0,_service_slider_service_slider__WEBPACK_IMPORTED_MODULE_1__.serviceSliderInit)(gallerySlider.querySelector('.service-slider'), gallery);\n    });\n}\n\n//# sourceURL=webpack://parus/./src/common.blocks/gallery-slider/gallery-slider.js?");

/***/ }),

/***/ "./src/common.blocks/header/header.js":
/*!********************************************!*\
  !*** ./src/common.blocks/header/header.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fixedHeaderOnDesktop: () => (/* binding */ fixedHeaderOnDesktop),\n/* harmony export */   hideMenuOnResize: () => (/* binding */ hideMenuOnResize),\n/* harmony export */   isMobile: () => (/* binding */ isMobile),\n/* harmony export */   toggleMobileMenu: () => (/* binding */ toggleMobileMenu)\n/* harmony export */ });\nconst CSS_HEADER = 'header';\nconst elHeader = document.querySelector('.' + CSS_HEADER);\nlet isMobile = false;\n\nif (!elHeader) {\n    throw new Error(`Selector \\'.${CSS_HEADER}\\' not available.`);\n}\n\nfunction lockScroll () {\n    document.body.style.setProperty('padding-right', window.innerWidth - document.documentElement.clientWidth + 'px');\n    document.body.style.setProperty('overflow', 'hidden');\n}\n\nfunction unLockScroll () {\n    document.body.style.removeProperty('padding-right');\n    document.body.style.removeProperty('overflow');\n}\n\nfunction toggleMobileMenu () {\n    isMobile = !isMobile;\n    isMobile ? lockScroll() : unLockScroll();\n    elHeader.classList.toggle(CSS_HEADER + '_is-show-menu');\n}\n\nfunction hideMenuOnResize () {\n    if (document.documentElement.clientWidth >= 1024 && elHeader.classList.contains(CSS_HEADER + '_is-show-menu')) {\n        isMobile = false;\n        elHeader.classList.remove(CSS_HEADER + '_is-show-menu');\n        document.querySelector('.burger').classList.remove('burger_is-show-menu');\n        unLockScroll();\n    }\n}\n\nfunction fixedHeaderOnDesktop (isFixed) {\n    isFixed ? document.querySelector('.page').style.setProperty('padding-top', document.querySelector('.' + CSS_HEADER).offsetHeight + 'px') : document.querySelector('.page').style.removeProperty('padding-top');\n    document.querySelector('.' + CSS_HEADER).classList[isFixed ? 'add' : 'remove'](CSS_HEADER + '_fixed');\n}\n\n\n\n//# sourceURL=webpack://parus/./src/common.blocks/header/header.js?");

/***/ }),

/***/ "./src/common.blocks/infographic/infographic.js":
/*!******************************************************!*\
  !*** ./src/common.blocks/infographic/infographic.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   destroyInfographicSlider: () => (/* binding */ destroyInfographicSlider)\n/* harmony export */ });\nconst CSS_INFOGRAPHIC = 'infographic';\nconst elInfographic = document.querySelector('.' + CSS_INFOGRAPHIC);\n\nlet activeIndex = 0;\n\nfunction createPaginationElements () {\n    const pagination = elInfographic.querySelector('.' + CSS_INFOGRAPHIC + '__pagination');\n    const length = elInfographic.querySelectorAll('.' + CSS_INFOGRAPHIC + '__item').length;\n\n    if (length >= 3) {\n        pagination.innerHTML = `<span class=\"${CSS_INFOGRAPHIC}__bullet ${CSS_INFOGRAPHIC}__bullet_active\"></span><span class=\"${CSS_INFOGRAPHIC}__bullet\"></span>`\n    }\n}\n\nfunction activationBullet (bullet, index) {\n    elInfographic.querySelector('.' + CSS_INFOGRAPHIC + '__bullet_active').classList.remove(CSS_INFOGRAPHIC + '__bullet_active');\n    bullet.classList.add(CSS_INFOGRAPHIC + '__bullet_active');\n}\n\nfunction swipe (bullet, index) {\n    const step = 2;\n    const width = index === 0 ? 0 : '-' + elInfographic.querySelector('.' + CSS_INFOGRAPHIC + '__table-item').offsetWidth * (step * index);\n\n    elInfographic.querySelector('.infographic__table').style.setProperty('transform',  `translateX(${width}px)`);\n}\n\nfunction changeSlide (bullet, index) {\n    if (!bullet.classList.contains(CSS_INFOGRAPHIC + '__bullet_active') && window.matchMedia('(max-width: 767px)').matches) {\n        activeIndex = index;\n        activationBullet(bullet, index);\n        swipe(bullet, activeIndex);\n    }\n}\n\nfunction destroyInfographicSlider () {\n    if (elInfographic && window.matchMedia('(max-width: 767px)').matches && elInfographic.querySelectorAll('.' + CSS_INFOGRAPHIC + '__item').length >= 3) {\n        const step = 2;\n        const width = activeIndex === 0 ? 0 : '-' + elInfographic.querySelector('.' + CSS_INFOGRAPHIC + '__table-item').offsetWidth * (step * activeIndex);\n\n        elInfographic.querySelector('.infographic__table').style.setProperty('transform',  `translateX(${width}px)`);\n    }\n\n    if (elInfographic && window.matchMedia('(min-width: 768px)').matches && elInfographic.querySelectorAll('.' + CSS_INFOGRAPHIC + '__item').length >= 3) {\n        elInfographic.querySelector('.' + CSS_INFOGRAPHIC + '__table').style.removeProperty('transform');\n        elInfographic.querySelector('.' + CSS_INFOGRAPHIC + '__bullet_active').classList.remove(CSS_INFOGRAPHIC + '__bullet_active');\n        elInfographic.querySelectorAll('.' + CSS_INFOGRAPHIC + '__bullet')[0].classList.add(CSS_INFOGRAPHIC + '__bullet_active');\n        activeIndex = 0;\n    }\n}\n\nfunction addListenersForBullets () {\n    if (elInfographic.querySelectorAll('.' + CSS_INFOGRAPHIC + '__bullet').length >= 2) {\n        elInfographic.querySelectorAll('.' + CSS_INFOGRAPHIC + '__bullet').forEach((bullet, index) => {\n            bullet.addEventListener('click', () => changeSlide(bullet, index));\n        });\n    }\n\n    let firstParam = 0;\n    let isDown = false;\n\n    function changeSlideAfterSwipe (e) {\n       if (e.clientX < firstParam && activeIndex < elInfographic.querySelectorAll('.' + CSS_INFOGRAPHIC + '__bullet').length - 1 && window.matchMedia('(max-width: 767px)').matches && !isDown) {\n           isDown = true;\n           document.body.style.setProperty('padding-right', window.innerWidth - document.documentElement.clientWidth + 'px');\n           document.body.style.setProperty('overflow', 'hidden');\n           changeSlide(elInfographic.querySelectorAll('.' + CSS_INFOGRAPHIC + '__bullet')[activeIndex + 1], activeIndex + 1);\n           elInfographic.querySelector('.' + CSS_INFOGRAPHIC + '__table').removeEventListener('pointermove', changeSlideAfterSwipe);\n           setTimeout(() => {\n               document.body.style.removeProperty('padding-right');\n               document.body.style.removeProperty('overflow');\n               isDown = false;\n           }, 500);\n       }\n\n       if (e.clientX > firstParam && activeIndex > 0 && window.matchMedia('(max-width: 767px)').matches && !isDown) {\n           isDown = true;\n           document.body.style.setProperty('padding-right', window.innerWidth - document.documentElement.clientWidth + 'px');\n           document.body.style.setProperty('overflow', 'hidden');\n           changeSlide(elInfographic.querySelectorAll('.' + CSS_INFOGRAPHIC + '__bullet')[activeIndex - 1], activeIndex - 1);\n           elInfographic.querySelector('.' + CSS_INFOGRAPHIC + '__table').removeEventListener('pointermove', changeSlideAfterSwipe);\n           setTimeout(() => {\n               document.body.style.removeProperty('padding-right');\n               document.body.style.removeProperty('overflow');\n               isDown = false;\n           }, 500);\n       }\n    }\n\n    elInfographic.querySelector('.' + CSS_INFOGRAPHIC + '__table').addEventListener('pointerdown', e => {\n        firstParam = e.clientX;\n        elInfographic.querySelector('.' + CSS_INFOGRAPHIC + '__table').addEventListener('pointermove', changeSlideAfterSwipe);\n    });\n\n    elInfographic.querySelector('.' + CSS_INFOGRAPHIC + '__table').addEventListener('pointerup', () => {\n        elInfographic.querySelector('.' + CSS_INFOGRAPHIC + '__table').removeEventListener('pointermove', changeSlideAfterSwipe);\n    });\n}\n\nif (elInfographic && elInfographic.querySelectorAll('.' + CSS_INFOGRAPHIC + '__item').length >= 3) {\n    createPaginationElements();\n    addListenersForBullets();\n}\n\nif (elInfographic && elInfographic.querySelectorAll('.' + CSS_INFOGRAPHIC + '__item').length <= 2) {\n    elInfographic.querySelector('.' + CSS_INFOGRAPHIC + '__pagination').style.setProperty('display', 'none');\n}\n\n\n\n//# sourceURL=webpack://parus/./src/common.blocks/infographic/infographic.js?");

/***/ }),

/***/ "./src/common.blocks/main-slider/main-slider.js":
/*!******************************************************!*\
  !*** ./src/common.blocks/main-slider/main-slider.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _js_utils_swiperInit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../js/utils/swiperInit */ \"./src/js/utils/swiperInit.js\");\n\n\nconst CSS_MAIN_SLIDER = 'main-slider';\nconst elMainSlider = document.querySelector('.' + CSS_MAIN_SLIDER);\n\nif (elMainSlider) {\n    (0,_js_utils_swiperInit__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(elMainSlider, '.swiper-container', {\n        slidesPerView: 1,\n        speed: 1000,\n        additional:{\n            loop: true,\n            breakpoints: {\n                1024:{\n                    speed: 1000\n                },\n                0: {\n                    speed: 700,\n                },\n            }\n        },\n        autoplay: {\n            delay: 5000,\n            disableOnInteraction: false\n        },\n        navigation: {\n            prevEl: elMainSlider.querySelector('.' + CSS_MAIN_SLIDER + '__slider-btn_prev'),\n            nextEl: elMainSlider.querySelector('.' + CSS_MAIN_SLIDER + '__slider-btn_next')\n        },\n        pagination: {\n            el: elMainSlider.querySelector('.' + CSS_MAIN_SLIDER + '__pagination'),\n            type: 'bullets',\n            bulletClass: CSS_MAIN_SLIDER + '__bullet',\n            bulletActiveClass: CSS_MAIN_SLIDER + '__bullet_active',\n            clickable: true\n        }\n    });\n}\n\n//# sourceURL=webpack://parus/./src/common.blocks/main-slider/main-slider.js?");

/***/ }),

/***/ "./src/common.blocks/mobile-slider/mobile-slider.js":
/*!**********************************************************!*\
  !*** ./src/common.blocks/mobile-slider/mobile-slider.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   initOrDestroyMobileSlider: () => (/* binding */ initOrDestroyMobileSlider)\n/* harmony export */ });\n/* harmony import */ var swiper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! swiper */ \"./node_modules/swiper/esm/components/core/core-class.js\");\n/* harmony import */ var swiper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! swiper */ \"./node_modules/swiper/esm/components/autoplay/autoplay.js\");\n/* harmony import */ var swiper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! swiper */ \"./node_modules/swiper/esm/components/navigation/navigation.js\");\n/* harmony import */ var swiper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! swiper */ \"./node_modules/swiper/esm/components/pagination/pagination.js\");\n\n\nconst CSS_MOBILE_SLIDER = 'mobile-slider';\nconst elMobileSlider = document.querySelector('.' + CSS_MOBILE_SLIDER);\n\nfunction getSwiperOptions () {\n    return {\n        slidesPerView: \"auto\",\n        spaceBetween: 20,\n        speed: 500,\n        watchSlidesVisibility: true,\n        watchOverflow: true,\n        watchSlidesProgress: true,\n        breakpoints: {\n            768: {\n                spaceBetween: 20\n            },\n\n            0: {\n                spaceBetween: 10\n            }\n        }\n    }\n}\n\nlet mobileSlider = null;\n\nfunction initOrDestroyMobileSlider () {\n    if (window.matchMedia('(max-width: 1023px)').matches && mobileSlider == null && elMobileSlider && elMobileSlider.querySelectorAll('.swiper-slide').length > 0) {\n        mobileSlider = new swiper__WEBPACK_IMPORTED_MODULE_0__[\"default\"](elMobileSlider.querySelector('.swiper-container'), getSwiperOptions())\n    }\n\n    if (!window.matchMedia('(max-width: 1023px)').matches && mobileSlider != null && elMobileSlider && elMobileSlider.querySelectorAll('.swiper-slide').length > 0) {\n        mobileSlider.destroy(true, true);\n        mobileSlider = null;\n    }\n}\n\nif (elMobileSlider && elMobileSlider.querySelectorAll('.swiper-slide').length > 0) {\n    swiper__WEBPACK_IMPORTED_MODULE_0__[\"default\"].use([swiper__WEBPACK_IMPORTED_MODULE_1__[\"default\"], swiper__WEBPACK_IMPORTED_MODULE_2__[\"default\"], swiper__WEBPACK_IMPORTED_MODULE_3__[\"default\"]]);\n\n    initOrDestroyMobileSlider();\n}\n\n\n\n\n//# sourceURL=webpack://parus/./src/common.blocks/mobile-slider/mobile-slider.js?");

/***/ }),

/***/ "./src/common.blocks/nav/nav.js":
/*!**************************************!*\
  !*** ./src/common.blocks/nav/nav.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   deactivationNavMenuOnResize: () => (/* binding */ deactivationNavMenuOnResize)\n/* harmony export */ });\n/* harmony import */ var _header_header__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../header/header */ \"./src/common.blocks/header/header.js\");\n\n\nconst CSS_NAV = 'nav';\nconst elNav = document.querySelector('.' + CSS_NAV);\n\nif (!elNav) {\n    throw new Error(`Selector \\'.${CSS_NAV}\\' not available.`);\n}\n\nlet isActiveSecondLevelOnDesktop = false;\n\nconst btnActivation = (btn, type) => btn.classList[type](CSS_NAV + '__link_is-active');\n\nfunction copyMenu (btn) {\n    const menu = btn.nextElementSibling.cloneNode(true);\n\n    menu.classList.remove(CSS_NAV + '__list_hidden');\n    menu.classList.add(CSS_NAV + '__list_second-level');\n    elNav.append(menu);\n}\n\nfunction activationSecondLevelOnDesktop () {\n    (0,_header_header__WEBPACK_IMPORTED_MODULE_0__.fixedHeaderOnDesktop)(true)\n    btnActivation(this, 'add');\n    copyMenu(this);\n    isActiveSecondLevelOnDesktop = true;\n}\n\nfunction removeSecondLevel () {\n    if (elNav.querySelector('.' + CSS_NAV + '__list_second-level')) elNav.querySelector('.' + CSS_NAV + '__list_second-level').remove();\n}\n\nfunction deactivationNavMenu (isDesktop, btn) {\n    if (isDesktop) {\n        removeSecondLevel();\n        btnActivation(btn, 'remove');\n        (0,_header_header__WEBPACK_IMPORTED_MODULE_0__.fixedHeaderOnDesktop)(false);\n        isActiveSecondLevelOnDesktop = false;\n    } else {\n        elNav.querySelector('.' + CSS_NAV + '__list_is-show').classList.remove(CSS_NAV + '__list_is-show');\n        btnActivation(elNav.querySelector('.' + CSS_NAV + '__link_is-active'), 'remove');\n    }\n}\n\nfunction activationSecondLevel () {\n    if (isActiveSecondLevelOnDesktop) {\n        if (!this.classList.contains(CSS_NAV + '__link_is-active')) {\n            deactivationNavMenu(true, elNav.querySelector('.' + CSS_NAV + '__link_is-active'));\n            activationSecondLevelOnDesktop.bind(this)();\n        } else {\n            deactivationNavMenu(true, elNav.querySelector('.' + CSS_NAV + '__link_is-active'));\n        }\n    } else {\n        activationSecondLevelOnDesktop.bind(this)();\n    }\n}\n\nfunction activationNavMenuOnMobile () {\n    if (elNav.querySelector('.' + CSS_NAV + '__list_is-show') && elNav.querySelector('.' + CSS_NAV + '__link_is-active') && !this.classList.contains(CSS_NAV + '__link_is-active')) {\n        deactivationNavMenu(false);\n    }\n\n    this.nextElementSibling.classList.toggle(CSS_NAV + '__list_is-show');\n    this.classList.toggle(CSS_NAV + '__link_is-active');\n}\n\nfunction deactivationNavMenuOnResize () {\n    if (isActiveSecondLevelOnDesktop) {\n        deactivationNavMenu(true, elNav.querySelector('.' + CSS_NAV + '__link_is-active'));\n    }\n\n    if (document.documentElement.clientWidth >= 1024 && elNav.querySelector('.' + CSS_NAV + '__link_is-active') && elNav.querySelector('.' + CSS_NAV + '__list_hidden.nav__list_is-show')) {\n        deactivationNavMenu(false);\n    }\n}\n\nfunction activationNavMenu () {\n    (_header_header__WEBPACK_IMPORTED_MODULE_0__.isMobile ? activationNavMenuOnMobile.bind(this) : activationSecondLevel.bind(this))();\n}\n\nelNav.querySelectorAll('.' + CSS_NAV + '__link_btn').forEach(btn => btn.addEventListener('click', activationNavMenu));\n\n\n\n//# sourceURL=webpack://parus/./src/common.blocks/nav/nav.js?");

/***/ }),

/***/ "./src/common.blocks/parallax/parallax.js":
/*!************************************************!*\
  !*** ./src/common.blocks/parallax/parallax.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   initParallax: () => (/* binding */ initParallax)\n/* harmony export */ });\nconst CSS_COLLAGE_PARALLAX = 'collage';\nconst CSS_INFOGRAPHIC_PARALLAX = 'infographic'\nconst elCollageParallax = document.querySelector('.' + CSS_COLLAGE_PARALLAX);\nconst elInfographicParallax = document.querySelector('.' + CSS_INFOGRAPHIC_PARALLAX);\nlet isInit = false;\n\nconst getCoordX = (e, parallaxLeftOffset, wrapper) => e.clientX - parallaxLeftOffset - 0.5 * wrapper.offsetWidth;\nconst getCoordY = (e, parallaxTopOffset, wrapper) => e.clientY - parallaxTopOffset - 0.5 *  wrapper.offsetHeight;\nconst getProperty = (coordX, coordY, speed) => `translateX(${(coordX * speed).toFixed(2)}px) translateY(${(coordY * speed).toFixed(2)}px)`;\n\nfunction setPropertyForElement (target, e, wrapper, speed) {\n    console.log(wrapper)\n    target.style.transform = getProperty(getCoordX(e, wrapper.getBoundingClientRect().left, wrapper),\n        getCoordY(e, wrapper.getBoundingClientRect().top, wrapper), speed);\n}\n\nfunction handleCollageParallax (e, wrapper) {\n    setPropertyForElement(elCollageParallax.querySelector('.collage__parallax_left'), e, wrapper, 0.13);\n    setPropertyForElement(elCollageParallax.querySelector('.collage__parallax_right'), e, wrapper, 0.07);\n}\n\nfunction handleInfographicParallax (e, wrapper) {\n    setPropertyForElement(elInfographicParallax.querySelector('.infographic__parallax_left'), e, wrapper, 0.14);\n    setPropertyForElement(elInfographicParallax.querySelector('.infographic__parallax_right'), e, wrapper, 0.07);\n}\n\nfunction initParallax () {\n    if (isInit || !window.matchMedia('(min-width: 1024px)').matches || !window.matchMedia('(hover: hover)').matches) {\n        return false;\n    }\n\n    if (elCollageParallax || elInfographicParallax) {\n        isInit = true;\n\n        document.body.addEventListener('mousemove', e => {\n            if (elCollageParallax.querySelector('.' + CSS_COLLAGE_PARALLAX + '__wrapper')) {\n                handleCollageParallax(e, elCollageParallax.querySelector('.' + CSS_COLLAGE_PARALLAX + '__wrapper'));\n            }\n\n            if (elInfographicParallax.querySelector('.' + CSS_INFOGRAPHIC_PARALLAX + '__wrapper')) {\n                handleInfographicParallax(e, elInfographicParallax.querySelector('.' + CSS_INFOGRAPHIC_PARALLAX + '__wrapper'));\n            }\n        });\n    }\n}\n\ninitParallax();\n\n\n\n//# sourceURL=webpack://parus/./src/common.blocks/parallax/parallax.js?");

/***/ }),

/***/ "./src/common.blocks/service-gallery/service-gallery.js":
/*!**************************************************************!*\
  !*** ./src/common.blocks/service-gallery/service-gallery.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   serviceGalleryInit: () => (/* binding */ serviceGalleryInit)\n/* harmony export */ });\n/* harmony import */ var _js_utils_swiperInit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../js/utils/swiperInit */ \"./src/js/utils/swiperInit.js\");\n\n\nconst CSS_SERVICE_GALLERY = 'service-gallery';\nfunction serviceGalleryInit (el) {\n    return (0,_js_utils_swiperInit__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(el, '.swiper-container', {\n        slidesPerView: 'auto',\n        speed: 500,\n        additional: {\n            spaceBetween: 23,\n            freeMode: true,\n            breakpoints: {\n                768: {\n                    spaceBetween: 23\n                },\n                0: {\n                    spaceBetween: 14\n                }\n            },\n            on: {\n                init (swiper) {\n                    if (swiper.isBeginning && swiper.isEnd) {\n                        el.classList.add(CSS_SERVICE_GALLERY + '_centered')\n                        el.style.setProperty('opacity', '1');\n                    } else {\n                        el.style.setProperty('opacity', '1');\n                    }\n                },\n\n                resize (swiper) {\n                    if (swiper.isBeginning && swiper.isEnd) {\n                        el.classList.add(CSS_SERVICE_GALLERY + '_centered')\n                        el.style.setProperty('opacity', '1');\n                    } else {\n                        el.classList.remove(CSS_SERVICE_GALLERY + '_centered')\n                        el.style.setProperty('opacity', '1');\n                    }\n                }\n            }\n        },\n        navigation: {\n            prevEl: el.querySelector('.' + CSS_SERVICE_GALLERY + '__slider-btn_prev'),\n            nextEl: el.querySelector('.' + CSS_SERVICE_GALLERY + '__slider-btn_next')\n        },\n    });\n}\n\n\n\n//# sourceURL=webpack://parus/./src/common.blocks/service-gallery/service-gallery.js?");

/***/ }),

/***/ "./src/common.blocks/service-slider/service-slider.js":
/*!************************************************************!*\
  !*** ./src/common.blocks/service-slider/service-slider.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   serviceSliderInit: () => (/* binding */ serviceSliderInit)\n/* harmony export */ });\n/* harmony import */ var _js_utils_swiperInit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../js/utils/swiperInit */ \"./src/js/utils/swiperInit.js\");\n\n\nconst CSS_SERVICE_SLIDER = 'service-slider';\nfunction serviceSliderInit (el, gallerySlider) {\n    const options = {\n        slidesPerView: 1,\n        speed: 500,\n        navigation: {\n            prevEl: el.querySelector('.' + CSS_SERVICE_SLIDER + '__slider-btn_prev'),\n            nextEl: el.querySelector('.' + CSS_SERVICE_SLIDER + '__slider-btn_next')\n        },\n    };\n\n    if (gallerySlider) {\n        options.thumbs = {\n            swiper: gallerySlider\n        };\n    }\n\n    (0,_js_utils_swiperInit__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(el, '.swiper-container', options);\n}\n\n\n\n//# sourceURL=webpack://parus/./src/common.blocks/service-slider/service-slider.js?");

/***/ }),

/***/ "./src/js/pages/index.js":
/*!*******************************!*\
  !*** ./src/js/pages/index.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _js_utils_resize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../js/utils/resize */ \"./src/js/utils/resize.js\");\n/* harmony import */ var _library_blocks_select_select__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../library.blocks/select/select */ \"./src/library.blocks/select/select.js\");\n/* harmony import */ var _library_blocks_select_select__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_library_blocks_select_select__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _common_blocks_header_header__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../common.blocks/header/header */ \"./src/common.blocks/header/header.js\");\n/* harmony import */ var _common_blocks_burger_burger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../common.blocks/burger/burger */ \"./src/common.blocks/burger/burger.js\");\n/* harmony import */ var _common_blocks_nav_nav__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../common.blocks/nav/nav */ \"./src/common.blocks/nav/nav.js\");\n/* harmony import */ var _common_blocks_main_slider_main_slider__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../common.blocks/main-slider/main-slider */ \"./src/common.blocks/main-slider/main-slider.js\");\n/* harmony import */ var _common_blocks_mobile_slider_mobile_slider__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../common.blocks/mobile-slider/mobile-slider */ \"./src/common.blocks/mobile-slider/mobile-slider.js\");\n/* harmony import */ var _common_blocks_infographic_infographic__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../common.blocks/infographic/infographic */ \"./src/common.blocks/infographic/infographic.js\");\n/* harmony import */ var _common_blocks_gallery_slider_gallery_slider__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../common.blocks/gallery-slider/gallery-slider */ \"./src/common.blocks/gallery-slider/gallery-slider.js\");\n/* harmony import */ var _common_blocks_parallax_parallax__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../common.blocks/parallax/parallax */ \"./src/common.blocks/parallax/parallax.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=webpack://parus/./src/js/pages/index.js?");

/***/ }),

/***/ "./src/js/utils/resize.js":
/*!********************************!*\
  !*** ./src/js/utils/resize.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _common_blocks_header_header__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../common.blocks/header/header */ \"./src/common.blocks/header/header.js\");\n/* harmony import */ var _common_blocks_nav_nav__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../common.blocks/nav/nav */ \"./src/common.blocks/nav/nav.js\");\n/* harmony import */ var _common_blocks_mobile_slider_mobile_slider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../common.blocks/mobile-slider/mobile-slider */ \"./src/common.blocks/mobile-slider/mobile-slider.js\");\n/* harmony import */ var _common_blocks_infographic_infographic__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../common.blocks/infographic/infographic */ \"./src/common.blocks/infographic/infographic.js\");\n/* harmony import */ var _common_blocks_parallax_parallax__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../common.blocks/parallax/parallax */ \"./src/common.blocks/parallax/parallax.js\");\n\n\n\n\n\n\nwindow.addEventListener('resize', () => {\n    (0,_common_blocks_header_header__WEBPACK_IMPORTED_MODULE_0__.hideMenuOnResize)();\n    (0,_common_blocks_nav_nav__WEBPACK_IMPORTED_MODULE_1__.deactivationNavMenuOnResize)();\n    (0,_common_blocks_mobile_slider_mobile_slider__WEBPACK_IMPORTED_MODULE_2__.initOrDestroyMobileSlider)();\n    (0,_common_blocks_infographic_infographic__WEBPACK_IMPORTED_MODULE_3__.destroyInfographicSlider)();\n    (0,_common_blocks_parallax_parallax__WEBPACK_IMPORTED_MODULE_4__.initParallax)();\n});\n\n//# sourceURL=webpack://parus/./src/js/utils/resize.js?");

/***/ }),

/***/ "./src/js/utils/swiperInit.js":
/*!************************************!*\
  !*** ./src/js/utils/swiperInit.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ swiperInit)\n/* harmony export */ });\n/* harmony import */ var swiper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! swiper */ \"./node_modules/swiper/esm/components/navigation/navigation.js\");\n/* harmony import */ var swiper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! swiper */ \"./node_modules/swiper/esm/components/pagination/pagination.js\");\n/* harmony import */ var swiper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! swiper */ \"./node_modules/swiper/esm/components/autoplay/autoplay.js\");\n/* harmony import */ var swiper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! swiper */ \"./node_modules/swiper/esm/components/thumbs/thumbs.js\");\n/* harmony import */ var swiper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! swiper */ \"./node_modules/swiper/esm/components/core/core-class.js\");\n\n\nfunction swiperInit (parent, el, options) {\n    const {slidesPerView, speed, additional, autoplay, navigation, pagination, thumbs} = options;\n    const sliderEl = parent.querySelector(el);\n\n    if (!sliderEl || sliderEl.querySelectorAll('.swiper-slide').length === 0) {\n        return console.error('swiperInit: DOM elements not found');\n    }\n\n    const swiperOptions = {\n        slidesPerView: slidesPerView || 1,\n        speed: speed || 300\n    };\n\n    Object.assign(swiperOptions, additional);\n\n    function getSwiperUseOptions () {\n        let swiperUseOptions = [];\n\n        if (navigation && navigation.prevEl && navigation.nextEl) {\n            swiperUseOptions.push(swiper__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n        }\n\n        if (pagination && pagination.el) {\n            swiperUseOptions.push(swiper__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n        }\n\n        if (autoplay) {\n            swiperUseOptions.push(swiper__WEBPACK_IMPORTED_MODULE_2__[\"default\"]);\n        }\n\n        if (thumbs) {\n            swiperUseOptions.push(swiper__WEBPACK_IMPORTED_MODULE_3__[\"default\"]);\n        }\n\n        return swiperUseOptions;\n    }\n\n    function setSwiperOptions () {\n        if (navigation && navigation.prevEl && navigation.nextEl) {\n            swiperOptions.navigation = navigation;\n        }\n\n        if (pagination && pagination.el) {\n            swiperOptions.pagination = pagination;\n        }\n\n        if (autoplay) {\n            swiperOptions.autoplay = autoplay;\n        }\n\n        if (thumbs) {\n            swiperOptions.thumbs = thumbs;\n        }\n    }\n\n    function hideSwiperPaginationAndPagination () {\n        if (navigation && navigation.prevEl && navigation.nextEl) {\n            navigation.prevEl.style.setProperty('display', 'none');\n            navigation.nextEl.style.setProperty('display', 'none');\n        }\n\n        if (pagination.el) {\n            pagination.el.style.setProperty('display', 'none');\n        }\n    }\n\n    sliderEl.querySelectorAll('.swiper-slide').length > 1 ? setSwiperOptions() :  hideSwiperPaginationAndPagination();\n\n    const swiperUseOptions = getSwiperUseOptions();\n\n    if (swiperUseOptions.length > 0) {\n        swiper__WEBPACK_IMPORTED_MODULE_4__[\"default\"].use(swiperUseOptions);\n    }\n\n    return new swiper__WEBPACK_IMPORTED_MODULE_4__[\"default\"](parent.querySelector(el), swiperOptions);\n}\n\n//# sourceURL=webpack://parus/./src/js/utils/swiperInit.js?");

/***/ }),

/***/ "./src/library.blocks/select/select.js":
/*!*********************************************!*\
  !*** ./src/library.blocks/select/select.js ***!
  \*********************************************/
/***/ (() => {

eval("const CSS_SELECT = 'select';\nconst elSelect = document.querySelectorAll('.' + CSS_SELECT);\n\nif (elSelect.length > 0) {\n    init();\n}\n\nfunction init () {\n    const selectEls = [];\n\n    elSelect.forEach((select, index) => selectInit(select, index, selectEls));\n    outsideClick(selectEls);\n}\n\nfunction selectInit (select, index, selectEls) {\n    if (!select.querySelector('.' + CSS_SELECT + '__value') || !select.querySelector('.' + CSS_SELECT + '__hidden-select') || select.querySelectorAll('.select__item').length === 0) {\n        return console.error('Select: some elements in the markup are missing');\n    }\n\n    const selectObj = {\n        id: index,\n        el: select,\n        '#isOpen': false,\n        get isOpenSelect () {\n            return this['#isOpen'];\n        },\n        set isOpenSelect (isOpenValue) {\n            this['#isOpen'] = isOpenValue;\n            this.el.classList.toggle(CSS_SELECT + '_is-open', isOpenValue);\n        },\n        setValue (selectedValue, activeIndex) {\n            this.el.querySelector('.' + CSS_SELECT + '__value').innerText = selectedValue;\n            this.el.querySelector('.' + CSS_SELECT + '__hidden-select').selectedIndex = activeIndex;\n        }\n    };\n\n    selectEls.push(selectObj);\n\n    select.addEventListener('click', e => selectClick(selectObj, selectEls));\n\n    select.querySelectorAll('.' + CSS_SELECT + '__item').forEach((option, index) => {\n        option.addEventListener('click', () => selectOption(selectObj, option, index));\n    });\n}\n\nfunction selectClick (selectObj, selectEls) {\n    selectObj.isOpenSelect = !selectObj.isOpenSelect;\n\n    for (let select of selectEls) {\n        if (select.id !== selectObj.id) select.isOpenSelect = false;\n    }\n}\n\nfunction selectOption (selectObj, activeOption, index) {\n    selectObj.setValue(activeOption.innerText, index);\n    activeOption.classList.add(CSS_SELECT + '__item_is-active');\n    selectObj.el.querySelector('.' + CSS_SELECT + '__item_is-active').classList.remove(CSS_SELECT + '__item_is-active');\n}\n\nfunction outsideClick (selectEls) {\n    document.addEventListener('click', e => {\n        if (!e.target.closest('.' + CSS_SELECT) && selectEls.length > 0) {\n            selectEls.forEach(select => {\n                if (select.isOpenSelect) select.isOpenSelect = false;\n            });\n        }\n    });\n}\n\n//# sourceURL=webpack://parus/./src/library.blocks/select/select.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/js/pages/index.js");
/******/ 	
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm1haW4uanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBaElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJidWlsZC5taW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQVRURU5USU9OOiBUaGUgXCJldmFsXCIgZGV2dG9vbCBoYXMgYmVlbiB1c2VkIChtYXliZSBieSBkZWZhdWx0IGluIG1vZGU6IFwiZGV2ZWxvcG1lbnRcIikuXG4gKiBUaGlzIGRldnRvb2wgaXMgbmVpdGhlciBtYWRlIGZvciBwcm9kdWN0aW9uIG5vciBmb3IgcmVhZGFibGUgb3V0cHV0IGZpbGVzLlxuICogSXQgdXNlcyBcImV2YWwoKVwiIGNhbGxzIHRvIGNyZWF0ZSBhIHNlcGFyYXRlIHNvdXJjZSBmaWxlIGluIHRoZSBicm93c2VyIGRldnRvb2xzLlxuICogSWYgeW91IGFyZSB0cnlpbmcgdG8gcmVhZCB0aGUgb3V0cHV0IGZpbGUsIHNlbGVjdCBhIGRpZmZlcmVudCBkZXZ0b29sIChodHRwczovL3dlYnBhY2suanMub3JnL2NvbmZpZ3VyYXRpb24vZGV2dG9vbC8pXG4gKiBvciBkaXNhYmxlIHRoZSBkZWZhdWx0IGRldnRvb2wgd2l0aCBcImRldnRvb2w6IGZhbHNlXCIuXG4gKiBJZiB5b3UgYXJlIGxvb2tpbmcgZm9yIHByb2R1Y3Rpb24tcmVhZHkgb3V0cHV0IGZpbGVzLCBzZWUgbW9kZTogXCJwcm9kdWN0aW9uXCIgKGh0dHBzOi8vd2VicGFjay5qcy5vcmcvY29uZmlndXJhdGlvbi9tb2RlLykuXG4gKi9cbi8qKioqKiovICgoKSA9PiB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVzX18gPSAoe1xuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2RvbTcvZG9tNy5lc20uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9kb203L2RvbTcuZXNtLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgJDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gJCksXFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBhZGQ6ICgpID0+ICgvKiBiaW5kaW5nICovIGFkZCksXFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBhZGRDbGFzczogKCkgPT4gKC8qIGJpbmRpbmcgKi8gYWRkQ2xhc3MpLFxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgYW5pbWF0ZTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gYW5pbWF0ZSksXFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBhbmltYXRpb25FbmQ6ICgpID0+ICgvKiBiaW5kaW5nICovIGFuaW1hdGlvbkVuZCksXFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBhcHBlbmQ6ICgpID0+ICgvKiBiaW5kaW5nICovIGFwcGVuZCksXFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBhcHBlbmRUbzogKCkgPT4gKC8qIGJpbmRpbmcgKi8gYXBwZW5kVG8pLFxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgYXR0cjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gYXR0ciksXFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBibHVyOiAoKSA9PiAoLyogYmluZGluZyAqLyBibHVyKSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIGNoYW5nZTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gY2hhbmdlKSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIGNoaWxkcmVuOiAoKSA9PiAoLyogYmluZGluZyAqLyBjaGlsZHJlbiksXFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBjbGljazogKCkgPT4gKC8qIGJpbmRpbmcgKi8gY2xpY2spLFxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgY2xvc2VzdDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gY2xvc2VzdCksXFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBjc3M6ICgpID0+ICgvKiBiaW5kaW5nICovIGNzcyksXFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBkYXRhOiAoKSA9PiAoLyogYmluZGluZyAqLyBkYXRhKSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIGRhdGFzZXQ6ICgpID0+ICgvKiBiaW5kaW5nICovIGRhdGFzZXQpLFxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcImRlZmF1bHRcXFwiOiAoKSA9PiAoX19XRUJQQUNLX0RFRkFVTFRfRVhQT1JUX18pLFxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgZGV0YWNoOiAoKSA9PiAoLyogYmluZGluZyAqLyBkZXRhY2gpLFxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgZWFjaDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gZWFjaCksXFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBlbXB0eTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gZW1wdHkpLFxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgZXE6ICgpID0+ICgvKiBiaW5kaW5nICovIGVxKSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIGZpbHRlcjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gZmlsdGVyKSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIGZpbmQ6ICgpID0+ICgvKiBiaW5kaW5nICovIGZpbmQpLFxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgZm9jdXM6ICgpID0+ICgvKiBiaW5kaW5nICovIGZvY3VzKSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIGZvY3VzaW46ICgpID0+ICgvKiBiaW5kaW5nICovIGZvY3VzaW4pLFxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgZm9jdXNvdXQ6ICgpID0+ICgvKiBiaW5kaW5nICovIGZvY3Vzb3V0KSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIGhhc0NsYXNzOiAoKSA9PiAoLyogYmluZGluZyAqLyBoYXNDbGFzcyksXFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBoZWlnaHQ6ICgpID0+ICgvKiBiaW5kaW5nICovIGhlaWdodCksXFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBoaWRlOiAoKSA9PiAoLyogYmluZGluZyAqLyBoaWRlKSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIGh0bWw6ICgpID0+ICgvKiBiaW5kaW5nICovIGh0bWwpLFxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgaW5kZXg6ICgpID0+ICgvKiBiaW5kaW5nICovIGluZGV4KSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIGluc2VydEFmdGVyOiAoKSA9PiAoLyogYmluZGluZyAqLyBpbnNlcnRBZnRlciksXFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBpbnNlcnRCZWZvcmU6ICgpID0+ICgvKiBiaW5kaW5nICovIGluc2VydEJlZm9yZSksXFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBpczogKCkgPT4gKC8qIGJpbmRpbmcgKi8gaXMpLFxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAga2V5ZG93bjogKCkgPT4gKC8qIGJpbmRpbmcgKi8ga2V5ZG93biksXFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBrZXlwcmVzczogKCkgPT4gKC8qIGJpbmRpbmcgKi8ga2V5cHJlc3MpLFxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAga2V5dXA6ICgpID0+ICgvKiBiaW5kaW5nICovIGtleXVwKSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIG1vdXNlZG93bjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gbW91c2Vkb3duKSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIG1vdXNlZW50ZXI6ICgpID0+ICgvKiBiaW5kaW5nICovIG1vdXNlZW50ZXIpLFxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgbW91c2VsZWF2ZTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gbW91c2VsZWF2ZSksXFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBtb3VzZW1vdmU6ICgpID0+ICgvKiBiaW5kaW5nICovIG1vdXNlbW92ZSksXFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBtb3VzZW91dDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gbW91c2VvdXQpLFxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgbW91c2VvdmVyOiAoKSA9PiAoLyogYmluZGluZyAqLyBtb3VzZW92ZXIpLFxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgbW91c2V1cDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gbW91c2V1cCksXFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBuZXh0OiAoKSA9PiAoLyogYmluZGluZyAqLyBuZXh0KSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIG5leHRBbGw6ICgpID0+ICgvKiBiaW5kaW5nICovIG5leHRBbGwpLFxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgb2ZmOiAoKSA9PiAoLyogYmluZGluZyAqLyBvZmYpLFxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgb2Zmc2V0OiAoKSA9PiAoLyogYmluZGluZyAqLyBvZmZzZXQpLFxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgb246ICgpID0+ICgvKiBiaW5kaW5nICovIG9uKSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIG9uY2U6ICgpID0+ICgvKiBiaW5kaW5nICovIG9uY2UpLFxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgb3V0ZXJIZWlnaHQ6ICgpID0+ICgvKiBiaW5kaW5nICovIG91dGVySGVpZ2h0KSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIG91dGVyV2lkdGg6ICgpID0+ICgvKiBiaW5kaW5nICovIG91dGVyV2lkdGgpLFxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgcGFyZW50OiAoKSA9PiAoLyogYmluZGluZyAqLyBwYXJlbnQpLFxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgcGFyZW50czogKCkgPT4gKC8qIGJpbmRpbmcgKi8gcGFyZW50cyksXFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBwcmVwZW5kOiAoKSA9PiAoLyogYmluZGluZyAqLyBwcmVwZW5kKSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIHByZXBlbmRUbzogKCkgPT4gKC8qIGJpbmRpbmcgKi8gcHJlcGVuZFRvKSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIHByZXY6ICgpID0+ICgvKiBiaW5kaW5nICovIHByZXYpLFxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgcHJldkFsbDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gcHJldkFsbCksXFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBwcm9wOiAoKSA9PiAoLyogYmluZGluZyAqLyBwcm9wKSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIHJlbW92ZTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gcmVtb3ZlKSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIHJlbW92ZUF0dHI6ICgpID0+ICgvKiBiaW5kaW5nICovIHJlbW92ZUF0dHIpLFxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgcmVtb3ZlQ2xhc3M6ICgpID0+ICgvKiBiaW5kaW5nICovIHJlbW92ZUNsYXNzKSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIHJlbW92ZURhdGE6ICgpID0+ICgvKiBiaW5kaW5nICovIHJlbW92ZURhdGEpLFxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgcmVzaXplOiAoKSA9PiAoLyogYmluZGluZyAqLyByZXNpemUpLFxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgc2Nyb2xsOiAoKSA9PiAoLyogYmluZGluZyAqLyBzY3JvbGwpLFxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgc2Nyb2xsTGVmdDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gc2Nyb2xsTGVmdCksXFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBzY3JvbGxUbzogKCkgPT4gKC8qIGJpbmRpbmcgKi8gc2Nyb2xsVG8pLFxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgc2Nyb2xsVG9wOiAoKSA9PiAoLyogYmluZGluZyAqLyBzY3JvbGxUb3ApLFxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgc2hvdzogKCkgPT4gKC8qIGJpbmRpbmcgKi8gc2hvdyksXFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBzaWJsaW5nczogKCkgPT4gKC8qIGJpbmRpbmcgKi8gc2libGluZ3MpLFxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgc3RvcDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gc3RvcCksXFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBzdHlsZXM6ICgpID0+ICgvKiBiaW5kaW5nICovIHN0eWxlcyksXFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBzdWJtaXQ6ICgpID0+ICgvKiBiaW5kaW5nICovIHN1Ym1pdCksXFxuLyogaGFybW9ueSBleHBvcnQgKi8gICB0ZXh0OiAoKSA9PiAoLyogYmluZGluZyAqLyB0ZXh0KSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIHRvZ2dsZUNsYXNzOiAoKSA9PiAoLyogYmluZGluZyAqLyB0b2dnbGVDbGFzcyksXFxuLyogaGFybW9ueSBleHBvcnQgKi8gICB0b3VjaGVuZDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gdG91Y2hlbmQpLFxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgdG91Y2htb3ZlOiAoKSA9PiAoLyogYmluZGluZyAqLyB0b3VjaG1vdmUpLFxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgdG91Y2hzdGFydDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gdG91Y2hzdGFydCksXFxuLyogaGFybW9ueSBleHBvcnQgKi8gICB0cmFuc2Zvcm06ICgpID0+ICgvKiBiaW5kaW5nICovIHRyYW5zZm9ybSksXFxuLyogaGFybW9ueSBleHBvcnQgKi8gICB0cmFuc2l0aW9uOiAoKSA9PiAoLyogYmluZGluZyAqLyB0cmFuc2l0aW9uKSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIHRyYW5zaXRpb25FbmQ6ICgpID0+ICgvKiBiaW5kaW5nICovIHRyYW5zaXRpb25FbmQpLFxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgdHJpZ2dlcjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gdHJpZ2dlciksXFxuLyogaGFybW9ueSBleHBvcnQgKi8gICB2YWw6ICgpID0+ICgvKiBiaW5kaW5nICovIHZhbCksXFxuLyogaGFybW9ueSBleHBvcnQgKi8gICB2YWx1ZTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gdmFsdWUpLFxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgd2lkdGg6ICgpID0+ICgvKiBiaW5kaW5nICovIHdpZHRoKVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBzc3Jfd2luZG93X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBzc3Itd2luZG93ICovIFxcXCIuL25vZGVfbW9kdWxlcy9zc3Itd2luZG93L3Nzci13aW5kb3cuZXNtLmpzXFxcIik7XFxuLyoqXFxuICogRG9tNyAzLjAuMFxcbiAqIE1pbmltYWxpc3RpYyBKYXZhU2NyaXB0IGxpYnJhcnkgZm9yIERPTSBtYW5pcHVsYXRpb24sIHdpdGggYSBqUXVlcnktY29tcGF0aWJsZSBBUElcXG4gKiBodHRwczovL2ZyYW1ld29yazcuaW8vZG9jcy9kb203Lmh0bWxcXG4gKlxcbiAqIENvcHlyaWdodCAyMDIwLCBWbGFkaW1pciBLaGFybGFtcGlkaVxcbiAqXFxuICogTGljZW5zZWQgdW5kZXIgTUlUXFxuICpcXG4gKiBSZWxlYXNlZCBvbjogTm92ZW1iZXIgOSwgMjAyMFxcbiAqL1xcblxcblxcbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XFxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcXG4gIHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzO1xcbiAgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcXG59XFxuXFxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcXG4gIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XFxuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XFxuICB9O1xcbiAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcXG59XFxuXFxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcXG4gIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xcbiAgICBvLl9fcHJvdG9fXyA9IHA7XFxuICAgIHJldHVybiBvO1xcbiAgfTtcXG5cXG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XFxufVxcblxcbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XFxuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFxcXCJ1bmRlZmluZWRcXFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xcbiAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcXG4gIGlmICh0eXBlb2YgUHJveHkgPT09IFxcXCJmdW5jdGlvblxcXCIpIHJldHVybiB0cnVlO1xcblxcbiAgdHJ5IHtcXG4gICAgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcXG4gICAgcmV0dXJuIHRydWU7XFxuICB9IGNhdGNoIChlKSB7XFxuICAgIHJldHVybiBmYWxzZTtcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7XFxuICBpZiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSB7XFxuICAgIF9jb25zdHJ1Y3QgPSBSZWZsZWN0LmNvbnN0cnVjdDtcXG4gIH0gZWxzZSB7XFxuICAgIF9jb25zdHJ1Y3QgPSBmdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcXG4gICAgICB2YXIgYSA9IFtudWxsXTtcXG4gICAgICBhLnB1c2guYXBwbHkoYSwgYXJncyk7XFxuICAgICAgdmFyIENvbnN0cnVjdG9yID0gRnVuY3Rpb24uYmluZC5hcHBseShQYXJlbnQsIGEpO1xcbiAgICAgIHZhciBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcigpO1xcbiAgICAgIGlmIChDbGFzcykgX3NldFByb3RvdHlwZU9mKGluc3RhbmNlLCBDbGFzcy5wcm90b3R5cGUpO1xcbiAgICAgIHJldHVybiBpbnN0YW5jZTtcXG4gICAgfTtcXG4gIH1cXG5cXG4gIHJldHVybiBfY29uc3RydWN0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XFxufVxcblxcbmZ1bmN0aW9uIF9pc05hdGl2ZUZ1bmN0aW9uKGZuKSB7XFxuICByZXR1cm4gRnVuY3Rpb24udG9TdHJpbmcuY2FsbChmbikuaW5kZXhPZihcXFwiW25hdGl2ZSBjb2RlXVxcXCIpICE9PSAtMTtcXG59XFxuXFxuZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykge1xcbiAgdmFyIF9jYWNoZSA9IHR5cGVvZiBNYXAgPT09IFxcXCJmdW5jdGlvblxcXCIgPyBuZXcgTWFwKCkgOiB1bmRlZmluZWQ7XFxuXFxuICBfd3JhcE5hdGl2ZVN1cGVyID0gZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykge1xcbiAgICBpZiAoQ2xhc3MgPT09IG51bGwgfHwgIV9pc05hdGl2ZUZ1bmN0aW9uKENsYXNzKSkgcmV0dXJuIENsYXNzO1xcblxcbiAgICBpZiAodHlwZW9mIENsYXNzICE9PSBcXFwiZnVuY3Rpb25cXFwiKSB7XFxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cXFwiKTtcXG4gICAgfVxcblxcbiAgICBpZiAodHlwZW9mIF9jYWNoZSAhPT0gXFxcInVuZGVmaW5lZFxcXCIpIHtcXG4gICAgICBpZiAoX2NhY2hlLmhhcyhDbGFzcykpIHJldHVybiBfY2FjaGUuZ2V0KENsYXNzKTtcXG5cXG4gICAgICBfY2FjaGUuc2V0KENsYXNzLCBXcmFwcGVyKTtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBXcmFwcGVyKCkge1xcbiAgICAgIHJldHVybiBfY29uc3RydWN0KENsYXNzLCBhcmd1bWVudHMsIF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3Rvcik7XFxuICAgIH1cXG5cXG4gICAgV3JhcHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENsYXNzLnByb3RvdHlwZSwge1xcbiAgICAgIGNvbnN0cnVjdG9yOiB7XFxuICAgICAgICB2YWx1ZTogV3JhcHBlcixcXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcXG4gICAgICB9XFxuICAgIH0pO1xcbiAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKFdyYXBwZXIsIENsYXNzKTtcXG4gIH07XFxuXFxuICByZXR1cm4gX3dyYXBOYXRpdmVTdXBlcihDbGFzcyk7XFxufVxcblxcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXFxcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFxcXCIpO1xcbiAgfVxcblxcbiAgcmV0dXJuIHNlbGY7XFxufVxcblxcbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXFxuZnVuY3Rpb24gbWFrZVJlYWN0aXZlKG9iaikge1xcbiAgdmFyIHByb3RvID0gb2JqLl9fcHJvdG9fXztcXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosICdfX3Byb3RvX18nLCB7XFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xcbiAgICAgIHJldHVybiBwcm90bztcXG4gICAgfSxcXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcXG4gICAgICBwcm90by5fX3Byb3RvX18gPSB2YWx1ZTtcXG4gICAgfVxcbiAgfSk7XFxufVxcblxcbnZhciBEb203ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQXJyYXkpIHtcXG4gIF9pbmhlcml0c0xvb3NlKERvbTcsIF9BcnJheSk7XFxuXFxuICBmdW5jdGlvbiBEb203KGl0ZW1zKSB7XFxuICAgIHZhciBfdGhpcztcXG5cXG4gICAgX3RoaXMgPSBfQXJyYXkuY2FsbC5hcHBseShfQXJyYXksIFt0aGlzXS5jb25jYXQoaXRlbXMpKSB8fCB0aGlzO1xcbiAgICBtYWtlUmVhY3RpdmUoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xcbiAgICByZXR1cm4gX3RoaXM7XFxuICB9XFxuXFxuICByZXR1cm4gRG9tNztcXG59KCAvKiNfX1BVUkVfXyovX3dyYXBOYXRpdmVTdXBlcihBcnJheSkpO1xcblxcbmZ1bmN0aW9uIGFycmF5RmxhdChhcnIpIHtcXG4gIGlmIChhcnIgPT09IHZvaWQgMCkge1xcbiAgICBhcnIgPSBbXTtcXG4gIH1cXG5cXG4gIHZhciByZXMgPSBbXTtcXG4gIGFyci5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xcbiAgICBpZiAoQXJyYXkuaXNBcnJheShlbCkpIHtcXG4gICAgICByZXMucHVzaC5hcHBseShyZXMsIGFycmF5RmxhdChlbCkpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHJlcy5wdXNoKGVsKTtcXG4gICAgfVxcbiAgfSk7XFxuICByZXR1cm4gcmVzO1xcbn1cXG5mdW5jdGlvbiBhcnJheUZpbHRlcihhcnIsIGNhbGxiYWNrKSB7XFxuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKGFyciwgY2FsbGJhY2spO1xcbn1cXG5mdW5jdGlvbiBhcnJheVVuaXF1ZShhcnIpIHtcXG4gIHZhciB1bmlxdWVBcnJheSA9IFtdO1xcblxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpICs9IDEpIHtcXG4gICAgaWYgKHVuaXF1ZUFycmF5LmluZGV4T2YoYXJyW2ldKSA9PT0gLTEpIHVuaXF1ZUFycmF5LnB1c2goYXJyW2ldKTtcXG4gIH1cXG5cXG4gIHJldHVybiB1bmlxdWVBcnJheTtcXG59XFxuZnVuY3Rpb24gdG9DYW1lbENhc2Uoc3RyaW5nKSB7XFxuICByZXR1cm4gc3RyaW5nLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvLSguKS9nLCBmdW5jdGlvbiAobWF0Y2gsIGdyb3VwKSB7XFxuICAgIHJldHVybiBncm91cC50b1VwcGVyQ2FzZSgpO1xcbiAgfSk7XFxufVxcblxcbmZ1bmN0aW9uIHFzYShzZWxlY3RvciwgY29udGV4dCkge1xcbiAgaWYgKHR5cGVvZiBzZWxlY3RvciAhPT0gJ3N0cmluZycpIHtcXG4gICAgcmV0dXJuIFtzZWxlY3Rvcl07XFxuICB9XFxuXFxuICB2YXIgYSA9IFtdO1xcbiAgdmFyIHJlcyA9IGNvbnRleHQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XFxuXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHJlcy5sZW5ndGg7IGkgKz0gMSkge1xcbiAgICBhLnB1c2gocmVzW2ldKTtcXG4gIH1cXG5cXG4gIHJldHVybiBhO1xcbn1cXG5cXG5mdW5jdGlvbiAkKHNlbGVjdG9yLCBjb250ZXh0KSB7XFxuICB2YXIgd2luZG93ID0gKDAsc3NyX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmdldFdpbmRvdykoKTtcXG4gIHZhciBkb2N1bWVudCA9ICgwLHNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5nZXREb2N1bWVudCkoKTtcXG4gIHZhciBhcnIgPSBbXTtcXG5cXG4gIGlmICghY29udGV4dCAmJiBzZWxlY3RvciBpbnN0YW5jZW9mIERvbTcpIHtcXG4gICAgcmV0dXJuIHNlbGVjdG9yO1xcbiAgfVxcblxcbiAgaWYgKCFzZWxlY3Rvcikge1xcbiAgICByZXR1cm4gbmV3IERvbTcoYXJyKTtcXG4gIH1cXG5cXG4gIGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09ICdzdHJpbmcnKSB7XFxuICAgIHZhciBodG1sID0gc2VsZWN0b3IudHJpbSgpO1xcblxcbiAgICBpZiAoaHRtbC5pbmRleE9mKCc8JykgPj0gMCAmJiBodG1sLmluZGV4T2YoJz4nKSA+PSAwKSB7XFxuICAgICAgdmFyIHRvQ3JlYXRlID0gJ2Rpdic7XFxuICAgICAgaWYgKGh0bWwuaW5kZXhPZignPGxpJykgPT09IDApIHRvQ3JlYXRlID0gJ3VsJztcXG4gICAgICBpZiAoaHRtbC5pbmRleE9mKCc8dHInKSA9PT0gMCkgdG9DcmVhdGUgPSAndGJvZHknO1xcbiAgICAgIGlmIChodG1sLmluZGV4T2YoJzx0ZCcpID09PSAwIHx8IGh0bWwuaW5kZXhPZignPHRoJykgPT09IDApIHRvQ3JlYXRlID0gJ3RyJztcXG4gICAgICBpZiAoaHRtbC5pbmRleE9mKCc8dGJvZHknKSA9PT0gMCkgdG9DcmVhdGUgPSAndGFibGUnO1xcbiAgICAgIGlmIChodG1sLmluZGV4T2YoJzxvcHRpb24nKSA9PT0gMCkgdG9DcmVhdGUgPSAnc2VsZWN0JztcXG4gICAgICB2YXIgdGVtcFBhcmVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodG9DcmVhdGUpO1xcbiAgICAgIHRlbXBQYXJlbnQuaW5uZXJIVE1MID0gaHRtbDtcXG5cXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRlbXBQYXJlbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKz0gMSkge1xcbiAgICAgICAgYXJyLnB1c2godGVtcFBhcmVudC5jaGlsZE5vZGVzW2ldKTtcXG4gICAgICB9XFxuICAgIH0gZWxzZSB7XFxuICAgICAgYXJyID0gcXNhKHNlbGVjdG9yLnRyaW0oKSwgY29udGV4dCB8fCBkb2N1bWVudCk7XFxuICAgIH0gLy8gYXJyID0gcXNhKHNlbGVjdG9yLCBkb2N1bWVudCk7XFxuXFxuICB9IGVsc2UgaWYgKHNlbGVjdG9yLm5vZGVUeXBlIHx8IHNlbGVjdG9yID09PSB3aW5kb3cgfHwgc2VsZWN0b3IgPT09IGRvY3VtZW50KSB7XFxuICAgIGFyci5wdXNoKHNlbGVjdG9yKTtcXG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShzZWxlY3RvcikpIHtcXG4gICAgaWYgKHNlbGVjdG9yIGluc3RhbmNlb2YgRG9tNykgcmV0dXJuIHNlbGVjdG9yO1xcbiAgICBhcnIgPSBzZWxlY3RvcjtcXG4gIH1cXG5cXG4gIHJldHVybiBuZXcgRG9tNyhhcnJheVVuaXF1ZShhcnIpKTtcXG59XFxuXFxuJC5mbiA9IERvbTcucHJvdG90eXBlO1xcblxcbmZ1bmN0aW9uIGFkZENsYXNzKCkge1xcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGNsYXNzZXMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XFxuICAgIGNsYXNzZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XFxuICB9XFxuXFxuICB2YXIgY2xhc3NOYW1lcyA9IGFycmF5RmxhdChjbGFzc2VzLm1hcChmdW5jdGlvbiAoYykge1xcbiAgICByZXR1cm4gYy5zcGxpdCgnICcpO1xcbiAgfSkpO1xcbiAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xcbiAgICB2YXIgX2VsJGNsYXNzTGlzdDtcXG5cXG4gICAgKF9lbCRjbGFzc0xpc3QgPSBlbC5jbGFzc0xpc3QpLmFkZC5hcHBseShfZWwkY2xhc3NMaXN0LCBjbGFzc05hbWVzKTtcXG4gIH0pO1xcbiAgcmV0dXJuIHRoaXM7XFxufVxcblxcbmZ1bmN0aW9uIHJlbW92ZUNsYXNzKCkge1xcbiAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBjbGFzc2VzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XFxuICAgIGNsYXNzZXNbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcXG4gIH1cXG5cXG4gIHZhciBjbGFzc05hbWVzID0gYXJyYXlGbGF0KGNsYXNzZXMubWFwKGZ1bmN0aW9uIChjKSB7XFxuICAgIHJldHVybiBjLnNwbGl0KCcgJyk7XFxuICB9KSk7XFxuICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XFxuICAgIHZhciBfZWwkY2xhc3NMaXN0MjtcXG5cXG4gICAgKF9lbCRjbGFzc0xpc3QyID0gZWwuY2xhc3NMaXN0KS5yZW1vdmUuYXBwbHkoX2VsJGNsYXNzTGlzdDIsIGNsYXNzTmFtZXMpO1xcbiAgfSk7XFxuICByZXR1cm4gdGhpcztcXG59XFxuXFxuZnVuY3Rpb24gdG9nZ2xlQ2xhc3MoKSB7XFxuICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGNsYXNzZXMgPSBuZXcgQXJyYXkoX2xlbjMpLCBfa2V5MyA9IDA7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcXG4gICAgY2xhc3Nlc1tfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO1xcbiAgfVxcblxcbiAgdmFyIGNsYXNzTmFtZXMgPSBhcnJheUZsYXQoY2xhc3Nlcy5tYXAoZnVuY3Rpb24gKGMpIHtcXG4gICAgcmV0dXJuIGMuc3BsaXQoJyAnKTtcXG4gIH0pKTtcXG4gIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcXG4gICAgY2xhc3NOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcXG4gICAgICBlbC5jbGFzc0xpc3QudG9nZ2xlKGNsYXNzTmFtZSk7XFxuICAgIH0pO1xcbiAgfSk7XFxufVxcblxcbmZ1bmN0aW9uIGhhc0NsYXNzKCkge1xcbiAgZm9yICh2YXIgX2xlbjQgPSBhcmd1bWVudHMubGVuZ3RoLCBjbGFzc2VzID0gbmV3IEFycmF5KF9sZW40KSwgX2tleTQgPSAwOyBfa2V5NCA8IF9sZW40OyBfa2V5NCsrKSB7XFxuICAgIGNsYXNzZXNbX2tleTRdID0gYXJndW1lbnRzW19rZXk0XTtcXG4gIH1cXG5cXG4gIHZhciBjbGFzc05hbWVzID0gYXJyYXlGbGF0KGNsYXNzZXMubWFwKGZ1bmN0aW9uIChjKSB7XFxuICAgIHJldHVybiBjLnNwbGl0KCcgJyk7XFxuICB9KSk7XFxuICByZXR1cm4gYXJyYXlGaWx0ZXIodGhpcywgZnVuY3Rpb24gKGVsKSB7XFxuICAgIHJldHVybiBjbGFzc05hbWVzLmZpbHRlcihmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XFxuICAgICAgcmV0dXJuIGVsLmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpO1xcbiAgICB9KS5sZW5ndGggPiAwO1xcbiAgfSkubGVuZ3RoID4gMDtcXG59XFxuXFxuZnVuY3Rpb24gYXR0cihhdHRycywgdmFsdWUpIHtcXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIHR5cGVvZiBhdHRycyA9PT0gJ3N0cmluZycpIHtcXG4gICAgLy8gR2V0IGF0dHJcXG4gICAgaWYgKHRoaXNbMF0pIHJldHVybiB0aGlzWzBdLmdldEF0dHJpYnV0ZShhdHRycyk7XFxuICAgIHJldHVybiB1bmRlZmluZWQ7XFxuICB9IC8vIFNldCBhdHRyc1xcblxcblxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSArPSAxKSB7XFxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XFxuICAgICAgLy8gU3RyaW5nXFxuICAgICAgdGhpc1tpXS5zZXRBdHRyaWJ1dGUoYXR0cnMsIHZhbHVlKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAvLyBPYmplY3RcXG4gICAgICBmb3IgKHZhciBhdHRyTmFtZSBpbiBhdHRycykge1xcbiAgICAgICAgdGhpc1tpXVthdHRyTmFtZV0gPSBhdHRyc1thdHRyTmFtZV07XFxuICAgICAgICB0aGlzW2ldLnNldEF0dHJpYnV0ZShhdHRyTmFtZSwgYXR0cnNbYXR0ck5hbWVdKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiB0aGlzO1xcbn1cXG5cXG5mdW5jdGlvbiByZW1vdmVBdHRyKGF0dHIpIHtcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkgKz0gMSkge1xcbiAgICB0aGlzW2ldLnJlbW92ZUF0dHJpYnV0ZShhdHRyKTtcXG4gIH1cXG5cXG4gIHJldHVybiB0aGlzO1xcbn1cXG5cXG5mdW5jdGlvbiBwcm9wKHByb3BzLCB2YWx1ZSkge1xcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIHByb3BzID09PSAnc3RyaW5nJykge1xcbiAgICAvLyBHZXQgcHJvcFxcbiAgICBpZiAodGhpc1swXSkgcmV0dXJuIHRoaXNbMF1bcHJvcHNdO1xcbiAgfSBlbHNlIHtcXG4gICAgLy8gU2V0IHByb3BzXFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkgKz0gMSkge1xcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XFxuICAgICAgICAvLyBTdHJpbmdcXG4gICAgICAgIHRoaXNbaV1bcHJvcHNdID0gdmFsdWU7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIC8vIE9iamVjdFxcbiAgICAgICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gcHJvcHMpIHtcXG4gICAgICAgICAgdGhpc1tpXVtwcm9wTmFtZV0gPSBwcm9wc1twcm9wTmFtZV07XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHJldHVybiB0aGlzO1xcbiAgfVxcblxcbiAgcmV0dXJuIHRoaXM7XFxufVxcblxcbmZ1bmN0aW9uIGRhdGEoa2V5LCB2YWx1ZSkge1xcbiAgdmFyIGVsO1xcblxcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgZWwgPSB0aGlzWzBdO1xcbiAgICBpZiAoIWVsKSByZXR1cm4gdW5kZWZpbmVkOyAvLyBHZXQgdmFsdWVcXG5cXG4gICAgaWYgKGVsLmRvbTdFbGVtZW50RGF0YVN0b3JhZ2UgJiYga2V5IGluIGVsLmRvbTdFbGVtZW50RGF0YVN0b3JhZ2UpIHtcXG4gICAgICByZXR1cm4gZWwuZG9tN0VsZW1lbnREYXRhU3RvcmFnZVtrZXldO1xcbiAgICB9XFxuXFxuICAgIHZhciBkYXRhS2V5ID0gZWwuZ2V0QXR0cmlidXRlKFxcXCJkYXRhLVxcXCIgKyBrZXkpO1xcblxcbiAgICBpZiAoZGF0YUtleSkge1xcbiAgICAgIHJldHVybiBkYXRhS2V5O1xcbiAgICB9XFxuXFxuICAgIHJldHVybiB1bmRlZmluZWQ7XFxuICB9IC8vIFNldCB2YWx1ZVxcblxcblxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSArPSAxKSB7XFxuICAgIGVsID0gdGhpc1tpXTtcXG4gICAgaWYgKCFlbC5kb203RWxlbWVudERhdGFTdG9yYWdlKSBlbC5kb203RWxlbWVudERhdGFTdG9yYWdlID0ge307XFxuICAgIGVsLmRvbTdFbGVtZW50RGF0YVN0b3JhZ2Vba2V5XSA9IHZhbHVlO1xcbiAgfVxcblxcbiAgcmV0dXJuIHRoaXM7XFxufVxcblxcbmZ1bmN0aW9uIHJlbW92ZURhdGEoa2V5KSB7XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpICs9IDEpIHtcXG4gICAgdmFyIGVsID0gdGhpc1tpXTtcXG5cXG4gICAgaWYgKGVsLmRvbTdFbGVtZW50RGF0YVN0b3JhZ2UgJiYgZWwuZG9tN0VsZW1lbnREYXRhU3RvcmFnZVtrZXldKSB7XFxuICAgICAgZWwuZG9tN0VsZW1lbnREYXRhU3RvcmFnZVtrZXldID0gbnVsbDtcXG4gICAgICBkZWxldGUgZWwuZG9tN0VsZW1lbnREYXRhU3RvcmFnZVtrZXldO1xcbiAgICB9XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGRhdGFzZXQoKSB7XFxuICB2YXIgZWwgPSB0aGlzWzBdO1xcbiAgaWYgKCFlbCkgcmV0dXJuIHVuZGVmaW5lZDtcXG4gIHZhciBkYXRhc2V0ID0ge307IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcXG5cXG4gIGlmIChlbC5kYXRhc2V0KSB7XFxuICAgIGZvciAodmFyIGRhdGFLZXkgaW4gZWwuZGF0YXNldCkge1xcbiAgICAgIGRhdGFzZXRbZGF0YUtleV0gPSBlbC5kYXRhc2V0W2RhdGFLZXldO1xcbiAgICB9XFxuICB9IGVsc2Uge1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsLmF0dHJpYnV0ZXMubGVuZ3RoOyBpICs9IDEpIHtcXG4gICAgICB2YXIgX2F0dHIgPSBlbC5hdHRyaWJ1dGVzW2ldO1xcblxcbiAgICAgIGlmIChfYXR0ci5uYW1lLmluZGV4T2YoJ2RhdGEtJykgPj0gMCkge1xcbiAgICAgICAgZGF0YXNldFt0b0NhbWVsQ2FzZShfYXR0ci5uYW1lLnNwbGl0KCdkYXRhLScpWzFdKV0gPSBfYXR0ci52YWx1ZTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZvciAodmFyIGtleSBpbiBkYXRhc2V0KSB7XFxuICAgIGlmIChkYXRhc2V0W2tleV0gPT09ICdmYWxzZScpIGRhdGFzZXRba2V5XSA9IGZhbHNlO2Vsc2UgaWYgKGRhdGFzZXRba2V5XSA9PT0gJ3RydWUnKSBkYXRhc2V0W2tleV0gPSB0cnVlO2Vsc2UgaWYgKHBhcnNlRmxvYXQoZGF0YXNldFtrZXldKSA9PT0gZGF0YXNldFtrZXldICogMSkgZGF0YXNldFtrZXldICo9IDE7XFxuICB9XFxuXFxuICByZXR1cm4gZGF0YXNldDtcXG59XFxuXFxuZnVuY3Rpb24gdmFsKHZhbHVlKSB7XFxuICBpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xcbiAgICAvLyBnZXQgdmFsdWVcXG4gICAgdmFyIGVsID0gdGhpc1swXTtcXG4gICAgaWYgKCFlbCkgcmV0dXJuIHVuZGVmaW5lZDtcXG5cXG4gICAgaWYgKGVsLm11bHRpcGxlICYmIGVsLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzZWxlY3QnKSB7XFxuICAgICAgdmFyIHZhbHVlcyA9IFtdO1xcblxcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWwuc2VsZWN0ZWRPcHRpb25zLmxlbmd0aDsgaSArPSAxKSB7XFxuICAgICAgICB2YWx1ZXMucHVzaChlbC5zZWxlY3RlZE9wdGlvbnNbaV0udmFsdWUpO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gdmFsdWVzO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBlbC52YWx1ZTtcXG4gIH0gLy8gc2V0IHZhbHVlXFxuXFxuXFxuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdGhpcy5sZW5ndGg7IF9pICs9IDEpIHtcXG4gICAgdmFyIF9lbCA9IHRoaXNbX2ldO1xcblxcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgX2VsLm11bHRpcGxlICYmIF9lbC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnc2VsZWN0Jykge1xcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgX2VsLm9wdGlvbnMubGVuZ3RoOyBqICs9IDEpIHtcXG4gICAgICAgIF9lbC5vcHRpb25zW2pdLnNlbGVjdGVkID0gdmFsdWUuaW5kZXhPZihfZWwub3B0aW9uc1tqXS52YWx1ZSkgPj0gMDtcXG4gICAgICB9XFxuICAgIH0gZWxzZSB7XFxuICAgICAgX2VsLnZhbHVlID0gdmFsdWU7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiB0aGlzO1xcbn1cXG5cXG5mdW5jdGlvbiB2YWx1ZSh2YWx1ZSkge1xcbiAgcmV0dXJuIHRoaXMudmFsKHZhbHVlKTtcXG59XFxuXFxuZnVuY3Rpb24gdHJhbnNmb3JtKHRyYW5zZm9ybSkge1xcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSArPSAxKSB7XFxuICAgIHRoaXNbaV0uc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xcbiAgfVxcblxcbiAgcmV0dXJuIHRoaXM7XFxufVxcblxcbmZ1bmN0aW9uIHRyYW5zaXRpb24oZHVyYXRpb24pIHtcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkgKz0gMSkge1xcbiAgICB0aGlzW2ldLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IHR5cGVvZiBkdXJhdGlvbiAhPT0gJ3N0cmluZycgPyBkdXJhdGlvbiArIFxcXCJtc1xcXCIgOiBkdXJhdGlvbjtcXG4gIH1cXG5cXG4gIHJldHVybiB0aGlzO1xcbn1cXG5cXG5mdW5jdGlvbiBvbigpIHtcXG4gIGZvciAodmFyIF9sZW41ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNSksIF9rZXk1ID0gMDsgX2tleTUgPCBfbGVuNTsgX2tleTUrKykge1xcbiAgICBhcmdzW19rZXk1XSA9IGFyZ3VtZW50c1tfa2V5NV07XFxuICB9XFxuXFxuICB2YXIgZXZlbnRUeXBlID0gYXJnc1swXSxcXG4gICAgICB0YXJnZXRTZWxlY3RvciA9IGFyZ3NbMV0sXFxuICAgICAgbGlzdGVuZXIgPSBhcmdzWzJdLFxcbiAgICAgIGNhcHR1cmUgPSBhcmdzWzNdO1xcblxcbiAgaWYgKHR5cGVvZiBhcmdzWzFdID09PSAnZnVuY3Rpb24nKSB7XFxuICAgIGV2ZW50VHlwZSA9IGFyZ3NbMF07XFxuICAgIGxpc3RlbmVyID0gYXJnc1sxXTtcXG4gICAgY2FwdHVyZSA9IGFyZ3NbMl07XFxuICAgIHRhcmdldFNlbGVjdG9yID0gdW5kZWZpbmVkO1xcbiAgfVxcblxcbiAgaWYgKCFjYXB0dXJlKSBjYXB0dXJlID0gZmFsc2U7XFxuXFxuICBmdW5jdGlvbiBoYW5kbGVMaXZlRXZlbnQoZSkge1xcbiAgICB2YXIgdGFyZ2V0ID0gZS50YXJnZXQ7XFxuICAgIGlmICghdGFyZ2V0KSByZXR1cm47XFxuICAgIHZhciBldmVudERhdGEgPSBlLnRhcmdldC5kb203RXZlbnREYXRhIHx8IFtdO1xcblxcbiAgICBpZiAoZXZlbnREYXRhLmluZGV4T2YoZSkgPCAwKSB7XFxuICAgICAgZXZlbnREYXRhLnVuc2hpZnQoZSk7XFxuICAgIH1cXG5cXG4gICAgaWYgKCQodGFyZ2V0KS5pcyh0YXJnZXRTZWxlY3RvcikpIGxpc3RlbmVyLmFwcGx5KHRhcmdldCwgZXZlbnREYXRhKTtlbHNlIHtcXG4gICAgICB2YXIgX3BhcmVudHMgPSAkKHRhcmdldCkucGFyZW50cygpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXFxuXFxuXFxuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBfcGFyZW50cy5sZW5ndGg7IGsgKz0gMSkge1xcbiAgICAgICAgaWYgKCQoX3BhcmVudHNba10pLmlzKHRhcmdldFNlbGVjdG9yKSkgbGlzdGVuZXIuYXBwbHkoX3BhcmVudHNba10sIGV2ZW50RGF0YSk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuXFxuICBmdW5jdGlvbiBoYW5kbGVFdmVudChlKSB7XFxuICAgIHZhciBldmVudERhdGEgPSBlICYmIGUudGFyZ2V0ID8gZS50YXJnZXQuZG9tN0V2ZW50RGF0YSB8fCBbXSA6IFtdO1xcblxcbiAgICBpZiAoZXZlbnREYXRhLmluZGV4T2YoZSkgPCAwKSB7XFxuICAgICAgZXZlbnREYXRhLnVuc2hpZnQoZSk7XFxuICAgIH1cXG5cXG4gICAgbGlzdGVuZXIuYXBwbHkodGhpcywgZXZlbnREYXRhKTtcXG4gIH1cXG5cXG4gIHZhciBldmVudHMgPSBldmVudFR5cGUuc3BsaXQoJyAnKTtcXG4gIHZhciBqO1xcblxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSArPSAxKSB7XFxuICAgIHZhciBlbCA9IHRoaXNbaV07XFxuXFxuICAgIGlmICghdGFyZ2V0U2VsZWN0b3IpIHtcXG4gICAgICBmb3IgKGogPSAwOyBqIDwgZXZlbnRzLmxlbmd0aDsgaiArPSAxKSB7XFxuICAgICAgICB2YXIgZXZlbnQgPSBldmVudHNbal07XFxuICAgICAgICBpZiAoIWVsLmRvbTdMaXN0ZW5lcnMpIGVsLmRvbTdMaXN0ZW5lcnMgPSB7fTtcXG4gICAgICAgIGlmICghZWwuZG9tN0xpc3RlbmVyc1tldmVudF0pIGVsLmRvbTdMaXN0ZW5lcnNbZXZlbnRdID0gW107XFxuICAgICAgICBlbC5kb203TGlzdGVuZXJzW2V2ZW50XS5wdXNoKHtcXG4gICAgICAgICAgbGlzdGVuZXI6IGxpc3RlbmVyLFxcbiAgICAgICAgICBwcm94eUxpc3RlbmVyOiBoYW5kbGVFdmVudFxcbiAgICAgICAgfSk7XFxuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVFdmVudCwgY2FwdHVyZSk7XFxuICAgICAgfVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIC8vIExpdmUgZXZlbnRzXFxuICAgICAgZm9yIChqID0gMDsgaiA8IGV2ZW50cy5sZW5ndGg7IGogKz0gMSkge1xcbiAgICAgICAgdmFyIF9ldmVudCA9IGV2ZW50c1tqXTtcXG4gICAgICAgIGlmICghZWwuZG9tN0xpdmVMaXN0ZW5lcnMpIGVsLmRvbTdMaXZlTGlzdGVuZXJzID0ge307XFxuICAgICAgICBpZiAoIWVsLmRvbTdMaXZlTGlzdGVuZXJzW19ldmVudF0pIGVsLmRvbTdMaXZlTGlzdGVuZXJzW19ldmVudF0gPSBbXTtcXG5cXG4gICAgICAgIGVsLmRvbTdMaXZlTGlzdGVuZXJzW19ldmVudF0ucHVzaCh7XFxuICAgICAgICAgIGxpc3RlbmVyOiBsaXN0ZW5lcixcXG4gICAgICAgICAgcHJveHlMaXN0ZW5lcjogaGFuZGxlTGl2ZUV2ZW50XFxuICAgICAgICB9KTtcXG5cXG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoX2V2ZW50LCBoYW5kbGVMaXZlRXZlbnQsIGNhcHR1cmUpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcblxcbiAgcmV0dXJuIHRoaXM7XFxufVxcblxcbmZ1bmN0aW9uIG9mZigpIHtcXG4gIGZvciAodmFyIF9sZW42ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNiksIF9rZXk2ID0gMDsgX2tleTYgPCBfbGVuNjsgX2tleTYrKykge1xcbiAgICBhcmdzW19rZXk2XSA9IGFyZ3VtZW50c1tfa2V5Nl07XFxuICB9XFxuXFxuICB2YXIgZXZlbnRUeXBlID0gYXJnc1swXSxcXG4gICAgICB0YXJnZXRTZWxlY3RvciA9IGFyZ3NbMV0sXFxuICAgICAgbGlzdGVuZXIgPSBhcmdzWzJdLFxcbiAgICAgIGNhcHR1cmUgPSBhcmdzWzNdO1xcblxcbiAgaWYgKHR5cGVvZiBhcmdzWzFdID09PSAnZnVuY3Rpb24nKSB7XFxuICAgIGV2ZW50VHlwZSA9IGFyZ3NbMF07XFxuICAgIGxpc3RlbmVyID0gYXJnc1sxXTtcXG4gICAgY2FwdHVyZSA9IGFyZ3NbMl07XFxuICAgIHRhcmdldFNlbGVjdG9yID0gdW5kZWZpbmVkO1xcbiAgfVxcblxcbiAgaWYgKCFjYXB0dXJlKSBjYXB0dXJlID0gZmFsc2U7XFxuICB2YXIgZXZlbnRzID0gZXZlbnRUeXBlLnNwbGl0KCcgJyk7XFxuXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50cy5sZW5ndGg7IGkgKz0gMSkge1xcbiAgICB2YXIgZXZlbnQgPSBldmVudHNbaV07XFxuXFxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5sZW5ndGg7IGogKz0gMSkge1xcbiAgICAgIHZhciBlbCA9IHRoaXNbal07XFxuICAgICAgdmFyIGhhbmRsZXJzID0gdm9pZCAwO1xcblxcbiAgICAgIGlmICghdGFyZ2V0U2VsZWN0b3IgJiYgZWwuZG9tN0xpc3RlbmVycykge1xcbiAgICAgICAgaGFuZGxlcnMgPSBlbC5kb203TGlzdGVuZXJzW2V2ZW50XTtcXG4gICAgICB9IGVsc2UgaWYgKHRhcmdldFNlbGVjdG9yICYmIGVsLmRvbTdMaXZlTGlzdGVuZXJzKSB7XFxuICAgICAgICBoYW5kbGVycyA9IGVsLmRvbTdMaXZlTGlzdGVuZXJzW2V2ZW50XTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGhhbmRsZXJzICYmIGhhbmRsZXJzLmxlbmd0aCkge1xcbiAgICAgICAgZm9yICh2YXIgayA9IGhhbmRsZXJzLmxlbmd0aCAtIDE7IGsgPj0gMDsgayAtPSAxKSB7XFxuICAgICAgICAgIHZhciBoYW5kbGVyID0gaGFuZGxlcnNba107XFxuXFxuICAgICAgICAgIGlmIChsaXN0ZW5lciAmJiBoYW5kbGVyLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xcbiAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIucHJveHlMaXN0ZW5lciwgY2FwdHVyZSk7XFxuICAgICAgICAgICAgaGFuZGxlcnMuc3BsaWNlKGssIDEpO1xcbiAgICAgICAgICB9IGVsc2UgaWYgKGxpc3RlbmVyICYmIGhhbmRsZXIubGlzdGVuZXIgJiYgaGFuZGxlci5saXN0ZW5lci5kb203cHJveHkgJiYgaGFuZGxlci5saXN0ZW5lci5kb203cHJveHkgPT09IGxpc3RlbmVyKSB7XFxuICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlci5wcm94eUxpc3RlbmVyLCBjYXB0dXJlKTtcXG4gICAgICAgICAgICBoYW5kbGVycy5zcGxpY2UoaywgMSk7XFxuICAgICAgICAgIH0gZWxzZSBpZiAoIWxpc3RlbmVyKSB7XFxuICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlci5wcm94eUxpc3RlbmVyLCBjYXB0dXJlKTtcXG4gICAgICAgICAgICBoYW5kbGVycy5zcGxpY2UoaywgMSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiB0aGlzO1xcbn1cXG5cXG5mdW5jdGlvbiBvbmNlKCkge1xcbiAgdmFyIGRvbSA9IHRoaXM7XFxuXFxuICBmb3IgKHZhciBfbGVuNyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjcpLCBfa2V5NyA9IDA7IF9rZXk3IDwgX2xlbjc7IF9rZXk3KyspIHtcXG4gICAgYXJnc1tfa2V5N10gPSBhcmd1bWVudHNbX2tleTddO1xcbiAgfVxcblxcbiAgdmFyIGV2ZW50TmFtZSA9IGFyZ3NbMF0sXFxuICAgICAgdGFyZ2V0U2VsZWN0b3IgPSBhcmdzWzFdLFxcbiAgICAgIGxpc3RlbmVyID0gYXJnc1syXSxcXG4gICAgICBjYXB0dXJlID0gYXJnc1szXTtcXG5cXG4gIGlmICh0eXBlb2YgYXJnc1sxXSA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICBldmVudE5hbWUgPSBhcmdzWzBdO1xcbiAgICBsaXN0ZW5lciA9IGFyZ3NbMV07XFxuICAgIGNhcHR1cmUgPSBhcmdzWzJdO1xcbiAgICB0YXJnZXRTZWxlY3RvciA9IHVuZGVmaW5lZDtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIG9uY2VIYW5kbGVyKCkge1xcbiAgICBmb3IgKHZhciBfbGVuOCA9IGFyZ3VtZW50cy5sZW5ndGgsIGV2ZW50QXJncyA9IG5ldyBBcnJheShfbGVuOCksIF9rZXk4ID0gMDsgX2tleTggPCBfbGVuODsgX2tleTgrKykge1xcbiAgICAgIGV2ZW50QXJnc1tfa2V5OF0gPSBhcmd1bWVudHNbX2tleThdO1xcbiAgICB9XFxuXFxuICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGV2ZW50QXJncyk7XFxuICAgIGRvbS5vZmYoZXZlbnROYW1lLCB0YXJnZXRTZWxlY3Rvciwgb25jZUhhbmRsZXIsIGNhcHR1cmUpO1xcblxcbiAgICBpZiAob25jZUhhbmRsZXIuZG9tN3Byb3h5KSB7XFxuICAgICAgZGVsZXRlIG9uY2VIYW5kbGVyLmRvbTdwcm94eTtcXG4gICAgfVxcbiAgfVxcblxcbiAgb25jZUhhbmRsZXIuZG9tN3Byb3h5ID0gbGlzdGVuZXI7XFxuICByZXR1cm4gZG9tLm9uKGV2ZW50TmFtZSwgdGFyZ2V0U2VsZWN0b3IsIG9uY2VIYW5kbGVyLCBjYXB0dXJlKTtcXG59XFxuXFxuZnVuY3Rpb24gdHJpZ2dlcigpIHtcXG4gIHZhciB3aW5kb3cgPSAoMCxzc3Jfd2luZG93X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uZ2V0V2luZG93KSgpO1xcblxcbiAgZm9yICh2YXIgX2xlbjkgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW45KSwgX2tleTkgPSAwOyBfa2V5OSA8IF9sZW45OyBfa2V5OSsrKSB7XFxuICAgIGFyZ3NbX2tleTldID0gYXJndW1lbnRzW19rZXk5XTtcXG4gIH1cXG5cXG4gIHZhciBldmVudHMgPSBhcmdzWzBdLnNwbGl0KCcgJyk7XFxuICB2YXIgZXZlbnREYXRhID0gYXJnc1sxXTtcXG5cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgaSArPSAxKSB7XFxuICAgIHZhciBldmVudCA9IGV2ZW50c1tpXTtcXG5cXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLmxlbmd0aDsgaiArPSAxKSB7XFxuICAgICAgdmFyIGVsID0gdGhpc1tqXTtcXG5cXG4gICAgICBpZiAod2luZG93LkN1c3RvbUV2ZW50KSB7XFxuICAgICAgICB2YXIgZXZ0ID0gbmV3IHdpbmRvdy5DdXN0b21FdmVudChldmVudCwge1xcbiAgICAgICAgICBkZXRhaWw6IGV2ZW50RGF0YSxcXG4gICAgICAgICAgYnViYmxlczogdHJ1ZSxcXG4gICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxcbiAgICAgICAgfSk7XFxuICAgICAgICBlbC5kb203RXZlbnREYXRhID0gYXJncy5maWx0ZXIoZnVuY3Rpb24gKGRhdGEsIGRhdGFJbmRleCkge1xcbiAgICAgICAgICByZXR1cm4gZGF0YUluZGV4ID4gMDtcXG4gICAgICAgIH0pO1xcbiAgICAgICAgZWwuZGlzcGF0Y2hFdmVudChldnQpO1xcbiAgICAgICAgZWwuZG9tN0V2ZW50RGF0YSA9IFtdO1xcbiAgICAgICAgZGVsZXRlIGVsLmRvbTdFdmVudERhdGE7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuXFxuICByZXR1cm4gdGhpcztcXG59XFxuXFxuZnVuY3Rpb24gdHJhbnNpdGlvbkVuZChjYWxsYmFjaykge1xcbiAgdmFyIGRvbSA9IHRoaXM7XFxuXFxuICBmdW5jdGlvbiBmaXJlQ2FsbEJhY2soZSkge1xcbiAgICBpZiAoZS50YXJnZXQgIT09IHRoaXMpIHJldHVybjtcXG4gICAgY2FsbGJhY2suY2FsbCh0aGlzLCBlKTtcXG4gICAgZG9tLm9mZigndHJhbnNpdGlvbmVuZCcsIGZpcmVDYWxsQmFjayk7XFxuICB9XFxuXFxuICBpZiAoY2FsbGJhY2spIHtcXG4gICAgZG9tLm9uKCd0cmFuc2l0aW9uZW5kJywgZmlyZUNhbGxCYWNrKTtcXG4gIH1cXG5cXG4gIHJldHVybiB0aGlzO1xcbn1cXG5cXG5mdW5jdGlvbiBhbmltYXRpb25FbmQoY2FsbGJhY2spIHtcXG4gIHZhciBkb20gPSB0aGlzO1xcblxcbiAgZnVuY3Rpb24gZmlyZUNhbGxCYWNrKGUpIHtcXG4gICAgaWYgKGUudGFyZ2V0ICE9PSB0aGlzKSByZXR1cm47XFxuICAgIGNhbGxiYWNrLmNhbGwodGhpcywgZSk7XFxuICAgIGRvbS5vZmYoJ2FuaW1hdGlvbmVuZCcsIGZpcmVDYWxsQmFjayk7XFxuICB9XFxuXFxuICBpZiAoY2FsbGJhY2spIHtcXG4gICAgZG9tLm9uKCdhbmltYXRpb25lbmQnLCBmaXJlQ2FsbEJhY2spO1xcbiAgfVxcblxcbiAgcmV0dXJuIHRoaXM7XFxufVxcblxcbmZ1bmN0aW9uIHdpZHRoKCkge1xcbiAgdmFyIHdpbmRvdyA9ICgwLHNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5nZXRXaW5kb3cpKCk7XFxuXFxuICBpZiAodGhpc1swXSA9PT0gd2luZG93KSB7XFxuICAgIHJldHVybiB3aW5kb3cuaW5uZXJXaWR0aDtcXG4gIH1cXG5cXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcXG4gICAgcmV0dXJuIHBhcnNlRmxvYXQodGhpcy5jc3MoJ3dpZHRoJykpO1xcbiAgfVxcblxcbiAgcmV0dXJuIG51bGw7XFxufVxcblxcbmZ1bmN0aW9uIG91dGVyV2lkdGgoaW5jbHVkZU1hcmdpbnMpIHtcXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcXG4gICAgaWYgKGluY2x1ZGVNYXJnaW5zKSB7XFxuICAgICAgdmFyIF9zdHlsZXMgPSB0aGlzLnN0eWxlcygpO1xcblxcbiAgICAgIHJldHVybiB0aGlzWzBdLm9mZnNldFdpZHRoICsgcGFyc2VGbG9hdChfc3R5bGVzLmdldFByb3BlcnR5VmFsdWUoJ21hcmdpbi1yaWdodCcpKSArIHBhcnNlRmxvYXQoX3N0eWxlcy5nZXRQcm9wZXJ0eVZhbHVlKCdtYXJnaW4tbGVmdCcpKTtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gdGhpc1swXS5vZmZzZXRXaWR0aDtcXG4gIH1cXG5cXG4gIHJldHVybiBudWxsO1xcbn1cXG5cXG5mdW5jdGlvbiBoZWlnaHQoKSB7XFxuICB2YXIgd2luZG93ID0gKDAsc3NyX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmdldFdpbmRvdykoKTtcXG5cXG4gIGlmICh0aGlzWzBdID09PSB3aW5kb3cpIHtcXG4gICAgcmV0dXJuIHdpbmRvdy5pbm5lckhlaWdodDtcXG4gIH1cXG5cXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcXG4gICAgcmV0dXJuIHBhcnNlRmxvYXQodGhpcy5jc3MoJ2hlaWdodCcpKTtcXG4gIH1cXG5cXG4gIHJldHVybiBudWxsO1xcbn1cXG5cXG5mdW5jdGlvbiBvdXRlckhlaWdodChpbmNsdWRlTWFyZ2lucykge1xcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xcbiAgICBpZiAoaW5jbHVkZU1hcmdpbnMpIHtcXG4gICAgICB2YXIgX3N0eWxlczIgPSB0aGlzLnN0eWxlcygpO1xcblxcbiAgICAgIHJldHVybiB0aGlzWzBdLm9mZnNldEhlaWdodCArIHBhcnNlRmxvYXQoX3N0eWxlczIuZ2V0UHJvcGVydHlWYWx1ZSgnbWFyZ2luLXRvcCcpKSArIHBhcnNlRmxvYXQoX3N0eWxlczIuZ2V0UHJvcGVydHlWYWx1ZSgnbWFyZ2luLWJvdHRvbScpKTtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gdGhpc1swXS5vZmZzZXRIZWlnaHQ7XFxuICB9XFxuXFxuICByZXR1cm4gbnVsbDtcXG59XFxuXFxuZnVuY3Rpb24gb2Zmc2V0KCkge1xcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xcbiAgICB2YXIgd2luZG93ID0gKDAsc3NyX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmdldFdpbmRvdykoKTtcXG4gICAgdmFyIGRvY3VtZW50ID0gKDAsc3NyX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmdldERvY3VtZW50KSgpO1xcbiAgICB2YXIgZWwgPSB0aGlzWzBdO1xcbiAgICB2YXIgYm94ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XFxuICAgIHZhciBib2R5ID0gZG9jdW1lbnQuYm9keTtcXG4gICAgdmFyIGNsaWVudFRvcCA9IGVsLmNsaWVudFRvcCB8fCBib2R5LmNsaWVudFRvcCB8fCAwO1xcbiAgICB2YXIgY2xpZW50TGVmdCA9IGVsLmNsaWVudExlZnQgfHwgYm9keS5jbGllbnRMZWZ0IHx8IDA7XFxuICAgIHZhciBzY3JvbGxUb3AgPSBlbCA9PT0gd2luZG93ID8gd2luZG93LnNjcm9sbFkgOiBlbC5zY3JvbGxUb3A7XFxuICAgIHZhciBzY3JvbGxMZWZ0ID0gZWwgPT09IHdpbmRvdyA/IHdpbmRvdy5zY3JvbGxYIDogZWwuc2Nyb2xsTGVmdDtcXG4gICAgcmV0dXJuIHtcXG4gICAgICB0b3A6IGJveC50b3AgKyBzY3JvbGxUb3AgLSBjbGllbnRUb3AsXFxuICAgICAgbGVmdDogYm94LmxlZnQgKyBzY3JvbGxMZWZ0IC0gY2xpZW50TGVmdFxcbiAgICB9O1xcbiAgfVxcblxcbiAgcmV0dXJuIG51bGw7XFxufVxcblxcbmZ1bmN0aW9uIGhpZGUoKSB7XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpICs9IDEpIHtcXG4gICAgdGhpc1tpXS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xcbiAgfVxcblxcbiAgcmV0dXJuIHRoaXM7XFxufVxcblxcbmZ1bmN0aW9uIHNob3coKSB7XFxuICB2YXIgd2luZG93ID0gKDAsc3NyX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmdldFdpbmRvdykoKTtcXG5cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkgKz0gMSkge1xcbiAgICB2YXIgZWwgPSB0aGlzW2ldO1xcblxcbiAgICBpZiAoZWwuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnKSB7XFxuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9ICcnO1xcbiAgICB9XFxuXFxuICAgIGlmICh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCwgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZSgnZGlzcGxheScpID09PSAnbm9uZScpIHtcXG4gICAgICAvLyBTdGlsbCBub3QgdmlzaWJsZVxcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xcbiAgICB9XFxuICB9XFxuXFxuICByZXR1cm4gdGhpcztcXG59XFxuXFxuZnVuY3Rpb24gc3R5bGVzKCkge1xcbiAgdmFyIHdpbmRvdyA9ICgwLHNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5nZXRXaW5kb3cpKCk7XFxuICBpZiAodGhpc1swXSkgcmV0dXJuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXNbMF0sIG51bGwpO1xcbiAgcmV0dXJuIHt9O1xcbn1cXG5cXG5mdW5jdGlvbiBjc3MocHJvcHMsIHZhbHVlKSB7XFxuICB2YXIgd2luZG93ID0gKDAsc3NyX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmdldFdpbmRvdykoKTtcXG4gIHZhciBpO1xcblxcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcXG4gICAgaWYgKHR5cGVvZiBwcm9wcyA9PT0gJ3N0cmluZycpIHtcXG4gICAgICAvLyAuY3NzKCd3aWR0aCcpXFxuICAgICAgaWYgKHRoaXNbMF0pIHJldHVybiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzWzBdLCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BzKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAvLyAuY3NzKHsgd2lkdGg6ICcxMDBweCcgfSlcXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkgKz0gMSkge1xcbiAgICAgICAgZm9yICh2YXIgX3Byb3AgaW4gcHJvcHMpIHtcXG4gICAgICAgICAgdGhpc1tpXS5zdHlsZVtfcHJvcF0gPSBwcm9wc1tfcHJvcF07XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiB0aGlzO1xcbiAgICB9XFxuICB9XFxuXFxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiB0eXBlb2YgcHJvcHMgPT09ICdzdHJpbmcnKSB7XFxuICAgIC8vIC5jc3MoJ3dpZHRoJywgJzEwMHB4JylcXG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpICs9IDEpIHtcXG4gICAgICB0aGlzW2ldLnN0eWxlW3Byb3BzXSA9IHZhbHVlO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiB0aGlzO1xcbiAgfVxcblxcbiAgcmV0dXJuIHRoaXM7XFxufVxcblxcbmZ1bmN0aW9uIGVhY2goY2FsbGJhY2spIHtcXG4gIGlmICghY2FsbGJhY2spIHJldHVybiB0aGlzO1xcbiAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uIChlbCwgaW5kZXgpIHtcXG4gICAgY2FsbGJhY2suYXBwbHkoZWwsIFtlbCwgaW5kZXhdKTtcXG4gIH0pO1xcbiAgcmV0dXJuIHRoaXM7XFxufVxcblxcbmZ1bmN0aW9uIGZpbHRlcihjYWxsYmFjaykge1xcbiAgdmFyIHJlc3VsdCA9IGFycmF5RmlsdGVyKHRoaXMsIGNhbGxiYWNrKTtcXG4gIHJldHVybiAkKHJlc3VsdCk7XFxufVxcblxcbmZ1bmN0aW9uIGh0bWwoaHRtbCkge1xcbiAgaWYgKHR5cGVvZiBodG1sID09PSAndW5kZWZpbmVkJykge1xcbiAgICByZXR1cm4gdGhpc1swXSA/IHRoaXNbMF0uaW5uZXJIVE1MIDogbnVsbDtcXG4gIH1cXG5cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkgKz0gMSkge1xcbiAgICB0aGlzW2ldLmlubmVySFRNTCA9IGh0bWw7XFxuICB9XFxuXFxuICByZXR1cm4gdGhpcztcXG59XFxuXFxuZnVuY3Rpb24gdGV4dCh0ZXh0KSB7XFxuICBpZiAodHlwZW9mIHRleHQgPT09ICd1bmRlZmluZWQnKSB7XFxuICAgIHJldHVybiB0aGlzWzBdID8gdGhpc1swXS50ZXh0Q29udGVudC50cmltKCkgOiBudWxsO1xcbiAgfVxcblxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSArPSAxKSB7XFxuICAgIHRoaXNbaV0udGV4dENvbnRlbnQgPSB0ZXh0O1xcbiAgfVxcblxcbiAgcmV0dXJuIHRoaXM7XFxufVxcblxcbmZ1bmN0aW9uIGlzKHNlbGVjdG9yKSB7XFxuICB2YXIgd2luZG93ID0gKDAsc3NyX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmdldFdpbmRvdykoKTtcXG4gIHZhciBkb2N1bWVudCA9ICgwLHNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5nZXREb2N1bWVudCkoKTtcXG4gIHZhciBlbCA9IHRoaXNbMF07XFxuICB2YXIgY29tcGFyZVdpdGg7XFxuICB2YXIgaTtcXG4gIGlmICghZWwgfHwgdHlwZW9mIHNlbGVjdG9yID09PSAndW5kZWZpbmVkJykgcmV0dXJuIGZhbHNlO1xcblxcbiAgaWYgKHR5cGVvZiBzZWxlY3RvciA9PT0gJ3N0cmluZycpIHtcXG4gICAgaWYgKGVsLm1hdGNoZXMpIHJldHVybiBlbC5tYXRjaGVzKHNlbGVjdG9yKTtcXG4gICAgaWYgKGVsLndlYmtpdE1hdGNoZXNTZWxlY3RvcikgcmV0dXJuIGVsLndlYmtpdE1hdGNoZXNTZWxlY3RvcihzZWxlY3Rvcik7XFxuICAgIGlmIChlbC5tc01hdGNoZXNTZWxlY3RvcikgcmV0dXJuIGVsLm1zTWF0Y2hlc1NlbGVjdG9yKHNlbGVjdG9yKTtcXG4gICAgY29tcGFyZVdpdGggPSAkKHNlbGVjdG9yKTtcXG5cXG4gICAgZm9yIChpID0gMDsgaSA8IGNvbXBhcmVXaXRoLmxlbmd0aDsgaSArPSAxKSB7XFxuICAgICAgaWYgKGNvbXBhcmVXaXRoW2ldID09PSBlbCkgcmV0dXJuIHRydWU7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIGZhbHNlO1xcbiAgfVxcblxcbiAgaWYgKHNlbGVjdG9yID09PSBkb2N1bWVudCkge1xcbiAgICByZXR1cm4gZWwgPT09IGRvY3VtZW50O1xcbiAgfVxcblxcbiAgaWYgKHNlbGVjdG9yID09PSB3aW5kb3cpIHtcXG4gICAgcmV0dXJuIGVsID09PSB3aW5kb3c7XFxuICB9XFxuXFxuICBpZiAoc2VsZWN0b3Iubm9kZVR5cGUgfHwgc2VsZWN0b3IgaW5zdGFuY2VvZiBEb203KSB7XFxuICAgIGNvbXBhcmVXaXRoID0gc2VsZWN0b3Iubm9kZVR5cGUgPyBbc2VsZWN0b3JdIDogc2VsZWN0b3I7XFxuXFxuICAgIGZvciAoaSA9IDA7IGkgPCBjb21wYXJlV2l0aC5sZW5ndGg7IGkgKz0gMSkge1xcbiAgICAgIGlmIChjb21wYXJlV2l0aFtpXSA9PT0gZWwpIHJldHVybiB0cnVlO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBmYWxzZTtcXG4gIH1cXG5cXG4gIHJldHVybiBmYWxzZTtcXG59XFxuXFxuZnVuY3Rpb24gaW5kZXgoKSB7XFxuICB2YXIgY2hpbGQgPSB0aGlzWzBdO1xcbiAgdmFyIGk7XFxuXFxuICBpZiAoY2hpbGQpIHtcXG4gICAgaSA9IDA7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxcblxcbiAgICB3aGlsZSAoKGNoaWxkID0gY2hpbGQucHJldmlvdXNTaWJsaW5nKSAhPT0gbnVsbCkge1xcbiAgICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PT0gMSkgaSArPSAxO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBpO1xcbiAgfVxcblxcbiAgcmV0dXJuIHVuZGVmaW5lZDtcXG59XFxuXFxuZnVuY3Rpb24gZXEoaW5kZXgpIHtcXG4gIGlmICh0eXBlb2YgaW5kZXggPT09ICd1bmRlZmluZWQnKSByZXR1cm4gdGhpcztcXG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aDtcXG5cXG4gIGlmIChpbmRleCA+IGxlbmd0aCAtIDEpIHtcXG4gICAgcmV0dXJuICQoW10pO1xcbiAgfVxcblxcbiAgaWYgKGluZGV4IDwgMCkge1xcbiAgICB2YXIgcmV0dXJuSW5kZXggPSBsZW5ndGggKyBpbmRleDtcXG4gICAgaWYgKHJldHVybkluZGV4IDwgMCkgcmV0dXJuICQoW10pO1xcbiAgICByZXR1cm4gJChbdGhpc1tyZXR1cm5JbmRleF1dKTtcXG4gIH1cXG5cXG4gIHJldHVybiAkKFt0aGlzW2luZGV4XV0pO1xcbn1cXG5cXG5mdW5jdGlvbiBhcHBlbmQoKSB7XFxuICB2YXIgbmV3Q2hpbGQ7XFxuICB2YXIgZG9jdW1lbnQgPSAoMCxzc3Jfd2luZG93X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uZ2V0RG9jdW1lbnQpKCk7XFxuXFxuICBmb3IgKHZhciBrID0gMDsgayA8IGFyZ3VtZW50cy5sZW5ndGg7IGsgKz0gMSkge1xcbiAgICBuZXdDaGlsZCA9IGsgPCAwIHx8IGFyZ3VtZW50cy5sZW5ndGggPD0gayA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1trXTtcXG5cXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSArPSAxKSB7XFxuICAgICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3N0cmluZycpIHtcXG4gICAgICAgIHZhciB0ZW1wRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XFxuICAgICAgICB0ZW1wRGl2LmlubmVySFRNTCA9IG5ld0NoaWxkO1xcblxcbiAgICAgICAgd2hpbGUgKHRlbXBEaXYuZmlyc3RDaGlsZCkge1xcbiAgICAgICAgICB0aGlzW2ldLmFwcGVuZENoaWxkKHRlbXBEaXYuZmlyc3RDaGlsZCk7XFxuICAgICAgICB9XFxuICAgICAgfSBlbHNlIGlmIChuZXdDaGlsZCBpbnN0YW5jZW9mIERvbTcpIHtcXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbmV3Q2hpbGQubGVuZ3RoOyBqICs9IDEpIHtcXG4gICAgICAgICAgdGhpc1tpXS5hcHBlbmRDaGlsZChuZXdDaGlsZFtqXSk7XFxuICAgICAgICB9XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRoaXNbaV0uYXBwZW5kQ2hpbGQobmV3Q2hpbGQpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcblxcbiAgcmV0dXJuIHRoaXM7XFxufVxcblxcbmZ1bmN0aW9uIGFwcGVuZFRvKHBhcmVudCkge1xcbiAgJChwYXJlbnQpLmFwcGVuZCh0aGlzKTtcXG4gIHJldHVybiB0aGlzO1xcbn1cXG5cXG5mdW5jdGlvbiBwcmVwZW5kKG5ld0NoaWxkKSB7XFxuICB2YXIgZG9jdW1lbnQgPSAoMCxzc3Jfd2luZG93X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uZ2V0RG9jdW1lbnQpKCk7XFxuICB2YXIgaTtcXG4gIHZhciBqO1xcblxcbiAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpICs9IDEpIHtcXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3N0cmluZycpIHtcXG4gICAgICB2YXIgdGVtcERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xcbiAgICAgIHRlbXBEaXYuaW5uZXJIVE1MID0gbmV3Q2hpbGQ7XFxuXFxuICAgICAgZm9yIChqID0gdGVtcERpdi5jaGlsZE5vZGVzLmxlbmd0aCAtIDE7IGogPj0gMDsgaiAtPSAxKSB7XFxuICAgICAgICB0aGlzW2ldLmluc2VydEJlZm9yZSh0ZW1wRGl2LmNoaWxkTm9kZXNbal0sIHRoaXNbaV0uY2hpbGROb2Rlc1swXSk7XFxuICAgICAgfVxcbiAgICB9IGVsc2UgaWYgKG5ld0NoaWxkIGluc3RhbmNlb2YgRG9tNykge1xcbiAgICAgIGZvciAoaiA9IDA7IGogPCBuZXdDaGlsZC5sZW5ndGg7IGogKz0gMSkge1xcbiAgICAgICAgdGhpc1tpXS5pbnNlcnRCZWZvcmUobmV3Q2hpbGRbal0sIHRoaXNbaV0uY2hpbGROb2Rlc1swXSk7XFxuICAgICAgfVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIHRoaXNbaV0uaW5zZXJ0QmVmb3JlKG5ld0NoaWxkLCB0aGlzW2ldLmNoaWxkTm9kZXNbMF0pO1xcbiAgICB9XFxuICB9XFxuXFxuICByZXR1cm4gdGhpcztcXG59XFxuXFxuZnVuY3Rpb24gcHJlcGVuZFRvKHBhcmVudCkge1xcbiAgJChwYXJlbnQpLnByZXBlbmQodGhpcyk7XFxuICByZXR1cm4gdGhpcztcXG59XFxuXFxuZnVuY3Rpb24gaW5zZXJ0QmVmb3JlKHNlbGVjdG9yKSB7XFxuICB2YXIgYmVmb3JlID0gJChzZWxlY3Rvcik7XFxuXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpICs9IDEpIHtcXG4gICAgaWYgKGJlZm9yZS5sZW5ndGggPT09IDEpIHtcXG4gICAgICBiZWZvcmVbMF0ucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpc1tpXSwgYmVmb3JlWzBdKTtcXG4gICAgfSBlbHNlIGlmIChiZWZvcmUubGVuZ3RoID4gMSkge1xcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYmVmb3JlLmxlbmd0aDsgaiArPSAxKSB7XFxuICAgICAgICBiZWZvcmVbal0ucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpc1tpXS5jbG9uZU5vZGUodHJ1ZSksIGJlZm9yZVtqXSk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGluc2VydEFmdGVyKHNlbGVjdG9yKSB7XFxuICB2YXIgYWZ0ZXIgPSAkKHNlbGVjdG9yKTtcXG5cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkgKz0gMSkge1xcbiAgICBpZiAoYWZ0ZXIubGVuZ3RoID09PSAxKSB7XFxuICAgICAgYWZ0ZXJbMF0ucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpc1tpXSwgYWZ0ZXJbMF0ubmV4dFNpYmxpbmcpO1xcbiAgICB9IGVsc2UgaWYgKGFmdGVyLmxlbmd0aCA+IDEpIHtcXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGFmdGVyLmxlbmd0aDsgaiArPSAxKSB7XFxuICAgICAgICBhZnRlcltqXS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzW2ldLmNsb25lTm9kZSh0cnVlKSwgYWZ0ZXJbal0ubmV4dFNpYmxpbmcpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBuZXh0KHNlbGVjdG9yKSB7XFxuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XFxuICAgIGlmIChzZWxlY3Rvcikge1xcbiAgICAgIGlmICh0aGlzWzBdLm5leHRFbGVtZW50U2libGluZyAmJiAkKHRoaXNbMF0ubmV4dEVsZW1lbnRTaWJsaW5nKS5pcyhzZWxlY3RvcikpIHtcXG4gICAgICAgIHJldHVybiAkKFt0aGlzWzBdLm5leHRFbGVtZW50U2libGluZ10pO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gJChbXSk7XFxuICAgIH1cXG5cXG4gICAgaWYgKHRoaXNbMF0ubmV4dEVsZW1lbnRTaWJsaW5nKSByZXR1cm4gJChbdGhpc1swXS5uZXh0RWxlbWVudFNpYmxpbmddKTtcXG4gICAgcmV0dXJuICQoW10pO1xcbiAgfVxcblxcbiAgcmV0dXJuICQoW10pO1xcbn1cXG5cXG5mdW5jdGlvbiBuZXh0QWxsKHNlbGVjdG9yKSB7XFxuICB2YXIgbmV4dEVscyA9IFtdO1xcbiAgdmFyIGVsID0gdGhpc1swXTtcXG4gIGlmICghZWwpIHJldHVybiAkKFtdKTtcXG5cXG4gIHdoaWxlIChlbC5uZXh0RWxlbWVudFNpYmxpbmcpIHtcXG4gICAgdmFyIF9uZXh0ID0gZWwubmV4dEVsZW1lbnRTaWJsaW5nOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXFxuXFxuICAgIGlmIChzZWxlY3Rvcikge1xcbiAgICAgIGlmICgkKF9uZXh0KS5pcyhzZWxlY3RvcikpIG5leHRFbHMucHVzaChfbmV4dCk7XFxuICAgIH0gZWxzZSBuZXh0RWxzLnB1c2goX25leHQpO1xcblxcbiAgICBlbCA9IF9uZXh0O1xcbiAgfVxcblxcbiAgcmV0dXJuICQobmV4dEVscyk7XFxufVxcblxcbmZ1bmN0aW9uIHByZXYoc2VsZWN0b3IpIHtcXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcXG4gICAgdmFyIGVsID0gdGhpc1swXTtcXG5cXG4gICAgaWYgKHNlbGVjdG9yKSB7XFxuICAgICAgaWYgKGVsLnByZXZpb3VzRWxlbWVudFNpYmxpbmcgJiYgJChlbC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nKS5pcyhzZWxlY3RvcikpIHtcXG4gICAgICAgIHJldHVybiAkKFtlbC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nXSk7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiAkKFtdKTtcXG4gICAgfVxcblxcbiAgICBpZiAoZWwucHJldmlvdXNFbGVtZW50U2libGluZykgcmV0dXJuICQoW2VsLnByZXZpb3VzRWxlbWVudFNpYmxpbmddKTtcXG4gICAgcmV0dXJuICQoW10pO1xcbiAgfVxcblxcbiAgcmV0dXJuICQoW10pO1xcbn1cXG5cXG5mdW5jdGlvbiBwcmV2QWxsKHNlbGVjdG9yKSB7XFxuICB2YXIgcHJldkVscyA9IFtdO1xcbiAgdmFyIGVsID0gdGhpc1swXTtcXG4gIGlmICghZWwpIHJldHVybiAkKFtdKTtcXG5cXG4gIHdoaWxlIChlbC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nKSB7XFxuICAgIHZhciBfcHJldiA9IGVsLnByZXZpb3VzRWxlbWVudFNpYmxpbmc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcXG5cXG4gICAgaWYgKHNlbGVjdG9yKSB7XFxuICAgICAgaWYgKCQoX3ByZXYpLmlzKHNlbGVjdG9yKSkgcHJldkVscy5wdXNoKF9wcmV2KTtcXG4gICAgfSBlbHNlIHByZXZFbHMucHVzaChfcHJldik7XFxuXFxuICAgIGVsID0gX3ByZXY7XFxuICB9XFxuXFxuICByZXR1cm4gJChwcmV2RWxzKTtcXG59XFxuXFxuZnVuY3Rpb24gc2libGluZ3Moc2VsZWN0b3IpIHtcXG4gIHJldHVybiB0aGlzLm5leHRBbGwoc2VsZWN0b3IpLmFkZCh0aGlzLnByZXZBbGwoc2VsZWN0b3IpKTtcXG59XFxuXFxuZnVuY3Rpb24gcGFyZW50KHNlbGVjdG9yKSB7XFxuICB2YXIgcGFyZW50cyA9IFtdOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXFxuXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpICs9IDEpIHtcXG4gICAgaWYgKHRoaXNbaV0ucGFyZW50Tm9kZSAhPT0gbnVsbCkge1xcbiAgICAgIGlmIChzZWxlY3Rvcikge1xcbiAgICAgICAgaWYgKCQodGhpc1tpXS5wYXJlbnROb2RlKS5pcyhzZWxlY3RvcikpIHBhcmVudHMucHVzaCh0aGlzW2ldLnBhcmVudE5vZGUpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBwYXJlbnRzLnB1c2godGhpc1tpXS5wYXJlbnROb2RlKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiAkKHBhcmVudHMpO1xcbn1cXG5cXG5mdW5jdGlvbiBwYXJlbnRzKHNlbGVjdG9yKSB7XFxuICB2YXIgcGFyZW50cyA9IFtdOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXFxuXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpICs9IDEpIHtcXG4gICAgdmFyIF9wYXJlbnQgPSB0aGlzW2ldLnBhcmVudE5vZGU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcXG5cXG4gICAgd2hpbGUgKF9wYXJlbnQpIHtcXG4gICAgICBpZiAoc2VsZWN0b3IpIHtcXG4gICAgICAgIGlmICgkKF9wYXJlbnQpLmlzKHNlbGVjdG9yKSkgcGFyZW50cy5wdXNoKF9wYXJlbnQpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBwYXJlbnRzLnB1c2goX3BhcmVudCk7XFxuICAgICAgfVxcblxcbiAgICAgIF9wYXJlbnQgPSBfcGFyZW50LnBhcmVudE5vZGU7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiAkKHBhcmVudHMpO1xcbn1cXG5cXG5mdW5jdGlvbiBjbG9zZXN0KHNlbGVjdG9yKSB7XFxuICB2YXIgY2xvc2VzdCA9IHRoaXM7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcXG5cXG4gIGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09ICd1bmRlZmluZWQnKSB7XFxuICAgIHJldHVybiAkKFtdKTtcXG4gIH1cXG5cXG4gIGlmICghY2xvc2VzdC5pcyhzZWxlY3RvcikpIHtcXG4gICAgY2xvc2VzdCA9IGNsb3Nlc3QucGFyZW50cyhzZWxlY3RvcikuZXEoMCk7XFxuICB9XFxuXFxuICByZXR1cm4gY2xvc2VzdDtcXG59XFxuXFxuZnVuY3Rpb24gZmluZChzZWxlY3Rvcikge1xcbiAgdmFyIGZvdW5kRWxlbWVudHMgPSBbXTtcXG5cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkgKz0gMSkge1xcbiAgICB2YXIgZm91bmQgPSB0aGlzW2ldLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xcblxcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGZvdW5kLmxlbmd0aDsgaiArPSAxKSB7XFxuICAgICAgZm91bmRFbGVtZW50cy5wdXNoKGZvdW5kW2pdKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgcmV0dXJuICQoZm91bmRFbGVtZW50cyk7XFxufVxcblxcbmZ1bmN0aW9uIGNoaWxkcmVuKHNlbGVjdG9yKSB7XFxuICB2YXIgY2hpbGRyZW4gPSBbXTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxcblxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSArPSAxKSB7XFxuICAgIHZhciBjaGlsZE5vZGVzID0gdGhpc1tpXS5jaGlsZHJlbjtcXG5cXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBjaGlsZE5vZGVzLmxlbmd0aDsgaiArPSAxKSB7XFxuICAgICAgaWYgKCFzZWxlY3RvciB8fCAkKGNoaWxkTm9kZXNbal0pLmlzKHNlbGVjdG9yKSkge1xcbiAgICAgICAgY2hpbGRyZW4ucHVzaChjaGlsZE5vZGVzW2pdKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiAkKGNoaWxkcmVuKTtcXG59XFxuXFxuZnVuY3Rpb24gcmVtb3ZlKCkge1xcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSArPSAxKSB7XFxuICAgIGlmICh0aGlzW2ldLnBhcmVudE5vZGUpIHRoaXNbaV0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzW2ldKTtcXG4gIH1cXG5cXG4gIHJldHVybiB0aGlzO1xcbn1cXG5cXG5mdW5jdGlvbiBkZXRhY2goKSB7XFxuICByZXR1cm4gdGhpcy5yZW1vdmUoKTtcXG59XFxuXFxuZnVuY3Rpb24gYWRkKCkge1xcbiAgdmFyIGRvbSA9IHRoaXM7XFxuICB2YXIgaTtcXG4gIHZhciBqO1xcblxcbiAgZm9yICh2YXIgX2xlbjEwID0gYXJndW1lbnRzLmxlbmd0aCwgZWxzID0gbmV3IEFycmF5KF9sZW4xMCksIF9rZXkxMCA9IDA7IF9rZXkxMCA8IF9sZW4xMDsgX2tleTEwKyspIHtcXG4gICAgZWxzW19rZXkxMF0gPSBhcmd1bWVudHNbX2tleTEwXTtcXG4gIH1cXG5cXG4gIGZvciAoaSA9IDA7IGkgPCBlbHMubGVuZ3RoOyBpICs9IDEpIHtcXG4gICAgdmFyIHRvQWRkID0gJChlbHNbaV0pO1xcblxcbiAgICBmb3IgKGogPSAwOyBqIDwgdG9BZGQubGVuZ3RoOyBqICs9IDEpIHtcXG4gICAgICBkb20ucHVzaCh0b0FkZFtqXSk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiBkb207XFxufVxcblxcbmZ1bmN0aW9uIGVtcHR5KCkge1xcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSArPSAxKSB7XFxuICAgIHZhciBlbCA9IHRoaXNbaV07XFxuXFxuICAgIGlmIChlbC5ub2RlVHlwZSA9PT0gMSkge1xcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZWwuY2hpbGROb2Rlcy5sZW5ndGg7IGogKz0gMSkge1xcbiAgICAgICAgaWYgKGVsLmNoaWxkTm9kZXNbal0ucGFyZW50Tm9kZSkge1xcbiAgICAgICAgICBlbC5jaGlsZE5vZGVzW2pdLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwuY2hpbGROb2Rlc1tqXSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGVsLnRleHRDb250ZW50ID0gJyc7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiB0aGlzO1xcbn1cXG5cXG5mdW5jdGlvbiBzY3JvbGxUbygpIHtcXG4gIHZhciB3aW5kb3cgPSAoMCxzc3Jfd2luZG93X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uZ2V0V2luZG93KSgpO1xcblxcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XFxuICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XFxuICB9XFxuXFxuICB2YXIgbGVmdCA9IGFyZ3NbMF0sXFxuICAgICAgdG9wID0gYXJnc1sxXSxcXG4gICAgICBkdXJhdGlvbiA9IGFyZ3NbMl0sXFxuICAgICAgZWFzaW5nID0gYXJnc1szXSxcXG4gICAgICBjYWxsYmFjayA9IGFyZ3NbNF07XFxuXFxuICBpZiAoYXJncy5sZW5ndGggPT09IDQgJiYgdHlwZW9mIGVhc2luZyA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICBjYWxsYmFjayA9IGVhc2luZztcXG4gICAgbGVmdCA9IGFyZ3NbMF07XFxuICAgIHRvcCA9IGFyZ3NbMV07XFxuICAgIGR1cmF0aW9uID0gYXJnc1syXTtcXG4gICAgY2FsbGJhY2sgPSBhcmdzWzNdO1xcbiAgICBlYXNpbmcgPSBhcmdzWzRdO1xcbiAgfVxcblxcbiAgaWYgKHR5cGVvZiBlYXNpbmcgPT09ICd1bmRlZmluZWQnKSBlYXNpbmcgPSAnc3dpbmcnO1xcbiAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiBhbmltYXRlKCkge1xcbiAgICB2YXIgZWwgPSB0aGlzO1xcbiAgICB2YXIgY3VycmVudFRvcDtcXG4gICAgdmFyIGN1cnJlbnRMZWZ0O1xcbiAgICB2YXIgbWF4VG9wO1xcbiAgICB2YXIgbWF4TGVmdDtcXG4gICAgdmFyIG5ld1RvcDtcXG4gICAgdmFyIG5ld0xlZnQ7XFxuICAgIHZhciBzY3JvbGxUb3A7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcXG5cXG4gICAgdmFyIHNjcm9sbExlZnQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcXG5cXG4gICAgdmFyIGFuaW1hdGVUb3AgPSB0b3AgPiAwIHx8IHRvcCA9PT0gMDtcXG4gICAgdmFyIGFuaW1hdGVMZWZ0ID0gbGVmdCA+IDAgfHwgbGVmdCA9PT0gMDtcXG5cXG4gICAgaWYgKHR5cGVvZiBlYXNpbmcgPT09ICd1bmRlZmluZWQnKSB7XFxuICAgICAgZWFzaW5nID0gJ3N3aW5nJztcXG4gICAgfVxcblxcbiAgICBpZiAoYW5pbWF0ZVRvcCkge1xcbiAgICAgIGN1cnJlbnRUb3AgPSBlbC5zY3JvbGxUb3A7XFxuXFxuICAgICAgaWYgKCFkdXJhdGlvbikge1xcbiAgICAgICAgZWwuc2Nyb2xsVG9wID0gdG9wO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBpZiAoYW5pbWF0ZUxlZnQpIHtcXG4gICAgICBjdXJyZW50TGVmdCA9IGVsLnNjcm9sbExlZnQ7XFxuXFxuICAgICAgaWYgKCFkdXJhdGlvbikge1xcbiAgICAgICAgZWwuc2Nyb2xsTGVmdCA9IGxlZnQ7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGlmICghZHVyYXRpb24pIHJldHVybjtcXG5cXG4gICAgaWYgKGFuaW1hdGVUb3ApIHtcXG4gICAgICBtYXhUb3AgPSBlbC5zY3JvbGxIZWlnaHQgLSBlbC5vZmZzZXRIZWlnaHQ7XFxuICAgICAgbmV3VG9wID0gTWF0aC5tYXgoTWF0aC5taW4odG9wLCBtYXhUb3ApLCAwKTtcXG4gICAgfVxcblxcbiAgICBpZiAoYW5pbWF0ZUxlZnQpIHtcXG4gICAgICBtYXhMZWZ0ID0gZWwuc2Nyb2xsV2lkdGggLSBlbC5vZmZzZXRXaWR0aDtcXG4gICAgICBuZXdMZWZ0ID0gTWF0aC5tYXgoTWF0aC5taW4obGVmdCwgbWF4TGVmdCksIDApO1xcbiAgICB9XFxuXFxuICAgIHZhciBzdGFydFRpbWUgPSBudWxsO1xcbiAgICBpZiAoYW5pbWF0ZVRvcCAmJiBuZXdUb3AgPT09IGN1cnJlbnRUb3ApIGFuaW1hdGVUb3AgPSBmYWxzZTtcXG4gICAgaWYgKGFuaW1hdGVMZWZ0ICYmIG5ld0xlZnQgPT09IGN1cnJlbnRMZWZ0KSBhbmltYXRlTGVmdCA9IGZhbHNlO1xcblxcbiAgICBmdW5jdGlvbiByZW5kZXIodGltZSkge1xcbiAgICAgIGlmICh0aW1lID09PSB2b2lkIDApIHtcXG4gICAgICAgIHRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHN0YXJ0VGltZSA9PT0gbnVsbCkge1xcbiAgICAgICAgc3RhcnRUaW1lID0gdGltZTtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIHByb2dyZXNzID0gTWF0aC5tYXgoTWF0aC5taW4oKHRpbWUgLSBzdGFydFRpbWUpIC8gZHVyYXRpb24sIDEpLCAwKTtcXG4gICAgICB2YXIgZWFzZVByb2dyZXNzID0gZWFzaW5nID09PSAnbGluZWFyJyA/IHByb2dyZXNzIDogMC41IC0gTWF0aC5jb3MocHJvZ3Jlc3MgKiBNYXRoLlBJKSAvIDI7XFxuICAgICAgdmFyIGRvbmU7XFxuICAgICAgaWYgKGFuaW1hdGVUb3ApIHNjcm9sbFRvcCA9IGN1cnJlbnRUb3AgKyBlYXNlUHJvZ3Jlc3MgKiAobmV3VG9wIC0gY3VycmVudFRvcCk7XFxuICAgICAgaWYgKGFuaW1hdGVMZWZ0KSBzY3JvbGxMZWZ0ID0gY3VycmVudExlZnQgKyBlYXNlUHJvZ3Jlc3MgKiAobmV3TGVmdCAtIGN1cnJlbnRMZWZ0KTtcXG5cXG4gICAgICBpZiAoYW5pbWF0ZVRvcCAmJiBuZXdUb3AgPiBjdXJyZW50VG9wICYmIHNjcm9sbFRvcCA+PSBuZXdUb3ApIHtcXG4gICAgICAgIGVsLnNjcm9sbFRvcCA9IG5ld1RvcDtcXG4gICAgICAgIGRvbmUgPSB0cnVlO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoYW5pbWF0ZVRvcCAmJiBuZXdUb3AgPCBjdXJyZW50VG9wICYmIHNjcm9sbFRvcCA8PSBuZXdUb3ApIHtcXG4gICAgICAgIGVsLnNjcm9sbFRvcCA9IG5ld1RvcDtcXG4gICAgICAgIGRvbmUgPSB0cnVlO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoYW5pbWF0ZUxlZnQgJiYgbmV3TGVmdCA+IGN1cnJlbnRMZWZ0ICYmIHNjcm9sbExlZnQgPj0gbmV3TGVmdCkge1xcbiAgICAgICAgZWwuc2Nyb2xsTGVmdCA9IG5ld0xlZnQ7XFxuICAgICAgICBkb25lID0gdHJ1ZTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGFuaW1hdGVMZWZ0ICYmIG5ld0xlZnQgPCBjdXJyZW50TGVmdCAmJiBzY3JvbGxMZWZ0IDw9IG5ld0xlZnQpIHtcXG4gICAgICAgIGVsLnNjcm9sbExlZnQgPSBuZXdMZWZ0O1xcbiAgICAgICAgZG9uZSA9IHRydWU7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChkb25lKSB7XFxuICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKCk7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChhbmltYXRlVG9wKSBlbC5zY3JvbGxUb3AgPSBzY3JvbGxUb3A7XFxuICAgICAgaWYgKGFuaW1hdGVMZWZ0KSBlbC5zY3JvbGxMZWZ0ID0gc2Nyb2xsTGVmdDtcXG4gICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJlbmRlcik7XFxuICAgIH1cXG5cXG4gICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShyZW5kZXIpO1xcbiAgfSk7XFxufSAvLyBzY3JvbGxUb3AodG9wLCBkdXJhdGlvbiwgZWFzaW5nLCBjYWxsYmFjaykge1xcblxcblxcbmZ1bmN0aW9uIHNjcm9sbFRvcCgpIHtcXG4gIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xcbiAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XFxuICB9XFxuXFxuICB2YXIgdG9wID0gYXJnc1swXSxcXG4gICAgICBkdXJhdGlvbiA9IGFyZ3NbMV0sXFxuICAgICAgZWFzaW5nID0gYXJnc1syXSxcXG4gICAgICBjYWxsYmFjayA9IGFyZ3NbM107XFxuXFxuICBpZiAoYXJncy5sZW5ndGggPT09IDMgJiYgdHlwZW9mIGVhc2luZyA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICB0b3AgPSBhcmdzWzBdO1xcbiAgICBkdXJhdGlvbiA9IGFyZ3NbMV07XFxuICAgIGNhbGxiYWNrID0gYXJnc1syXTtcXG4gICAgZWFzaW5nID0gYXJnc1szXTtcXG4gIH1cXG5cXG4gIHZhciBkb20gPSB0aGlzO1xcblxcbiAgaWYgKHR5cGVvZiB0b3AgPT09ICd1bmRlZmluZWQnKSB7XFxuICAgIGlmIChkb20ubGVuZ3RoID4gMCkgcmV0dXJuIGRvbVswXS5zY3JvbGxUb3A7XFxuICAgIHJldHVybiBudWxsO1xcbiAgfVxcblxcbiAgcmV0dXJuIGRvbS5zY3JvbGxUbyh1bmRlZmluZWQsIHRvcCwgZHVyYXRpb24sIGVhc2luZywgY2FsbGJhY2spO1xcbn1cXG5cXG5mdW5jdGlvbiBzY3JvbGxMZWZ0KCkge1xcbiAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zKSwgX2tleTMgPSAwOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XFxuICAgIGFyZ3NbX2tleTNdID0gYXJndW1lbnRzW19rZXkzXTtcXG4gIH1cXG5cXG4gIHZhciBsZWZ0ID0gYXJnc1swXSxcXG4gICAgICBkdXJhdGlvbiA9IGFyZ3NbMV0sXFxuICAgICAgZWFzaW5nID0gYXJnc1syXSxcXG4gICAgICBjYWxsYmFjayA9IGFyZ3NbM107XFxuXFxuICBpZiAoYXJncy5sZW5ndGggPT09IDMgJiYgdHlwZW9mIGVhc2luZyA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICBsZWZ0ID0gYXJnc1swXTtcXG4gICAgZHVyYXRpb24gPSBhcmdzWzFdO1xcbiAgICBjYWxsYmFjayA9IGFyZ3NbMl07XFxuICAgIGVhc2luZyA9IGFyZ3NbM107XFxuICB9XFxuXFxuICB2YXIgZG9tID0gdGhpcztcXG5cXG4gIGlmICh0eXBlb2YgbGVmdCA9PT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgaWYgKGRvbS5sZW5ndGggPiAwKSByZXR1cm4gZG9tWzBdLnNjcm9sbExlZnQ7XFxuICAgIHJldHVybiBudWxsO1xcbiAgfVxcblxcbiAgcmV0dXJuIGRvbS5zY3JvbGxUbyhsZWZ0LCB1bmRlZmluZWQsIGR1cmF0aW9uLCBlYXNpbmcsIGNhbGxiYWNrKTtcXG59XFxuXFxuZnVuY3Rpb24gYW5pbWF0ZShpbml0aWFsUHJvcHMsIGluaXRpYWxQYXJhbXMpIHtcXG4gIHZhciB3aW5kb3cgPSAoMCxzc3Jfd2luZG93X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uZ2V0V2luZG93KSgpO1xcbiAgdmFyIGVscyA9IHRoaXM7XFxuICB2YXIgYSA9IHtcXG4gICAgcHJvcHM6IE9iamVjdC5hc3NpZ24oe30sIGluaXRpYWxQcm9wcyksXFxuICAgIHBhcmFtczogT2JqZWN0LmFzc2lnbih7XFxuICAgICAgZHVyYXRpb246IDMwMCxcXG4gICAgICBlYXNpbmc6ICdzd2luZycgLy8gb3IgJ2xpbmVhcidcXG5cXG4gICAgICAvKiBDYWxsYmFja3NcXG4gICAgICBiZWdpbihlbGVtZW50cylcXG4gICAgICBjb21wbGV0ZShlbGVtZW50cylcXG4gICAgICBwcm9ncmVzcyhlbGVtZW50cywgY29tcGxldGUsIHJlbWFpbmluZywgc3RhcnQsIHR3ZWVuVmFsdWUpXFxuICAgICAgKi9cXG5cXG4gICAgfSwgaW5pdGlhbFBhcmFtcyksXFxuICAgIGVsZW1lbnRzOiBlbHMsXFxuICAgIGFuaW1hdGluZzogZmFsc2UsXFxuICAgIHF1ZTogW10sXFxuICAgIGVhc2luZ1Byb2dyZXNzOiBmdW5jdGlvbiBlYXNpbmdQcm9ncmVzcyhlYXNpbmcsIHByb2dyZXNzKSB7XFxuICAgICAgaWYgKGVhc2luZyA9PT0gJ3N3aW5nJykge1xcbiAgICAgICAgcmV0dXJuIDAuNSAtIE1hdGguY29zKHByb2dyZXNzICogTWF0aC5QSSkgLyAyO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodHlwZW9mIGVhc2luZyA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgICAgcmV0dXJuIGVhc2luZyhwcm9ncmVzcyk7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBwcm9ncmVzcztcXG4gICAgfSxcXG4gICAgc3RvcDogZnVuY3Rpb24gc3RvcCgpIHtcXG4gICAgICBpZiAoYS5mcmFtZUlkKSB7XFxuICAgICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoYS5mcmFtZUlkKTtcXG4gICAgICB9XFxuXFxuICAgICAgYS5hbmltYXRpbmcgPSBmYWxzZTtcXG4gICAgICBhLmVsZW1lbnRzLmVhY2goZnVuY3Rpb24gKGVsKSB7XFxuICAgICAgICB2YXIgZWxlbWVudCA9IGVsO1xcbiAgICAgICAgZGVsZXRlIGVsZW1lbnQuZG9tN0FuaW1hdGVJbnN0YW5jZTtcXG4gICAgICB9KTtcXG4gICAgICBhLnF1ZSA9IFtdO1xcbiAgICB9LFxcbiAgICBkb25lOiBmdW5jdGlvbiBkb25lKGNvbXBsZXRlKSB7XFxuICAgICAgYS5hbmltYXRpbmcgPSBmYWxzZTtcXG4gICAgICBhLmVsZW1lbnRzLmVhY2goZnVuY3Rpb24gKGVsKSB7XFxuICAgICAgICB2YXIgZWxlbWVudCA9IGVsO1xcbiAgICAgICAgZGVsZXRlIGVsZW1lbnQuZG9tN0FuaW1hdGVJbnN0YW5jZTtcXG4gICAgICB9KTtcXG4gICAgICBpZiAoY29tcGxldGUpIGNvbXBsZXRlKGVscyk7XFxuXFxuICAgICAgaWYgKGEucXVlLmxlbmd0aCA+IDApIHtcXG4gICAgICAgIHZhciBxdWUgPSBhLnF1ZS5zaGlmdCgpO1xcbiAgICAgICAgYS5hbmltYXRlKHF1ZVswXSwgcXVlWzFdKTtcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIGFuaW1hdGU6IGZ1bmN0aW9uIGFuaW1hdGUocHJvcHMsIHBhcmFtcykge1xcbiAgICAgIGlmIChhLmFuaW1hdGluZykge1xcbiAgICAgICAgYS5xdWUucHVzaChbcHJvcHMsIHBhcmFtc10pO1xcbiAgICAgICAgcmV0dXJuIGE7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBlbGVtZW50cyA9IFtdOyAvLyBEZWZpbmUgJiBDYWNoZSBJbml0aWFscyAmIFVuaXRzXFxuXFxuICAgICAgYS5lbGVtZW50cy5lYWNoKGZ1bmN0aW9uIChlbCwgaW5kZXgpIHtcXG4gICAgICAgIHZhciBpbml0aWFsRnVsbFZhbHVlO1xcbiAgICAgICAgdmFyIGluaXRpYWxWYWx1ZTtcXG4gICAgICAgIHZhciB1bml0O1xcbiAgICAgICAgdmFyIGZpbmFsVmFsdWU7XFxuICAgICAgICB2YXIgZmluYWxGdWxsVmFsdWU7XFxuICAgICAgICBpZiAoIWVsLmRvbTdBbmltYXRlSW5zdGFuY2UpIGEuZWxlbWVudHNbaW5kZXhdLmRvbTdBbmltYXRlSW5zdGFuY2UgPSBhO1xcbiAgICAgICAgZWxlbWVudHNbaW5kZXhdID0ge1xcbiAgICAgICAgICBjb250YWluZXI6IGVsXFxuICAgICAgICB9O1xcbiAgICAgICAgT2JqZWN0LmtleXMocHJvcHMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcXG4gICAgICAgICAgaW5pdGlhbEZ1bGxWYWx1ZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsLCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKHByb3ApLnJlcGxhY2UoJywnLCAnLicpO1xcbiAgICAgICAgICBpbml0aWFsVmFsdWUgPSBwYXJzZUZsb2F0KGluaXRpYWxGdWxsVmFsdWUpO1xcbiAgICAgICAgICB1bml0ID0gaW5pdGlhbEZ1bGxWYWx1ZS5yZXBsYWNlKGluaXRpYWxWYWx1ZSwgJycpO1xcbiAgICAgICAgICBmaW5hbFZhbHVlID0gcGFyc2VGbG9hdChwcm9wc1twcm9wXSk7XFxuICAgICAgICAgIGZpbmFsRnVsbFZhbHVlID0gcHJvcHNbcHJvcF0gKyB1bml0O1xcbiAgICAgICAgICBlbGVtZW50c1tpbmRleF1bcHJvcF0gPSB7XFxuICAgICAgICAgICAgaW5pdGlhbEZ1bGxWYWx1ZTogaW5pdGlhbEZ1bGxWYWx1ZSxcXG4gICAgICAgICAgICBpbml0aWFsVmFsdWU6IGluaXRpYWxWYWx1ZSxcXG4gICAgICAgICAgICB1bml0OiB1bml0LFxcbiAgICAgICAgICAgIGZpbmFsVmFsdWU6IGZpbmFsVmFsdWUsXFxuICAgICAgICAgICAgZmluYWxGdWxsVmFsdWU6IGZpbmFsRnVsbFZhbHVlLFxcbiAgICAgICAgICAgIGN1cnJlbnRWYWx1ZTogaW5pdGlhbFZhbHVlXFxuICAgICAgICAgIH07XFxuICAgICAgICB9KTtcXG4gICAgICB9KTtcXG4gICAgICB2YXIgc3RhcnRUaW1lID0gbnVsbDtcXG4gICAgICB2YXIgdGltZTtcXG4gICAgICB2YXIgZWxlbWVudHNEb25lID0gMDtcXG4gICAgICB2YXIgcHJvcHNEb25lID0gMDtcXG4gICAgICB2YXIgZG9uZTtcXG4gICAgICB2YXIgYmVnYW4gPSBmYWxzZTtcXG4gICAgICBhLmFuaW1hdGluZyA9IHRydWU7XFxuXFxuICAgICAgZnVuY3Rpb24gcmVuZGVyKCkge1xcbiAgICAgICAgdGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xcbiAgICAgICAgdmFyIHByb2dyZXNzO1xcbiAgICAgICAgdmFyIGVhc2VQcm9ncmVzczsgLy8gbGV0IGVsO1xcblxcbiAgICAgICAgaWYgKCFiZWdhbikge1xcbiAgICAgICAgICBiZWdhbiA9IHRydWU7XFxuICAgICAgICAgIGlmIChwYXJhbXMuYmVnaW4pIHBhcmFtcy5iZWdpbihlbHMpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKHN0YXJ0VGltZSA9PT0gbnVsbCkge1xcbiAgICAgICAgICBzdGFydFRpbWUgPSB0aW1lO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKHBhcmFtcy5wcm9ncmVzcykge1xcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcXG4gICAgICAgICAgcGFyYW1zLnByb2dyZXNzKGVscywgTWF0aC5tYXgoTWF0aC5taW4oKHRpbWUgLSBzdGFydFRpbWUpIC8gcGFyYW1zLmR1cmF0aW9uLCAxKSwgMCksIHN0YXJ0VGltZSArIHBhcmFtcy5kdXJhdGlvbiAtIHRpbWUgPCAwID8gMCA6IHN0YXJ0VGltZSArIHBhcmFtcy5kdXJhdGlvbiAtIHRpbWUsIHN0YXJ0VGltZSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7XFxuICAgICAgICAgIHZhciBlbCA9IGVsZW1lbnQ7XFxuICAgICAgICAgIGlmIChkb25lIHx8IGVsLmRvbmUpIHJldHVybjtcXG4gICAgICAgICAgT2JqZWN0LmtleXMocHJvcHMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcXG4gICAgICAgICAgICBpZiAoZG9uZSB8fCBlbC5kb25lKSByZXR1cm47XFxuICAgICAgICAgICAgcHJvZ3Jlc3MgPSBNYXRoLm1heChNYXRoLm1pbigodGltZSAtIHN0YXJ0VGltZSkgLyBwYXJhbXMuZHVyYXRpb24sIDEpLCAwKTtcXG4gICAgICAgICAgICBlYXNlUHJvZ3Jlc3MgPSBhLmVhc2luZ1Byb2dyZXNzKHBhcmFtcy5lYXNpbmcsIHByb2dyZXNzKTtcXG4gICAgICAgICAgICB2YXIgX2VsJHByb3AgPSBlbFtwcm9wXSxcXG4gICAgICAgICAgICAgICAgaW5pdGlhbFZhbHVlID0gX2VsJHByb3AuaW5pdGlhbFZhbHVlLFxcbiAgICAgICAgICAgICAgICBmaW5hbFZhbHVlID0gX2VsJHByb3AuZmluYWxWYWx1ZSxcXG4gICAgICAgICAgICAgICAgdW5pdCA9IF9lbCRwcm9wLnVuaXQ7XFxuICAgICAgICAgICAgZWxbcHJvcF0uY3VycmVudFZhbHVlID0gaW5pdGlhbFZhbHVlICsgZWFzZVByb2dyZXNzICogKGZpbmFsVmFsdWUgLSBpbml0aWFsVmFsdWUpO1xcbiAgICAgICAgICAgIHZhciBjdXJyZW50VmFsdWUgPSBlbFtwcm9wXS5jdXJyZW50VmFsdWU7XFxuXFxuICAgICAgICAgICAgaWYgKGZpbmFsVmFsdWUgPiBpbml0aWFsVmFsdWUgJiYgY3VycmVudFZhbHVlID49IGZpbmFsVmFsdWUgfHwgZmluYWxWYWx1ZSA8IGluaXRpYWxWYWx1ZSAmJiBjdXJyZW50VmFsdWUgPD0gZmluYWxWYWx1ZSkge1xcbiAgICAgICAgICAgICAgZWwuY29udGFpbmVyLnN0eWxlW3Byb3BdID0gZmluYWxWYWx1ZSArIHVuaXQ7XFxuICAgICAgICAgICAgICBwcm9wc0RvbmUgKz0gMTtcXG5cXG4gICAgICAgICAgICAgIGlmIChwcm9wc0RvbmUgPT09IE9iamVjdC5rZXlzKHByb3BzKS5sZW5ndGgpIHtcXG4gICAgICAgICAgICAgICAgZWwuZG9uZSA9IHRydWU7XFxuICAgICAgICAgICAgICAgIGVsZW1lbnRzRG9uZSArPSAxO1xcbiAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgaWYgKGVsZW1lbnRzRG9uZSA9PT0gZWxlbWVudHMubGVuZ3RoKSB7XFxuICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBpZiAoZG9uZSkge1xcbiAgICAgICAgICAgICAgYS5kb25lKHBhcmFtcy5jb21wbGV0ZSk7XFxuICAgICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGVsLmNvbnRhaW5lci5zdHlsZVtwcm9wXSA9IGN1cnJlbnRWYWx1ZSArIHVuaXQ7XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfSk7XFxuICAgICAgICBpZiAoZG9uZSkgcmV0dXJuOyAvLyBUaGVuIGNhbGxcXG5cXG4gICAgICAgIGEuZnJhbWVJZCA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmVuZGVyKTtcXG4gICAgICB9XFxuXFxuICAgICAgYS5mcmFtZUlkID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShyZW5kZXIpO1xcbiAgICAgIHJldHVybiBhO1xcbiAgICB9XFxuICB9O1xcblxcbiAgaWYgKGEuZWxlbWVudHMubGVuZ3RoID09PSAwKSB7XFxuICAgIHJldHVybiBlbHM7XFxuICB9XFxuXFxuICB2YXIgYW5pbWF0ZUluc3RhbmNlO1xcblxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmVsZW1lbnRzLmxlbmd0aDsgaSArPSAxKSB7XFxuICAgIGlmIChhLmVsZW1lbnRzW2ldLmRvbTdBbmltYXRlSW5zdGFuY2UpIHtcXG4gICAgICBhbmltYXRlSW5zdGFuY2UgPSBhLmVsZW1lbnRzW2ldLmRvbTdBbmltYXRlSW5zdGFuY2U7XFxuICAgIH0gZWxzZSBhLmVsZW1lbnRzW2ldLmRvbTdBbmltYXRlSW5zdGFuY2UgPSBhO1xcbiAgfVxcblxcbiAgaWYgKCFhbmltYXRlSW5zdGFuY2UpIHtcXG4gICAgYW5pbWF0ZUluc3RhbmNlID0gYTtcXG4gIH1cXG5cXG4gIGlmIChpbml0aWFsUHJvcHMgPT09ICdzdG9wJykge1xcbiAgICBhbmltYXRlSW5zdGFuY2Uuc3RvcCgpO1xcbiAgfSBlbHNlIHtcXG4gICAgYW5pbWF0ZUluc3RhbmNlLmFuaW1hdGUoYS5wcm9wcywgYS5wYXJhbXMpO1xcbiAgfVxcblxcbiAgcmV0dXJuIGVscztcXG59XFxuXFxuZnVuY3Rpb24gc3RvcCgpIHtcXG4gIHZhciBlbHMgPSB0aGlzO1xcblxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbHMubGVuZ3RoOyBpICs9IDEpIHtcXG4gICAgaWYgKGVsc1tpXS5kb203QW5pbWF0ZUluc3RhbmNlKSB7XFxuICAgICAgZWxzW2ldLmRvbTdBbmltYXRlSW5zdGFuY2Uuc3RvcCgpO1xcbiAgICB9XFxuICB9XFxufVxcblxcbnZhciBub1RyaWdnZXIgPSAncmVzaXplIHNjcm9sbCcuc3BsaXQoJyAnKTtcXG5cXG5mdW5jdGlvbiBzaG9ydGN1dChuYW1lKSB7XFxuICBmdW5jdGlvbiBldmVudEhhbmRsZXIoKSB7XFxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XFxuICAgIH1cXG5cXG4gICAgaWYgKHR5cGVvZiBhcmdzWzBdID09PSAndW5kZWZpbmVkJykge1xcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkgKz0gMSkge1xcbiAgICAgICAgaWYgKG5vVHJpZ2dlci5pbmRleE9mKG5hbWUpIDwgMCkge1xcbiAgICAgICAgICBpZiAobmFtZSBpbiB0aGlzW2ldKSB0aGlzW2ldW25hbWVdKCk7ZWxzZSB7XFxuICAgICAgICAgICAgJCh0aGlzW2ldKS50cmlnZ2VyKG5hbWUpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiB0aGlzO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiB0aGlzLm9uLmFwcGx5KHRoaXMsIFtuYW1lXS5jb25jYXQoYXJncykpO1xcbiAgfVxcblxcbiAgcmV0dXJuIGV2ZW50SGFuZGxlcjtcXG59XFxuXFxudmFyIGNsaWNrID0gc2hvcnRjdXQoJ2NsaWNrJyk7XFxudmFyIGJsdXIgPSBzaG9ydGN1dCgnYmx1cicpO1xcbnZhciBmb2N1cyA9IHNob3J0Y3V0KCdmb2N1cycpO1xcbnZhciBmb2N1c2luID0gc2hvcnRjdXQoJ2ZvY3VzaW4nKTtcXG52YXIgZm9jdXNvdXQgPSBzaG9ydGN1dCgnZm9jdXNvdXQnKTtcXG52YXIga2V5dXAgPSBzaG9ydGN1dCgna2V5dXAnKTtcXG52YXIga2V5ZG93biA9IHNob3J0Y3V0KCdrZXlkb3duJyk7XFxudmFyIGtleXByZXNzID0gc2hvcnRjdXQoJ2tleXByZXNzJyk7XFxudmFyIHN1Ym1pdCA9IHNob3J0Y3V0KCdzdWJtaXQnKTtcXG52YXIgY2hhbmdlID0gc2hvcnRjdXQoJ2NoYW5nZScpO1xcbnZhciBtb3VzZWRvd24gPSBzaG9ydGN1dCgnbW91c2Vkb3duJyk7XFxudmFyIG1vdXNlbW92ZSA9IHNob3J0Y3V0KCdtb3VzZW1vdmUnKTtcXG52YXIgbW91c2V1cCA9IHNob3J0Y3V0KCdtb3VzZXVwJyk7XFxudmFyIG1vdXNlZW50ZXIgPSBzaG9ydGN1dCgnbW91c2VlbnRlcicpO1xcbnZhciBtb3VzZWxlYXZlID0gc2hvcnRjdXQoJ21vdXNlbGVhdmUnKTtcXG52YXIgbW91c2VvdXQgPSBzaG9ydGN1dCgnbW91c2VvdXQnKTtcXG52YXIgbW91c2VvdmVyID0gc2hvcnRjdXQoJ21vdXNlb3ZlcicpO1xcbnZhciB0b3VjaHN0YXJ0ID0gc2hvcnRjdXQoJ3RvdWNoc3RhcnQnKTtcXG52YXIgdG91Y2hlbmQgPSBzaG9ydGN1dCgndG91Y2hlbmQnKTtcXG52YXIgdG91Y2htb3ZlID0gc2hvcnRjdXQoJ3RvdWNobW92ZScpO1xcbnZhciByZXNpemUgPSBzaG9ydGN1dCgncmVzaXplJyk7XFxudmFyIHNjcm9sbCA9IHNob3J0Y3V0KCdzY3JvbGwnKTtcXG5cXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IF9fV0VCUEFDS19ERUZBVUxUX0VYUE9SVF9fID0gKCQpO1xcblxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3BhcnVzLy4vbm9kZV9tb2R1bGVzL2RvbTcvZG9tNy5lc20uanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9zc3Itd2luZG93L3Nzci13aW5kb3cuZXNtLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvc3NyLXdpbmRvdy9zc3Itd2luZG93LmVzbS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIGV4dGVuZDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gZXh0ZW5kKSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIGdldERvY3VtZW50OiAoKSA9PiAoLyogYmluZGluZyAqLyBnZXREb2N1bWVudCksXFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBnZXRXaW5kb3c6ICgpID0+ICgvKiBiaW5kaW5nICovIGdldFdpbmRvdyksXFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBzc3JEb2N1bWVudDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gc3NyRG9jdW1lbnQpLFxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgc3NyV2luZG93OiAoKSA9PiAoLyogYmluZGluZyAqLyBzc3JXaW5kb3cpXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuLyoqXFxuICogU1NSIFdpbmRvdyAzLjAuMFxcbiAqIEJldHRlciBoYW5kbGluZyBmb3Igd2luZG93IG9iamVjdCBpbiBTU1IgZW52aXJvbm1lbnRcXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbm9saW1pdHM0d2ViL3Nzci13aW5kb3dcXG4gKlxcbiAqIENvcHlyaWdodCAyMDIwLCBWbGFkaW1pciBLaGFybGFtcGlkaVxcbiAqXFxuICogTGljZW5zZWQgdW5kZXIgTUlUXFxuICpcXG4gKiBSZWxlYXNlZCBvbjogTm92ZW1iZXIgOSwgMjAyMFxcbiAqL1xcbi8qIGVzbGludC1kaXNhYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXFxuZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XFxuICAgIHJldHVybiAob2JqICE9PSBudWxsICYmXFxuICAgICAgICB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJlxcbiAgICAgICAgJ2NvbnN0cnVjdG9yJyBpbiBvYmogJiZcXG4gICAgICAgIG9iai5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KTtcXG59XFxuZnVuY3Rpb24gZXh0ZW5kKHRhcmdldCwgc3JjKSB7XFxuICAgIGlmICh0YXJnZXQgPT09IHZvaWQgMCkgeyB0YXJnZXQgPSB7fTsgfVxcbiAgICBpZiAoc3JjID09PSB2b2lkIDApIHsgc3JjID0ge307IH1cXG4gICAgT2JqZWN0LmtleXMoc3JjKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcXG4gICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0W2tleV0gPT09ICd1bmRlZmluZWQnKVxcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gc3JjW2tleV07XFxuICAgICAgICBlbHNlIGlmIChpc09iamVjdChzcmNba2V5XSkgJiZcXG4gICAgICAgICAgICBpc09iamVjdCh0YXJnZXRba2V5XSkgJiZcXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhzcmNba2V5XSkubGVuZ3RoID4gMCkge1xcbiAgICAgICAgICAgIGV4dGVuZCh0YXJnZXRba2V5XSwgc3JjW2tleV0pO1xcbiAgICAgICAgfVxcbiAgICB9KTtcXG59XFxuXFxudmFyIHNzckRvY3VtZW50ID0ge1xcbiAgICBib2R5OiB7fSxcXG4gICAgYWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKCkgeyB9LFxcbiAgICByZW1vdmVFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAoKSB7IH0sXFxuICAgIGFjdGl2ZUVsZW1lbnQ6IHtcXG4gICAgICAgIGJsdXI6IGZ1bmN0aW9uICgpIHsgfSxcXG4gICAgICAgIG5vZGVOYW1lOiAnJyxcXG4gICAgfSxcXG4gICAgcXVlcnlTZWxlY3RvcjogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgcmV0dXJuIG51bGw7XFxuICAgIH0sXFxuICAgIHF1ZXJ5U2VsZWN0b3JBbGw6IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHJldHVybiBbXTtcXG4gICAgfSxcXG4gICAgZ2V0RWxlbWVudEJ5SWQ6IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHJldHVybiBudWxsO1xcbiAgICB9LFxcbiAgICBjcmVhdGVFdmVudDogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICBpbml0RXZlbnQ6IGZ1bmN0aW9uICgpIHsgfSxcXG4gICAgICAgIH07XFxuICAgIH0sXFxuICAgIGNyZWF0ZUVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgY2hpbGRyZW46IFtdLFxcbiAgICAgICAgICAgIGNoaWxkTm9kZXM6IFtdLFxcbiAgICAgICAgICAgIHN0eWxlOiB7fSxcXG4gICAgICAgICAgICBzZXRBdHRyaWJ1dGU6IGZ1bmN0aW9uICgpIHsgfSxcXG4gICAgICAgICAgICBnZXRFbGVtZW50c0J5VGFnTmFtZTogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XFxuICAgICAgICAgICAgfSxcXG4gICAgICAgIH07XFxuICAgIH0sXFxuICAgIGNyZWF0ZUVsZW1lbnROUzogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgcmV0dXJuIHt9O1xcbiAgICB9LFxcbiAgICBpbXBvcnROb2RlOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICByZXR1cm4gbnVsbDtcXG4gICAgfSxcXG4gICAgbG9jYXRpb246IHtcXG4gICAgICAgIGhhc2g6ICcnLFxcbiAgICAgICAgaG9zdDogJycsXFxuICAgICAgICBob3N0bmFtZTogJycsXFxuICAgICAgICBocmVmOiAnJyxcXG4gICAgICAgIG9yaWdpbjogJycsXFxuICAgICAgICBwYXRobmFtZTogJycsXFxuICAgICAgICBwcm90b2NvbDogJycsXFxuICAgICAgICBzZWFyY2g6ICcnLFxcbiAgICB9LFxcbn07XFxuZnVuY3Rpb24gZ2V0RG9jdW1lbnQoKSB7XFxuICAgIHZhciBkb2MgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gZG9jdW1lbnQgOiB7fTtcXG4gICAgZXh0ZW5kKGRvYywgc3NyRG9jdW1lbnQpO1xcbiAgICByZXR1cm4gZG9jO1xcbn1cXG5cXG52YXIgc3NyV2luZG93ID0ge1xcbiAgICBkb2N1bWVudDogc3NyRG9jdW1lbnQsXFxuICAgIG5hdmlnYXRvcjoge1xcbiAgICAgICAgdXNlckFnZW50OiAnJyxcXG4gICAgfSxcXG4gICAgbG9jYXRpb246IHtcXG4gICAgICAgIGhhc2g6ICcnLFxcbiAgICAgICAgaG9zdDogJycsXFxuICAgICAgICBob3N0bmFtZTogJycsXFxuICAgICAgICBocmVmOiAnJyxcXG4gICAgICAgIG9yaWdpbjogJycsXFxuICAgICAgICBwYXRobmFtZTogJycsXFxuICAgICAgICBwcm90b2NvbDogJycsXFxuICAgICAgICBzZWFyY2g6ICcnLFxcbiAgICB9LFxcbiAgICBoaXN0b3J5OiB7XFxuICAgICAgICByZXBsYWNlU3RhdGU6IGZ1bmN0aW9uICgpIHsgfSxcXG4gICAgICAgIHB1c2hTdGF0ZTogZnVuY3Rpb24gKCkgeyB9LFxcbiAgICAgICAgZ286IGZ1bmN0aW9uICgpIHsgfSxcXG4gICAgICAgIGJhY2s6IGZ1bmN0aW9uICgpIHsgfSxcXG4gICAgfSxcXG4gICAgQ3VzdG9tRXZlbnQ6IGZ1bmN0aW9uIEN1c3RvbUV2ZW50KCkge1xcbiAgICAgICAgcmV0dXJuIHRoaXM7XFxuICAgIH0sXFxuICAgIGFkZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uICgpIHsgfSxcXG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKCkgeyB9LFxcbiAgICBnZXRDb21wdXRlZFN0eWxlOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgIGdldFByb3BlcnR5VmFsdWU6IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xcbiAgICAgICAgICAgIH0sXFxuICAgICAgICB9O1xcbiAgICB9LFxcbiAgICBJbWFnZTogZnVuY3Rpb24gKCkgeyB9LFxcbiAgICBEYXRlOiBmdW5jdGlvbiAoKSB7IH0sXFxuICAgIHNjcmVlbjoge30sXFxuICAgIHNldFRpbWVvdXQ6IGZ1bmN0aW9uICgpIHsgfSxcXG4gICAgY2xlYXJUaW1lb3V0OiBmdW5jdGlvbiAoKSB7IH0sXFxuICAgIG1hdGNoTWVkaWE6IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHJldHVybiB7fTtcXG4gICAgfSxcXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcXG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICAgICAgICBjYWxsYmFjaygpO1xcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoY2FsbGJhY2ssIDApO1xcbiAgICB9LFxcbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZTogZnVuY3Rpb24gKGlkKSB7XFxuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICd1bmRlZmluZWQnKSB7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcbiAgICAgICAgY2xlYXJUaW1lb3V0KGlkKTtcXG4gICAgfSxcXG59O1xcbmZ1bmN0aW9uIGdldFdpbmRvdygpIHtcXG4gICAgdmFyIHdpbiA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDoge307XFxuICAgIGV4dGVuZCh3aW4sIHNzcldpbmRvdyk7XFxuICAgIHJldHVybiB3aW47XFxufVxcblxcblxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3BhcnVzLy4vbm9kZV9tb2R1bGVzL3Nzci13aW5kb3cvc3NyLXdpbmRvdy5lc20uanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvYXV0b3BsYXkvYXV0b3BsYXkuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9hdXRvcGxheS9hdXRvcGxheS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcImRlZmF1bHRcXFwiOiAoKSA9PiAoX19XRUJQQUNLX0RFRkFVTFRfRVhQT1JUX18pXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHNzci13aW5kb3cgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3Nzci13aW5kb3cvc3NyLXdpbmRvdy5lc20uanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi91dGlscy91dGlscyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS91dGlscy91dGlscy5qc1xcXCIpO1xcbmZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XFxuXFxuLyogZXNsaW50IG5vLXVuZGVyc2NvcmUtZGFuZ2xlOiBcXFwib2ZmXFxcIiAqL1xcblxcblxcbnZhciBBdXRvcGxheSA9IHtcXG4gIHJ1bjogZnVuY3Rpb24gcnVuKCkge1xcbiAgICB2YXIgc3dpcGVyID0gdGhpcztcXG4gICAgdmFyICRhY3RpdmVTbGlkZUVsID0gc3dpcGVyLnNsaWRlcy5lcShzd2lwZXIuYWN0aXZlSW5kZXgpO1xcbiAgICB2YXIgZGVsYXkgPSBzd2lwZXIucGFyYW1zLmF1dG9wbGF5LmRlbGF5O1xcblxcbiAgICBpZiAoJGFjdGl2ZVNsaWRlRWwuYXR0cignZGF0YS1zd2lwZXItYXV0b3BsYXknKSkge1xcbiAgICAgIGRlbGF5ID0gJGFjdGl2ZVNsaWRlRWwuYXR0cignZGF0YS1zd2lwZXItYXV0b3BsYXknKSB8fCBzd2lwZXIucGFyYW1zLmF1dG9wbGF5LmRlbGF5O1xcbiAgICB9XFxuXFxuICAgIGNsZWFyVGltZW91dChzd2lwZXIuYXV0b3BsYXkudGltZW91dCk7XFxuICAgIHN3aXBlci5hdXRvcGxheS50aW1lb3V0ID0gKDAsX3V0aWxzX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18ubmV4dFRpY2spKGZ1bmN0aW9uICgpIHtcXG4gICAgICB2YXIgYXV0b3BsYXlSZXN1bHQ7XFxuXFxuICAgICAgaWYgKHN3aXBlci5wYXJhbXMuYXV0b3BsYXkucmV2ZXJzZURpcmVjdGlvbikge1xcbiAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMubG9vcCkge1xcbiAgICAgICAgICBzd2lwZXIubG9vcEZpeCgpO1xcbiAgICAgICAgICBhdXRvcGxheVJlc3VsdCA9IHN3aXBlci5zbGlkZVByZXYoc3dpcGVyLnBhcmFtcy5zcGVlZCwgdHJ1ZSwgdHJ1ZSk7XFxuICAgICAgICAgIHN3aXBlci5lbWl0KCdhdXRvcGxheScpO1xcbiAgICAgICAgfSBlbHNlIGlmICghc3dpcGVyLmlzQmVnaW5uaW5nKSB7XFxuICAgICAgICAgIGF1dG9wbGF5UmVzdWx0ID0gc3dpcGVyLnNsaWRlUHJldihzd2lwZXIucGFyYW1zLnNwZWVkLCB0cnVlLCB0cnVlKTtcXG4gICAgICAgICAgc3dpcGVyLmVtaXQoJ2F1dG9wbGF5Jyk7XFxuICAgICAgICB9IGVsc2UgaWYgKCFzd2lwZXIucGFyYW1zLmF1dG9wbGF5LnN0b3BPbkxhc3RTbGlkZSkge1xcbiAgICAgICAgICBhdXRvcGxheVJlc3VsdCA9IHN3aXBlci5zbGlkZVRvKHN3aXBlci5zbGlkZXMubGVuZ3RoIC0gMSwgc3dpcGVyLnBhcmFtcy5zcGVlZCwgdHJ1ZSwgdHJ1ZSk7XFxuICAgICAgICAgIHN3aXBlci5lbWl0KCdhdXRvcGxheScpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgc3dpcGVyLmF1dG9wbGF5LnN0b3AoKTtcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2UgaWYgKHN3aXBlci5wYXJhbXMubG9vcCkge1xcbiAgICAgICAgc3dpcGVyLmxvb3BGaXgoKTtcXG4gICAgICAgIGF1dG9wbGF5UmVzdWx0ID0gc3dpcGVyLnNsaWRlTmV4dChzd2lwZXIucGFyYW1zLnNwZWVkLCB0cnVlLCB0cnVlKTtcXG4gICAgICAgIHN3aXBlci5lbWl0KCdhdXRvcGxheScpO1xcbiAgICAgIH0gZWxzZSBpZiAoIXN3aXBlci5pc0VuZCkge1xcbiAgICAgICAgYXV0b3BsYXlSZXN1bHQgPSBzd2lwZXIuc2xpZGVOZXh0KHN3aXBlci5wYXJhbXMuc3BlZWQsIHRydWUsIHRydWUpO1xcbiAgICAgICAgc3dpcGVyLmVtaXQoJ2F1dG9wbGF5Jyk7XFxuICAgICAgfSBlbHNlIGlmICghc3dpcGVyLnBhcmFtcy5hdXRvcGxheS5zdG9wT25MYXN0U2xpZGUpIHtcXG4gICAgICAgIGF1dG9wbGF5UmVzdWx0ID0gc3dpcGVyLnNsaWRlVG8oMCwgc3dpcGVyLnBhcmFtcy5zcGVlZCwgdHJ1ZSwgdHJ1ZSk7XFxuICAgICAgICBzd2lwZXIuZW1pdCgnYXV0b3BsYXknKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgc3dpcGVyLmF1dG9wbGF5LnN0b3AoKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHN3aXBlci5wYXJhbXMuY3NzTW9kZSAmJiBzd2lwZXIuYXV0b3BsYXkucnVubmluZykgc3dpcGVyLmF1dG9wbGF5LnJ1bigpO2Vsc2UgaWYgKGF1dG9wbGF5UmVzdWx0ID09PSBmYWxzZSkge1xcbiAgICAgICAgc3dpcGVyLmF1dG9wbGF5LnJ1bigpO1xcbiAgICAgIH1cXG4gICAgfSwgZGVsYXkpO1xcbiAgfSxcXG4gIHN0YXJ0OiBmdW5jdGlvbiBzdGFydCgpIHtcXG4gICAgdmFyIHN3aXBlciA9IHRoaXM7XFxuICAgIGlmICh0eXBlb2Ygc3dpcGVyLmF1dG9wbGF5LnRpbWVvdXQgIT09ICd1bmRlZmluZWQnKSByZXR1cm4gZmFsc2U7XFxuICAgIGlmIChzd2lwZXIuYXV0b3BsYXkucnVubmluZykgcmV0dXJuIGZhbHNlO1xcbiAgICBzd2lwZXIuYXV0b3BsYXkucnVubmluZyA9IHRydWU7XFxuICAgIHN3aXBlci5lbWl0KCdhdXRvcGxheVN0YXJ0Jyk7XFxuICAgIHN3aXBlci5hdXRvcGxheS5ydW4oKTtcXG4gICAgcmV0dXJuIHRydWU7XFxuICB9LFxcbiAgc3RvcDogZnVuY3Rpb24gc3RvcCgpIHtcXG4gICAgdmFyIHN3aXBlciA9IHRoaXM7XFxuICAgIGlmICghc3dpcGVyLmF1dG9wbGF5LnJ1bm5pbmcpIHJldHVybiBmYWxzZTtcXG4gICAgaWYgKHR5cGVvZiBzd2lwZXIuYXV0b3BsYXkudGltZW91dCA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBmYWxzZTtcXG5cXG4gICAgaWYgKHN3aXBlci5hdXRvcGxheS50aW1lb3V0KSB7XFxuICAgICAgY2xlYXJUaW1lb3V0KHN3aXBlci5hdXRvcGxheS50aW1lb3V0KTtcXG4gICAgICBzd2lwZXIuYXV0b3BsYXkudGltZW91dCA9IHVuZGVmaW5lZDtcXG4gICAgfVxcblxcbiAgICBzd2lwZXIuYXV0b3BsYXkucnVubmluZyA9IGZhbHNlO1xcbiAgICBzd2lwZXIuZW1pdCgnYXV0b3BsYXlTdG9wJyk7XFxuICAgIHJldHVybiB0cnVlO1xcbiAgfSxcXG4gIHBhdXNlOiBmdW5jdGlvbiBwYXVzZShzcGVlZCkge1xcbiAgICB2YXIgc3dpcGVyID0gdGhpcztcXG4gICAgaWYgKCFzd2lwZXIuYXV0b3BsYXkucnVubmluZykgcmV0dXJuO1xcbiAgICBpZiAoc3dpcGVyLmF1dG9wbGF5LnBhdXNlZCkgcmV0dXJuO1xcbiAgICBpZiAoc3dpcGVyLmF1dG9wbGF5LnRpbWVvdXQpIGNsZWFyVGltZW91dChzd2lwZXIuYXV0b3BsYXkudGltZW91dCk7XFxuICAgIHN3aXBlci5hdXRvcGxheS5wYXVzZWQgPSB0cnVlO1xcblxcbiAgICBpZiAoc3BlZWQgPT09IDAgfHwgIXN3aXBlci5wYXJhbXMuYXV0b3BsYXkud2FpdEZvclRyYW5zaXRpb24pIHtcXG4gICAgICBzd2lwZXIuYXV0b3BsYXkucGF1c2VkID0gZmFsc2U7XFxuICAgICAgc3dpcGVyLmF1dG9wbGF5LnJ1bigpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIFsndHJhbnNpdGlvbmVuZCcsICd3ZWJraXRUcmFuc2l0aW9uRW5kJ10uZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcXG4gICAgICAgIHN3aXBlci4kd3JhcHBlckVsWzBdLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIHN3aXBlci5hdXRvcGxheS5vblRyYW5zaXRpb25FbmQpO1xcbiAgICAgIH0pO1xcbiAgICB9XFxuICB9LFxcbiAgb25WaXNpYmlsaXR5Q2hhbmdlOiBmdW5jdGlvbiBvblZpc2liaWxpdHlDaGFuZ2UoKSB7XFxuICAgIHZhciBzd2lwZXIgPSB0aGlzO1xcbiAgICB2YXIgZG9jdW1lbnQgPSAoMCxzc3Jfd2luZG93X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uZ2V0RG9jdW1lbnQpKCk7XFxuXFxuICAgIGlmIChkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPT09ICdoaWRkZW4nICYmIHN3aXBlci5hdXRvcGxheS5ydW5uaW5nKSB7XFxuICAgICAgc3dpcGVyLmF1dG9wbGF5LnBhdXNlKCk7XFxuICAgIH1cXG5cXG4gICAgaWYgKGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gJ3Zpc2libGUnICYmIHN3aXBlci5hdXRvcGxheS5wYXVzZWQpIHtcXG4gICAgICBzd2lwZXIuYXV0b3BsYXkucnVuKCk7XFxuICAgICAgc3dpcGVyLmF1dG9wbGF5LnBhdXNlZCA9IGZhbHNlO1xcbiAgICB9XFxuICB9LFxcbiAgb25UcmFuc2l0aW9uRW5kOiBmdW5jdGlvbiBvblRyYW5zaXRpb25FbmQoZSkge1xcbiAgICB2YXIgc3dpcGVyID0gdGhpcztcXG4gICAgaWYgKCFzd2lwZXIgfHwgc3dpcGVyLmRlc3Ryb3llZCB8fCAhc3dpcGVyLiR3cmFwcGVyRWwpIHJldHVybjtcXG4gICAgaWYgKGUudGFyZ2V0ICE9PSBzd2lwZXIuJHdyYXBwZXJFbFswXSkgcmV0dXJuO1xcbiAgICBbJ3RyYW5zaXRpb25lbmQnLCAnd2Via2l0VHJhbnNpdGlvbkVuZCddLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XFxuICAgICAgc3dpcGVyLiR3cmFwcGVyRWxbMF0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgc3dpcGVyLmF1dG9wbGF5Lm9uVHJhbnNpdGlvbkVuZCk7XFxuICAgIH0pO1xcbiAgICBzd2lwZXIuYXV0b3BsYXkucGF1c2VkID0gZmFsc2U7XFxuXFxuICAgIGlmICghc3dpcGVyLmF1dG9wbGF5LnJ1bm5pbmcpIHtcXG4gICAgICBzd2lwZXIuYXV0b3BsYXkuc3RvcCgpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHN3aXBlci5hdXRvcGxheS5ydW4oKTtcXG4gICAgfVxcbiAgfSxcXG4gIG9uTW91c2VFbnRlcjogZnVuY3Rpb24gb25Nb3VzZUVudGVyKCkge1xcbiAgICB2YXIgc3dpcGVyID0gdGhpcztcXG5cXG4gICAgaWYgKHN3aXBlci5wYXJhbXMuYXV0b3BsYXkuZGlzYWJsZU9uSW50ZXJhY3Rpb24pIHtcXG4gICAgICBzd2lwZXIuYXV0b3BsYXkuc3RvcCgpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHN3aXBlci5hdXRvcGxheS5wYXVzZSgpO1xcbiAgICB9XFxuXFxuICAgIFsndHJhbnNpdGlvbmVuZCcsICd3ZWJraXRUcmFuc2l0aW9uRW5kJ10uZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcXG4gICAgICBzd2lwZXIuJHdyYXBwZXJFbFswXS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBzd2lwZXIuYXV0b3BsYXkub25UcmFuc2l0aW9uRW5kKTtcXG4gICAgfSk7XFxuICB9LFxcbiAgb25Nb3VzZUxlYXZlOiBmdW5jdGlvbiBvbk1vdXNlTGVhdmUoKSB7XFxuICAgIHZhciBzd2lwZXIgPSB0aGlzO1xcblxcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy5hdXRvcGxheS5kaXNhYmxlT25JbnRlcmFjdGlvbikge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICBzd2lwZXIuYXV0b3BsYXkucGF1c2VkID0gZmFsc2U7XFxuICAgIHN3aXBlci5hdXRvcGxheS5ydW4oKTtcXG4gIH0sXFxuICBhdHRhY2hNb3VzZUV2ZW50czogZnVuY3Rpb24gYXR0YWNoTW91c2VFdmVudHMoKSB7XFxuICAgIHZhciBzd2lwZXIgPSB0aGlzO1xcblxcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy5hdXRvcGxheS5wYXVzZU9uTW91c2VFbnRlcikge1xcbiAgICAgIHN3aXBlci4kZWwub24oJ21vdXNlZW50ZXInLCBzd2lwZXIuYXV0b3BsYXkub25Nb3VzZUVudGVyKTtcXG4gICAgICBzd2lwZXIuJGVsLm9uKCdtb3VzZWxlYXZlJywgc3dpcGVyLmF1dG9wbGF5Lm9uTW91c2VMZWF2ZSk7XFxuICAgIH1cXG4gIH0sXFxuICBkZXRhY2hNb3VzZUV2ZW50czogZnVuY3Rpb24gZGV0YWNoTW91c2VFdmVudHMoKSB7XFxuICAgIHZhciBzd2lwZXIgPSB0aGlzO1xcbiAgICBzd2lwZXIuJGVsLm9mZignbW91c2VlbnRlcicsIHN3aXBlci5hdXRvcGxheS5vbk1vdXNlRW50ZXIpO1xcbiAgICBzd2lwZXIuJGVsLm9mZignbW91c2VsZWF2ZScsIHN3aXBlci5hdXRvcGxheS5vbk1vdXNlTGVhdmUpO1xcbiAgfVxcbn07XFxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBfX1dFQlBBQ0tfREVGQVVMVF9FWFBPUlRfXyA9ICh7XFxuICBuYW1lOiAnYXV0b3BsYXknLFxcbiAgcGFyYW1zOiB7XFxuICAgIGF1dG9wbGF5OiB7XFxuICAgICAgZW5hYmxlZDogZmFsc2UsXFxuICAgICAgZGVsYXk6IDMwMDAsXFxuICAgICAgd2FpdEZvclRyYW5zaXRpb246IHRydWUsXFxuICAgICAgZGlzYWJsZU9uSW50ZXJhY3Rpb246IHRydWUsXFxuICAgICAgc3RvcE9uTGFzdFNsaWRlOiBmYWxzZSxcXG4gICAgICByZXZlcnNlRGlyZWN0aW9uOiBmYWxzZSxcXG4gICAgICBwYXVzZU9uTW91c2VFbnRlcjogZmFsc2VcXG4gICAgfVxcbiAgfSxcXG4gIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKCkge1xcbiAgICB2YXIgc3dpcGVyID0gdGhpcztcXG4gICAgKDAsX3V0aWxzX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uYmluZE1vZHVsZU1ldGhvZHMpKHN3aXBlciwge1xcbiAgICAgIGF1dG9wbGF5OiBfZXh0ZW5kcyh7fSwgQXV0b3BsYXksIHtcXG4gICAgICAgIHJ1bm5pbmc6IGZhbHNlLFxcbiAgICAgICAgcGF1c2VkOiBmYWxzZVxcbiAgICAgIH0pXFxuICAgIH0pO1xcbiAgfSxcXG4gIG9uOiB7XFxuICAgIGluaXQ6IGZ1bmN0aW9uIGluaXQoc3dpcGVyKSB7XFxuICAgICAgaWYgKHN3aXBlci5wYXJhbXMuYXV0b3BsYXkuZW5hYmxlZCkge1xcbiAgICAgICAgc3dpcGVyLmF1dG9wbGF5LnN0YXJ0KCk7XFxuICAgICAgICB2YXIgZG9jdW1lbnQgPSAoMCxzc3Jfd2luZG93X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uZ2V0RG9jdW1lbnQpKCk7XFxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgc3dpcGVyLmF1dG9wbGF5Lm9uVmlzaWJpbGl0eUNoYW5nZSk7XFxuICAgICAgICBzd2lwZXIuYXV0b3BsYXkuYXR0YWNoTW91c2VFdmVudHMoKTtcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIGJlZm9yZVRyYW5zaXRpb25TdGFydDogZnVuY3Rpb24gYmVmb3JlVHJhbnNpdGlvblN0YXJ0KHN3aXBlciwgc3BlZWQsIGludGVybmFsKSB7XFxuICAgICAgaWYgKHN3aXBlci5hdXRvcGxheS5ydW5uaW5nKSB7XFxuICAgICAgICBpZiAoaW50ZXJuYWwgfHwgIXN3aXBlci5wYXJhbXMuYXV0b3BsYXkuZGlzYWJsZU9uSW50ZXJhY3Rpb24pIHtcXG4gICAgICAgICAgc3dpcGVyLmF1dG9wbGF5LnBhdXNlKHNwZWVkKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHN3aXBlci5hdXRvcGxheS5zdG9wKCk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9LFxcbiAgICBzbGlkZXJGaXJzdE1vdmU6IGZ1bmN0aW9uIHNsaWRlckZpcnN0TW92ZShzd2lwZXIpIHtcXG4gICAgICBpZiAoc3dpcGVyLmF1dG9wbGF5LnJ1bm5pbmcpIHtcXG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmF1dG9wbGF5LmRpc2FibGVPbkludGVyYWN0aW9uKSB7XFxuICAgICAgICAgIHN3aXBlci5hdXRvcGxheS5zdG9wKCk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBzd2lwZXIuYXV0b3BsYXkucGF1c2UoKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH0sXFxuICAgIHRvdWNoRW5kOiBmdW5jdGlvbiB0b3VjaEVuZChzd2lwZXIpIHtcXG4gICAgICBpZiAoc3dpcGVyLnBhcmFtcy5jc3NNb2RlICYmIHN3aXBlci5hdXRvcGxheS5wYXVzZWQgJiYgIXN3aXBlci5wYXJhbXMuYXV0b3BsYXkuZGlzYWJsZU9uSW50ZXJhY3Rpb24pIHtcXG4gICAgICAgIHN3aXBlci5hdXRvcGxheS5ydW4oKTtcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koc3dpcGVyKSB7XFxuICAgICAgc3dpcGVyLmF1dG9wbGF5LmRldGFjaE1vdXNlRXZlbnRzKCk7XFxuXFxuICAgICAgaWYgKHN3aXBlci5hdXRvcGxheS5ydW5uaW5nKSB7XFxuICAgICAgICBzd2lwZXIuYXV0b3BsYXkuc3RvcCgpO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgZG9jdW1lbnQgPSAoMCxzc3Jfd2luZG93X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uZ2V0RG9jdW1lbnQpKCk7XFxuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIHN3aXBlci5hdXRvcGxheS5vblZpc2liaWxpdHlDaGFuZ2UpO1xcbiAgICB9XFxuICB9XFxufSk7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vcGFydXMvLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2F1dG9wbGF5L2F1dG9wbGF5LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvYnJlYWtwb2ludHMvZ2V0QnJlYWtwb2ludC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL2JyZWFrcG9pbnRzL2dldEJyZWFrcG9pbnQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwiZGVmYXVsdFxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIGdldEJyZWFrcG9pbnQpXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHNzci13aW5kb3cgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3Nzci13aW5kb3cvc3NyLXdpbmRvdy5lc20uanNcXFwiKTtcXG5cXG5mdW5jdGlvbiBnZXRCcmVha3BvaW50KGJyZWFrcG9pbnRzLCBiYXNlLCBjb250YWluZXJFbCkge1xcbiAgaWYgKGJhc2UgPT09IHZvaWQgMCkge1xcbiAgICBiYXNlID0gJ3dpbmRvdyc7XFxuICB9XFxuXFxuICBpZiAoIWJyZWFrcG9pbnRzIHx8IGJhc2UgPT09ICdjb250YWluZXInICYmICFjb250YWluZXJFbCkgcmV0dXJuIHVuZGVmaW5lZDtcXG4gIHZhciBicmVha3BvaW50ID0gZmFsc2U7XFxuICB2YXIgd2luZG93ID0gKDAsc3NyX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmdldFdpbmRvdykoKTtcXG4gIHZhciBjdXJyZW50SGVpZ2h0ID0gYmFzZSA9PT0gJ3dpbmRvdycgPyB3aW5kb3cuaW5uZXJIZWlnaHQgOiBjb250YWluZXJFbC5jbGllbnRIZWlnaHQ7XFxuICB2YXIgcG9pbnRzID0gT2JqZWN0LmtleXMoYnJlYWtwb2ludHMpLm1hcChmdW5jdGlvbiAocG9pbnQpIHtcXG4gICAgaWYgKHR5cGVvZiBwb2ludCA9PT0gJ3N0cmluZycgJiYgcG9pbnQuaW5kZXhPZignQCcpID09PSAwKSB7XFxuICAgICAgdmFyIG1pblJhdGlvID0gcGFyc2VGbG9hdChwb2ludC5zdWJzdHIoMSkpO1xcbiAgICAgIHZhciB2YWx1ZSA9IGN1cnJlbnRIZWlnaHQgKiBtaW5SYXRpbztcXG4gICAgICByZXR1cm4ge1xcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxcbiAgICAgICAgcG9pbnQ6IHBvaW50XFxuICAgICAgfTtcXG4gICAgfVxcblxcbiAgICByZXR1cm4ge1xcbiAgICAgIHZhbHVlOiBwb2ludCxcXG4gICAgICBwb2ludDogcG9pbnRcXG4gICAgfTtcXG4gIH0pO1xcbiAgcG9pbnRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgcmV0dXJuIHBhcnNlSW50KGEudmFsdWUsIDEwKSAtIHBhcnNlSW50KGIudmFsdWUsIDEwKTtcXG4gIH0pO1xcblxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpICs9IDEpIHtcXG4gICAgdmFyIF9wb2ludHMkaSA9IHBvaW50c1tpXSxcXG4gICAgICAgIHBvaW50ID0gX3BvaW50cyRpLnBvaW50LFxcbiAgICAgICAgdmFsdWUgPSBfcG9pbnRzJGkudmFsdWU7XFxuXFxuICAgIGlmIChiYXNlID09PSAnd2luZG93Jykge1xcbiAgICAgIGlmICh3aW5kb3cubWF0Y2hNZWRpYShcXFwiKG1pbi13aWR0aDogXFxcIiArIHZhbHVlICsgXFxcInB4KVxcXCIpLm1hdGNoZXMpIHtcXG4gICAgICAgIGJyZWFrcG9pbnQgPSBwb2ludDtcXG4gICAgICB9XFxuICAgIH0gZWxzZSBpZiAodmFsdWUgPD0gY29udGFpbmVyRWwuY2xpZW50V2lkdGgpIHtcXG4gICAgICBicmVha3BvaW50ID0gcG9pbnQ7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiBicmVha3BvaW50IHx8ICdtYXgnO1xcbn1cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9wYXJ1cy8uL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS9icmVha3BvaW50cy9nZXRCcmVha3BvaW50LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvYnJlYWtwb2ludHMvaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvYnJlYWtwb2ludHMvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcImRlZmF1bHRcXFwiOiAoKSA9PiAoX19XRUJQQUNLX0RFRkFVTFRfRVhQT1JUX18pXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zZXRCcmVha3BvaW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NldEJyZWFrcG9pbnQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL2JyZWFrcG9pbnRzL3NldEJyZWFrcG9pbnQuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2dldEJyZWFrcG9pbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ2V0QnJlYWtwb2ludCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvYnJlYWtwb2ludHMvZ2V0QnJlYWtwb2ludC5qc1xcXCIpO1xcblxcblxcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgX19XRUJQQUNLX0RFRkFVTFRfRVhQT1JUX18gPSAoe1xcbiAgc2V0QnJlYWtwb2ludDogX3NldEJyZWFrcG9pbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiZGVmYXVsdFxcXCJdLFxcbiAgZ2V0QnJlYWtwb2ludDogX2dldEJyZWFrcG9pbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiZGVmYXVsdFxcXCJdXFxufSk7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vcGFydXMvLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvYnJlYWtwb2ludHMvaW5kZXguanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS9icmVha3BvaW50cy9zZXRCcmVha3BvaW50LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvYnJlYWtwb2ludHMvc2V0QnJlYWtwb2ludC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJkZWZhdWx0XFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gc2V0QnJlYWtwb2ludClcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi8uLi91dGlscy91dGlscyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS91dGlscy91dGlscy5qc1xcXCIpO1xcblxcbmZ1bmN0aW9uIHNldEJyZWFrcG9pbnQoKSB7XFxuICB2YXIgc3dpcGVyID0gdGhpcztcXG4gIHZhciBhY3RpdmVJbmRleCA9IHN3aXBlci5hY3RpdmVJbmRleCxcXG4gICAgICBpbml0aWFsaXplZCA9IHN3aXBlci5pbml0aWFsaXplZCxcXG4gICAgICBfc3dpcGVyJGxvb3BlZFNsaWRlcyA9IHN3aXBlci5sb29wZWRTbGlkZXMsXFxuICAgICAgbG9vcGVkU2xpZGVzID0gX3N3aXBlciRsb29wZWRTbGlkZXMgPT09IHZvaWQgMCA/IDAgOiBfc3dpcGVyJGxvb3BlZFNsaWRlcyxcXG4gICAgICBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLFxcbiAgICAgICRlbCA9IHN3aXBlci4kZWw7XFxuICB2YXIgYnJlYWtwb2ludHMgPSBwYXJhbXMuYnJlYWtwb2ludHM7XFxuICBpZiAoIWJyZWFrcG9pbnRzIHx8IGJyZWFrcG9pbnRzICYmIE9iamVjdC5rZXlzKGJyZWFrcG9pbnRzKS5sZW5ndGggPT09IDApIHJldHVybjsgLy8gR2V0IGJyZWFrcG9pbnQgZm9yIHdpbmRvdyB3aWR0aCBhbmQgdXBkYXRlIHBhcmFtZXRlcnNcXG5cXG4gIHZhciBicmVha3BvaW50ID0gc3dpcGVyLmdldEJyZWFrcG9pbnQoYnJlYWtwb2ludHMsIHN3aXBlci5wYXJhbXMuYnJlYWtwb2ludHNCYXNlLCBzd2lwZXIuZWwpO1xcbiAgaWYgKCFicmVha3BvaW50IHx8IHN3aXBlci5jdXJyZW50QnJlYWtwb2ludCA9PT0gYnJlYWtwb2ludCkgcmV0dXJuO1xcbiAgdmFyIGJyZWFrcG9pbnRPbmx5UGFyYW1zID0gYnJlYWtwb2ludCBpbiBicmVha3BvaW50cyA/IGJyZWFrcG9pbnRzW2JyZWFrcG9pbnRdIDogdW5kZWZpbmVkO1xcblxcbiAgaWYgKGJyZWFrcG9pbnRPbmx5UGFyYW1zKSB7XFxuICAgIFsnc2xpZGVzUGVyVmlldycsICdzcGFjZUJldHdlZW4nLCAnc2xpZGVzUGVyR3JvdXAnLCAnc2xpZGVzUGVyR3JvdXBTa2lwJywgJ3NsaWRlc1BlckNvbHVtbiddLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtKSB7XFxuICAgICAgdmFyIHBhcmFtVmFsdWUgPSBicmVha3BvaW50T25seVBhcmFtc1twYXJhbV07XFxuICAgICAgaWYgKHR5cGVvZiBwYXJhbVZhbHVlID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xcblxcbiAgICAgIGlmIChwYXJhbSA9PT0gJ3NsaWRlc1BlclZpZXcnICYmIChwYXJhbVZhbHVlID09PSAnQVVUTycgfHwgcGFyYW1WYWx1ZSA9PT0gJ2F1dG8nKSkge1xcbiAgICAgICAgYnJlYWtwb2ludE9ubHlQYXJhbXNbcGFyYW1dID0gJ2F1dG8nO1xcbiAgICAgIH0gZWxzZSBpZiAocGFyYW0gPT09ICdzbGlkZXNQZXJWaWV3Jykge1xcbiAgICAgICAgYnJlYWtwb2ludE9ubHlQYXJhbXNbcGFyYW1dID0gcGFyc2VGbG9hdChwYXJhbVZhbHVlKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgYnJlYWtwb2ludE9ubHlQYXJhbXNbcGFyYW1dID0gcGFyc2VJbnQocGFyYW1WYWx1ZSwgMTApO1xcbiAgICAgIH1cXG4gICAgfSk7XFxuICB9XFxuXFxuICB2YXIgYnJlYWtwb2ludFBhcmFtcyA9IGJyZWFrcG9pbnRPbmx5UGFyYW1zIHx8IHN3aXBlci5vcmlnaW5hbFBhcmFtcztcXG4gIHZhciB3YXNNdWx0aVJvdyA9IHBhcmFtcy5zbGlkZXNQZXJDb2x1bW4gPiAxO1xcbiAgdmFyIGlzTXVsdGlSb3cgPSBicmVha3BvaW50UGFyYW1zLnNsaWRlc1BlckNvbHVtbiA+IDE7XFxuICB2YXIgd2FzRW5hYmxlZCA9IHBhcmFtcy5lbmFibGVkO1xcblxcbiAgaWYgKHdhc011bHRpUm93ICYmICFpc011bHRpUm93KSB7XFxuICAgICRlbC5yZW1vdmVDbGFzcyhwYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzcyArIFxcXCJtdWx0aXJvdyBcXFwiICsgcGFyYW1zLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3MgKyBcXFwibXVsdGlyb3ctY29sdW1uXFxcIik7XFxuICAgIHN3aXBlci5lbWl0Q29udGFpbmVyQ2xhc3NlcygpO1xcbiAgfSBlbHNlIGlmICghd2FzTXVsdGlSb3cgJiYgaXNNdWx0aVJvdykge1xcbiAgICAkZWwuYWRkQ2xhc3MocGFyYW1zLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3MgKyBcXFwibXVsdGlyb3dcXFwiKTtcXG5cXG4gICAgaWYgKGJyZWFrcG9pbnRQYXJhbXMuc2xpZGVzUGVyQ29sdW1uRmlsbCAmJiBicmVha3BvaW50UGFyYW1zLnNsaWRlc1BlckNvbHVtbkZpbGwgPT09ICdjb2x1bW4nIHx8ICFicmVha3BvaW50UGFyYW1zLnNsaWRlc1BlckNvbHVtbkZpbGwgJiYgcGFyYW1zLnNsaWRlc1BlckNvbHVtbkZpbGwgPT09ICdjb2x1bW4nKSB7XFxuICAgICAgJGVsLmFkZENsYXNzKHBhcmFtcy5jb250YWluZXJNb2RpZmllckNsYXNzICsgXFxcIm11bHRpcm93LWNvbHVtblxcXCIpO1xcbiAgICB9XFxuXFxuICAgIHN3aXBlci5lbWl0Q29udGFpbmVyQ2xhc3NlcygpO1xcbiAgfVxcblxcbiAgdmFyIGRpcmVjdGlvbkNoYW5nZWQgPSBicmVha3BvaW50UGFyYW1zLmRpcmVjdGlvbiAmJiBicmVha3BvaW50UGFyYW1zLmRpcmVjdGlvbiAhPT0gcGFyYW1zLmRpcmVjdGlvbjtcXG4gIHZhciBuZWVkc1JlTG9vcCA9IHBhcmFtcy5sb29wICYmIChicmVha3BvaW50UGFyYW1zLnNsaWRlc1BlclZpZXcgIT09IHBhcmFtcy5zbGlkZXNQZXJWaWV3IHx8IGRpcmVjdGlvbkNoYW5nZWQpO1xcblxcbiAgaWYgKGRpcmVjdGlvbkNoYW5nZWQgJiYgaW5pdGlhbGl6ZWQpIHtcXG4gICAgc3dpcGVyLmNoYW5nZURpcmVjdGlvbigpO1xcbiAgfVxcblxcbiAgKDAsX3V0aWxzX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uZXh0ZW5kKShzd2lwZXIucGFyYW1zLCBicmVha3BvaW50UGFyYW1zKTtcXG4gIHZhciBpc0VuYWJsZWQgPSBzd2lwZXIucGFyYW1zLmVuYWJsZWQ7XFxuICAoMCxfdXRpbHNfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5leHRlbmQpKHN3aXBlciwge1xcbiAgICBhbGxvd1RvdWNoTW92ZTogc3dpcGVyLnBhcmFtcy5hbGxvd1RvdWNoTW92ZSxcXG4gICAgYWxsb3dTbGlkZU5leHQ6IHN3aXBlci5wYXJhbXMuYWxsb3dTbGlkZU5leHQsXFxuICAgIGFsbG93U2xpZGVQcmV2OiBzd2lwZXIucGFyYW1zLmFsbG93U2xpZGVQcmV2XFxuICB9KTtcXG5cXG4gIGlmICh3YXNFbmFibGVkICYmICFpc0VuYWJsZWQpIHtcXG4gICAgc3dpcGVyLmRpc2FibGUoKTtcXG4gIH0gZWxzZSBpZiAoIXdhc0VuYWJsZWQgJiYgaXNFbmFibGVkKSB7XFxuICAgIHN3aXBlci5lbmFibGUoKTtcXG4gIH1cXG5cXG4gIHN3aXBlci5jdXJyZW50QnJlYWtwb2ludCA9IGJyZWFrcG9pbnQ7XFxuICBzd2lwZXIuZW1pdCgnX2JlZm9yZUJyZWFrcG9pbnQnLCBicmVha3BvaW50UGFyYW1zKTtcXG5cXG4gIGlmIChuZWVkc1JlTG9vcCAmJiBpbml0aWFsaXplZCkge1xcbiAgICBzd2lwZXIubG9vcERlc3Ryb3koKTtcXG4gICAgc3dpcGVyLmxvb3BDcmVhdGUoKTtcXG4gICAgc3dpcGVyLnVwZGF0ZVNsaWRlcygpO1xcbiAgICBzd2lwZXIuc2xpZGVUbyhhY3RpdmVJbmRleCAtIGxvb3BlZFNsaWRlcyArIHN3aXBlci5sb29wZWRTbGlkZXMsIDAsIGZhbHNlKTtcXG4gIH1cXG5cXG4gIHN3aXBlci5lbWl0KCdicmVha3BvaW50JywgYnJlYWtwb2ludFBhcmFtcyk7XFxufVxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3BhcnVzLy4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL2JyZWFrcG9pbnRzL3NldEJyZWFrcG9pbnQuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS9jaGVjay1vdmVyZmxvdy9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS9jaGVjay1vdmVyZmxvdy9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwiZGVmYXVsdFxcXCI6ICgpID0+IChfX1dFQlBBQ0tfREVGQVVMVF9FWFBPUlRfXylcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG5mdW5jdGlvbiBjaGVja092ZXJmbG93KCkge1xcbiAgdmFyIHN3aXBlciA9IHRoaXM7XFxuICB2YXIgcGFyYW1zID0gc3dpcGVyLnBhcmFtcztcXG4gIHZhciB3YXNMb2NrZWQgPSBzd2lwZXIuaXNMb2NrZWQ7XFxuICB2YXIgbGFzdFNsaWRlUG9zaXRpb24gPSBzd2lwZXIuc2xpZGVzLmxlbmd0aCA+IDAgJiYgcGFyYW1zLnNsaWRlc09mZnNldEJlZm9yZSArIHBhcmFtcy5zcGFjZUJldHdlZW4gKiAoc3dpcGVyLnNsaWRlcy5sZW5ndGggLSAxKSArIHN3aXBlci5zbGlkZXNbMF0ub2Zmc2V0V2lkdGggKiBzd2lwZXIuc2xpZGVzLmxlbmd0aDtcXG5cXG4gIGlmIChwYXJhbXMuc2xpZGVzT2Zmc2V0QmVmb3JlICYmIHBhcmFtcy5zbGlkZXNPZmZzZXRBZnRlciAmJiBsYXN0U2xpZGVQb3NpdGlvbikge1xcbiAgICBzd2lwZXIuaXNMb2NrZWQgPSBsYXN0U2xpZGVQb3NpdGlvbiA8PSBzd2lwZXIuc2l6ZTtcXG4gIH0gZWxzZSB7XFxuICAgIHN3aXBlci5pc0xvY2tlZCA9IHN3aXBlci5zbmFwR3JpZC5sZW5ndGggPT09IDE7XFxuICB9XFxuXFxuICBzd2lwZXIuYWxsb3dTbGlkZU5leHQgPSAhc3dpcGVyLmlzTG9ja2VkO1xcbiAgc3dpcGVyLmFsbG93U2xpZGVQcmV2ID0gIXN3aXBlci5pc0xvY2tlZDsgLy8gZXZlbnRzXFxuXFxuICBpZiAod2FzTG9ja2VkICE9PSBzd2lwZXIuaXNMb2NrZWQpIHN3aXBlci5lbWl0KHN3aXBlci5pc0xvY2tlZCA/ICdsb2NrJyA6ICd1bmxvY2snKTtcXG5cXG4gIGlmICh3YXNMb2NrZWQgJiYgd2FzTG9ja2VkICE9PSBzd2lwZXIuaXNMb2NrZWQpIHtcXG4gICAgc3dpcGVyLmlzRW5kID0gZmFsc2U7XFxuICAgIGlmIChzd2lwZXIubmF2aWdhdGlvbikgc3dpcGVyLm5hdmlnYXRpb24udXBkYXRlKCk7XFxuICB9XFxufVxcblxcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgX19XRUJQQUNLX0RFRkFVTFRfRVhQT1JUX18gPSAoe1xcbiAgY2hlY2tPdmVyZmxvdzogY2hlY2tPdmVyZmxvd1xcbn0pO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3BhcnVzLy4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL2NoZWNrLW92ZXJmbG93L2luZGV4LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvY2xhc3Nlcy9hZGRDbGFzc2VzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS9jbGFzc2VzL2FkZENsYXNzZXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJkZWZhdWx0XFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gYWRkQ2xhc3NlcylcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG5mdW5jdGlvbiBwcmVwYXJlQ2xhc3NlcyhlbnRyaWVzLCBwcmVmaXgpIHtcXG4gIHZhciByZXN1bHRDbGFzc2VzID0gW107XFxuICBlbnRyaWVzLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcXG4gICAgaWYgKHR5cGVvZiBpdGVtID09PSAnb2JqZWN0Jykge1xcbiAgICAgIE9iamVjdC5rZXlzKGl0ZW0pLmZvckVhY2goZnVuY3Rpb24gKGNsYXNzTmFtZXMpIHtcXG4gICAgICAgIGlmIChpdGVtW2NsYXNzTmFtZXNdKSB7XFxuICAgICAgICAgIHJlc3VsdENsYXNzZXMucHVzaChwcmVmaXggKyBjbGFzc05hbWVzKTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycpIHtcXG4gICAgICByZXN1bHRDbGFzc2VzLnB1c2gocHJlZml4ICsgaXRlbSk7XFxuICAgIH1cXG4gIH0pO1xcbiAgcmV0dXJuIHJlc3VsdENsYXNzZXM7XFxufVxcblxcbmZ1bmN0aW9uIGFkZENsYXNzZXMoKSB7XFxuICB2YXIgc3dpcGVyID0gdGhpcztcXG4gIHZhciBjbGFzc05hbWVzID0gc3dpcGVyLmNsYXNzTmFtZXMsXFxuICAgICAgcGFyYW1zID0gc3dpcGVyLnBhcmFtcyxcXG4gICAgICBydGwgPSBzd2lwZXIucnRsLFxcbiAgICAgICRlbCA9IHN3aXBlci4kZWwsXFxuICAgICAgZGV2aWNlID0gc3dpcGVyLmRldmljZSxcXG4gICAgICBzdXBwb3J0ID0gc3dpcGVyLnN1cHBvcnQ7IC8vIHByZXR0aWVyLWlnbm9yZVxcblxcbiAgdmFyIHN1ZmZpeGVzID0gcHJlcGFyZUNsYXNzZXMoWydpbml0aWFsaXplZCcsIHBhcmFtcy5kaXJlY3Rpb24sIHtcXG4gICAgJ3BvaW50ZXItZXZlbnRzJzogc3VwcG9ydC5wb2ludGVyRXZlbnRzICYmICFzdXBwb3J0LnRvdWNoXFxuICB9LCB7XFxuICAgICdmcmVlLW1vZGUnOiBwYXJhbXMuZnJlZU1vZGVcXG4gIH0sIHtcXG4gICAgJ2F1dG9oZWlnaHQnOiBwYXJhbXMuYXV0b0hlaWdodFxcbiAgfSwge1xcbiAgICAncnRsJzogcnRsXFxuICB9LCB7XFxuICAgICdtdWx0aXJvdyc6IHBhcmFtcy5zbGlkZXNQZXJDb2x1bW4gPiAxXFxuICB9LCB7XFxuICAgICdtdWx0aXJvdy1jb2x1bW4nOiBwYXJhbXMuc2xpZGVzUGVyQ29sdW1uID4gMSAmJiBwYXJhbXMuc2xpZGVzUGVyQ29sdW1uRmlsbCA9PT0gJ2NvbHVtbidcXG4gIH0sIHtcXG4gICAgJ2FuZHJvaWQnOiBkZXZpY2UuYW5kcm9pZFxcbiAgfSwge1xcbiAgICAnaW9zJzogZGV2aWNlLmlvc1xcbiAgfSwge1xcbiAgICAnY3NzLW1vZGUnOiBwYXJhbXMuY3NzTW9kZVxcbiAgfV0sIHBhcmFtcy5jb250YWluZXJNb2RpZmllckNsYXNzKTtcXG4gIGNsYXNzTmFtZXMucHVzaC5hcHBseShjbGFzc05hbWVzLCBzdWZmaXhlcyk7XFxuICAkZWwuYWRkQ2xhc3MoW10uY29uY2F0KGNsYXNzTmFtZXMpLmpvaW4oJyAnKSk7XFxuICBzd2lwZXIuZW1pdENvbnRhaW5lckNsYXNzZXMoKTtcXG59XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vcGFydXMvLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvY2xhc3Nlcy9hZGRDbGFzc2VzLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvY2xhc3Nlcy9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL2NsYXNzZXMvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwiZGVmYXVsdFxcXCI6ICgpID0+IChfX1dFQlBBQ0tfREVGQVVMVF9FWFBPUlRfXylcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2FkZENsYXNzZXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vYWRkQ2xhc3NlcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvY2xhc3Nlcy9hZGRDbGFzc2VzLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9yZW1vdmVDbGFzc2VzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3JlbW92ZUNsYXNzZXMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL2NsYXNzZXMvcmVtb3ZlQ2xhc3Nlcy5qc1xcXCIpO1xcblxcblxcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgX19XRUJQQUNLX0RFRkFVTFRfRVhQT1JUX18gPSAoe1xcbiAgYWRkQ2xhc3NlczogX2FkZENsYXNzZXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiZGVmYXVsdFxcXCJdLFxcbiAgcmVtb3ZlQ2xhc3NlczogX3JlbW92ZUNsYXNzZXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiZGVmYXVsdFxcXCJdXFxufSk7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vcGFydXMvLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvY2xhc3Nlcy9pbmRleC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL2NsYXNzZXMvcmVtb3ZlQ2xhc3Nlcy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvY2xhc3Nlcy9yZW1vdmVDbGFzc2VzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwiZGVmYXVsdFxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIHJlbW92ZUNsYXNzZXMpXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuZnVuY3Rpb24gcmVtb3ZlQ2xhc3NlcygpIHtcXG4gIHZhciBzd2lwZXIgPSB0aGlzO1xcbiAgdmFyICRlbCA9IHN3aXBlci4kZWwsXFxuICAgICAgY2xhc3NOYW1lcyA9IHN3aXBlci5jbGFzc05hbWVzO1xcbiAgJGVsLnJlbW92ZUNsYXNzKGNsYXNzTmFtZXMuam9pbignICcpKTtcXG4gIHN3aXBlci5lbWl0Q29udGFpbmVyQ2xhc3NlcygpO1xcbn1cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9wYXJ1cy8uL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS9jbGFzc2VzL3JlbW92ZUNsYXNzZXMuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS9jb3JlLWNsYXNzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvY29yZS1jbGFzcy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJkZWZhdWx0XFxcIjogKCkgPT4gKF9fV0VCUEFDS19ERUZBVUxUX0VYUE9SVF9fKVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBzc3Jfd2luZG93X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBzc3Itd2luZG93ICovIFxcXCIuL25vZGVfbW9kdWxlcy9zc3Itd2luZG93L3Nzci13aW5kb3cuZXNtLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19kb21fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3V0aWxzL2RvbSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS91dGlscy9kb20uanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vdXRpbHMvdXRpbHMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vdXRpbHMvdXRpbHMuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2dldF9zdXBwb3J0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xN19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vdXRpbHMvZ2V0LXN1cHBvcnQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vdXRpbHMvZ2V0LXN1cHBvcnQuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2dldF9kZXZpY2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE4X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi91dGlscy9nZXQtZGV2aWNlICovIFxcXCIuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL3V0aWxzL2dldC1kZXZpY2UuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2dldF9icm93c2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xOV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vdXRpbHMvZ2V0LWJyb3dzZXIgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vdXRpbHMvZ2V0LWJyb3dzZXIuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21vZHVsZXNfcmVzaXplX3Jlc2l6ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMjFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21vZHVsZXMvcmVzaXplL3Jlc2l6ZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9tb2R1bGVzL3Jlc2l6ZS9yZXNpemUuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21vZHVsZXNfb2JzZXJ2ZXJfb2JzZXJ2ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzIyX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9tb2R1bGVzL29ic2VydmVyL29ic2VydmVyICovIFxcXCIuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL21vZHVsZXMvb2JzZXJ2ZXIvb2JzZXJ2ZXIuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21vZHVsYXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbW9kdWxhciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvbW9kdWxhci5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXZlbnRzX2VtaXR0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZXZlbnRzLWVtaXR0ZXIgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL2V2ZW50cy1lbWl0dGVyLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91cGRhdGVfaW5kZXhfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXBkYXRlL2luZGV4ICovIFxcXCIuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS91cGRhdGUvaW5kZXguanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3RyYW5zbGF0ZV9pbmRleF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90cmFuc2xhdGUvaW5kZXggKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL3RyYW5zbGF0ZS9pbmRleC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHJhbnNpdGlvbl9pbmRleF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90cmFuc2l0aW9uL2luZGV4ICovIFxcXCIuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS90cmFuc2l0aW9uL2luZGV4LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zbGlkZV9pbmRleF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zbGlkZS9pbmRleCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvc2xpZGUvaW5kZXguanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2xvb3BfaW5kZXhfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbG9vcC9pbmRleCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvbG9vcC9pbmRleC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZ3JhYl9jdXJzb3JfaW5kZXhfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ3JhYi1jdXJzb3IvaW5kZXggKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL2dyYWItY3Vyc29yL2luZGV4LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9tYW5pcHVsYXRpb25faW5kZXhfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL21hbmlwdWxhdGlvbi9pbmRleCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvbWFuaXB1bGF0aW9uL2luZGV4LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ldmVudHNfaW5kZXhfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzExX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2V2ZW50cy9pbmRleCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvZXZlbnRzL2luZGV4LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9icmVha3BvaW50c19pbmRleF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vYnJlYWtwb2ludHMvaW5kZXggKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL2JyZWFrcG9pbnRzL2luZGV4LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jbGFzc2VzX2luZGV4X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jbGFzc2VzL2luZGV4ICovIFxcXCIuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS9jbGFzc2VzL2luZGV4LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9pbWFnZXNfaW5kZXhfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE1X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ltYWdlcy9pbmRleCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvaW1hZ2VzL2luZGV4LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jaGVja19vdmVyZmxvd19pbmRleF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY2hlY2stb3ZlcmZsb3cvaW5kZXggKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL2NoZWNrLW92ZXJmbG93L2luZGV4LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kZWZhdWx0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMjBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZGVmYXVsdHMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL2RlZmF1bHRzLmpzXFxcIik7XFxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXFxcInZhbHVlXFxcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cXG5cXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxcblxcbi8qIGVzbGludCBuby1wYXJhbS1yZWFzc2lnbjogXFxcIm9mZlxcXCIgKi9cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG52YXIgcHJvdG90eXBlcyA9IHtcXG4gIG1vZHVsYXI6IF9tb2R1bGFyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcImRlZmF1bHRcXFwiXSxcXG4gIGV2ZW50c0VtaXR0ZXI6IF9ldmVudHNfZW1pdHRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1xcXCJkZWZhdWx0XFxcIl0sXFxuICB1cGRhdGU6IF91cGRhdGVfaW5kZXhfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcXFwiZGVmYXVsdFxcXCJdLFxcbiAgdHJhbnNsYXRlOiBfdHJhbnNsYXRlX2luZGV4X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXFxcImRlZmF1bHRcXFwiXSxcXG4gIHRyYW5zaXRpb246IF90cmFuc2l0aW9uX2luZGV4X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXFxcImRlZmF1bHRcXFwiXSxcXG4gIHNsaWRlOiBfc2xpZGVfaW5kZXhfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcXFwiZGVmYXVsdFxcXCJdLFxcbiAgbG9vcDogX2xvb3BfaW5kZXhfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX1tcXFwiZGVmYXVsdFxcXCJdLFxcbiAgZ3JhYkN1cnNvcjogX2dyYWJfY3Vyc29yX2luZGV4X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X19bXFxcImRlZmF1bHRcXFwiXSxcXG4gIG1hbmlwdWxhdGlvbjogX21hbmlwdWxhdGlvbl9pbmRleF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfX1tcXFwiZGVmYXVsdFxcXCJdLFxcbiAgZXZlbnRzOiBfZXZlbnRzX2luZGV4X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fW1xcXCJkZWZhdWx0XFxcIl0sXFxuICBicmVha3BvaW50czogX2JyZWFrcG9pbnRzX2luZGV4X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMl9fW1xcXCJkZWZhdWx0XFxcIl0sXFxuICBjaGVja092ZXJmbG93OiBfY2hlY2tfb3ZlcmZsb3dfaW5kZXhfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEzX19bXFxcImRlZmF1bHRcXFwiXSxcXG4gIGNsYXNzZXM6IF9jbGFzc2VzX2luZGV4X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNF9fW1xcXCJkZWZhdWx0XFxcIl0sXFxuICBpbWFnZXM6IF9pbWFnZXNfaW5kZXhfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE1X19bXFxcImRlZmF1bHRcXFwiXVxcbn07XFxudmFyIGV4dGVuZGVkRGVmYXVsdHMgPSB7fTtcXG5cXG52YXIgU3dpcGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcXG4gIGZ1bmN0aW9uIFN3aXBlcigpIHtcXG4gICAgdmFyIGVsO1xcbiAgICB2YXIgcGFyYW1zO1xcblxcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcXG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xcbiAgICB9XFxuXFxuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSAmJiBhcmdzWzBdLmNvbnN0cnVjdG9yICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmdzWzBdKS5zbGljZSg4LCAtMSkgPT09ICdPYmplY3QnKSB7XFxuICAgICAgcGFyYW1zID0gYXJnc1swXTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBlbCA9IGFyZ3NbMF07XFxuICAgICAgcGFyYW1zID0gYXJnc1sxXTtcXG4gICAgfVxcblxcbiAgICBpZiAoIXBhcmFtcykgcGFyYW1zID0ge307XFxuICAgIHBhcmFtcyA9ICgwLF91dGlsc191dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTZfXy5leHRlbmQpKHt9LCBwYXJhbXMpO1xcbiAgICBpZiAoZWwgJiYgIXBhcmFtcy5lbCkgcGFyYW1zLmVsID0gZWw7XFxuXFxuICAgIGlmIChwYXJhbXMuZWwgJiYgKDAsX3V0aWxzX2RvbV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJkZWZhdWx0XFxcIl0pKHBhcmFtcy5lbCkubGVuZ3RoID4gMSkge1xcbiAgICAgIHZhciBzd2lwZXJzID0gW107XFxuICAgICAgKDAsX3V0aWxzX2RvbV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJkZWZhdWx0XFxcIl0pKHBhcmFtcy5lbCkuZWFjaChmdW5jdGlvbiAoY29udGFpbmVyRWwpIHtcXG4gICAgICAgIHZhciBuZXdQYXJhbXMgPSAoMCxfdXRpbHNfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE2X18uZXh0ZW5kKSh7fSwgcGFyYW1zLCB7XFxuICAgICAgICAgIGVsOiBjb250YWluZXJFbFxcbiAgICAgICAgfSk7XFxuICAgICAgICBzd2lwZXJzLnB1c2gobmV3IFN3aXBlcihuZXdQYXJhbXMpKTtcXG4gICAgICB9KTtcXG4gICAgICByZXR1cm4gc3dpcGVycztcXG4gICAgfSAvLyBTd2lwZXIgSW5zdGFuY2VcXG5cXG5cXG4gICAgdmFyIHN3aXBlciA9IHRoaXM7XFxuICAgIHN3aXBlci5fX3N3aXBlcl9fID0gdHJ1ZTtcXG4gICAgc3dpcGVyLnN1cHBvcnQgPSAoMCxfdXRpbHNfZ2V0X3N1cHBvcnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE3X18uZ2V0U3VwcG9ydCkoKTtcXG4gICAgc3dpcGVyLmRldmljZSA9ICgwLF91dGlsc19nZXRfZGV2aWNlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xOF9fLmdldERldmljZSkoe1xcbiAgICAgIHVzZXJBZ2VudDogcGFyYW1zLnVzZXJBZ2VudFxcbiAgICB9KTtcXG4gICAgc3dpcGVyLmJyb3dzZXIgPSAoMCxfdXRpbHNfZ2V0X2Jyb3dzZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE5X18uZ2V0QnJvd3NlcikoKTtcXG4gICAgc3dpcGVyLmV2ZW50c0xpc3RlbmVycyA9IHt9O1xcbiAgICBzd2lwZXIuZXZlbnRzQW55TGlzdGVuZXJzID0gW107XFxuXFxuICAgIGlmICh0eXBlb2Ygc3dpcGVyLm1vZHVsZXMgPT09ICd1bmRlZmluZWQnKSB7XFxuICAgICAgc3dpcGVyLm1vZHVsZXMgPSB7fTtcXG4gICAgfVxcblxcbiAgICBPYmplY3Qua2V5cyhzd2lwZXIubW9kdWxlcykuZm9yRWFjaChmdW5jdGlvbiAobW9kdWxlTmFtZSkge1xcbiAgICAgIHZhciBtb2R1bGUgPSBzd2lwZXIubW9kdWxlc1ttb2R1bGVOYW1lXTtcXG5cXG4gICAgICBpZiAobW9kdWxlLnBhcmFtcykge1xcbiAgICAgICAgdmFyIG1vZHVsZVBhcmFtTmFtZSA9IE9iamVjdC5rZXlzKG1vZHVsZS5wYXJhbXMpWzBdO1xcbiAgICAgICAgdmFyIG1vZHVsZVBhcmFtcyA9IG1vZHVsZS5wYXJhbXNbbW9kdWxlUGFyYW1OYW1lXTtcXG4gICAgICAgIGlmICh0eXBlb2YgbW9kdWxlUGFyYW1zICE9PSAnb2JqZWN0JyB8fCBtb2R1bGVQYXJhbXMgPT09IG51bGwpIHJldHVybjtcXG5cXG4gICAgICAgIGlmIChbJ25hdmlnYXRpb24nLCAncGFnaW5hdGlvbicsICdzY3JvbGxiYXInXS5pbmRleE9mKG1vZHVsZVBhcmFtTmFtZSkgPj0gMCAmJiBwYXJhbXNbbW9kdWxlUGFyYW1OYW1lXSA9PT0gdHJ1ZSkge1xcbiAgICAgICAgICBwYXJhbXNbbW9kdWxlUGFyYW1OYW1lXSA9IHtcXG4gICAgICAgICAgICBhdXRvOiB0cnVlXFxuICAgICAgICAgIH07XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoIShtb2R1bGVQYXJhbU5hbWUgaW4gcGFyYW1zICYmICdlbmFibGVkJyBpbiBtb2R1bGVQYXJhbXMpKSByZXR1cm47XFxuXFxuICAgICAgICBpZiAocGFyYW1zW21vZHVsZVBhcmFtTmFtZV0gPT09IHRydWUpIHtcXG4gICAgICAgICAgcGFyYW1zW21vZHVsZVBhcmFtTmFtZV0gPSB7XFxuICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZVxcbiAgICAgICAgICB9O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKHR5cGVvZiBwYXJhbXNbbW9kdWxlUGFyYW1OYW1lXSA9PT0gJ29iamVjdCcgJiYgISgnZW5hYmxlZCcgaW4gcGFyYW1zW21vZHVsZVBhcmFtTmFtZV0pKSB7XFxuICAgICAgICAgIHBhcmFtc1ttb2R1bGVQYXJhbU5hbWVdLmVuYWJsZWQgPSB0cnVlO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKCFwYXJhbXNbbW9kdWxlUGFyYW1OYW1lXSkgcGFyYW1zW21vZHVsZVBhcmFtTmFtZV0gPSB7XFxuICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlXFxuICAgICAgICB9O1xcbiAgICAgIH1cXG4gICAgfSk7IC8vIEV4dGVuZCBkZWZhdWx0cyB3aXRoIG1vZHVsZXMgcGFyYW1zXFxuXFxuICAgIHZhciBzd2lwZXJQYXJhbXMgPSAoMCxfdXRpbHNfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE2X18uZXh0ZW5kKSh7fSwgX2RlZmF1bHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yMF9fW1xcXCJkZWZhdWx0XFxcIl0pO1xcbiAgICBzd2lwZXIudXNlUGFyYW1zKHN3aXBlclBhcmFtcyk7IC8vIEV4dGVuZCBkZWZhdWx0cyB3aXRoIHBhc3NlZCBwYXJhbXNcXG5cXG4gICAgc3dpcGVyLnBhcmFtcyA9ICgwLF91dGlsc191dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTZfXy5leHRlbmQpKHt9LCBzd2lwZXJQYXJhbXMsIGV4dGVuZGVkRGVmYXVsdHMsIHBhcmFtcyk7XFxuICAgIHN3aXBlci5vcmlnaW5hbFBhcmFtcyA9ICgwLF91dGlsc191dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTZfXy5leHRlbmQpKHt9LCBzd2lwZXIucGFyYW1zKTtcXG4gICAgc3dpcGVyLnBhc3NlZFBhcmFtcyA9ICgwLF91dGlsc191dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTZfXy5leHRlbmQpKHt9LCBwYXJhbXMpOyAvLyBhZGQgZXZlbnQgbGlzdGVuZXJzXFxuXFxuICAgIGlmIChzd2lwZXIucGFyYW1zICYmIHN3aXBlci5wYXJhbXMub24pIHtcXG4gICAgICBPYmplY3Qua2V5cyhzd2lwZXIucGFyYW1zLm9uKS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudE5hbWUpIHtcXG4gICAgICAgIHN3aXBlci5vbihldmVudE5hbWUsIHN3aXBlci5wYXJhbXMub25bZXZlbnROYW1lXSk7XFxuICAgICAgfSk7XFxuICAgIH1cXG5cXG4gICAgaWYgKHN3aXBlci5wYXJhbXMgJiYgc3dpcGVyLnBhcmFtcy5vbkFueSkge1xcbiAgICAgIHN3aXBlci5vbkFueShzd2lwZXIucGFyYW1zLm9uQW55KTtcXG4gICAgfSAvLyBTYXZlIERvbSBsaWJcXG5cXG5cXG4gICAgc3dpcGVyLiQgPSBfdXRpbHNfZG9tX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcImRlZmF1bHRcXFwiXTsgLy8gRXh0ZW5kIFN3aXBlclxcblxcbiAgICAoMCxfdXRpbHNfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE2X18uZXh0ZW5kKShzd2lwZXIsIHtcXG4gICAgICBlbmFibGVkOiBzd2lwZXIucGFyYW1zLmVuYWJsZWQsXFxuICAgICAgZWw6IGVsLFxcbiAgICAgIC8vIENsYXNzZXNcXG4gICAgICBjbGFzc05hbWVzOiBbXSxcXG4gICAgICAvLyBTbGlkZXNcXG4gICAgICBzbGlkZXM6ICgwLF91dGlsc19kb21fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiZGVmYXVsdFxcXCJdKSgpLFxcbiAgICAgIHNsaWRlc0dyaWQ6IFtdLFxcbiAgICAgIHNuYXBHcmlkOiBbXSxcXG4gICAgICBzbGlkZXNTaXplc0dyaWQ6IFtdLFxcbiAgICAgIC8vIGlzRGlyZWN0aW9uXFxuICAgICAgaXNIb3Jpem9udGFsOiBmdW5jdGlvbiBpc0hvcml6b250YWwoKSB7XFxuICAgICAgICByZXR1cm4gc3dpcGVyLnBhcmFtcy5kaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJztcXG4gICAgICB9LFxcbiAgICAgIGlzVmVydGljYWw6IGZ1bmN0aW9uIGlzVmVydGljYWwoKSB7XFxuICAgICAgICByZXR1cm4gc3dpcGVyLnBhcmFtcy5kaXJlY3Rpb24gPT09ICd2ZXJ0aWNhbCc7XFxuICAgICAgfSxcXG4gICAgICAvLyBJbmRleGVzXFxuICAgICAgYWN0aXZlSW5kZXg6IDAsXFxuICAgICAgcmVhbEluZGV4OiAwLFxcbiAgICAgIC8vXFxuICAgICAgaXNCZWdpbm5pbmc6IHRydWUsXFxuICAgICAgaXNFbmQ6IGZhbHNlLFxcbiAgICAgIC8vIFByb3BzXFxuICAgICAgdHJhbnNsYXRlOiAwLFxcbiAgICAgIHByZXZpb3VzVHJhbnNsYXRlOiAwLFxcbiAgICAgIHByb2dyZXNzOiAwLFxcbiAgICAgIHZlbG9jaXR5OiAwLFxcbiAgICAgIGFuaW1hdGluZzogZmFsc2UsXFxuICAgICAgLy8gTG9ja3NcXG4gICAgICBhbGxvd1NsaWRlTmV4dDogc3dpcGVyLnBhcmFtcy5hbGxvd1NsaWRlTmV4dCxcXG4gICAgICBhbGxvd1NsaWRlUHJldjogc3dpcGVyLnBhcmFtcy5hbGxvd1NsaWRlUHJldixcXG4gICAgICAvLyBUb3VjaCBFdmVudHNcXG4gICAgICB0b3VjaEV2ZW50czogZnVuY3Rpb24gdG91Y2hFdmVudHMoKSB7XFxuICAgICAgICB2YXIgdG91Y2ggPSBbJ3RvdWNoc3RhcnQnLCAndG91Y2htb3ZlJywgJ3RvdWNoZW5kJywgJ3RvdWNoY2FuY2VsJ107XFxuICAgICAgICB2YXIgZGVza3RvcCA9IFsnbW91c2Vkb3duJywgJ21vdXNlbW92ZScsICdtb3VzZXVwJ107XFxuXFxuICAgICAgICBpZiAoc3dpcGVyLnN1cHBvcnQucG9pbnRlckV2ZW50cykge1xcbiAgICAgICAgICBkZXNrdG9wID0gWydwb2ludGVyZG93bicsICdwb2ludGVybW92ZScsICdwb2ludGVydXAnXTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHN3aXBlci50b3VjaEV2ZW50c1RvdWNoID0ge1xcbiAgICAgICAgICBzdGFydDogdG91Y2hbMF0sXFxuICAgICAgICAgIG1vdmU6IHRvdWNoWzFdLFxcbiAgICAgICAgICBlbmQ6IHRvdWNoWzJdLFxcbiAgICAgICAgICBjYW5jZWw6IHRvdWNoWzNdXFxuICAgICAgICB9O1xcbiAgICAgICAgc3dpcGVyLnRvdWNoRXZlbnRzRGVza3RvcCA9IHtcXG4gICAgICAgICAgc3RhcnQ6IGRlc2t0b3BbMF0sXFxuICAgICAgICAgIG1vdmU6IGRlc2t0b3BbMV0sXFxuICAgICAgICAgIGVuZDogZGVza3RvcFsyXVxcbiAgICAgICAgfTtcXG4gICAgICAgIHJldHVybiBzd2lwZXIuc3VwcG9ydC50b3VjaCB8fCAhc3dpcGVyLnBhcmFtcy5zaW11bGF0ZVRvdWNoID8gc3dpcGVyLnRvdWNoRXZlbnRzVG91Y2ggOiBzd2lwZXIudG91Y2hFdmVudHNEZXNrdG9wO1xcbiAgICAgIH0oKSxcXG4gICAgICB0b3VjaEV2ZW50c0RhdGE6IHtcXG4gICAgICAgIGlzVG91Y2hlZDogdW5kZWZpbmVkLFxcbiAgICAgICAgaXNNb3ZlZDogdW5kZWZpbmVkLFxcbiAgICAgICAgYWxsb3dUb3VjaENhbGxiYWNrczogdW5kZWZpbmVkLFxcbiAgICAgICAgdG91Y2hTdGFydFRpbWU6IHVuZGVmaW5lZCxcXG4gICAgICAgIGlzU2Nyb2xsaW5nOiB1bmRlZmluZWQsXFxuICAgICAgICBjdXJyZW50VHJhbnNsYXRlOiB1bmRlZmluZWQsXFxuICAgICAgICBzdGFydFRyYW5zbGF0ZTogdW5kZWZpbmVkLFxcbiAgICAgICAgYWxsb3dUaHJlc2hvbGRNb3ZlOiB1bmRlZmluZWQsXFxuICAgICAgICAvLyBGb3JtIGVsZW1lbnRzIHRvIG1hdGNoXFxuICAgICAgICBmb2N1c2FibGVFbGVtZW50czogc3dpcGVyLnBhcmFtcy5mb2N1c2FibGVFbGVtZW50cyxcXG4gICAgICAgIC8vIExhc3QgY2xpY2sgdGltZVxcbiAgICAgICAgbGFzdENsaWNrVGltZTogKDAsX3V0aWxzX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNl9fLm5vdykoKSxcXG4gICAgICAgIGNsaWNrVGltZW91dDogdW5kZWZpbmVkLFxcbiAgICAgICAgLy8gVmVsb2NpdGllc1xcbiAgICAgICAgdmVsb2NpdGllczogW10sXFxuICAgICAgICBhbGxvd01vbWVudHVtQm91bmNlOiB1bmRlZmluZWQsXFxuICAgICAgICBpc1RvdWNoRXZlbnQ6IHVuZGVmaW5lZCxcXG4gICAgICAgIHN0YXJ0TW92aW5nOiB1bmRlZmluZWRcXG4gICAgICB9LFxcbiAgICAgIC8vIENsaWNrc1xcbiAgICAgIGFsbG93Q2xpY2s6IHRydWUsXFxuICAgICAgLy8gVG91Y2hlc1xcbiAgICAgIGFsbG93VG91Y2hNb3ZlOiBzd2lwZXIucGFyYW1zLmFsbG93VG91Y2hNb3ZlLFxcbiAgICAgIHRvdWNoZXM6IHtcXG4gICAgICAgIHN0YXJ0WDogMCxcXG4gICAgICAgIHN0YXJ0WTogMCxcXG4gICAgICAgIGN1cnJlbnRYOiAwLFxcbiAgICAgICAgY3VycmVudFk6IDAsXFxuICAgICAgICBkaWZmOiAwXFxuICAgICAgfSxcXG4gICAgICAvLyBJbWFnZXNcXG4gICAgICBpbWFnZXNUb0xvYWQ6IFtdLFxcbiAgICAgIGltYWdlc0xvYWRlZDogMFxcbiAgICB9KTsgLy8gSW5zdGFsbCBNb2R1bGVzXFxuXFxuICAgIHN3aXBlci51c2VNb2R1bGVzKCk7XFxuICAgIHN3aXBlci5lbWl0KCdfc3dpcGVyJyk7IC8vIEluaXRcXG5cXG4gICAgaWYgKHN3aXBlci5wYXJhbXMuaW5pdCkge1xcbiAgICAgIHN3aXBlci5pbml0KCk7XFxuICAgIH0gLy8gUmV0dXJuIGFwcCBpbnN0YW5jZVxcblxcblxcbiAgICByZXR1cm4gc3dpcGVyO1xcbiAgfVxcblxcbiAgdmFyIF9wcm90byA9IFN3aXBlci5wcm90b3R5cGU7XFxuXFxuICBfcHJvdG8uZW5hYmxlID0gZnVuY3Rpb24gZW5hYmxlKCkge1xcbiAgICB2YXIgc3dpcGVyID0gdGhpcztcXG4gICAgaWYgKHN3aXBlci5lbmFibGVkKSByZXR1cm47XFxuICAgIHN3aXBlci5lbmFibGVkID0gdHJ1ZTtcXG5cXG4gICAgaWYgKHN3aXBlci5wYXJhbXMuZ3JhYkN1cnNvcikge1xcbiAgICAgIHN3aXBlci5zZXRHcmFiQ3Vyc29yKCk7XFxuICAgIH1cXG5cXG4gICAgc3dpcGVyLmVtaXQoJ2VuYWJsZScpO1xcbiAgfTtcXG5cXG4gIF9wcm90by5kaXNhYmxlID0gZnVuY3Rpb24gZGlzYWJsZSgpIHtcXG4gICAgdmFyIHN3aXBlciA9IHRoaXM7XFxuICAgIGlmICghc3dpcGVyLmVuYWJsZWQpIHJldHVybjtcXG4gICAgc3dpcGVyLmVuYWJsZWQgPSBmYWxzZTtcXG5cXG4gICAgaWYgKHN3aXBlci5wYXJhbXMuZ3JhYkN1cnNvcikge1xcbiAgICAgIHN3aXBlci51bnNldEdyYWJDdXJzb3IoKTtcXG4gICAgfVxcblxcbiAgICBzd2lwZXIuZW1pdCgnZGlzYWJsZScpO1xcbiAgfTtcXG5cXG4gIF9wcm90by5zZXRQcm9ncmVzcyA9IGZ1bmN0aW9uIHNldFByb2dyZXNzKHByb2dyZXNzLCBzcGVlZCkge1xcbiAgICB2YXIgc3dpcGVyID0gdGhpcztcXG4gICAgcHJvZ3Jlc3MgPSBNYXRoLm1pbihNYXRoLm1heChwcm9ncmVzcywgMCksIDEpO1xcbiAgICB2YXIgbWluID0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpO1xcbiAgICB2YXIgbWF4ID0gc3dpcGVyLm1heFRyYW5zbGF0ZSgpO1xcbiAgICB2YXIgY3VycmVudCA9IChtYXggLSBtaW4pICogcHJvZ3Jlc3MgKyBtaW47XFxuICAgIHN3aXBlci50cmFuc2xhdGVUbyhjdXJyZW50LCB0eXBlb2Ygc3BlZWQgPT09ICd1bmRlZmluZWQnID8gMCA6IHNwZWVkKTtcXG4gICAgc3dpcGVyLnVwZGF0ZUFjdGl2ZUluZGV4KCk7XFxuICAgIHN3aXBlci51cGRhdGVTbGlkZXNDbGFzc2VzKCk7XFxuICB9O1xcblxcbiAgX3Byb3RvLmVtaXRDb250YWluZXJDbGFzc2VzID0gZnVuY3Rpb24gZW1pdENvbnRhaW5lckNsYXNzZXMoKSB7XFxuICAgIHZhciBzd2lwZXIgPSB0aGlzO1xcbiAgICBpZiAoIXN3aXBlci5wYXJhbXMuX2VtaXRDbGFzc2VzIHx8ICFzd2lwZXIuZWwpIHJldHVybjtcXG4gICAgdmFyIGNsYXNzZXMgPSBzd2lwZXIuZWwuY2xhc3NOYW1lLnNwbGl0KCcgJykuZmlsdGVyKGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcXG4gICAgICByZXR1cm4gY2xhc3NOYW1lLmluZGV4T2YoJ3N3aXBlci1jb250YWluZXInKSA9PT0gMCB8fCBjbGFzc05hbWUuaW5kZXhPZihzd2lwZXIucGFyYW1zLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3MpID09PSAwO1xcbiAgICB9KTtcXG4gICAgc3dpcGVyLmVtaXQoJ19jb250YWluZXJDbGFzc2VzJywgY2xhc3Nlcy5qb2luKCcgJykpO1xcbiAgfTtcXG5cXG4gIF9wcm90by5nZXRTbGlkZUNsYXNzZXMgPSBmdW5jdGlvbiBnZXRTbGlkZUNsYXNzZXMoc2xpZGVFbCkge1xcbiAgICB2YXIgc3dpcGVyID0gdGhpcztcXG4gICAgcmV0dXJuIHNsaWRlRWwuY2xhc3NOYW1lLnNwbGl0KCcgJykuZmlsdGVyKGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcXG4gICAgICByZXR1cm4gY2xhc3NOYW1lLmluZGV4T2YoJ3N3aXBlci1zbGlkZScpID09PSAwIHx8IGNsYXNzTmFtZS5pbmRleE9mKHN3aXBlci5wYXJhbXMuc2xpZGVDbGFzcykgPT09IDA7XFxuICAgIH0pLmpvaW4oJyAnKTtcXG4gIH07XFxuXFxuICBfcHJvdG8uZW1pdFNsaWRlc0NsYXNzZXMgPSBmdW5jdGlvbiBlbWl0U2xpZGVzQ2xhc3NlcygpIHtcXG4gICAgdmFyIHN3aXBlciA9IHRoaXM7XFxuICAgIGlmICghc3dpcGVyLnBhcmFtcy5fZW1pdENsYXNzZXMgfHwgIXN3aXBlci5lbCkgcmV0dXJuO1xcbiAgICB2YXIgdXBkYXRlcyA9IFtdO1xcbiAgICBzd2lwZXIuc2xpZGVzLmVhY2goZnVuY3Rpb24gKHNsaWRlRWwpIHtcXG4gICAgICB2YXIgY2xhc3NOYW1lcyA9IHN3aXBlci5nZXRTbGlkZUNsYXNzZXMoc2xpZGVFbCk7XFxuICAgICAgdXBkYXRlcy5wdXNoKHtcXG4gICAgICAgIHNsaWRlRWw6IHNsaWRlRWwsXFxuICAgICAgICBjbGFzc05hbWVzOiBjbGFzc05hbWVzXFxuICAgICAgfSk7XFxuICAgICAgc3dpcGVyLmVtaXQoJ19zbGlkZUNsYXNzJywgc2xpZGVFbCwgY2xhc3NOYW1lcyk7XFxuICAgIH0pO1xcbiAgICBzd2lwZXIuZW1pdCgnX3NsaWRlQ2xhc3NlcycsIHVwZGF0ZXMpO1xcbiAgfTtcXG5cXG4gIF9wcm90by5zbGlkZXNQZXJWaWV3RHluYW1pYyA9IGZ1bmN0aW9uIHNsaWRlc1BlclZpZXdEeW5hbWljKCkge1xcbiAgICB2YXIgc3dpcGVyID0gdGhpcztcXG4gICAgdmFyIHBhcmFtcyA9IHN3aXBlci5wYXJhbXMsXFxuICAgICAgICBzbGlkZXMgPSBzd2lwZXIuc2xpZGVzLFxcbiAgICAgICAgc2xpZGVzR3JpZCA9IHN3aXBlci5zbGlkZXNHcmlkLFxcbiAgICAgICAgc3dpcGVyU2l6ZSA9IHN3aXBlci5zaXplLFxcbiAgICAgICAgYWN0aXZlSW5kZXggPSBzd2lwZXIuYWN0aXZlSW5kZXg7XFxuICAgIHZhciBzcHYgPSAxO1xcblxcbiAgICBpZiAocGFyYW1zLmNlbnRlcmVkU2xpZGVzKSB7XFxuICAgICAgdmFyIHNsaWRlU2l6ZSA9IHNsaWRlc1thY3RpdmVJbmRleF0uc3dpcGVyU2xpZGVTaXplO1xcbiAgICAgIHZhciBicmVha0xvb3A7XFxuXFxuICAgICAgZm9yICh2YXIgaSA9IGFjdGl2ZUluZGV4ICsgMTsgaSA8IHNsaWRlcy5sZW5ndGg7IGkgKz0gMSkge1xcbiAgICAgICAgaWYgKHNsaWRlc1tpXSAmJiAhYnJlYWtMb29wKSB7XFxuICAgICAgICAgIHNsaWRlU2l6ZSArPSBzbGlkZXNbaV0uc3dpcGVyU2xpZGVTaXplO1xcbiAgICAgICAgICBzcHYgKz0gMTtcXG4gICAgICAgICAgaWYgKHNsaWRlU2l6ZSA+IHN3aXBlclNpemUpIGJyZWFrTG9vcCA9IHRydWU7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGZvciAodmFyIF9pID0gYWN0aXZlSW5kZXggLSAxOyBfaSA+PSAwOyBfaSAtPSAxKSB7XFxuICAgICAgICBpZiAoc2xpZGVzW19pXSAmJiAhYnJlYWtMb29wKSB7XFxuICAgICAgICAgIHNsaWRlU2l6ZSArPSBzbGlkZXNbX2ldLnN3aXBlclNsaWRlU2l6ZTtcXG4gICAgICAgICAgc3B2ICs9IDE7XFxuICAgICAgICAgIGlmIChzbGlkZVNpemUgPiBzd2lwZXJTaXplKSBicmVha0xvb3AgPSB0cnVlO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfSBlbHNlIHtcXG4gICAgICBmb3IgKHZhciBfaTIgPSBhY3RpdmVJbmRleCArIDE7IF9pMiA8IHNsaWRlcy5sZW5ndGg7IF9pMiArPSAxKSB7XFxuICAgICAgICBpZiAoc2xpZGVzR3JpZFtfaTJdIC0gc2xpZGVzR3JpZFthY3RpdmVJbmRleF0gPCBzd2lwZXJTaXplKSB7XFxuICAgICAgICAgIHNwdiArPSAxO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICByZXR1cm4gc3B2O1xcbiAgfTtcXG5cXG4gIF9wcm90by51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoKSB7XFxuICAgIHZhciBzd2lwZXIgPSB0aGlzO1xcbiAgICBpZiAoIXN3aXBlciB8fCBzd2lwZXIuZGVzdHJveWVkKSByZXR1cm47XFxuICAgIHZhciBzbmFwR3JpZCA9IHN3aXBlci5zbmFwR3JpZCxcXG4gICAgICAgIHBhcmFtcyA9IHN3aXBlci5wYXJhbXM7IC8vIEJyZWFrcG9pbnRzXFxuXFxuICAgIGlmIChwYXJhbXMuYnJlYWtwb2ludHMpIHtcXG4gICAgICBzd2lwZXIuc2V0QnJlYWtwb2ludCgpO1xcbiAgICB9XFxuXFxuICAgIHN3aXBlci51cGRhdGVTaXplKCk7XFxuICAgIHN3aXBlci51cGRhdGVTbGlkZXMoKTtcXG4gICAgc3dpcGVyLnVwZGF0ZVByb2dyZXNzKCk7XFxuICAgIHN3aXBlci51cGRhdGVTbGlkZXNDbGFzc2VzKCk7XFxuXFxuICAgIGZ1bmN0aW9uIHNldFRyYW5zbGF0ZSgpIHtcXG4gICAgICB2YXIgdHJhbnNsYXRlVmFsdWUgPSBzd2lwZXIucnRsVHJhbnNsYXRlID8gc3dpcGVyLnRyYW5zbGF0ZSAqIC0xIDogc3dpcGVyLnRyYW5zbGF0ZTtcXG4gICAgICB2YXIgbmV3VHJhbnNsYXRlID0gTWF0aC5taW4oTWF0aC5tYXgodHJhbnNsYXRlVmFsdWUsIHN3aXBlci5tYXhUcmFuc2xhdGUoKSksIHN3aXBlci5taW5UcmFuc2xhdGUoKSk7XFxuICAgICAgc3dpcGVyLnNldFRyYW5zbGF0ZShuZXdUcmFuc2xhdGUpO1xcbiAgICAgIHN3aXBlci51cGRhdGVBY3RpdmVJbmRleCgpO1xcbiAgICAgIHN3aXBlci51cGRhdGVTbGlkZXNDbGFzc2VzKCk7XFxuICAgIH1cXG5cXG4gICAgdmFyIHRyYW5zbGF0ZWQ7XFxuXFxuICAgIGlmIChzd2lwZXIucGFyYW1zLmZyZWVNb2RlKSB7XFxuICAgICAgc2V0VHJhbnNsYXRlKCk7XFxuXFxuICAgICAgaWYgKHN3aXBlci5wYXJhbXMuYXV0b0hlaWdodCkge1xcbiAgICAgICAgc3dpcGVyLnVwZGF0ZUF1dG9IZWlnaHQoKTtcXG4gICAgICB9XFxuICAgIH0gZWxzZSB7XFxuICAgICAgaWYgKChzd2lwZXIucGFyYW1zLnNsaWRlc1BlclZpZXcgPT09ICdhdXRvJyB8fCBzd2lwZXIucGFyYW1zLnNsaWRlc1BlclZpZXcgPiAxKSAmJiBzd2lwZXIuaXNFbmQgJiYgIXN3aXBlci5wYXJhbXMuY2VudGVyZWRTbGlkZXMpIHtcXG4gICAgICAgIHRyYW5zbGF0ZWQgPSBzd2lwZXIuc2xpZGVUbyhzd2lwZXIuc2xpZGVzLmxlbmd0aCAtIDEsIDAsIGZhbHNlLCB0cnVlKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdHJhbnNsYXRlZCA9IHN3aXBlci5zbGlkZVRvKHN3aXBlci5hY3RpdmVJbmRleCwgMCwgZmFsc2UsIHRydWUpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIXRyYW5zbGF0ZWQpIHtcXG4gICAgICAgIHNldFRyYW5zbGF0ZSgpO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBpZiAocGFyYW1zLndhdGNoT3ZlcmZsb3cgJiYgc25hcEdyaWQgIT09IHN3aXBlci5zbmFwR3JpZCkge1xcbiAgICAgIHN3aXBlci5jaGVja092ZXJmbG93KCk7XFxuICAgIH1cXG5cXG4gICAgc3dpcGVyLmVtaXQoJ3VwZGF0ZScpO1xcbiAgfTtcXG5cXG4gIF9wcm90by5jaGFuZ2VEaXJlY3Rpb24gPSBmdW5jdGlvbiBjaGFuZ2VEaXJlY3Rpb24obmV3RGlyZWN0aW9uLCBuZWVkVXBkYXRlKSB7XFxuICAgIGlmIChuZWVkVXBkYXRlID09PSB2b2lkIDApIHtcXG4gICAgICBuZWVkVXBkYXRlID0gdHJ1ZTtcXG4gICAgfVxcblxcbiAgICB2YXIgc3dpcGVyID0gdGhpcztcXG4gICAgdmFyIGN1cnJlbnREaXJlY3Rpb24gPSBzd2lwZXIucGFyYW1zLmRpcmVjdGlvbjtcXG5cXG4gICAgaWYgKCFuZXdEaXJlY3Rpb24pIHtcXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcXG4gICAgICBuZXdEaXJlY3Rpb24gPSBjdXJyZW50RGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcgPyAndmVydGljYWwnIDogJ2hvcml6b250YWwnO1xcbiAgICB9XFxuXFxuICAgIGlmIChuZXdEaXJlY3Rpb24gPT09IGN1cnJlbnREaXJlY3Rpb24gfHwgbmV3RGlyZWN0aW9uICE9PSAnaG9yaXpvbnRhbCcgJiYgbmV3RGlyZWN0aW9uICE9PSAndmVydGljYWwnKSB7XFxuICAgICAgcmV0dXJuIHN3aXBlcjtcXG4gICAgfVxcblxcbiAgICBzd2lwZXIuJGVsLnJlbW92ZUNsYXNzKFxcXCJcXFwiICsgc3dpcGVyLnBhcmFtcy5jb250YWluZXJNb2RpZmllckNsYXNzICsgY3VycmVudERpcmVjdGlvbikuYWRkQ2xhc3MoXFxcIlxcXCIgKyBzd2lwZXIucGFyYW1zLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3MgKyBuZXdEaXJlY3Rpb24pO1xcbiAgICBzd2lwZXIuZW1pdENvbnRhaW5lckNsYXNzZXMoKTtcXG4gICAgc3dpcGVyLnBhcmFtcy5kaXJlY3Rpb24gPSBuZXdEaXJlY3Rpb247XFxuICAgIHN3aXBlci5zbGlkZXMuZWFjaChmdW5jdGlvbiAoc2xpZGVFbCkge1xcbiAgICAgIGlmIChuZXdEaXJlY3Rpb24gPT09ICd2ZXJ0aWNhbCcpIHtcXG4gICAgICAgIHNsaWRlRWwuc3R5bGUud2lkdGggPSAnJztcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgc2xpZGVFbC5zdHlsZS5oZWlnaHQgPSAnJztcXG4gICAgICB9XFxuICAgIH0pO1xcbiAgICBzd2lwZXIuZW1pdCgnY2hhbmdlRGlyZWN0aW9uJyk7XFxuICAgIGlmIChuZWVkVXBkYXRlKSBzd2lwZXIudXBkYXRlKCk7XFxuICAgIHJldHVybiBzd2lwZXI7XFxuICB9O1xcblxcbiAgX3Byb3RvLm1vdW50ID0gZnVuY3Rpb24gbW91bnQoZWwpIHtcXG4gICAgdmFyIHN3aXBlciA9IHRoaXM7XFxuICAgIGlmIChzd2lwZXIubW91bnRlZCkgcmV0dXJuIHRydWU7IC8vIEZpbmQgZWxcXG5cXG4gICAgdmFyICRlbCA9ICgwLF91dGlsc19kb21fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiZGVmYXVsdFxcXCJdKShlbCB8fCBzd2lwZXIucGFyYW1zLmVsKTtcXG4gICAgZWwgPSAkZWxbMF07XFxuXFxuICAgIGlmICghZWwpIHtcXG4gICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH1cXG5cXG4gICAgZWwuc3dpcGVyID0gc3dpcGVyO1xcblxcbiAgICB2YXIgZ2V0V3JhcHBlclNlbGVjdG9yID0gZnVuY3Rpb24gZ2V0V3JhcHBlclNlbGVjdG9yKCkge1xcbiAgICAgIHJldHVybiBcXFwiLlxcXCIgKyAoc3dpcGVyLnBhcmFtcy53cmFwcGVyQ2xhc3MgfHwgJycpLnRyaW0oKS5zcGxpdCgnICcpLmpvaW4oJy4nKTtcXG4gICAgfTtcXG5cXG4gICAgdmFyIGdldFdyYXBwZXIgPSBmdW5jdGlvbiBnZXRXcmFwcGVyKCkge1xcbiAgICAgIGlmIChlbCAmJiBlbC5zaGFkb3dSb290ICYmIGVsLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3Rvcikge1xcbiAgICAgICAgdmFyIHJlcyA9ICgwLF91dGlsc19kb21fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiZGVmYXVsdFxcXCJdKShlbC5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoZ2V0V3JhcHBlclNlbGVjdG9yKCkpKTsgLy8gQ2hpbGRyZW4gbmVlZHMgdG8gcmV0dXJuIHNsb3QgaXRlbXNcXG5cXG4gICAgICAgIHJlcy5jaGlsZHJlbiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XFxuICAgICAgICAgIHJldHVybiAkZWwuY2hpbGRyZW4ob3B0aW9ucyk7XFxuICAgICAgICB9O1xcblxcbiAgICAgICAgcmV0dXJuIHJlcztcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuICRlbC5jaGlsZHJlbihnZXRXcmFwcGVyU2VsZWN0b3IoKSk7XFxuICAgIH07IC8vIEZpbmQgV3JhcHBlclxcblxcblxcbiAgICB2YXIgJHdyYXBwZXJFbCA9IGdldFdyYXBwZXIoKTtcXG5cXG4gICAgaWYgKCR3cmFwcGVyRWwubGVuZ3RoID09PSAwICYmIHN3aXBlci5wYXJhbXMuY3JlYXRlRWxlbWVudHMpIHtcXG4gICAgICB2YXIgZG9jdW1lbnQgPSAoMCxzc3Jfd2luZG93X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uZ2V0RG9jdW1lbnQpKCk7XFxuICAgICAgdmFyIHdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcXG4gICAgICAkd3JhcHBlckVsID0gKDAsX3V0aWxzX2RvbV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJkZWZhdWx0XFxcIl0pKHdyYXBwZXIpO1xcbiAgICAgIHdyYXBwZXIuY2xhc3NOYW1lID0gc3dpcGVyLnBhcmFtcy53cmFwcGVyQ2xhc3M7XFxuICAgICAgJGVsLmFwcGVuZCh3cmFwcGVyKTtcXG4gICAgICAkZWwuY2hpbGRyZW4oXFxcIi5cXFwiICsgc3dpcGVyLnBhcmFtcy5zbGlkZUNsYXNzKS5lYWNoKGZ1bmN0aW9uIChzbGlkZUVsKSB7XFxuICAgICAgICAkd3JhcHBlckVsLmFwcGVuZChzbGlkZUVsKTtcXG4gICAgICB9KTtcXG4gICAgfVxcblxcbiAgICAoMCxfdXRpbHNfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE2X18uZXh0ZW5kKShzd2lwZXIsIHtcXG4gICAgICAkZWw6ICRlbCxcXG4gICAgICBlbDogZWwsXFxuICAgICAgJHdyYXBwZXJFbDogJHdyYXBwZXJFbCxcXG4gICAgICB3cmFwcGVyRWw6ICR3cmFwcGVyRWxbMF0sXFxuICAgICAgbW91bnRlZDogdHJ1ZSxcXG4gICAgICAvLyBSVExcXG4gICAgICBydGw6IGVsLmRpci50b0xvd2VyQ2FzZSgpID09PSAncnRsJyB8fCAkZWwuY3NzKCdkaXJlY3Rpb24nKSA9PT0gJ3J0bCcsXFxuICAgICAgcnRsVHJhbnNsYXRlOiBzd2lwZXIucGFyYW1zLmRpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnICYmIChlbC5kaXIudG9Mb3dlckNhc2UoKSA9PT0gJ3J0bCcgfHwgJGVsLmNzcygnZGlyZWN0aW9uJykgPT09ICdydGwnKSxcXG4gICAgICB3cm9uZ1JUTDogJHdyYXBwZXJFbC5jc3MoJ2Rpc3BsYXknKSA9PT0gJy13ZWJraXQtYm94J1xcbiAgICB9KTtcXG4gICAgcmV0dXJuIHRydWU7XFxuICB9O1xcblxcbiAgX3Byb3RvLmluaXQgPSBmdW5jdGlvbiBpbml0KGVsKSB7XFxuICAgIHZhciBzd2lwZXIgPSB0aGlzO1xcbiAgICBpZiAoc3dpcGVyLmluaXRpYWxpemVkKSByZXR1cm4gc3dpcGVyO1xcbiAgICB2YXIgbW91bnRlZCA9IHN3aXBlci5tb3VudChlbCk7XFxuICAgIGlmIChtb3VudGVkID09PSBmYWxzZSkgcmV0dXJuIHN3aXBlcjtcXG4gICAgc3dpcGVyLmVtaXQoJ2JlZm9yZUluaXQnKTsgLy8gU2V0IGJyZWFrcG9pbnRcXG5cXG4gICAgaWYgKHN3aXBlci5wYXJhbXMuYnJlYWtwb2ludHMpIHtcXG4gICAgICBzd2lwZXIuc2V0QnJlYWtwb2ludCgpO1xcbiAgICB9IC8vIEFkZCBDbGFzc2VzXFxuXFxuXFxuICAgIHN3aXBlci5hZGRDbGFzc2VzKCk7IC8vIENyZWF0ZSBsb29wXFxuXFxuICAgIGlmIChzd2lwZXIucGFyYW1zLmxvb3ApIHtcXG4gICAgICBzd2lwZXIubG9vcENyZWF0ZSgpO1xcbiAgICB9IC8vIFVwZGF0ZSBzaXplXFxuXFxuXFxuICAgIHN3aXBlci51cGRhdGVTaXplKCk7IC8vIFVwZGF0ZSBzbGlkZXNcXG5cXG4gICAgc3dpcGVyLnVwZGF0ZVNsaWRlcygpO1xcblxcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy53YXRjaE92ZXJmbG93KSB7XFxuICAgICAgc3dpcGVyLmNoZWNrT3ZlcmZsb3coKTtcXG4gICAgfSAvLyBTZXQgR3JhYiBDdXJzb3JcXG5cXG5cXG4gICAgaWYgKHN3aXBlci5wYXJhbXMuZ3JhYkN1cnNvciAmJiBzd2lwZXIuZW5hYmxlZCkge1xcbiAgICAgIHN3aXBlci5zZXRHcmFiQ3Vyc29yKCk7XFxuICAgIH1cXG5cXG4gICAgaWYgKHN3aXBlci5wYXJhbXMucHJlbG9hZEltYWdlcykge1xcbiAgICAgIHN3aXBlci5wcmVsb2FkSW1hZ2VzKCk7XFxuICAgIH0gLy8gU2xpZGUgVG8gSW5pdGlhbCBTbGlkZVxcblxcblxcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy5sb29wKSB7XFxuICAgICAgc3dpcGVyLnNsaWRlVG8oc3dpcGVyLnBhcmFtcy5pbml0aWFsU2xpZGUgKyBzd2lwZXIubG9vcGVkU2xpZGVzLCAwLCBzd2lwZXIucGFyYW1zLnJ1bkNhbGxiYWNrc09uSW5pdCwgZmFsc2UsIHRydWUpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHN3aXBlci5zbGlkZVRvKHN3aXBlci5wYXJhbXMuaW5pdGlhbFNsaWRlLCAwLCBzd2lwZXIucGFyYW1zLnJ1bkNhbGxiYWNrc09uSW5pdCwgZmFsc2UsIHRydWUpO1xcbiAgICB9IC8vIEF0dGFjaCBldmVudHNcXG5cXG5cXG4gICAgc3dpcGVyLmF0dGFjaEV2ZW50cygpOyAvLyBJbml0IEZsYWdcXG5cXG4gICAgc3dpcGVyLmluaXRpYWxpemVkID0gdHJ1ZTsgLy8gRW1pdFxcblxcbiAgICBzd2lwZXIuZW1pdCgnaW5pdCcpO1xcbiAgICBzd2lwZXIuZW1pdCgnYWZ0ZXJJbml0Jyk7XFxuICAgIHJldHVybiBzd2lwZXI7XFxuICB9O1xcblxcbiAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KGRlbGV0ZUluc3RhbmNlLCBjbGVhblN0eWxlcykge1xcbiAgICBpZiAoZGVsZXRlSW5zdGFuY2UgPT09IHZvaWQgMCkge1xcbiAgICAgIGRlbGV0ZUluc3RhbmNlID0gdHJ1ZTtcXG4gICAgfVxcblxcbiAgICBpZiAoY2xlYW5TdHlsZXMgPT09IHZvaWQgMCkge1xcbiAgICAgIGNsZWFuU3R5bGVzID0gdHJ1ZTtcXG4gICAgfVxcblxcbiAgICB2YXIgc3dpcGVyID0gdGhpcztcXG4gICAgdmFyIHBhcmFtcyA9IHN3aXBlci5wYXJhbXMsXFxuICAgICAgICAkZWwgPSBzd2lwZXIuJGVsLFxcbiAgICAgICAgJHdyYXBwZXJFbCA9IHN3aXBlci4kd3JhcHBlckVsLFxcbiAgICAgICAgc2xpZGVzID0gc3dpcGVyLnNsaWRlcztcXG5cXG4gICAgaWYgKHR5cGVvZiBzd2lwZXIucGFyYW1zID09PSAndW5kZWZpbmVkJyB8fCBzd2lwZXIuZGVzdHJveWVkKSB7XFxuICAgICAgcmV0dXJuIG51bGw7XFxuICAgIH1cXG5cXG4gICAgc3dpcGVyLmVtaXQoJ2JlZm9yZURlc3Ryb3knKTsgLy8gSW5pdCBGbGFnXFxuXFxuICAgIHN3aXBlci5pbml0aWFsaXplZCA9IGZhbHNlOyAvLyBEZXRhY2ggZXZlbnRzXFxuXFxuICAgIHN3aXBlci5kZXRhY2hFdmVudHMoKTsgLy8gRGVzdHJveSBsb29wXFxuXFxuICAgIGlmIChwYXJhbXMubG9vcCkge1xcbiAgICAgIHN3aXBlci5sb29wRGVzdHJveSgpO1xcbiAgICB9IC8vIENsZWFudXAgc3R5bGVzXFxuXFxuXFxuICAgIGlmIChjbGVhblN0eWxlcykge1xcbiAgICAgIHN3aXBlci5yZW1vdmVDbGFzc2VzKCk7XFxuICAgICAgJGVsLnJlbW92ZUF0dHIoJ3N0eWxlJyk7XFxuICAgICAgJHdyYXBwZXJFbC5yZW1vdmVBdHRyKCdzdHlsZScpO1xcblxcbiAgICAgIGlmIChzbGlkZXMgJiYgc2xpZGVzLmxlbmd0aCkge1xcbiAgICAgICAgc2xpZGVzLnJlbW92ZUNsYXNzKFtwYXJhbXMuc2xpZGVWaXNpYmxlQ2xhc3MsIHBhcmFtcy5zbGlkZUFjdGl2ZUNsYXNzLCBwYXJhbXMuc2xpZGVOZXh0Q2xhc3MsIHBhcmFtcy5zbGlkZVByZXZDbGFzc10uam9pbignICcpKS5yZW1vdmVBdHRyKCdzdHlsZScpLnJlbW92ZUF0dHIoJ2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4Jyk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHN3aXBlci5lbWl0KCdkZXN0cm95Jyk7IC8vIERldGFjaCBlbWl0dGVyIGV2ZW50c1xcblxcbiAgICBPYmplY3Qua2V5cyhzd2lwZXIuZXZlbnRzTGlzdGVuZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudE5hbWUpIHtcXG4gICAgICBzd2lwZXIub2ZmKGV2ZW50TmFtZSk7XFxuICAgIH0pO1xcblxcbiAgICBpZiAoZGVsZXRlSW5zdGFuY2UgIT09IGZhbHNlKSB7XFxuICAgICAgc3dpcGVyLiRlbFswXS5zd2lwZXIgPSBudWxsO1xcbiAgICAgICgwLF91dGlsc191dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTZfXy5kZWxldGVQcm9wcykoc3dpcGVyKTtcXG4gICAgfVxcblxcbiAgICBzd2lwZXIuZGVzdHJveWVkID0gdHJ1ZTtcXG4gICAgcmV0dXJuIG51bGw7XFxuICB9O1xcblxcbiAgU3dpcGVyLmV4dGVuZERlZmF1bHRzID0gZnVuY3Rpb24gZXh0ZW5kRGVmYXVsdHMobmV3RGVmYXVsdHMpIHtcXG4gICAgKDAsX3V0aWxzX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNl9fLmV4dGVuZCkoZXh0ZW5kZWREZWZhdWx0cywgbmV3RGVmYXVsdHMpO1xcbiAgfTtcXG5cXG4gIFN3aXBlci5pbnN0YWxsTW9kdWxlID0gZnVuY3Rpb24gaW5zdGFsbE1vZHVsZShtb2R1bGUpIHtcXG4gICAgaWYgKCFTd2lwZXIucHJvdG90eXBlLm1vZHVsZXMpIFN3aXBlci5wcm90b3R5cGUubW9kdWxlcyA9IHt9O1xcbiAgICB2YXIgbmFtZSA9IG1vZHVsZS5uYW1lIHx8IE9iamVjdC5rZXlzKFN3aXBlci5wcm90b3R5cGUubW9kdWxlcykubGVuZ3RoICsgXFxcIl9cXFwiICsgKDAsX3V0aWxzX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNl9fLm5vdykoKTtcXG4gICAgU3dpcGVyLnByb3RvdHlwZS5tb2R1bGVzW25hbWVdID0gbW9kdWxlO1xcbiAgfTtcXG5cXG4gIFN3aXBlci51c2UgPSBmdW5jdGlvbiB1c2UobW9kdWxlKSB7XFxuICAgIGlmIChBcnJheS5pc0FycmF5KG1vZHVsZSkpIHtcXG4gICAgICBtb2R1bGUuZm9yRWFjaChmdW5jdGlvbiAobSkge1xcbiAgICAgICAgcmV0dXJuIFN3aXBlci5pbnN0YWxsTW9kdWxlKG0pO1xcbiAgICAgIH0pO1xcbiAgICAgIHJldHVybiBTd2lwZXI7XFxuICAgIH1cXG5cXG4gICAgU3dpcGVyLmluc3RhbGxNb2R1bGUobW9kdWxlKTtcXG4gICAgcmV0dXJuIFN3aXBlcjtcXG4gIH07XFxuXFxuICBfY3JlYXRlQ2xhc3MoU3dpcGVyLCBudWxsLCBbe1xcbiAgICBrZXk6IFxcXCJleHRlbmRlZERlZmF1bHRzXFxcIixcXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XFxuICAgICAgcmV0dXJuIGV4dGVuZGVkRGVmYXVsdHM7XFxuICAgIH1cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiZGVmYXVsdHNcXFwiLFxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcXG4gICAgICByZXR1cm4gX2RlZmF1bHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yMF9fW1xcXCJkZWZhdWx0XFxcIl07XFxuICAgIH1cXG4gIH1dKTtcXG5cXG4gIHJldHVybiBTd2lwZXI7XFxufSgpO1xcblxcbk9iamVjdC5rZXlzKHByb3RvdHlwZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3RvdHlwZUdyb3VwKSB7XFxuICBPYmplY3Qua2V5cyhwcm90b3R5cGVzW3Byb3RvdHlwZUdyb3VwXSkuZm9yRWFjaChmdW5jdGlvbiAocHJvdG9NZXRob2QpIHtcXG4gICAgU3dpcGVyLnByb3RvdHlwZVtwcm90b01ldGhvZF0gPSBwcm90b3R5cGVzW3Byb3RvdHlwZUdyb3VwXVtwcm90b01ldGhvZF07XFxuICB9KTtcXG59KTtcXG5Td2lwZXIudXNlKFtfbW9kdWxlc19yZXNpemVfcmVzaXplX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yMV9fW1xcXCJkZWZhdWx0XFxcIl0sIF9tb2R1bGVzX29ic2VydmVyX29ic2VydmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yMl9fW1xcXCJkZWZhdWx0XFxcIl1dKTtcXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IF9fV0VCUEFDS19ERUZBVUxUX0VYUE9SVF9fID0gKFN3aXBlcik7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vcGFydXMvLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvY29yZS1jbGFzcy5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL2RlZmF1bHRzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL2RlZmF1bHRzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJkZWZhdWx0XFxcIjogKCkgPT4gKF9fV0VCUEFDS19ERUZBVUxUX0VYUE9SVF9fKVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgX19XRUJQQUNLX0RFRkFVTFRfRVhQT1JUX18gPSAoe1xcbiAgaW5pdDogdHJ1ZSxcXG4gIGRpcmVjdGlvbjogJ2hvcml6b250YWwnLFxcbiAgdG91Y2hFdmVudHNUYXJnZXQ6ICdjb250YWluZXInLFxcbiAgaW5pdGlhbFNsaWRlOiAwLFxcbiAgc3BlZWQ6IDMwMCxcXG4gIGNzc01vZGU6IGZhbHNlLFxcbiAgdXBkYXRlT25XaW5kb3dSZXNpemU6IHRydWUsXFxuICByZXNpemVPYnNlcnZlcjogZmFsc2UsXFxuICBuZXN0ZWQ6IGZhbHNlLFxcbiAgY3JlYXRlRWxlbWVudHM6IGZhbHNlLFxcbiAgZW5hYmxlZDogdHJ1ZSxcXG4gIGZvY3VzYWJsZUVsZW1lbnRzOiAnaW5wdXQsIHNlbGVjdCwgb3B0aW9uLCB0ZXh0YXJlYSwgYnV0dG9uLCB2aWRlbywgbGFiZWwnLFxcbiAgLy8gT3ZlcnJpZGVzXFxuICB3aWR0aDogbnVsbCxcXG4gIGhlaWdodDogbnVsbCxcXG4gIC8vXFxuICBwcmV2ZW50SW50ZXJhY3Rpb25PblRyYW5zaXRpb246IGZhbHNlLFxcbiAgLy8gc3NyXFxuICB1c2VyQWdlbnQ6IG51bGwsXFxuICB1cmw6IG51bGwsXFxuICAvLyBUbyBzdXBwb3J0IGlPUydzIHN3aXBlLXRvLWdvLWJhY2sgZ2VzdHVyZSAod2hlbiBiZWluZyB1c2VkIGluLWFwcCkuXFxuICBlZGdlU3dpcGVEZXRlY3Rpb246IGZhbHNlLFxcbiAgZWRnZVN3aXBlVGhyZXNob2xkOiAyMCxcXG4gIC8vIEZyZWUgbW9kZVxcbiAgZnJlZU1vZGU6IGZhbHNlLFxcbiAgZnJlZU1vZGVNb21lbnR1bTogdHJ1ZSxcXG4gIGZyZWVNb2RlTW9tZW50dW1SYXRpbzogMSxcXG4gIGZyZWVNb2RlTW9tZW50dW1Cb3VuY2U6IHRydWUsXFxuICBmcmVlTW9kZU1vbWVudHVtQm91bmNlUmF0aW86IDEsXFxuICBmcmVlTW9kZU1vbWVudHVtVmVsb2NpdHlSYXRpbzogMSxcXG4gIGZyZWVNb2RlU3RpY2t5OiBmYWxzZSxcXG4gIGZyZWVNb2RlTWluaW11bVZlbG9jaXR5OiAwLjAyLFxcbiAgLy8gQXV0b2hlaWdodFxcbiAgYXV0b0hlaWdodDogZmFsc2UsXFxuICAvLyBTZXQgd3JhcHBlciB3aWR0aFxcbiAgc2V0V3JhcHBlclNpemU6IGZhbHNlLFxcbiAgLy8gVmlydHVhbCBUcmFuc2xhdGVcXG4gIHZpcnR1YWxUcmFuc2xhdGU6IGZhbHNlLFxcbiAgLy8gRWZmZWN0c1xcbiAgZWZmZWN0OiAnc2xpZGUnLFxcbiAgLy8gJ3NsaWRlJyBvciAnZmFkZScgb3IgJ2N1YmUnIG9yICdjb3ZlcmZsb3cnIG9yICdmbGlwJ1xcbiAgLy8gQnJlYWtwb2ludHNcXG4gIGJyZWFrcG9pbnRzOiB1bmRlZmluZWQsXFxuICBicmVha3BvaW50c0Jhc2U6ICd3aW5kb3cnLFxcbiAgLy8gU2xpZGVzIGdyaWRcXG4gIHNwYWNlQmV0d2VlbjogMCxcXG4gIHNsaWRlc1BlclZpZXc6IDEsXFxuICBzbGlkZXNQZXJDb2x1bW46IDEsXFxuICBzbGlkZXNQZXJDb2x1bW5GaWxsOiAnY29sdW1uJyxcXG4gIHNsaWRlc1Blckdyb3VwOiAxLFxcbiAgc2xpZGVzUGVyR3JvdXBTa2lwOiAwLFxcbiAgY2VudGVyZWRTbGlkZXM6IGZhbHNlLFxcbiAgY2VudGVyZWRTbGlkZXNCb3VuZHM6IGZhbHNlLFxcbiAgc2xpZGVzT2Zmc2V0QmVmb3JlOiAwLFxcbiAgLy8gaW4gcHhcXG4gIHNsaWRlc09mZnNldEFmdGVyOiAwLFxcbiAgLy8gaW4gcHhcXG4gIG5vcm1hbGl6ZVNsaWRlSW5kZXg6IHRydWUsXFxuICBjZW50ZXJJbnN1ZmZpY2llbnRTbGlkZXM6IGZhbHNlLFxcbiAgLy8gRGlzYWJsZSBzd2lwZXIgYW5kIGhpZGUgbmF2aWdhdGlvbiB3aGVuIGNvbnRhaW5lciBub3Qgb3ZlcmZsb3dcXG4gIHdhdGNoT3ZlcmZsb3c6IGZhbHNlLFxcbiAgLy8gUm91bmQgbGVuZ3RoXFxuICByb3VuZExlbmd0aHM6IGZhbHNlLFxcbiAgLy8gVG91Y2hlc1xcbiAgdG91Y2hSYXRpbzogMSxcXG4gIHRvdWNoQW5nbGU6IDQ1LFxcbiAgc2ltdWxhdGVUb3VjaDogdHJ1ZSxcXG4gIHNob3J0U3dpcGVzOiB0cnVlLFxcbiAgbG9uZ1N3aXBlczogdHJ1ZSxcXG4gIGxvbmdTd2lwZXNSYXRpbzogMC41LFxcbiAgbG9uZ1N3aXBlc01zOiAzMDAsXFxuICBmb2xsb3dGaW5nZXI6IHRydWUsXFxuICBhbGxvd1RvdWNoTW92ZTogdHJ1ZSxcXG4gIHRocmVzaG9sZDogMCxcXG4gIHRvdWNoTW92ZVN0b3BQcm9wYWdhdGlvbjogZmFsc2UsXFxuICB0b3VjaFN0YXJ0UHJldmVudERlZmF1bHQ6IHRydWUsXFxuICB0b3VjaFN0YXJ0Rm9yY2VQcmV2ZW50RGVmYXVsdDogZmFsc2UsXFxuICB0b3VjaFJlbGVhc2VPbkVkZ2VzOiBmYWxzZSxcXG4gIC8vIFVuaXF1ZSBOYXZpZ2F0aW9uIEVsZW1lbnRzXFxuICB1bmlxdWVOYXZFbGVtZW50czogdHJ1ZSxcXG4gIC8vIFJlc2lzdGFuY2VcXG4gIHJlc2lzdGFuY2U6IHRydWUsXFxuICByZXNpc3RhbmNlUmF0aW86IDAuODUsXFxuICAvLyBQcm9ncmVzc1xcbiAgd2F0Y2hTbGlkZXNQcm9ncmVzczogZmFsc2UsXFxuICB3YXRjaFNsaWRlc1Zpc2liaWxpdHk6IGZhbHNlLFxcbiAgLy8gQ3Vyc29yXFxuICBncmFiQ3Vyc29yOiBmYWxzZSxcXG4gIC8vIENsaWNrc1xcbiAgcHJldmVudENsaWNrczogdHJ1ZSxcXG4gIHByZXZlbnRDbGlja3NQcm9wYWdhdGlvbjogdHJ1ZSxcXG4gIHNsaWRlVG9DbGlja2VkU2xpZGU6IGZhbHNlLFxcbiAgLy8gSW1hZ2VzXFxuICBwcmVsb2FkSW1hZ2VzOiB0cnVlLFxcbiAgdXBkYXRlT25JbWFnZXNSZWFkeTogdHJ1ZSxcXG4gIC8vIGxvb3BcXG4gIGxvb3A6IGZhbHNlLFxcbiAgbG9vcEFkZGl0aW9uYWxTbGlkZXM6IDAsXFxuICBsb29wZWRTbGlkZXM6IG51bGwsXFxuICBsb29wRmlsbEdyb3VwV2l0aEJsYW5rOiBmYWxzZSxcXG4gIGxvb3BQcmV2ZW50c1NsaWRlOiB0cnVlLFxcbiAgLy8gU3dpcGluZy9ubyBzd2lwaW5nXFxuICBhbGxvd1NsaWRlUHJldjogdHJ1ZSxcXG4gIGFsbG93U2xpZGVOZXh0OiB0cnVlLFxcbiAgc3dpcGVIYW5kbGVyOiBudWxsLFxcbiAgLy8gJy5zd2lwZS1oYW5kbGVyJyxcXG4gIG5vU3dpcGluZzogdHJ1ZSxcXG4gIG5vU3dpcGluZ0NsYXNzOiAnc3dpcGVyLW5vLXN3aXBpbmcnLFxcbiAgbm9Td2lwaW5nU2VsZWN0b3I6IG51bGwsXFxuICAvLyBQYXNzaXZlIExpc3RlbmVyc1xcbiAgcGFzc2l2ZUxpc3RlbmVyczogdHJ1ZSxcXG4gIC8vIE5TXFxuICBjb250YWluZXJNb2RpZmllckNsYXNzOiAnc3dpcGVyLWNvbnRhaW5lci0nLFxcbiAgLy8gTkVXXFxuICBzbGlkZUNsYXNzOiAnc3dpcGVyLXNsaWRlJyxcXG4gIHNsaWRlQmxhbmtDbGFzczogJ3N3aXBlci1zbGlkZS1pbnZpc2libGUtYmxhbmsnLFxcbiAgc2xpZGVBY3RpdmVDbGFzczogJ3N3aXBlci1zbGlkZS1hY3RpdmUnLFxcbiAgc2xpZGVEdXBsaWNhdGVBY3RpdmVDbGFzczogJ3N3aXBlci1zbGlkZS1kdXBsaWNhdGUtYWN0aXZlJyxcXG4gIHNsaWRlVmlzaWJsZUNsYXNzOiAnc3dpcGVyLXNsaWRlLXZpc2libGUnLFxcbiAgc2xpZGVEdXBsaWNhdGVDbGFzczogJ3N3aXBlci1zbGlkZS1kdXBsaWNhdGUnLFxcbiAgc2xpZGVOZXh0Q2xhc3M6ICdzd2lwZXItc2xpZGUtbmV4dCcsXFxuICBzbGlkZUR1cGxpY2F0ZU5leHRDbGFzczogJ3N3aXBlci1zbGlkZS1kdXBsaWNhdGUtbmV4dCcsXFxuICBzbGlkZVByZXZDbGFzczogJ3N3aXBlci1zbGlkZS1wcmV2JyxcXG4gIHNsaWRlRHVwbGljYXRlUHJldkNsYXNzOiAnc3dpcGVyLXNsaWRlLWR1cGxpY2F0ZS1wcmV2JyxcXG4gIHdyYXBwZXJDbGFzczogJ3N3aXBlci13cmFwcGVyJyxcXG4gIC8vIENhbGxiYWNrc1xcbiAgcnVuQ2FsbGJhY2tzT25Jbml0OiB0cnVlLFxcbiAgLy8gSW50ZXJuYWxzXFxuICBfZW1pdENsYXNzZXM6IGZhbHNlXFxufSk7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vcGFydXMvLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvZGVmYXVsdHMuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS9ldmVudHMtZW1pdHRlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS9ldmVudHMtZW1pdHRlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwiZGVmYXVsdFxcXCI6ICgpID0+IChfX1dFQlBBQ0tfREVGQVVMVF9FWFBPUlRfXylcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlcnNjb3JlLWRhbmdsZSAqL1xcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgX19XRUJQQUNLX0RFRkFVTFRfRVhQT1JUX18gPSAoe1xcbiAgb246IGZ1bmN0aW9uIG9uKGV2ZW50cywgaGFuZGxlciwgcHJpb3JpdHkpIHtcXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgICBpZiAodHlwZW9mIGhhbmRsZXIgIT09ICdmdW5jdGlvbicpIHJldHVybiBzZWxmO1xcbiAgICB2YXIgbWV0aG9kID0gcHJpb3JpdHkgPyAndW5zaGlmdCcgOiAncHVzaCc7XFxuICAgIGV2ZW50cy5zcGxpdCgnICcpLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XFxuICAgICAgaWYgKCFzZWxmLmV2ZW50c0xpc3RlbmVyc1tldmVudF0pIHNlbGYuZXZlbnRzTGlzdGVuZXJzW2V2ZW50XSA9IFtdO1xcbiAgICAgIHNlbGYuZXZlbnRzTGlzdGVuZXJzW2V2ZW50XVttZXRob2RdKGhhbmRsZXIpO1xcbiAgICB9KTtcXG4gICAgcmV0dXJuIHNlbGY7XFxuICB9LFxcbiAgb25jZTogZnVuY3Rpb24gb25jZShldmVudHMsIGhhbmRsZXIsIHByaW9yaXR5KSB7XFxuICAgIHZhciBzZWxmID0gdGhpcztcXG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gc2VsZjtcXG5cXG4gICAgZnVuY3Rpb24gb25jZUhhbmRsZXIoKSB7XFxuICAgICAgc2VsZi5vZmYoZXZlbnRzLCBvbmNlSGFuZGxlcik7XFxuXFxuICAgICAgaWYgKG9uY2VIYW5kbGVyLl9fZW1pdHRlclByb3h5KSB7XFxuICAgICAgICBkZWxldGUgb25jZUhhbmRsZXIuX19lbWl0dGVyUHJveHk7XFxuICAgICAgfVxcblxcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xcbiAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcXG4gICAgICB9XFxuXFxuICAgICAgaGFuZGxlci5hcHBseShzZWxmLCBhcmdzKTtcXG4gICAgfVxcblxcbiAgICBvbmNlSGFuZGxlci5fX2VtaXR0ZXJQcm94eSA9IGhhbmRsZXI7XFxuICAgIHJldHVybiBzZWxmLm9uKGV2ZW50cywgb25jZUhhbmRsZXIsIHByaW9yaXR5KTtcXG4gIH0sXFxuICBvbkFueTogZnVuY3Rpb24gb25BbnkoaGFuZGxlciwgcHJpb3JpdHkpIHtcXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgICBpZiAodHlwZW9mIGhhbmRsZXIgIT09ICdmdW5jdGlvbicpIHJldHVybiBzZWxmO1xcbiAgICB2YXIgbWV0aG9kID0gcHJpb3JpdHkgPyAndW5zaGlmdCcgOiAncHVzaCc7XFxuXFxuICAgIGlmIChzZWxmLmV2ZW50c0FueUxpc3RlbmVycy5pbmRleE9mKGhhbmRsZXIpIDwgMCkge1xcbiAgICAgIHNlbGYuZXZlbnRzQW55TGlzdGVuZXJzW21ldGhvZF0oaGFuZGxlcik7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIHNlbGY7XFxuICB9LFxcbiAgb2ZmQW55OiBmdW5jdGlvbiBvZmZBbnkoaGFuZGxlcikge1xcbiAgICB2YXIgc2VsZiA9IHRoaXM7XFxuICAgIGlmICghc2VsZi5ldmVudHNBbnlMaXN0ZW5lcnMpIHJldHVybiBzZWxmO1xcbiAgICB2YXIgaW5kZXggPSBzZWxmLmV2ZW50c0FueUxpc3RlbmVycy5pbmRleE9mKGhhbmRsZXIpO1xcblxcbiAgICBpZiAoaW5kZXggPj0gMCkge1xcbiAgICAgIHNlbGYuZXZlbnRzQW55TGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIHNlbGY7XFxuICB9LFxcbiAgb2ZmOiBmdW5jdGlvbiBvZmYoZXZlbnRzLCBoYW5kbGVyKSB7XFxuICAgIHZhciBzZWxmID0gdGhpcztcXG4gICAgaWYgKCFzZWxmLmV2ZW50c0xpc3RlbmVycykgcmV0dXJuIHNlbGY7XFxuICAgIGV2ZW50cy5zcGxpdCgnICcpLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XFxuICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAndW5kZWZpbmVkJykge1xcbiAgICAgICAgc2VsZi5ldmVudHNMaXN0ZW5lcnNbZXZlbnRdID0gW107XFxuICAgICAgfSBlbHNlIGlmIChzZWxmLmV2ZW50c0xpc3RlbmVyc1tldmVudF0pIHtcXG4gICAgICAgIHNlbGYuZXZlbnRzTGlzdGVuZXJzW2V2ZW50XS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudEhhbmRsZXIsIGluZGV4KSB7XFxuICAgICAgICAgIGlmIChldmVudEhhbmRsZXIgPT09IGhhbmRsZXIgfHwgZXZlbnRIYW5kbGVyLl9fZW1pdHRlclByb3h5ICYmIGV2ZW50SGFuZGxlci5fX2VtaXR0ZXJQcm94eSA9PT0gaGFuZGxlcikge1xcbiAgICAgICAgICAgIHNlbGYuZXZlbnRzTGlzdGVuZXJzW2V2ZW50XS5zcGxpY2UoaW5kZXgsIDEpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuICAgIH0pO1xcbiAgICByZXR1cm4gc2VsZjtcXG4gIH0sXFxuICBlbWl0OiBmdW5jdGlvbiBlbWl0KCkge1xcbiAgICB2YXIgc2VsZiA9IHRoaXM7XFxuICAgIGlmICghc2VsZi5ldmVudHNMaXN0ZW5lcnMpIHJldHVybiBzZWxmO1xcbiAgICB2YXIgZXZlbnRzO1xcbiAgICB2YXIgZGF0YTtcXG4gICAgdmFyIGNvbnRleHQ7XFxuXFxuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xcbiAgICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcXG4gICAgfVxcblxcbiAgICBpZiAodHlwZW9mIGFyZ3NbMF0gPT09ICdzdHJpbmcnIHx8IEFycmF5LmlzQXJyYXkoYXJnc1swXSkpIHtcXG4gICAgICBldmVudHMgPSBhcmdzWzBdO1xcbiAgICAgIGRhdGEgPSBhcmdzLnNsaWNlKDEsIGFyZ3MubGVuZ3RoKTtcXG4gICAgICBjb250ZXh0ID0gc2VsZjtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBldmVudHMgPSBhcmdzWzBdLmV2ZW50cztcXG4gICAgICBkYXRhID0gYXJnc1swXS5kYXRhO1xcbiAgICAgIGNvbnRleHQgPSBhcmdzWzBdLmNvbnRleHQgfHwgc2VsZjtcXG4gICAgfVxcblxcbiAgICBkYXRhLnVuc2hpZnQoY29udGV4dCk7XFxuICAgIHZhciBldmVudHNBcnJheSA9IEFycmF5LmlzQXJyYXkoZXZlbnRzKSA/IGV2ZW50cyA6IGV2ZW50cy5zcGxpdCgnICcpO1xcbiAgICBldmVudHNBcnJheS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xcbiAgICAgIGlmIChzZWxmLmV2ZW50c0FueUxpc3RlbmVycyAmJiBzZWxmLmV2ZW50c0FueUxpc3RlbmVycy5sZW5ndGgpIHtcXG4gICAgICAgIHNlbGYuZXZlbnRzQW55TGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50SGFuZGxlcikge1xcbiAgICAgICAgICBldmVudEhhbmRsZXIuYXBwbHkoY29udGV4dCwgW2V2ZW50XS5jb25jYXQoZGF0YSkpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChzZWxmLmV2ZW50c0xpc3RlbmVycyAmJiBzZWxmLmV2ZW50c0xpc3RlbmVyc1tldmVudF0pIHtcXG4gICAgICAgIHNlbGYuZXZlbnRzTGlzdGVuZXJzW2V2ZW50XS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudEhhbmRsZXIpIHtcXG4gICAgICAgICAgZXZlbnRIYW5kbGVyLmFwcGx5KGNvbnRleHQsIGRhdGEpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfVxcbiAgICB9KTtcXG4gICAgcmV0dXJuIHNlbGY7XFxuICB9XFxufSk7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vcGFydXMvLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvZXZlbnRzLWVtaXR0ZXIuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS9ldmVudHMvaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL2V2ZW50cy9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcImRlZmF1bHRcXFwiOiAoKSA9PiAoX19XRUJQQUNLX0RFRkFVTFRfRVhQT1JUX18pXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHNzci13aW5kb3cgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3Nzci13aW5kb3cvc3NyLXdpbmRvdy5lc20uanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX29uVG91Y2hTdGFydF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9vblRvdWNoU3RhcnQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL2V2ZW50cy9vblRvdWNoU3RhcnQuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX29uVG91Y2hNb3ZlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL29uVG91Y2hNb3ZlICovIFxcXCIuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS9ldmVudHMvb25Ub3VjaE1vdmUuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX29uVG91Y2hFbmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vb25Ub3VjaEVuZCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvZXZlbnRzL29uVG91Y2hFbmQuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX29uUmVzaXplX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL29uUmVzaXplICovIFxcXCIuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS9ldmVudHMvb25SZXNpemUuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX29uQ2xpY2tfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vb25DbGljayAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvZXZlbnRzL29uQ2xpY2suanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX29uU2Nyb2xsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL29uU2Nyb2xsICovIFxcXCIuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS9ldmVudHMvb25TY3JvbGwuanNcXFwiKTtcXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG52YXIgZHVtbXlFdmVudEF0dGFjaGVkID0gZmFsc2U7XFxuXFxuZnVuY3Rpb24gZHVtbXlFdmVudExpc3RlbmVyKCkge31cXG5cXG5mdW5jdGlvbiBhdHRhY2hFdmVudHMoKSB7XFxuICB2YXIgc3dpcGVyID0gdGhpcztcXG4gIHZhciBkb2N1bWVudCA9ICgwLHNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5nZXREb2N1bWVudCkoKTtcXG4gIHZhciBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLFxcbiAgICAgIHRvdWNoRXZlbnRzID0gc3dpcGVyLnRvdWNoRXZlbnRzLFxcbiAgICAgIGVsID0gc3dpcGVyLmVsLFxcbiAgICAgIHdyYXBwZXJFbCA9IHN3aXBlci53cmFwcGVyRWwsXFxuICAgICAgZGV2aWNlID0gc3dpcGVyLmRldmljZSxcXG4gICAgICBzdXBwb3J0ID0gc3dpcGVyLnN1cHBvcnQ7XFxuICBzd2lwZXIub25Ub3VjaFN0YXJ0ID0gX29uVG91Y2hTdGFydF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJkZWZhdWx0XFxcIl0uYmluZChzd2lwZXIpO1xcbiAgc3dpcGVyLm9uVG91Y2hNb3ZlID0gX29uVG91Y2hNb3ZlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcImRlZmF1bHRcXFwiXS5iaW5kKHN3aXBlcik7XFxuICBzd2lwZXIub25Ub3VjaEVuZCA9IF9vblRvdWNoRW5kX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXFxcImRlZmF1bHRcXFwiXS5iaW5kKHN3aXBlcik7XFxuXFxuICBpZiAocGFyYW1zLmNzc01vZGUpIHtcXG4gICAgc3dpcGVyLm9uU2Nyb2xsID0gX29uU2Nyb2xsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXFxcImRlZmF1bHRcXFwiXS5iaW5kKHN3aXBlcik7XFxuICB9XFxuXFxuICBzd2lwZXIub25DbGljayA9IF9vbkNsaWNrX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXFxcImRlZmF1bHRcXFwiXS5iaW5kKHN3aXBlcik7XFxuICB2YXIgY2FwdHVyZSA9ICEhcGFyYW1zLm5lc3RlZDsgLy8gVG91Y2ggRXZlbnRzXFxuXFxuICBpZiAoIXN1cHBvcnQudG91Y2ggJiYgc3VwcG9ydC5wb2ludGVyRXZlbnRzKSB7XFxuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIodG91Y2hFdmVudHMuc3RhcnQsIHN3aXBlci5vblRvdWNoU3RhcnQsIGZhbHNlKTtcXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0b3VjaEV2ZW50cy5tb3ZlLCBzd2lwZXIub25Ub3VjaE1vdmUsIGNhcHR1cmUpO1xcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKHRvdWNoRXZlbnRzLmVuZCwgc3dpcGVyLm9uVG91Y2hFbmQsIGZhbHNlKTtcXG4gIH0gZWxzZSB7XFxuICAgIGlmIChzdXBwb3J0LnRvdWNoKSB7XFxuICAgICAgdmFyIHBhc3NpdmVMaXN0ZW5lciA9IHRvdWNoRXZlbnRzLnN0YXJ0ID09PSAndG91Y2hzdGFydCcgJiYgc3VwcG9ydC5wYXNzaXZlTGlzdGVuZXIgJiYgcGFyYW1zLnBhc3NpdmVMaXN0ZW5lcnMgPyB7XFxuICAgICAgICBwYXNzaXZlOiB0cnVlLFxcbiAgICAgICAgY2FwdHVyZTogZmFsc2VcXG4gICAgICB9IDogZmFsc2U7XFxuICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcih0b3VjaEV2ZW50cy5zdGFydCwgc3dpcGVyLm9uVG91Y2hTdGFydCwgcGFzc2l2ZUxpc3RlbmVyKTtcXG4gICAgICBlbC5hZGRFdmVudExpc3RlbmVyKHRvdWNoRXZlbnRzLm1vdmUsIHN3aXBlci5vblRvdWNoTW92ZSwgc3VwcG9ydC5wYXNzaXZlTGlzdGVuZXIgPyB7XFxuICAgICAgICBwYXNzaXZlOiBmYWxzZSxcXG4gICAgICAgIGNhcHR1cmU6IGNhcHR1cmVcXG4gICAgICB9IDogY2FwdHVyZSk7XFxuICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcih0b3VjaEV2ZW50cy5lbmQsIHN3aXBlci5vblRvdWNoRW5kLCBwYXNzaXZlTGlzdGVuZXIpO1xcblxcbiAgICAgIGlmICh0b3VjaEV2ZW50cy5jYW5jZWwpIHtcXG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIodG91Y2hFdmVudHMuY2FuY2VsLCBzd2lwZXIub25Ub3VjaEVuZCwgcGFzc2l2ZUxpc3RlbmVyKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCFkdW1teUV2ZW50QXR0YWNoZWQpIHtcXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBkdW1teUV2ZW50TGlzdGVuZXIpO1xcbiAgICAgICAgZHVtbXlFdmVudEF0dGFjaGVkID0gdHJ1ZTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgaWYgKHBhcmFtcy5zaW11bGF0ZVRvdWNoICYmICFkZXZpY2UuaW9zICYmICFkZXZpY2UuYW5kcm9pZCB8fCBwYXJhbXMuc2ltdWxhdGVUb3VjaCAmJiAhc3VwcG9ydC50b3VjaCAmJiBkZXZpY2UuaW9zKSB7XFxuICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgc3dpcGVyLm9uVG91Y2hTdGFydCwgZmFsc2UpO1xcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHN3aXBlci5vblRvdWNoTW92ZSwgY2FwdHVyZSk7XFxuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHN3aXBlci5vblRvdWNoRW5kLCBmYWxzZSk7XFxuICAgIH1cXG4gIH0gLy8gUHJldmVudCBMaW5rcyBDbGlja3NcXG5cXG5cXG4gIGlmIChwYXJhbXMucHJldmVudENsaWNrcyB8fCBwYXJhbXMucHJldmVudENsaWNrc1Byb3BhZ2F0aW9uKSB7XFxuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgc3dpcGVyLm9uQ2xpY2ssIHRydWUpO1xcbiAgfVxcblxcbiAgaWYgKHBhcmFtcy5jc3NNb2RlKSB7XFxuICAgIHdyYXBwZXJFbC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBzd2lwZXIub25TY3JvbGwpO1xcbiAgfSAvLyBSZXNpemUgaGFuZGxlclxcblxcblxcbiAgaWYgKHBhcmFtcy51cGRhdGVPbldpbmRvd1Jlc2l6ZSkge1xcbiAgICBzd2lwZXIub24oZGV2aWNlLmlvcyB8fCBkZXZpY2UuYW5kcm9pZCA/ICdyZXNpemUgb3JpZW50YXRpb25jaGFuZ2Ugb2JzZXJ2ZXJVcGRhdGUnIDogJ3Jlc2l6ZSBvYnNlcnZlclVwZGF0ZScsIF9vblJlc2l6ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1xcXCJkZWZhdWx0XFxcIl0sIHRydWUpO1xcbiAgfSBlbHNlIHtcXG4gICAgc3dpcGVyLm9uKCdvYnNlcnZlclVwZGF0ZScsIF9vblJlc2l6ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1xcXCJkZWZhdWx0XFxcIl0sIHRydWUpO1xcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBkZXRhY2hFdmVudHMoKSB7XFxuICB2YXIgc3dpcGVyID0gdGhpcztcXG4gIHZhciBkb2N1bWVudCA9ICgwLHNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5nZXREb2N1bWVudCkoKTtcXG4gIHZhciBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLFxcbiAgICAgIHRvdWNoRXZlbnRzID0gc3dpcGVyLnRvdWNoRXZlbnRzLFxcbiAgICAgIGVsID0gc3dpcGVyLmVsLFxcbiAgICAgIHdyYXBwZXJFbCA9IHN3aXBlci53cmFwcGVyRWwsXFxuICAgICAgZGV2aWNlID0gc3dpcGVyLmRldmljZSxcXG4gICAgICBzdXBwb3J0ID0gc3dpcGVyLnN1cHBvcnQ7XFxuICB2YXIgY2FwdHVyZSA9ICEhcGFyYW1zLm5lc3RlZDsgLy8gVG91Y2ggRXZlbnRzXFxuXFxuICBpZiAoIXN1cHBvcnQudG91Y2ggJiYgc3VwcG9ydC5wb2ludGVyRXZlbnRzKSB7XFxuICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodG91Y2hFdmVudHMuc3RhcnQsIHN3aXBlci5vblRvdWNoU3RhcnQsIGZhbHNlKTtcXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0b3VjaEV2ZW50cy5tb3ZlLCBzd2lwZXIub25Ub3VjaE1vdmUsIGNhcHR1cmUpO1xcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHRvdWNoRXZlbnRzLmVuZCwgc3dpcGVyLm9uVG91Y2hFbmQsIGZhbHNlKTtcXG4gIH0gZWxzZSB7XFxuICAgIGlmIChzdXBwb3J0LnRvdWNoKSB7XFxuICAgICAgdmFyIHBhc3NpdmVMaXN0ZW5lciA9IHRvdWNoRXZlbnRzLnN0YXJ0ID09PSAnb25Ub3VjaFN0YXJ0JyAmJiBzdXBwb3J0LnBhc3NpdmVMaXN0ZW5lciAmJiBwYXJhbXMucGFzc2l2ZUxpc3RlbmVycyA/IHtcXG4gICAgICAgIHBhc3NpdmU6IHRydWUsXFxuICAgICAgICBjYXB0dXJlOiBmYWxzZVxcbiAgICAgIH0gOiBmYWxzZTtcXG4gICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKHRvdWNoRXZlbnRzLnN0YXJ0LCBzd2lwZXIub25Ub3VjaFN0YXJ0LCBwYXNzaXZlTGlzdGVuZXIpO1xcbiAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodG91Y2hFdmVudHMubW92ZSwgc3dpcGVyLm9uVG91Y2hNb3ZlLCBjYXB0dXJlKTtcXG4gICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKHRvdWNoRXZlbnRzLmVuZCwgc3dpcGVyLm9uVG91Y2hFbmQsIHBhc3NpdmVMaXN0ZW5lcik7XFxuXFxuICAgICAgaWYgKHRvdWNoRXZlbnRzLmNhbmNlbCkge1xcbiAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih0b3VjaEV2ZW50cy5jYW5jZWwsIHN3aXBlci5vblRvdWNoRW5kLCBwYXNzaXZlTGlzdGVuZXIpO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBpZiAocGFyYW1zLnNpbXVsYXRlVG91Y2ggJiYgIWRldmljZS5pb3MgJiYgIWRldmljZS5hbmRyb2lkIHx8IHBhcmFtcy5zaW11bGF0ZVRvdWNoICYmICFzdXBwb3J0LnRvdWNoICYmIGRldmljZS5pb3MpIHtcXG4gICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBzd2lwZXIub25Ub3VjaFN0YXJ0LCBmYWxzZSk7XFxuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgc3dpcGVyLm9uVG91Y2hNb3ZlLCBjYXB0dXJlKTtcXG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgc3dpcGVyLm9uVG91Y2hFbmQsIGZhbHNlKTtcXG4gICAgfVxcbiAgfSAvLyBQcmV2ZW50IExpbmtzIENsaWNrc1xcblxcblxcbiAgaWYgKHBhcmFtcy5wcmV2ZW50Q2xpY2tzIHx8IHBhcmFtcy5wcmV2ZW50Q2xpY2tzUHJvcGFnYXRpb24pIHtcXG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBzd2lwZXIub25DbGljaywgdHJ1ZSk7XFxuICB9XFxuXFxuICBpZiAocGFyYW1zLmNzc01vZGUpIHtcXG4gICAgd3JhcHBlckVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHN3aXBlci5vblNjcm9sbCk7XFxuICB9IC8vIFJlc2l6ZSBoYW5kbGVyXFxuXFxuXFxuICBzd2lwZXIub2ZmKGRldmljZS5pb3MgfHwgZGV2aWNlLmFuZHJvaWQgPyAncmVzaXplIG9yaWVudGF0aW9uY2hhbmdlIG9ic2VydmVyVXBkYXRlJyA6ICdyZXNpemUgb2JzZXJ2ZXJVcGRhdGUnLCBfb25SZXNpemVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcXFwiZGVmYXVsdFxcXCJdKTtcXG59XFxuXFxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBfX1dFQlBBQ0tfREVGQVVMVF9FWFBPUlRfXyA9ICh7XFxuICBhdHRhY2hFdmVudHM6IGF0dGFjaEV2ZW50cyxcXG4gIGRldGFjaEV2ZW50czogZGV0YWNoRXZlbnRzXFxufSk7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vcGFydXMvLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvZXZlbnRzL2luZGV4LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvZXZlbnRzL29uQ2xpY2suanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvZXZlbnRzL29uQ2xpY2suanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcImRlZmF1bHRcXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBvbkNsaWNrKVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbmZ1bmN0aW9uIG9uQ2xpY2soZSkge1xcbiAgdmFyIHN3aXBlciA9IHRoaXM7XFxuICBpZiAoIXN3aXBlci5lbmFibGVkKSByZXR1cm47XFxuXFxuICBpZiAoIXN3aXBlci5hbGxvd0NsaWNrKSB7XFxuICAgIGlmIChzd2lwZXIucGFyYW1zLnByZXZlbnRDbGlja3MpIGUucHJldmVudERlZmF1bHQoKTtcXG5cXG4gICAgaWYgKHN3aXBlci5wYXJhbXMucHJldmVudENsaWNrc1Byb3BhZ2F0aW9uICYmIHN3aXBlci5hbmltYXRpbmcpIHtcXG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xcbiAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XFxuICAgIH1cXG4gIH1cXG59XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vcGFydXMvLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvZXZlbnRzL29uQ2xpY2suanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS9ldmVudHMvb25SZXNpemUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL2V2ZW50cy9vblJlc2l6ZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcImRlZmF1bHRcXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBvblJlc2l6ZSlcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG5mdW5jdGlvbiBvblJlc2l6ZSgpIHtcXG4gIHZhciBzd2lwZXIgPSB0aGlzO1xcbiAgdmFyIHBhcmFtcyA9IHN3aXBlci5wYXJhbXMsXFxuICAgICAgZWwgPSBzd2lwZXIuZWw7XFxuICBpZiAoZWwgJiYgZWwub2Zmc2V0V2lkdGggPT09IDApIHJldHVybjsgLy8gQnJlYWtwb2ludHNcXG5cXG4gIGlmIChwYXJhbXMuYnJlYWtwb2ludHMpIHtcXG4gICAgc3dpcGVyLnNldEJyZWFrcG9pbnQoKTtcXG4gIH0gLy8gU2F2ZSBsb2Nrc1xcblxcblxcbiAgdmFyIGFsbG93U2xpZGVOZXh0ID0gc3dpcGVyLmFsbG93U2xpZGVOZXh0LFxcbiAgICAgIGFsbG93U2xpZGVQcmV2ID0gc3dpcGVyLmFsbG93U2xpZGVQcmV2LFxcbiAgICAgIHNuYXBHcmlkID0gc3dpcGVyLnNuYXBHcmlkOyAvLyBEaXNhYmxlIGxvY2tzIG9uIHJlc2l6ZVxcblxcbiAgc3dpcGVyLmFsbG93U2xpZGVOZXh0ID0gdHJ1ZTtcXG4gIHN3aXBlci5hbGxvd1NsaWRlUHJldiA9IHRydWU7XFxuICBzd2lwZXIudXBkYXRlU2l6ZSgpO1xcbiAgc3dpcGVyLnVwZGF0ZVNsaWRlcygpO1xcbiAgc3dpcGVyLnVwZGF0ZVNsaWRlc0NsYXNzZXMoKTtcXG5cXG4gIGlmICgocGFyYW1zLnNsaWRlc1BlclZpZXcgPT09ICdhdXRvJyB8fCBwYXJhbXMuc2xpZGVzUGVyVmlldyA+IDEpICYmIHN3aXBlci5pc0VuZCAmJiAhc3dpcGVyLmlzQmVnaW5uaW5nICYmICFzd2lwZXIucGFyYW1zLmNlbnRlcmVkU2xpZGVzKSB7XFxuICAgIHN3aXBlci5zbGlkZVRvKHN3aXBlci5zbGlkZXMubGVuZ3RoIC0gMSwgMCwgZmFsc2UsIHRydWUpO1xcbiAgfSBlbHNlIHtcXG4gICAgc3dpcGVyLnNsaWRlVG8oc3dpcGVyLmFjdGl2ZUluZGV4LCAwLCBmYWxzZSwgdHJ1ZSk7XFxuICB9XFxuXFxuICBpZiAoc3dpcGVyLmF1dG9wbGF5ICYmIHN3aXBlci5hdXRvcGxheS5ydW5uaW5nICYmIHN3aXBlci5hdXRvcGxheS5wYXVzZWQpIHtcXG4gICAgc3dpcGVyLmF1dG9wbGF5LnJ1bigpO1xcbiAgfSAvLyBSZXR1cm4gbG9ja3MgYWZ0ZXIgcmVzaXplXFxuXFxuXFxuICBzd2lwZXIuYWxsb3dTbGlkZVByZXYgPSBhbGxvd1NsaWRlUHJldjtcXG4gIHN3aXBlci5hbGxvd1NsaWRlTmV4dCA9IGFsbG93U2xpZGVOZXh0O1xcblxcbiAgaWYgKHN3aXBlci5wYXJhbXMud2F0Y2hPdmVyZmxvdyAmJiBzbmFwR3JpZCAhPT0gc3dpcGVyLnNuYXBHcmlkKSB7XFxuICAgIHN3aXBlci5jaGVja092ZXJmbG93KCk7XFxuICB9XFxufVxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3BhcnVzLy4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL2V2ZW50cy9vblJlc2l6ZS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL2V2ZW50cy9vblNjcm9sbC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvZXZlbnRzL29uU2Nyb2xsLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwiZGVmYXVsdFxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIG9uU2Nyb2xsKVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbmZ1bmN0aW9uIG9uU2Nyb2xsKCkge1xcbiAgdmFyIHN3aXBlciA9IHRoaXM7XFxuICB2YXIgd3JhcHBlckVsID0gc3dpcGVyLndyYXBwZXJFbCxcXG4gICAgICBydGxUcmFuc2xhdGUgPSBzd2lwZXIucnRsVHJhbnNsYXRlLFxcbiAgICAgIGVuYWJsZWQgPSBzd2lwZXIuZW5hYmxlZDtcXG4gIGlmICghZW5hYmxlZCkgcmV0dXJuO1xcbiAgc3dpcGVyLnByZXZpb3VzVHJhbnNsYXRlID0gc3dpcGVyLnRyYW5zbGF0ZTtcXG5cXG4gIGlmIChzd2lwZXIuaXNIb3Jpem9udGFsKCkpIHtcXG4gICAgaWYgKHJ0bFRyYW5zbGF0ZSkge1xcbiAgICAgIHN3aXBlci50cmFuc2xhdGUgPSB3cmFwcGVyRWwuc2Nyb2xsV2lkdGggLSB3cmFwcGVyRWwub2Zmc2V0V2lkdGggLSB3cmFwcGVyRWwuc2Nyb2xsTGVmdDtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBzd2lwZXIudHJhbnNsYXRlID0gLXdyYXBwZXJFbC5zY3JvbGxMZWZ0O1xcbiAgICB9XFxuICB9IGVsc2Uge1xcbiAgICBzd2lwZXIudHJhbnNsYXRlID0gLXdyYXBwZXJFbC5zY3JvbGxUb3A7XFxuICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxcblxcblxcbiAgaWYgKHN3aXBlci50cmFuc2xhdGUgPT09IC0wKSBzd2lwZXIudHJhbnNsYXRlID0gMDtcXG4gIHN3aXBlci51cGRhdGVBY3RpdmVJbmRleCgpO1xcbiAgc3dpcGVyLnVwZGF0ZVNsaWRlc0NsYXNzZXMoKTtcXG4gIHZhciBuZXdQcm9ncmVzcztcXG4gIHZhciB0cmFuc2xhdGVzRGlmZiA9IHN3aXBlci5tYXhUcmFuc2xhdGUoKSAtIHN3aXBlci5taW5UcmFuc2xhdGUoKTtcXG5cXG4gIGlmICh0cmFuc2xhdGVzRGlmZiA9PT0gMCkge1xcbiAgICBuZXdQcm9ncmVzcyA9IDA7XFxuICB9IGVsc2Uge1xcbiAgICBuZXdQcm9ncmVzcyA9IChzd2lwZXIudHJhbnNsYXRlIC0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpKSAvIHRyYW5zbGF0ZXNEaWZmO1xcbiAgfVxcblxcbiAgaWYgKG5ld1Byb2dyZXNzICE9PSBzd2lwZXIucHJvZ3Jlc3MpIHtcXG4gICAgc3dpcGVyLnVwZGF0ZVByb2dyZXNzKHJ0bFRyYW5zbGF0ZSA/IC1zd2lwZXIudHJhbnNsYXRlIDogc3dpcGVyLnRyYW5zbGF0ZSk7XFxuICB9XFxuXFxuICBzd2lwZXIuZW1pdCgnc2V0VHJhbnNsYXRlJywgc3dpcGVyLnRyYW5zbGF0ZSwgZmFsc2UpO1xcbn1cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9wYXJ1cy8uL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS9ldmVudHMvb25TY3JvbGwuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS9ldmVudHMvb25Ub3VjaEVuZC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS9ldmVudHMvb25Ub3VjaEVuZC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwiZGVmYXVsdFxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIG9uVG91Y2hFbmQpXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc191dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vLi4vdXRpbHMvdXRpbHMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vdXRpbHMvdXRpbHMuanNcXFwiKTtcXG5cXG5mdW5jdGlvbiBvblRvdWNoRW5kKGV2ZW50KSB7XFxuICB2YXIgc3dpcGVyID0gdGhpcztcXG4gIHZhciBkYXRhID0gc3dpcGVyLnRvdWNoRXZlbnRzRGF0YTtcXG4gIHZhciBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLFxcbiAgICAgIHRvdWNoZXMgPSBzd2lwZXIudG91Y2hlcyxcXG4gICAgICBydGwgPSBzd2lwZXIucnRsVHJhbnNsYXRlLFxcbiAgICAgICR3cmFwcGVyRWwgPSBzd2lwZXIuJHdyYXBwZXJFbCxcXG4gICAgICBzbGlkZXNHcmlkID0gc3dpcGVyLnNsaWRlc0dyaWQsXFxuICAgICAgc25hcEdyaWQgPSBzd2lwZXIuc25hcEdyaWQsXFxuICAgICAgZW5hYmxlZCA9IHN3aXBlci5lbmFibGVkO1xcbiAgaWYgKCFlbmFibGVkKSByZXR1cm47XFxuICB2YXIgZSA9IGV2ZW50O1xcbiAgaWYgKGUub3JpZ2luYWxFdmVudCkgZSA9IGUub3JpZ2luYWxFdmVudDtcXG5cXG4gIGlmIChkYXRhLmFsbG93VG91Y2hDYWxsYmFja3MpIHtcXG4gICAgc3dpcGVyLmVtaXQoJ3RvdWNoRW5kJywgZSk7XFxuICB9XFxuXFxuICBkYXRhLmFsbG93VG91Y2hDYWxsYmFja3MgPSBmYWxzZTtcXG5cXG4gIGlmICghZGF0YS5pc1RvdWNoZWQpIHtcXG4gICAgaWYgKGRhdGEuaXNNb3ZlZCAmJiBwYXJhbXMuZ3JhYkN1cnNvcikge1xcbiAgICAgIHN3aXBlci5zZXRHcmFiQ3Vyc29yKGZhbHNlKTtcXG4gICAgfVxcblxcbiAgICBkYXRhLmlzTW92ZWQgPSBmYWxzZTtcXG4gICAgZGF0YS5zdGFydE1vdmluZyA9IGZhbHNlO1xcbiAgICByZXR1cm47XFxuICB9IC8vIFJldHVybiBHcmFiIEN1cnNvclxcblxcblxcbiAgaWYgKHBhcmFtcy5ncmFiQ3Vyc29yICYmIGRhdGEuaXNNb3ZlZCAmJiBkYXRhLmlzVG91Y2hlZCAmJiAoc3dpcGVyLmFsbG93U2xpZGVOZXh0ID09PSB0cnVlIHx8IHN3aXBlci5hbGxvd1NsaWRlUHJldiA9PT0gdHJ1ZSkpIHtcXG4gICAgc3dpcGVyLnNldEdyYWJDdXJzb3IoZmFsc2UpO1xcbiAgfSAvLyBUaW1lIGRpZmZcXG5cXG5cXG4gIHZhciB0b3VjaEVuZFRpbWUgPSAoMCxfdXRpbHNfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5ub3cpKCk7XFxuICB2YXIgdGltZURpZmYgPSB0b3VjaEVuZFRpbWUgLSBkYXRhLnRvdWNoU3RhcnRUaW1lOyAvLyBUYXAsIGRvdWJsZVRhcCwgQ2xpY2tcXG5cXG4gIGlmIChzd2lwZXIuYWxsb3dDbGljaykge1xcbiAgICBzd2lwZXIudXBkYXRlQ2xpY2tlZFNsaWRlKGUpO1xcbiAgICBzd2lwZXIuZW1pdCgndGFwIGNsaWNrJywgZSk7XFxuXFxuICAgIGlmICh0aW1lRGlmZiA8IDMwMCAmJiB0b3VjaEVuZFRpbWUgLSBkYXRhLmxhc3RDbGlja1RpbWUgPCAzMDApIHtcXG4gICAgICBzd2lwZXIuZW1pdCgnZG91YmxlVGFwIGRvdWJsZUNsaWNrJywgZSk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGRhdGEubGFzdENsaWNrVGltZSA9ICgwLF91dGlsc191dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLm5vdykoKTtcXG4gICgwLF91dGlsc191dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLm5leHRUaWNrKShmdW5jdGlvbiAoKSB7XFxuICAgIGlmICghc3dpcGVyLmRlc3Ryb3llZCkgc3dpcGVyLmFsbG93Q2xpY2sgPSB0cnVlO1xcbiAgfSk7XFxuXFxuICBpZiAoIWRhdGEuaXNUb3VjaGVkIHx8ICFkYXRhLmlzTW92ZWQgfHwgIXN3aXBlci5zd2lwZURpcmVjdGlvbiB8fCB0b3VjaGVzLmRpZmYgPT09IDAgfHwgZGF0YS5jdXJyZW50VHJhbnNsYXRlID09PSBkYXRhLnN0YXJ0VHJhbnNsYXRlKSB7XFxuICAgIGRhdGEuaXNUb3VjaGVkID0gZmFsc2U7XFxuICAgIGRhdGEuaXNNb3ZlZCA9IGZhbHNlO1xcbiAgICBkYXRhLnN0YXJ0TW92aW5nID0gZmFsc2U7XFxuICAgIHJldHVybjtcXG4gIH1cXG5cXG4gIGRhdGEuaXNUb3VjaGVkID0gZmFsc2U7XFxuICBkYXRhLmlzTW92ZWQgPSBmYWxzZTtcXG4gIGRhdGEuc3RhcnRNb3ZpbmcgPSBmYWxzZTtcXG4gIHZhciBjdXJyZW50UG9zO1xcblxcbiAgaWYgKHBhcmFtcy5mb2xsb3dGaW5nZXIpIHtcXG4gICAgY3VycmVudFBvcyA9IHJ0bCA/IHN3aXBlci50cmFuc2xhdGUgOiAtc3dpcGVyLnRyYW5zbGF0ZTtcXG4gIH0gZWxzZSB7XFxuICAgIGN1cnJlbnRQb3MgPSAtZGF0YS5jdXJyZW50VHJhbnNsYXRlO1xcbiAgfVxcblxcbiAgaWYgKHBhcmFtcy5jc3NNb2RlKSB7XFxuICAgIHJldHVybjtcXG4gIH1cXG5cXG4gIGlmIChwYXJhbXMuZnJlZU1vZGUpIHtcXG4gICAgaWYgKGN1cnJlbnRQb3MgPCAtc3dpcGVyLm1pblRyYW5zbGF0ZSgpKSB7XFxuICAgICAgc3dpcGVyLnNsaWRlVG8oc3dpcGVyLmFjdGl2ZUluZGV4KTtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgaWYgKGN1cnJlbnRQb3MgPiAtc3dpcGVyLm1heFRyYW5zbGF0ZSgpKSB7XFxuICAgICAgaWYgKHN3aXBlci5zbGlkZXMubGVuZ3RoIDwgc25hcEdyaWQubGVuZ3RoKSB7XFxuICAgICAgICBzd2lwZXIuc2xpZGVUbyhzbmFwR3JpZC5sZW5ndGggLSAxKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgc3dpcGVyLnNsaWRlVG8oc3dpcGVyLnNsaWRlcy5sZW5ndGggLSAxKTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGlmIChwYXJhbXMuZnJlZU1vZGVNb21lbnR1bSkge1xcbiAgICAgIGlmIChkYXRhLnZlbG9jaXRpZXMubGVuZ3RoID4gMSkge1xcbiAgICAgICAgdmFyIGxhc3RNb3ZlRXZlbnQgPSBkYXRhLnZlbG9jaXRpZXMucG9wKCk7XFxuICAgICAgICB2YXIgdmVsb2NpdHlFdmVudCA9IGRhdGEudmVsb2NpdGllcy5wb3AoKTtcXG4gICAgICAgIHZhciBkaXN0YW5jZSA9IGxhc3RNb3ZlRXZlbnQucG9zaXRpb24gLSB2ZWxvY2l0eUV2ZW50LnBvc2l0aW9uO1xcbiAgICAgICAgdmFyIHRpbWUgPSBsYXN0TW92ZUV2ZW50LnRpbWUgLSB2ZWxvY2l0eUV2ZW50LnRpbWU7XFxuICAgICAgICBzd2lwZXIudmVsb2NpdHkgPSBkaXN0YW5jZSAvIHRpbWU7XFxuICAgICAgICBzd2lwZXIudmVsb2NpdHkgLz0gMjtcXG5cXG4gICAgICAgIGlmIChNYXRoLmFicyhzd2lwZXIudmVsb2NpdHkpIDwgcGFyYW1zLmZyZWVNb2RlTWluaW11bVZlbG9jaXR5KSB7XFxuICAgICAgICAgIHN3aXBlci52ZWxvY2l0eSA9IDA7XFxuICAgICAgICB9IC8vIHRoaXMgaW1wbGllcyB0aGF0IHRoZSB1c2VyIHN0b3BwZWQgbW92aW5nIGEgZmluZ2VyIHRoZW4gcmVsZWFzZWQuXFxuICAgICAgICAvLyBUaGVyZSB3b3VsZCBiZSBubyBldmVudHMgd2l0aCBkaXN0YW5jZSB6ZXJvLCBzbyB0aGUgbGFzdCBldmVudCBpcyBzdGFsZS5cXG5cXG5cXG4gICAgICAgIGlmICh0aW1lID4gMTUwIHx8ICgwLF91dGlsc191dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLm5vdykoKSAtIGxhc3RNb3ZlRXZlbnQudGltZSA+IDMwMCkge1xcbiAgICAgICAgICBzd2lwZXIudmVsb2NpdHkgPSAwO1xcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBzd2lwZXIudmVsb2NpdHkgPSAwO1xcbiAgICAgIH1cXG5cXG4gICAgICBzd2lwZXIudmVsb2NpdHkgKj0gcGFyYW1zLmZyZWVNb2RlTW9tZW50dW1WZWxvY2l0eVJhdGlvO1xcbiAgICAgIGRhdGEudmVsb2NpdGllcy5sZW5ndGggPSAwO1xcbiAgICAgIHZhciBtb21lbnR1bUR1cmF0aW9uID0gMTAwMCAqIHBhcmFtcy5mcmVlTW9kZU1vbWVudHVtUmF0aW87XFxuICAgICAgdmFyIG1vbWVudHVtRGlzdGFuY2UgPSBzd2lwZXIudmVsb2NpdHkgKiBtb21lbnR1bUR1cmF0aW9uO1xcbiAgICAgIHZhciBuZXdQb3NpdGlvbiA9IHN3aXBlci50cmFuc2xhdGUgKyBtb21lbnR1bURpc3RhbmNlO1xcbiAgICAgIGlmIChydGwpIG5ld1Bvc2l0aW9uID0gLW5ld1Bvc2l0aW9uO1xcbiAgICAgIHZhciBkb0JvdW5jZSA9IGZhbHNlO1xcbiAgICAgIHZhciBhZnRlckJvdW5jZVBvc2l0aW9uO1xcbiAgICAgIHZhciBib3VuY2VBbW91bnQgPSBNYXRoLmFicyhzd2lwZXIudmVsb2NpdHkpICogMjAgKiBwYXJhbXMuZnJlZU1vZGVNb21lbnR1bUJvdW5jZVJhdGlvO1xcbiAgICAgIHZhciBuZWVkc0xvb3BGaXg7XFxuXFxuICAgICAgaWYgKG5ld1Bvc2l0aW9uIDwgc3dpcGVyLm1heFRyYW5zbGF0ZSgpKSB7XFxuICAgICAgICBpZiAocGFyYW1zLmZyZWVNb2RlTW9tZW50dW1Cb3VuY2UpIHtcXG4gICAgICAgICAgaWYgKG5ld1Bvc2l0aW9uICsgc3dpcGVyLm1heFRyYW5zbGF0ZSgpIDwgLWJvdW5jZUFtb3VudCkge1xcbiAgICAgICAgICAgIG5ld1Bvc2l0aW9uID0gc3dpcGVyLm1heFRyYW5zbGF0ZSgpIC0gYm91bmNlQW1vdW50O1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGFmdGVyQm91bmNlUG9zaXRpb24gPSBzd2lwZXIubWF4VHJhbnNsYXRlKCk7XFxuICAgICAgICAgIGRvQm91bmNlID0gdHJ1ZTtcXG4gICAgICAgICAgZGF0YS5hbGxvd01vbWVudHVtQm91bmNlID0gdHJ1ZTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIG5ld1Bvc2l0aW9uID0gc3dpcGVyLm1heFRyYW5zbGF0ZSgpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKHBhcmFtcy5sb29wICYmIHBhcmFtcy5jZW50ZXJlZFNsaWRlcykgbmVlZHNMb29wRml4ID0gdHJ1ZTtcXG4gICAgICB9IGVsc2UgaWYgKG5ld1Bvc2l0aW9uID4gc3dpcGVyLm1pblRyYW5zbGF0ZSgpKSB7XFxuICAgICAgICBpZiAocGFyYW1zLmZyZWVNb2RlTW9tZW50dW1Cb3VuY2UpIHtcXG4gICAgICAgICAgaWYgKG5ld1Bvc2l0aW9uIC0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpID4gYm91bmNlQW1vdW50KSB7XFxuICAgICAgICAgICAgbmV3UG9zaXRpb24gPSBzd2lwZXIubWluVHJhbnNsYXRlKCkgKyBib3VuY2VBbW91bnQ7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgYWZ0ZXJCb3VuY2VQb3NpdGlvbiA9IHN3aXBlci5taW5UcmFuc2xhdGUoKTtcXG4gICAgICAgICAgZG9Cb3VuY2UgPSB0cnVlO1xcbiAgICAgICAgICBkYXRhLmFsbG93TW9tZW50dW1Cb3VuY2UgPSB0cnVlO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgbmV3UG9zaXRpb24gPSBzd2lwZXIubWluVHJhbnNsYXRlKCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAocGFyYW1zLmxvb3AgJiYgcGFyYW1zLmNlbnRlcmVkU2xpZGVzKSBuZWVkc0xvb3BGaXggPSB0cnVlO1xcbiAgICAgIH0gZWxzZSBpZiAocGFyYW1zLmZyZWVNb2RlU3RpY2t5KSB7XFxuICAgICAgICB2YXIgbmV4dFNsaWRlO1xcblxcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzbmFwR3JpZC5sZW5ndGg7IGogKz0gMSkge1xcbiAgICAgICAgICBpZiAoc25hcEdyaWRbal0gPiAtbmV3UG9zaXRpb24pIHtcXG4gICAgICAgICAgICBuZXh0U2xpZGUgPSBqO1xcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoTWF0aC5hYnMoc25hcEdyaWRbbmV4dFNsaWRlXSAtIG5ld1Bvc2l0aW9uKSA8IE1hdGguYWJzKHNuYXBHcmlkW25leHRTbGlkZSAtIDFdIC0gbmV3UG9zaXRpb24pIHx8IHN3aXBlci5zd2lwZURpcmVjdGlvbiA9PT0gJ25leHQnKSB7XFxuICAgICAgICAgIG5ld1Bvc2l0aW9uID0gc25hcEdyaWRbbmV4dFNsaWRlXTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIG5ld1Bvc2l0aW9uID0gc25hcEdyaWRbbmV4dFNsaWRlIC0gMV07XFxuICAgICAgICB9XFxuXFxuICAgICAgICBuZXdQb3NpdGlvbiA9IC1uZXdQb3NpdGlvbjtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKG5lZWRzTG9vcEZpeCkge1xcbiAgICAgICAgc3dpcGVyLm9uY2UoJ3RyYW5zaXRpb25FbmQnLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHN3aXBlci5sb29wRml4KCk7XFxuICAgICAgICB9KTtcXG4gICAgICB9IC8vIEZpeCBkdXJhdGlvblxcblxcblxcbiAgICAgIGlmIChzd2lwZXIudmVsb2NpdHkgIT09IDApIHtcXG4gICAgICAgIGlmIChydGwpIHtcXG4gICAgICAgICAgbW9tZW50dW1EdXJhdGlvbiA9IE1hdGguYWJzKCgtbmV3UG9zaXRpb24gLSBzd2lwZXIudHJhbnNsYXRlKSAvIHN3aXBlci52ZWxvY2l0eSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBtb21lbnR1bUR1cmF0aW9uID0gTWF0aC5hYnMoKG5ld1Bvc2l0aW9uIC0gc3dpcGVyLnRyYW5zbGF0ZSkgLyBzd2lwZXIudmVsb2NpdHkpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKHBhcmFtcy5mcmVlTW9kZVN0aWNreSkge1xcbiAgICAgICAgICAvLyBJZiBmcmVlTW9kZVN0aWNreSBpcyBhY3RpdmUgYW5kIHRoZSB1c2VyIGVuZHMgYSBzd2lwZSB3aXRoIGEgc2xvdy12ZWxvY2l0eVxcbiAgICAgICAgICAvLyBldmVudCwgdGhlbiBkdXJhdGlvbnMgY2FuIGJlIDIwKyBzZWNvbmRzIHRvIHNsaWRlIG9uZSAob3IgemVybyEpIHNsaWRlcy5cXG4gICAgICAgICAgLy8gSXQncyBlYXN5IHRvIHNlZSB0aGlzIHdoZW4gc2ltdWxhdGluZyB0b3VjaCB3aXRoIG1vdXNlIGV2ZW50cy4gVG8gZml4IHRoaXMsXFxuICAgICAgICAgIC8vIGxpbWl0IHNpbmdsZS1zbGlkZSBzd2lwZXMgdG8gdGhlIGRlZmF1bHQgc2xpZGUgZHVyYXRpb24uIFRoaXMgYWxzbyBoYXMgdGhlXFxuICAgICAgICAgIC8vIG5pY2Ugc2lkZSBlZmZlY3Qgb2YgbWF0Y2hpbmcgc2xpZGUgc3BlZWQgaWYgdGhlIHVzZXIgc3RvcHBlZCBtb3ZpbmcgYmVmb3JlXFxuICAgICAgICAgIC8vIGxpZnRpbmcgZmluZ2VyIG9yIG1vdXNlIHZzLiBtb3Zpbmcgc2xvd2x5IGJlZm9yZSBsaWZ0aW5nIHRoZSBmaW5nZXIvbW91c2UuXFxuICAgICAgICAgIC8vIEZvciBmYXN0ZXIgc3dpcGVzLCBhbHNvIGFwcGx5IGxpbWl0cyAoYWxiZWl0IGhpZ2hlciBvbmVzKS5cXG4gICAgICAgICAgdmFyIG1vdmVEaXN0YW5jZSA9IE1hdGguYWJzKChydGwgPyAtbmV3UG9zaXRpb24gOiBuZXdQb3NpdGlvbikgLSBzd2lwZXIudHJhbnNsYXRlKTtcXG4gICAgICAgICAgdmFyIGN1cnJlbnRTbGlkZVNpemUgPSBzd2lwZXIuc2xpZGVzU2l6ZXNHcmlkW3N3aXBlci5hY3RpdmVJbmRleF07XFxuXFxuICAgICAgICAgIGlmIChtb3ZlRGlzdGFuY2UgPCBjdXJyZW50U2xpZGVTaXplKSB7XFxuICAgICAgICAgICAgbW9tZW50dW1EdXJhdGlvbiA9IHBhcmFtcy5zcGVlZDtcXG4gICAgICAgICAgfSBlbHNlIGlmIChtb3ZlRGlzdGFuY2UgPCAyICogY3VycmVudFNsaWRlU2l6ZSkge1xcbiAgICAgICAgICAgIG1vbWVudHVtRHVyYXRpb24gPSBwYXJhbXMuc3BlZWQgKiAxLjU7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgbW9tZW50dW1EdXJhdGlvbiA9IHBhcmFtcy5zcGVlZCAqIDIuNTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSBpZiAocGFyYW1zLmZyZWVNb2RlU3RpY2t5KSB7XFxuICAgICAgICBzd2lwZXIuc2xpZGVUb0Nsb3Nlc3QoKTtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHBhcmFtcy5mcmVlTW9kZU1vbWVudHVtQm91bmNlICYmIGRvQm91bmNlKSB7XFxuICAgICAgICBzd2lwZXIudXBkYXRlUHJvZ3Jlc3MoYWZ0ZXJCb3VuY2VQb3NpdGlvbik7XFxuICAgICAgICBzd2lwZXIuc2V0VHJhbnNpdGlvbihtb21lbnR1bUR1cmF0aW9uKTtcXG4gICAgICAgIHN3aXBlci5zZXRUcmFuc2xhdGUobmV3UG9zaXRpb24pO1xcbiAgICAgICAgc3dpcGVyLnRyYW5zaXRpb25TdGFydCh0cnVlLCBzd2lwZXIuc3dpcGVEaXJlY3Rpb24pO1xcbiAgICAgICAgc3dpcGVyLmFuaW1hdGluZyA9IHRydWU7XFxuICAgICAgICAkd3JhcHBlckVsLnRyYW5zaXRpb25FbmQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBpZiAoIXN3aXBlciB8fCBzd2lwZXIuZGVzdHJveWVkIHx8ICFkYXRhLmFsbG93TW9tZW50dW1Cb3VuY2UpIHJldHVybjtcXG4gICAgICAgICAgc3dpcGVyLmVtaXQoJ21vbWVudHVtQm91bmNlJyk7XFxuICAgICAgICAgIHN3aXBlci5zZXRUcmFuc2l0aW9uKHBhcmFtcy5zcGVlZCk7XFxuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIHN3aXBlci5zZXRUcmFuc2xhdGUoYWZ0ZXJCb3VuY2VQb3NpdGlvbik7XFxuICAgICAgICAgICAgJHdyYXBwZXJFbC50cmFuc2l0aW9uRW5kKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgIGlmICghc3dpcGVyIHx8IHN3aXBlci5kZXN0cm95ZWQpIHJldHVybjtcXG4gICAgICAgICAgICAgIHN3aXBlci50cmFuc2l0aW9uRW5kKCk7XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgIH0sIDApO1xcbiAgICAgICAgfSk7XFxuICAgICAgfSBlbHNlIGlmIChzd2lwZXIudmVsb2NpdHkpIHtcXG4gICAgICAgIHN3aXBlci51cGRhdGVQcm9ncmVzcyhuZXdQb3NpdGlvbik7XFxuICAgICAgICBzd2lwZXIuc2V0VHJhbnNpdGlvbihtb21lbnR1bUR1cmF0aW9uKTtcXG4gICAgICAgIHN3aXBlci5zZXRUcmFuc2xhdGUobmV3UG9zaXRpb24pO1xcbiAgICAgICAgc3dpcGVyLnRyYW5zaXRpb25TdGFydCh0cnVlLCBzd2lwZXIuc3dpcGVEaXJlY3Rpb24pO1xcblxcbiAgICAgICAgaWYgKCFzd2lwZXIuYW5pbWF0aW5nKSB7XFxuICAgICAgICAgIHN3aXBlci5hbmltYXRpbmcgPSB0cnVlO1xcbiAgICAgICAgICAkd3JhcHBlckVsLnRyYW5zaXRpb25FbmQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIGlmICghc3dpcGVyIHx8IHN3aXBlci5kZXN0cm95ZWQpIHJldHVybjtcXG4gICAgICAgICAgICBzd2lwZXIudHJhbnNpdGlvbkVuZCgpO1xcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgc3dpcGVyLmVtaXQoJ19mcmVlTW9kZU5vTW9tZW50dW1SZWxlYXNlJyk7XFxuICAgICAgICBzd2lwZXIudXBkYXRlUHJvZ3Jlc3MobmV3UG9zaXRpb24pO1xcbiAgICAgIH1cXG5cXG4gICAgICBzd2lwZXIudXBkYXRlQWN0aXZlSW5kZXgoKTtcXG4gICAgICBzd2lwZXIudXBkYXRlU2xpZGVzQ2xhc3NlcygpO1xcbiAgICB9IGVsc2UgaWYgKHBhcmFtcy5mcmVlTW9kZVN0aWNreSkge1xcbiAgICAgIHN3aXBlci5zbGlkZVRvQ2xvc2VzdCgpO1xcbiAgICAgIHJldHVybjtcXG4gICAgfSBlbHNlIGlmIChwYXJhbXMuZnJlZU1vZGUpIHtcXG4gICAgICBzd2lwZXIuZW1pdCgnX2ZyZWVNb2RlTm9Nb21lbnR1bVJlbGVhc2UnKTtcXG4gICAgfVxcblxcbiAgICBpZiAoIXBhcmFtcy5mcmVlTW9kZU1vbWVudHVtIHx8IHRpbWVEaWZmID49IHBhcmFtcy5sb25nU3dpcGVzTXMpIHtcXG4gICAgICBzd2lwZXIudXBkYXRlUHJvZ3Jlc3MoKTtcXG4gICAgICBzd2lwZXIudXBkYXRlQWN0aXZlSW5kZXgoKTtcXG4gICAgICBzd2lwZXIudXBkYXRlU2xpZGVzQ2xhc3NlcygpO1xcbiAgICB9XFxuXFxuICAgIHJldHVybjtcXG4gIH0gLy8gRmluZCBjdXJyZW50IHNsaWRlXFxuXFxuXFxuICB2YXIgc3RvcEluZGV4ID0gMDtcXG4gIHZhciBncm91cFNpemUgPSBzd2lwZXIuc2xpZGVzU2l6ZXNHcmlkWzBdO1xcblxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGlkZXNHcmlkLmxlbmd0aDsgaSArPSBpIDwgcGFyYW1zLnNsaWRlc1Blckdyb3VwU2tpcCA/IDEgOiBwYXJhbXMuc2xpZGVzUGVyR3JvdXApIHtcXG4gICAgdmFyIF9pbmNyZW1lbnQgPSBpIDwgcGFyYW1zLnNsaWRlc1Blckdyb3VwU2tpcCAtIDEgPyAxIDogcGFyYW1zLnNsaWRlc1Blckdyb3VwO1xcblxcbiAgICBpZiAodHlwZW9mIHNsaWRlc0dyaWRbaSArIF9pbmNyZW1lbnRdICE9PSAndW5kZWZpbmVkJykge1xcbiAgICAgIGlmIChjdXJyZW50UG9zID49IHNsaWRlc0dyaWRbaV0gJiYgY3VycmVudFBvcyA8IHNsaWRlc0dyaWRbaSArIF9pbmNyZW1lbnRdKSB7XFxuICAgICAgICBzdG9wSW5kZXggPSBpO1xcbiAgICAgICAgZ3JvdXBTaXplID0gc2xpZGVzR3JpZFtpICsgX2luY3JlbWVudF0gLSBzbGlkZXNHcmlkW2ldO1xcbiAgICAgIH1cXG4gICAgfSBlbHNlIGlmIChjdXJyZW50UG9zID49IHNsaWRlc0dyaWRbaV0pIHtcXG4gICAgICBzdG9wSW5kZXggPSBpO1xcbiAgICAgIGdyb3VwU2l6ZSA9IHNsaWRlc0dyaWRbc2xpZGVzR3JpZC5sZW5ndGggLSAxXSAtIHNsaWRlc0dyaWRbc2xpZGVzR3JpZC5sZW5ndGggLSAyXTtcXG4gICAgfVxcbiAgfSAvLyBGaW5kIGN1cnJlbnQgc2xpZGUgc2l6ZVxcblxcblxcbiAgdmFyIHJhdGlvID0gKGN1cnJlbnRQb3MgLSBzbGlkZXNHcmlkW3N0b3BJbmRleF0pIC8gZ3JvdXBTaXplO1xcbiAgdmFyIGluY3JlbWVudCA9IHN0b3BJbmRleCA8IHBhcmFtcy5zbGlkZXNQZXJHcm91cFNraXAgLSAxID8gMSA6IHBhcmFtcy5zbGlkZXNQZXJHcm91cDtcXG5cXG4gIGlmICh0aW1lRGlmZiA+IHBhcmFtcy5sb25nU3dpcGVzTXMpIHtcXG4gICAgLy8gTG9uZyB0b3VjaGVzXFxuICAgIGlmICghcGFyYW1zLmxvbmdTd2lwZXMpIHtcXG4gICAgICBzd2lwZXIuc2xpZGVUbyhzd2lwZXIuYWN0aXZlSW5kZXgpO1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICBpZiAoc3dpcGVyLnN3aXBlRGlyZWN0aW9uID09PSAnbmV4dCcpIHtcXG4gICAgICBpZiAocmF0aW8gPj0gcGFyYW1zLmxvbmdTd2lwZXNSYXRpbykgc3dpcGVyLnNsaWRlVG8oc3RvcEluZGV4ICsgaW5jcmVtZW50KTtlbHNlIHN3aXBlci5zbGlkZVRvKHN0b3BJbmRleCk7XFxuICAgIH1cXG5cXG4gICAgaWYgKHN3aXBlci5zd2lwZURpcmVjdGlvbiA9PT0gJ3ByZXYnKSB7XFxuICAgICAgaWYgKHJhdGlvID4gMSAtIHBhcmFtcy5sb25nU3dpcGVzUmF0aW8pIHN3aXBlci5zbGlkZVRvKHN0b3BJbmRleCArIGluY3JlbWVudCk7ZWxzZSBzd2lwZXIuc2xpZGVUbyhzdG9wSW5kZXgpO1xcbiAgICB9XFxuICB9IGVsc2Uge1xcbiAgICAvLyBTaG9ydCBzd2lwZXNcXG4gICAgaWYgKCFwYXJhbXMuc2hvcnRTd2lwZXMpIHtcXG4gICAgICBzd2lwZXIuc2xpZGVUbyhzd2lwZXIuYWN0aXZlSW5kZXgpO1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICB2YXIgaXNOYXZCdXR0b25UYXJnZXQgPSBzd2lwZXIubmF2aWdhdGlvbiAmJiAoZS50YXJnZXQgPT09IHN3aXBlci5uYXZpZ2F0aW9uLm5leHRFbCB8fCBlLnRhcmdldCA9PT0gc3dpcGVyLm5hdmlnYXRpb24ucHJldkVsKTtcXG5cXG4gICAgaWYgKCFpc05hdkJ1dHRvblRhcmdldCkge1xcbiAgICAgIGlmIChzd2lwZXIuc3dpcGVEaXJlY3Rpb24gPT09ICduZXh0Jykge1xcbiAgICAgICAgc3dpcGVyLnNsaWRlVG8oc3RvcEluZGV4ICsgaW5jcmVtZW50KTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHN3aXBlci5zd2lwZURpcmVjdGlvbiA9PT0gJ3ByZXYnKSB7XFxuICAgICAgICBzd2lwZXIuc2xpZGVUbyhzdG9wSW5kZXgpO1xcbiAgICAgIH1cXG4gICAgfSBlbHNlIGlmIChlLnRhcmdldCA9PT0gc3dpcGVyLm5hdmlnYXRpb24ubmV4dEVsKSB7XFxuICAgICAgc3dpcGVyLnNsaWRlVG8oc3RvcEluZGV4ICsgaW5jcmVtZW50KTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBzd2lwZXIuc2xpZGVUbyhzdG9wSW5kZXgpO1xcbiAgICB9XFxuICB9XFxufVxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3BhcnVzLy4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL2V2ZW50cy9vblRvdWNoRW5kLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvZXZlbnRzL29uVG91Y2hNb3ZlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS9ldmVudHMvb25Ub3VjaE1vdmUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJkZWZhdWx0XFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gb25Ub3VjaE1vdmUpXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHNzci13aW5kb3cgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3Nzci13aW5kb3cvc3NyLXdpbmRvdy5lc20uanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2RvbV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vLi4vdXRpbHMvZG9tICovIFxcXCIuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL3V0aWxzL2RvbS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uLy4uL3V0aWxzL3V0aWxzICovIFxcXCIuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL3V0aWxzL3V0aWxzLmpzXFxcIik7XFxuXFxuXFxuXFxuZnVuY3Rpb24gb25Ub3VjaE1vdmUoZXZlbnQpIHtcXG4gIHZhciBkb2N1bWVudCA9ICgwLHNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5nZXREb2N1bWVudCkoKTtcXG4gIHZhciBzd2lwZXIgPSB0aGlzO1xcbiAgdmFyIGRhdGEgPSBzd2lwZXIudG91Y2hFdmVudHNEYXRhO1xcbiAgdmFyIHBhcmFtcyA9IHN3aXBlci5wYXJhbXMsXFxuICAgICAgdG91Y2hlcyA9IHN3aXBlci50b3VjaGVzLFxcbiAgICAgIHJ0bCA9IHN3aXBlci5ydGxUcmFuc2xhdGUsXFxuICAgICAgZW5hYmxlZCA9IHN3aXBlci5lbmFibGVkO1xcbiAgaWYgKCFlbmFibGVkKSByZXR1cm47XFxuICB2YXIgZSA9IGV2ZW50O1xcbiAgaWYgKGUub3JpZ2luYWxFdmVudCkgZSA9IGUub3JpZ2luYWxFdmVudDtcXG5cXG4gIGlmICghZGF0YS5pc1RvdWNoZWQpIHtcXG4gICAgaWYgKGRhdGEuc3RhcnRNb3ZpbmcgJiYgZGF0YS5pc1Njcm9sbGluZykge1xcbiAgICAgIHN3aXBlci5lbWl0KCd0b3VjaE1vdmVPcHBvc2l0ZScsIGUpO1xcbiAgICB9XFxuXFxuICAgIHJldHVybjtcXG4gIH1cXG5cXG4gIGlmIChkYXRhLmlzVG91Y2hFdmVudCAmJiBlLnR5cGUgIT09ICd0b3VjaG1vdmUnKSByZXR1cm47XFxuICB2YXIgdGFyZ2V0VG91Y2ggPSBlLnR5cGUgPT09ICd0b3VjaG1vdmUnICYmIGUudGFyZ2V0VG91Y2hlcyAmJiAoZS50YXJnZXRUb3VjaGVzWzBdIHx8IGUuY2hhbmdlZFRvdWNoZXNbMF0pO1xcbiAgdmFyIHBhZ2VYID0gZS50eXBlID09PSAndG91Y2htb3ZlJyA/IHRhcmdldFRvdWNoLnBhZ2VYIDogZS5wYWdlWDtcXG4gIHZhciBwYWdlWSA9IGUudHlwZSA9PT0gJ3RvdWNobW92ZScgPyB0YXJnZXRUb3VjaC5wYWdlWSA6IGUucGFnZVk7XFxuXFxuICBpZiAoZS5wcmV2ZW50ZWRCeU5lc3RlZFN3aXBlcikge1xcbiAgICB0b3VjaGVzLnN0YXJ0WCA9IHBhZ2VYO1xcbiAgICB0b3VjaGVzLnN0YXJ0WSA9IHBhZ2VZO1xcbiAgICByZXR1cm47XFxuICB9XFxuXFxuICBpZiAoIXN3aXBlci5hbGxvd1RvdWNoTW92ZSkge1xcbiAgICAvLyBpc01vdmVkID0gdHJ1ZTtcXG4gICAgc3dpcGVyLmFsbG93Q2xpY2sgPSBmYWxzZTtcXG5cXG4gICAgaWYgKGRhdGEuaXNUb3VjaGVkKSB7XFxuICAgICAgKDAsX3V0aWxzX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18uZXh0ZW5kKSh0b3VjaGVzLCB7XFxuICAgICAgICBzdGFydFg6IHBhZ2VYLFxcbiAgICAgICAgc3RhcnRZOiBwYWdlWSxcXG4gICAgICAgIGN1cnJlbnRYOiBwYWdlWCxcXG4gICAgICAgIGN1cnJlbnRZOiBwYWdlWVxcbiAgICAgIH0pO1xcbiAgICAgIGRhdGEudG91Y2hTdGFydFRpbWUgPSAoMCxfdXRpbHNfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5ub3cpKCk7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuO1xcbiAgfVxcblxcbiAgaWYgKGRhdGEuaXNUb3VjaEV2ZW50ICYmIHBhcmFtcy50b3VjaFJlbGVhc2VPbkVkZ2VzICYmICFwYXJhbXMubG9vcCkge1xcbiAgICBpZiAoc3dpcGVyLmlzVmVydGljYWwoKSkge1xcbiAgICAgIC8vIFZlcnRpY2FsXFxuICAgICAgaWYgKHBhZ2VZIDwgdG91Y2hlcy5zdGFydFkgJiYgc3dpcGVyLnRyYW5zbGF0ZSA8PSBzd2lwZXIubWF4VHJhbnNsYXRlKCkgfHwgcGFnZVkgPiB0b3VjaGVzLnN0YXJ0WSAmJiBzd2lwZXIudHJhbnNsYXRlID49IHN3aXBlci5taW5UcmFuc2xhdGUoKSkge1xcbiAgICAgICAgZGF0YS5pc1RvdWNoZWQgPSBmYWxzZTtcXG4gICAgICAgIGRhdGEuaXNNb3ZlZCA9IGZhbHNlO1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG4gICAgfSBlbHNlIGlmIChwYWdlWCA8IHRvdWNoZXMuc3RhcnRYICYmIHN3aXBlci50cmFuc2xhdGUgPD0gc3dpcGVyLm1heFRyYW5zbGF0ZSgpIHx8IHBhZ2VYID4gdG91Y2hlcy5zdGFydFggJiYgc3dpcGVyLnRyYW5zbGF0ZSA+PSBzd2lwZXIubWluVHJhbnNsYXRlKCkpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG4gIH1cXG5cXG4gIGlmIChkYXRhLmlzVG91Y2hFdmVudCAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50KSB7XFxuICAgIGlmIChlLnRhcmdldCA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiAoMCxfdXRpbHNfZG9tX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcImRlZmF1bHRcXFwiXSkoZS50YXJnZXQpLmlzKGRhdGEuZm9jdXNhYmxlRWxlbWVudHMpKSB7XFxuICAgICAgZGF0YS5pc01vdmVkID0gdHJ1ZTtcXG4gICAgICBzd2lwZXIuYWxsb3dDbGljayA9IGZhbHNlO1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgfVxcblxcbiAgaWYgKGRhdGEuYWxsb3dUb3VjaENhbGxiYWNrcykge1xcbiAgICBzd2lwZXIuZW1pdCgndG91Y2hNb3ZlJywgZSk7XFxuICB9XFxuXFxuICBpZiAoZS50YXJnZXRUb3VjaGVzICYmIGUudGFyZ2V0VG91Y2hlcy5sZW5ndGggPiAxKSByZXR1cm47XFxuICB0b3VjaGVzLmN1cnJlbnRYID0gcGFnZVg7XFxuICB0b3VjaGVzLmN1cnJlbnRZID0gcGFnZVk7XFxuICB2YXIgZGlmZlggPSB0b3VjaGVzLmN1cnJlbnRYIC0gdG91Y2hlcy5zdGFydFg7XFxuICB2YXIgZGlmZlkgPSB0b3VjaGVzLmN1cnJlbnRZIC0gdG91Y2hlcy5zdGFydFk7XFxuICBpZiAoc3dpcGVyLnBhcmFtcy50aHJlc2hvbGQgJiYgTWF0aC5zcXJ0KE1hdGgucG93KGRpZmZYLCAyKSArIE1hdGgucG93KGRpZmZZLCAyKSkgPCBzd2lwZXIucGFyYW1zLnRocmVzaG9sZCkgcmV0dXJuO1xcblxcbiAgaWYgKHR5cGVvZiBkYXRhLmlzU2Nyb2xsaW5nID09PSAndW5kZWZpbmVkJykge1xcbiAgICB2YXIgdG91Y2hBbmdsZTtcXG5cXG4gICAgaWYgKHN3aXBlci5pc0hvcml6b250YWwoKSAmJiB0b3VjaGVzLmN1cnJlbnRZID09PSB0b3VjaGVzLnN0YXJ0WSB8fCBzd2lwZXIuaXNWZXJ0aWNhbCgpICYmIHRvdWNoZXMuY3VycmVudFggPT09IHRvdWNoZXMuc3RhcnRYKSB7XFxuICAgICAgZGF0YS5pc1Njcm9sbGluZyA9IGZhbHNlO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxcbiAgICAgIGlmIChkaWZmWCAqIGRpZmZYICsgZGlmZlkgKiBkaWZmWSA+PSAyNSkge1xcbiAgICAgICAgdG91Y2hBbmdsZSA9IE1hdGguYXRhbjIoTWF0aC5hYnMoZGlmZlkpLCBNYXRoLmFicyhkaWZmWCkpICogMTgwIC8gTWF0aC5QSTtcXG4gICAgICAgIGRhdGEuaXNTY3JvbGxpbmcgPSBzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyB0b3VjaEFuZ2xlID4gcGFyYW1zLnRvdWNoQW5nbGUgOiA5MCAtIHRvdWNoQW5nbGUgPiBwYXJhbXMudG91Y2hBbmdsZTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIGlmIChkYXRhLmlzU2Nyb2xsaW5nKSB7XFxuICAgIHN3aXBlci5lbWl0KCd0b3VjaE1vdmVPcHBvc2l0ZScsIGUpO1xcbiAgfVxcblxcbiAgaWYgKHR5cGVvZiBkYXRhLnN0YXJ0TW92aW5nID09PSAndW5kZWZpbmVkJykge1xcbiAgICBpZiAodG91Y2hlcy5jdXJyZW50WCAhPT0gdG91Y2hlcy5zdGFydFggfHwgdG91Y2hlcy5jdXJyZW50WSAhPT0gdG91Y2hlcy5zdGFydFkpIHtcXG4gICAgICBkYXRhLnN0YXJ0TW92aW5nID0gdHJ1ZTtcXG4gICAgfVxcbiAgfVxcblxcbiAgaWYgKGRhdGEuaXNTY3JvbGxpbmcpIHtcXG4gICAgZGF0YS5pc1RvdWNoZWQgPSBmYWxzZTtcXG4gICAgcmV0dXJuO1xcbiAgfVxcblxcbiAgaWYgKCFkYXRhLnN0YXJ0TW92aW5nKSB7XFxuICAgIHJldHVybjtcXG4gIH1cXG5cXG4gIHN3aXBlci5hbGxvd0NsaWNrID0gZmFsc2U7XFxuXFxuICBpZiAoIXBhcmFtcy5jc3NNb2RlICYmIGUuY2FuY2VsYWJsZSkge1xcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuICB9XFxuXFxuICBpZiAocGFyYW1zLnRvdWNoTW92ZVN0b3BQcm9wYWdhdGlvbiAmJiAhcGFyYW1zLm5lc3RlZCkge1xcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xcbiAgfVxcblxcbiAgaWYgKCFkYXRhLmlzTW92ZWQpIHtcXG4gICAgaWYgKHBhcmFtcy5sb29wKSB7XFxuICAgICAgc3dpcGVyLmxvb3BGaXgoKTtcXG4gICAgfVxcblxcbiAgICBkYXRhLnN0YXJ0VHJhbnNsYXRlID0gc3dpcGVyLmdldFRyYW5zbGF0ZSgpO1xcbiAgICBzd2lwZXIuc2V0VHJhbnNpdGlvbigwKTtcXG5cXG4gICAgaWYgKHN3aXBlci5hbmltYXRpbmcpIHtcXG4gICAgICBzd2lwZXIuJHdyYXBwZXJFbC50cmlnZ2VyKCd3ZWJraXRUcmFuc2l0aW9uRW5kIHRyYW5zaXRpb25lbmQnKTtcXG4gICAgfVxcblxcbiAgICBkYXRhLmFsbG93TW9tZW50dW1Cb3VuY2UgPSBmYWxzZTsgLy8gR3JhYiBDdXJzb3JcXG5cXG4gICAgaWYgKHBhcmFtcy5ncmFiQ3Vyc29yICYmIChzd2lwZXIuYWxsb3dTbGlkZU5leHQgPT09IHRydWUgfHwgc3dpcGVyLmFsbG93U2xpZGVQcmV2ID09PSB0cnVlKSkge1xcbiAgICAgIHN3aXBlci5zZXRHcmFiQ3Vyc29yKHRydWUpO1xcbiAgICB9XFxuXFxuICAgIHN3aXBlci5lbWl0KCdzbGlkZXJGaXJzdE1vdmUnLCBlKTtcXG4gIH1cXG5cXG4gIHN3aXBlci5lbWl0KCdzbGlkZXJNb3ZlJywgZSk7XFxuICBkYXRhLmlzTW92ZWQgPSB0cnVlO1xcbiAgdmFyIGRpZmYgPSBzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyBkaWZmWCA6IGRpZmZZO1xcbiAgdG91Y2hlcy5kaWZmID0gZGlmZjtcXG4gIGRpZmYgKj0gcGFyYW1zLnRvdWNoUmF0aW87XFxuICBpZiAocnRsKSBkaWZmID0gLWRpZmY7XFxuICBzd2lwZXIuc3dpcGVEaXJlY3Rpb24gPSBkaWZmID4gMCA/ICdwcmV2JyA6ICduZXh0JztcXG4gIGRhdGEuY3VycmVudFRyYW5zbGF0ZSA9IGRpZmYgKyBkYXRhLnN0YXJ0VHJhbnNsYXRlO1xcbiAgdmFyIGRpc2FibGVQYXJlbnRTd2lwZXIgPSB0cnVlO1xcbiAgdmFyIHJlc2lzdGFuY2VSYXRpbyA9IHBhcmFtcy5yZXNpc3RhbmNlUmF0aW87XFxuXFxuICBpZiAocGFyYW1zLnRvdWNoUmVsZWFzZU9uRWRnZXMpIHtcXG4gICAgcmVzaXN0YW5jZVJhdGlvID0gMDtcXG4gIH1cXG5cXG4gIGlmIChkaWZmID4gMCAmJiBkYXRhLmN1cnJlbnRUcmFuc2xhdGUgPiBzd2lwZXIubWluVHJhbnNsYXRlKCkpIHtcXG4gICAgZGlzYWJsZVBhcmVudFN3aXBlciA9IGZhbHNlO1xcbiAgICBpZiAocGFyYW1zLnJlc2lzdGFuY2UpIGRhdGEuY3VycmVudFRyYW5zbGF0ZSA9IHN3aXBlci5taW5UcmFuc2xhdGUoKSAtIDEgKyBNYXRoLnBvdygtc3dpcGVyLm1pblRyYW5zbGF0ZSgpICsgZGF0YS5zdGFydFRyYW5zbGF0ZSArIGRpZmYsIHJlc2lzdGFuY2VSYXRpbyk7XFxuICB9IGVsc2UgaWYgKGRpZmYgPCAwICYmIGRhdGEuY3VycmVudFRyYW5zbGF0ZSA8IHN3aXBlci5tYXhUcmFuc2xhdGUoKSkge1xcbiAgICBkaXNhYmxlUGFyZW50U3dpcGVyID0gZmFsc2U7XFxuICAgIGlmIChwYXJhbXMucmVzaXN0YW5jZSkgZGF0YS5jdXJyZW50VHJhbnNsYXRlID0gc3dpcGVyLm1heFRyYW5zbGF0ZSgpICsgMSAtIE1hdGgucG93KHN3aXBlci5tYXhUcmFuc2xhdGUoKSAtIGRhdGEuc3RhcnRUcmFuc2xhdGUgLSBkaWZmLCByZXNpc3RhbmNlUmF0aW8pO1xcbiAgfVxcblxcbiAgaWYgKGRpc2FibGVQYXJlbnRTd2lwZXIpIHtcXG4gICAgZS5wcmV2ZW50ZWRCeU5lc3RlZFN3aXBlciA9IHRydWU7XFxuICB9IC8vIERpcmVjdGlvbnMgbG9ja3NcXG5cXG5cXG4gIGlmICghc3dpcGVyLmFsbG93U2xpZGVOZXh0ICYmIHN3aXBlci5zd2lwZURpcmVjdGlvbiA9PT0gJ25leHQnICYmIGRhdGEuY3VycmVudFRyYW5zbGF0ZSA8IGRhdGEuc3RhcnRUcmFuc2xhdGUpIHtcXG4gICAgZGF0YS5jdXJyZW50VHJhbnNsYXRlID0gZGF0YS5zdGFydFRyYW5zbGF0ZTtcXG4gIH1cXG5cXG4gIGlmICghc3dpcGVyLmFsbG93U2xpZGVQcmV2ICYmIHN3aXBlci5zd2lwZURpcmVjdGlvbiA9PT0gJ3ByZXYnICYmIGRhdGEuY3VycmVudFRyYW5zbGF0ZSA+IGRhdGEuc3RhcnRUcmFuc2xhdGUpIHtcXG4gICAgZGF0YS5jdXJyZW50VHJhbnNsYXRlID0gZGF0YS5zdGFydFRyYW5zbGF0ZTtcXG4gIH1cXG5cXG4gIGlmICghc3dpcGVyLmFsbG93U2xpZGVQcmV2ICYmICFzd2lwZXIuYWxsb3dTbGlkZU5leHQpIHtcXG4gICAgZGF0YS5jdXJyZW50VHJhbnNsYXRlID0gZGF0YS5zdGFydFRyYW5zbGF0ZTtcXG4gIH0gLy8gVGhyZXNob2xkXFxuXFxuXFxuICBpZiAocGFyYW1zLnRocmVzaG9sZCA+IDApIHtcXG4gICAgaWYgKE1hdGguYWJzKGRpZmYpID4gcGFyYW1zLnRocmVzaG9sZCB8fCBkYXRhLmFsbG93VGhyZXNob2xkTW92ZSkge1xcbiAgICAgIGlmICghZGF0YS5hbGxvd1RocmVzaG9sZE1vdmUpIHtcXG4gICAgICAgIGRhdGEuYWxsb3dUaHJlc2hvbGRNb3ZlID0gdHJ1ZTtcXG4gICAgICAgIHRvdWNoZXMuc3RhcnRYID0gdG91Y2hlcy5jdXJyZW50WDtcXG4gICAgICAgIHRvdWNoZXMuc3RhcnRZID0gdG91Y2hlcy5jdXJyZW50WTtcXG4gICAgICAgIGRhdGEuY3VycmVudFRyYW5zbGF0ZSA9IGRhdGEuc3RhcnRUcmFuc2xhdGU7XFxuICAgICAgICB0b3VjaGVzLmRpZmYgPSBzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyB0b3VjaGVzLmN1cnJlbnRYIC0gdG91Y2hlcy5zdGFydFggOiB0b3VjaGVzLmN1cnJlbnRZIC0gdG91Y2hlcy5zdGFydFk7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIGRhdGEuY3VycmVudFRyYW5zbGF0ZSA9IGRhdGEuc3RhcnRUcmFuc2xhdGU7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICB9XFxuXFxuICBpZiAoIXBhcmFtcy5mb2xsb3dGaW5nZXIgfHwgcGFyYW1zLmNzc01vZGUpIHJldHVybjsgLy8gVXBkYXRlIGFjdGl2ZSBpbmRleCBpbiBmcmVlIG1vZGVcXG5cXG4gIGlmIChwYXJhbXMuZnJlZU1vZGUgfHwgcGFyYW1zLndhdGNoU2xpZGVzUHJvZ3Jlc3MgfHwgcGFyYW1zLndhdGNoU2xpZGVzVmlzaWJpbGl0eSkge1xcbiAgICBzd2lwZXIudXBkYXRlQWN0aXZlSW5kZXgoKTtcXG4gICAgc3dpcGVyLnVwZGF0ZVNsaWRlc0NsYXNzZXMoKTtcXG4gIH1cXG5cXG4gIGlmIChwYXJhbXMuZnJlZU1vZGUpIHtcXG4gICAgLy8gVmVsb2NpdHlcXG4gICAgaWYgKGRhdGEudmVsb2NpdGllcy5sZW5ndGggPT09IDApIHtcXG4gICAgICBkYXRhLnZlbG9jaXRpZXMucHVzaCh7XFxuICAgICAgICBwb3NpdGlvbjogdG91Y2hlc1tzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyAnc3RhcnRYJyA6ICdzdGFydFknXSxcXG4gICAgICAgIHRpbWU6IGRhdGEudG91Y2hTdGFydFRpbWVcXG4gICAgICB9KTtcXG4gICAgfVxcblxcbiAgICBkYXRhLnZlbG9jaXRpZXMucHVzaCh7XFxuICAgICAgcG9zaXRpb246IHRvdWNoZXNbc3dpcGVyLmlzSG9yaXpvbnRhbCgpID8gJ2N1cnJlbnRYJyA6ICdjdXJyZW50WSddLFxcbiAgICAgIHRpbWU6ICgwLF91dGlsc191dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLm5vdykoKVxcbiAgICB9KTtcXG4gIH0gLy8gVXBkYXRlIHByb2dyZXNzXFxuXFxuXFxuICBzd2lwZXIudXBkYXRlUHJvZ3Jlc3MoZGF0YS5jdXJyZW50VHJhbnNsYXRlKTsgLy8gVXBkYXRlIHRyYW5zbGF0ZVxcblxcbiAgc3dpcGVyLnNldFRyYW5zbGF0ZShkYXRhLmN1cnJlbnRUcmFuc2xhdGUpO1xcbn1cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9wYXJ1cy8uL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS9ldmVudHMvb25Ub3VjaE1vdmUuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS9ldmVudHMvb25Ub3VjaFN0YXJ0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvZXZlbnRzL29uVG91Y2hTdGFydC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJkZWZhdWx0XFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gb25Ub3VjaFN0YXJ0KVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBzc3Jfd2luZG93X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBzc3Itd2luZG93ICovIFxcXCIuL25vZGVfbW9kdWxlcy9zc3Itd2luZG93L3Nzci13aW5kb3cuZXNtLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19kb21fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uLy4uL3V0aWxzL2RvbSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS91dGlscy9kb20uanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi8uLi91dGlscy91dGlscyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS91dGlscy91dGlscy5qc1xcXCIpO1xcblxcblxcbiAvLyBNb2RpZmllZCBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzU0NTIwNTU0L2N1c3RvbS1lbGVtZW50LWdldHJvb3Rub2RlLWNsb3Nlc3QtZnVuY3Rpb24tY3Jvc3NpbmctbXVsdGlwbGUtcGFyZW50LXNoYWRvd2RcXG5cXG5mdW5jdGlvbiBjbG9zZXN0RWxlbWVudChzZWxlY3RvciwgYmFzZSkge1xcbiAgaWYgKGJhc2UgPT09IHZvaWQgMCkge1xcbiAgICBiYXNlID0gdGhpcztcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIF9fY2xvc2VzdEZyb20oZWwpIHtcXG4gICAgaWYgKCFlbCB8fCBlbCA9PT0gKDAsc3NyX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmdldERvY3VtZW50KSgpIHx8IGVsID09PSAoMCxzc3Jfd2luZG93X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uZ2V0V2luZG93KSgpKSByZXR1cm4gbnVsbDtcXG4gICAgaWYgKGVsLmFzc2lnbmVkU2xvdCkgZWwgPSBlbC5hc3NpZ25lZFNsb3Q7XFxuICAgIHZhciBmb3VuZCA9IGVsLmNsb3Nlc3Qoc2VsZWN0b3IpO1xcbiAgICByZXR1cm4gZm91bmQgfHwgX19jbG9zZXN0RnJvbShlbC5nZXRSb290Tm9kZSgpLmhvc3QpO1xcbiAgfVxcblxcbiAgcmV0dXJuIF9fY2xvc2VzdEZyb20oYmFzZSk7XFxufVxcblxcbmZ1bmN0aW9uIG9uVG91Y2hTdGFydChldmVudCkge1xcbiAgdmFyIHN3aXBlciA9IHRoaXM7XFxuICB2YXIgZG9jdW1lbnQgPSAoMCxzc3Jfd2luZG93X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uZ2V0RG9jdW1lbnQpKCk7XFxuICB2YXIgd2luZG93ID0gKDAsc3NyX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmdldFdpbmRvdykoKTtcXG4gIHZhciBkYXRhID0gc3dpcGVyLnRvdWNoRXZlbnRzRGF0YTtcXG4gIHZhciBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLFxcbiAgICAgIHRvdWNoZXMgPSBzd2lwZXIudG91Y2hlcyxcXG4gICAgICBlbmFibGVkID0gc3dpcGVyLmVuYWJsZWQ7XFxuICBpZiAoIWVuYWJsZWQpIHJldHVybjtcXG5cXG4gIGlmIChzd2lwZXIuYW5pbWF0aW5nICYmIHBhcmFtcy5wcmV2ZW50SW50ZXJhY3Rpb25PblRyYW5zaXRpb24pIHtcXG4gICAgcmV0dXJuO1xcbiAgfVxcblxcbiAgdmFyIGUgPSBldmVudDtcXG4gIGlmIChlLm9yaWdpbmFsRXZlbnQpIGUgPSBlLm9yaWdpbmFsRXZlbnQ7XFxuICB2YXIgJHRhcmdldEVsID0gKDAsX3V0aWxzX2RvbV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJkZWZhdWx0XFxcIl0pKGUudGFyZ2V0KTtcXG5cXG4gIGlmIChwYXJhbXMudG91Y2hFdmVudHNUYXJnZXQgPT09ICd3cmFwcGVyJykge1xcbiAgICBpZiAoISR0YXJnZXRFbC5jbG9zZXN0KHN3aXBlci53cmFwcGVyRWwpLmxlbmd0aCkgcmV0dXJuO1xcbiAgfVxcblxcbiAgZGF0YS5pc1RvdWNoRXZlbnQgPSBlLnR5cGUgPT09ICd0b3VjaHN0YXJ0JztcXG4gIGlmICghZGF0YS5pc1RvdWNoRXZlbnQgJiYgJ3doaWNoJyBpbiBlICYmIGUud2hpY2ggPT09IDMpIHJldHVybjtcXG4gIGlmICghZGF0YS5pc1RvdWNoRXZlbnQgJiYgJ2J1dHRvbicgaW4gZSAmJiBlLmJ1dHRvbiA+IDApIHJldHVybjtcXG4gIGlmIChkYXRhLmlzVG91Y2hlZCAmJiBkYXRhLmlzTW92ZWQpIHJldHVybjsgLy8gY2hhbmdlIHRhcmdldCBlbCBmb3Igc2hhZG93IHJvb3QgY29tcG9uZW50XFxuXFxuICB2YXIgc3dpcGluZ0NsYXNzSGFzVmFsdWUgPSAhIXBhcmFtcy5ub1N3aXBpbmdDbGFzcyAmJiBwYXJhbXMubm9Td2lwaW5nQ2xhc3MgIT09ICcnO1xcblxcbiAgaWYgKHN3aXBpbmdDbGFzc0hhc1ZhbHVlICYmIGUudGFyZ2V0ICYmIGUudGFyZ2V0LnNoYWRvd1Jvb3QgJiYgZXZlbnQucGF0aCAmJiBldmVudC5wYXRoWzBdKSB7XFxuICAgICR0YXJnZXRFbCA9ICgwLF91dGlsc19kb21fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiZGVmYXVsdFxcXCJdKShldmVudC5wYXRoWzBdKTtcXG4gIH1cXG5cXG4gIHZhciBub1N3aXBpbmdTZWxlY3RvciA9IHBhcmFtcy5ub1N3aXBpbmdTZWxlY3RvciA/IHBhcmFtcy5ub1N3aXBpbmdTZWxlY3RvciA6IFxcXCIuXFxcIiArIHBhcmFtcy5ub1N3aXBpbmdDbGFzcztcXG4gIHZhciBpc1RhcmdldFNoYWRvdyA9ICEhKGUudGFyZ2V0ICYmIGUudGFyZ2V0LnNoYWRvd1Jvb3QpOyAvLyB1c2UgY2xvc2VzdEVsZW1lbnQgZm9yIHNoYWRvdyByb290IGVsZW1lbnQgdG8gZ2V0IHRoZSBhY3R1YWwgY2xvc2VzdCBmb3IgbmVzdGVkIHNoYWRvdyByb290IGVsZW1lbnRcXG5cXG4gIGlmIChwYXJhbXMubm9Td2lwaW5nICYmIChpc1RhcmdldFNoYWRvdyA/IGNsb3Nlc3RFbGVtZW50KG5vU3dpcGluZ1NlbGVjdG9yLCBlLnRhcmdldCkgOiAkdGFyZ2V0RWwuY2xvc2VzdChub1N3aXBpbmdTZWxlY3RvcilbMF0pKSB7XFxuICAgIHN3aXBlci5hbGxvd0NsaWNrID0gdHJ1ZTtcXG4gICAgcmV0dXJuO1xcbiAgfVxcblxcbiAgaWYgKHBhcmFtcy5zd2lwZUhhbmRsZXIpIHtcXG4gICAgaWYgKCEkdGFyZ2V0RWwuY2xvc2VzdChwYXJhbXMuc3dpcGVIYW5kbGVyKVswXSkgcmV0dXJuO1xcbiAgfVxcblxcbiAgdG91Y2hlcy5jdXJyZW50WCA9IGUudHlwZSA9PT0gJ3RvdWNoc3RhcnQnID8gZS50YXJnZXRUb3VjaGVzWzBdLnBhZ2VYIDogZS5wYWdlWDtcXG4gIHRvdWNoZXMuY3VycmVudFkgPSBlLnR5cGUgPT09ICd0b3VjaHN0YXJ0JyA/IGUudGFyZ2V0VG91Y2hlc1swXS5wYWdlWSA6IGUucGFnZVk7XFxuICB2YXIgc3RhcnRYID0gdG91Y2hlcy5jdXJyZW50WDtcXG4gIHZhciBzdGFydFkgPSB0b3VjaGVzLmN1cnJlbnRZOyAvLyBEbyBOT1Qgc3RhcnQgaWYgaU9TIGVkZ2Ugc3dpcGUgaXMgZGV0ZWN0ZWQuIE90aGVyd2lzZSBpT1MgYXBwIGNhbm5vdCBzd2lwZS10by1nby1iYWNrIGFueW1vcmVcXG5cXG4gIHZhciBlZGdlU3dpcGVEZXRlY3Rpb24gPSBwYXJhbXMuZWRnZVN3aXBlRGV0ZWN0aW9uIHx8IHBhcmFtcy5pT1NFZGdlU3dpcGVEZXRlY3Rpb247XFxuICB2YXIgZWRnZVN3aXBlVGhyZXNob2xkID0gcGFyYW1zLmVkZ2VTd2lwZVRocmVzaG9sZCB8fCBwYXJhbXMuaU9TRWRnZVN3aXBlVGhyZXNob2xkO1xcblxcbiAgaWYgKGVkZ2VTd2lwZURldGVjdGlvbiAmJiAoc3RhcnRYIDw9IGVkZ2VTd2lwZVRocmVzaG9sZCB8fCBzdGFydFggPj0gd2luZG93LmlubmVyV2lkdGggLSBlZGdlU3dpcGVUaHJlc2hvbGQpKSB7XFxuICAgIGlmIChlZGdlU3dpcGVEZXRlY3Rpb24gPT09ICdwcmV2ZW50Jykge1xcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICB9XFxuXFxuICAoMCxfdXRpbHNfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5leHRlbmQpKGRhdGEsIHtcXG4gICAgaXNUb3VjaGVkOiB0cnVlLFxcbiAgICBpc01vdmVkOiBmYWxzZSxcXG4gICAgYWxsb3dUb3VjaENhbGxiYWNrczogdHJ1ZSxcXG4gICAgaXNTY3JvbGxpbmc6IHVuZGVmaW5lZCxcXG4gICAgc3RhcnRNb3Zpbmc6IHVuZGVmaW5lZFxcbiAgfSk7XFxuICB0b3VjaGVzLnN0YXJ0WCA9IHN0YXJ0WDtcXG4gIHRvdWNoZXMuc3RhcnRZID0gc3RhcnRZO1xcbiAgZGF0YS50b3VjaFN0YXJ0VGltZSA9ICgwLF91dGlsc191dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLm5vdykoKTtcXG4gIHN3aXBlci5hbGxvd0NsaWNrID0gdHJ1ZTtcXG4gIHN3aXBlci51cGRhdGVTaXplKCk7XFxuICBzd2lwZXIuc3dpcGVEaXJlY3Rpb24gPSB1bmRlZmluZWQ7XFxuICBpZiAocGFyYW1zLnRocmVzaG9sZCA+IDApIGRhdGEuYWxsb3dUaHJlc2hvbGRNb3ZlID0gZmFsc2U7XFxuXFxuICBpZiAoZS50eXBlICE9PSAndG91Y2hzdGFydCcpIHtcXG4gICAgdmFyIHByZXZlbnREZWZhdWx0ID0gdHJ1ZTtcXG4gICAgaWYgKCR0YXJnZXRFbC5pcyhkYXRhLmZvY3VzYWJsZUVsZW1lbnRzKSkgcHJldmVudERlZmF1bHQgPSBmYWxzZTtcXG5cXG4gICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgKDAsX3V0aWxzX2RvbV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJkZWZhdWx0XFxcIl0pKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpLmlzKGRhdGEuZm9jdXNhYmxlRWxlbWVudHMpICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09ICR0YXJnZXRFbFswXSkge1xcbiAgICAgIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1cigpO1xcbiAgICB9XFxuXFxuICAgIHZhciBzaG91bGRQcmV2ZW50RGVmYXVsdCA9IHByZXZlbnREZWZhdWx0ICYmIHN3aXBlci5hbGxvd1RvdWNoTW92ZSAmJiBwYXJhbXMudG91Y2hTdGFydFByZXZlbnREZWZhdWx0O1xcblxcbiAgICBpZiAoKHBhcmFtcy50b3VjaFN0YXJ0Rm9yY2VQcmV2ZW50RGVmYXVsdCB8fCBzaG91bGRQcmV2ZW50RGVmYXVsdCkgJiYgISR0YXJnZXRFbFswXS5pc0NvbnRlbnRFZGl0YWJsZSkge1xcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgc3dpcGVyLmVtaXQoJ3RvdWNoU3RhcnQnLCBlKTtcXG59XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vcGFydXMvLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvZXZlbnRzL29uVG91Y2hTdGFydC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL2dyYWItY3Vyc29yL2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL2dyYWItY3Vyc29yL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJkZWZhdWx0XFxcIjogKCkgPT4gKF9fV0VCUEFDS19ERUZBVUxUX0VYUE9SVF9fKVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc2V0R3JhYkN1cnNvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zZXRHcmFiQ3Vyc29yICovIFxcXCIuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS9ncmFiLWN1cnNvci9zZXRHcmFiQ3Vyc29yLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91bnNldEdyYWJDdXJzb3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdW5zZXRHcmFiQ3Vyc29yICovIFxcXCIuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS9ncmFiLWN1cnNvci91bnNldEdyYWJDdXJzb3IuanNcXFwiKTtcXG5cXG5cXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IF9fV0VCUEFDS19ERUZBVUxUX0VYUE9SVF9fID0gKHtcXG4gIHNldEdyYWJDdXJzb3I6IF9zZXRHcmFiQ3Vyc29yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImRlZmF1bHRcXFwiXSxcXG4gIHVuc2V0R3JhYkN1cnNvcjogX3Vuc2V0R3JhYkN1cnNvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJkZWZhdWx0XFxcIl1cXG59KTtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9wYXJ1cy8uL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS9ncmFiLWN1cnNvci9pbmRleC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL2dyYWItY3Vyc29yL3NldEdyYWJDdXJzb3IuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS9ncmFiLWN1cnNvci9zZXRHcmFiQ3Vyc29yLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcImRlZmF1bHRcXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBzZXRHcmFiQ3Vyc29yKVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbmZ1bmN0aW9uIHNldEdyYWJDdXJzb3IobW92aW5nKSB7XFxuICB2YXIgc3dpcGVyID0gdGhpcztcXG4gIGlmIChzd2lwZXIuc3VwcG9ydC50b3VjaCB8fCAhc3dpcGVyLnBhcmFtcy5zaW11bGF0ZVRvdWNoIHx8IHN3aXBlci5wYXJhbXMud2F0Y2hPdmVyZmxvdyAmJiBzd2lwZXIuaXNMb2NrZWQgfHwgc3dpcGVyLnBhcmFtcy5jc3NNb2RlKSByZXR1cm47XFxuICB2YXIgZWwgPSBzd2lwZXIuZWw7XFxuICBlbC5zdHlsZS5jdXJzb3IgPSAnbW92ZSc7XFxuICBlbC5zdHlsZS5jdXJzb3IgPSBtb3ZpbmcgPyAnLXdlYmtpdC1ncmFiYmluZycgOiAnLXdlYmtpdC1ncmFiJztcXG4gIGVsLnN0eWxlLmN1cnNvciA9IG1vdmluZyA/ICctbW96LWdyYWJiaW4nIDogJy1tb3otZ3JhYic7XFxuICBlbC5zdHlsZS5jdXJzb3IgPSBtb3ZpbmcgPyAnZ3JhYmJpbmcnIDogJ2dyYWInO1xcbn1cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9wYXJ1cy8uL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS9ncmFiLWN1cnNvci9zZXRHcmFiQ3Vyc29yLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvZ3JhYi1jdXJzb3IvdW5zZXRHcmFiQ3Vyc29yLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS9ncmFiLWN1cnNvci91bnNldEdyYWJDdXJzb3IuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJkZWZhdWx0XFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gdW5zZXRHcmFiQ3Vyc29yKVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbmZ1bmN0aW9uIHVuc2V0R3JhYkN1cnNvcigpIHtcXG4gIHZhciBzd2lwZXIgPSB0aGlzO1xcblxcbiAgaWYgKHN3aXBlci5zdXBwb3J0LnRvdWNoIHx8IHN3aXBlci5wYXJhbXMud2F0Y2hPdmVyZmxvdyAmJiBzd2lwZXIuaXNMb2NrZWQgfHwgc3dpcGVyLnBhcmFtcy5jc3NNb2RlKSB7XFxuICAgIHJldHVybjtcXG4gIH1cXG5cXG4gIHN3aXBlci5lbC5zdHlsZS5jdXJzb3IgPSAnJztcXG59XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vcGFydXMvLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvZ3JhYi1jdXJzb3IvdW5zZXRHcmFiQ3Vyc29yLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvaW1hZ2VzL2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS9pbWFnZXMvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJkZWZhdWx0XFxcIjogKCkgPT4gKF9fV0VCUEFDS19ERUZBVUxUX0VYUE9SVF9fKVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbG9hZEltYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2xvYWRJbWFnZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvaW1hZ2VzL2xvYWRJbWFnZS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfcHJlbG9hZEltYWdlc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9wcmVsb2FkSW1hZ2VzICovIFxcXCIuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS9pbWFnZXMvcHJlbG9hZEltYWdlcy5qc1xcXCIpO1xcblxcblxcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgX19XRUJQQUNLX0RFRkFVTFRfRVhQT1JUX18gPSAoe1xcbiAgbG9hZEltYWdlOiBfbG9hZEltYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImRlZmF1bHRcXFwiXSxcXG4gIHByZWxvYWRJbWFnZXM6IF9wcmVsb2FkSW1hZ2VzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcImRlZmF1bHRcXFwiXVxcbn0pO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3BhcnVzLy4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL2ltYWdlcy9pbmRleC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL2ltYWdlcy9sb2FkSW1hZ2UuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS9pbWFnZXMvbG9hZEltYWdlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcImRlZmF1bHRcXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBsb2FkSW1hZ2UpXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHNzci13aW5kb3cgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3Nzci13aW5kb3cvc3NyLXdpbmRvdy5lc20uanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2RvbV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vLi4vdXRpbHMvZG9tICovIFxcXCIuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL3V0aWxzL2RvbS5qc1xcXCIpO1xcblxcblxcbmZ1bmN0aW9uIGxvYWRJbWFnZShpbWFnZUVsLCBzcmMsIHNyY3NldCwgc2l6ZXMsIGNoZWNrRm9yQ29tcGxldGUsIGNhbGxiYWNrKSB7XFxuICB2YXIgd2luZG93ID0gKDAsc3NyX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmdldFdpbmRvdykoKTtcXG4gIHZhciBpbWFnZTtcXG5cXG4gIGZ1bmN0aW9uIG9uUmVhZHkoKSB7XFxuICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soKTtcXG4gIH1cXG5cXG4gIHZhciBpc1BpY3R1cmUgPSAoMCxfdXRpbHNfZG9tX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcImRlZmF1bHRcXFwiXSkoaW1hZ2VFbCkucGFyZW50KCdwaWN0dXJlJylbMF07XFxuXFxuICBpZiAoIWlzUGljdHVyZSAmJiAoIWltYWdlRWwuY29tcGxldGUgfHwgIWNoZWNrRm9yQ29tcGxldGUpKSB7XFxuICAgIGlmIChzcmMpIHtcXG4gICAgICBpbWFnZSA9IG5ldyB3aW5kb3cuSW1hZ2UoKTtcXG4gICAgICBpbWFnZS5vbmxvYWQgPSBvblJlYWR5O1xcbiAgICAgIGltYWdlLm9uZXJyb3IgPSBvblJlYWR5O1xcblxcbiAgICAgIGlmIChzaXplcykge1xcbiAgICAgICAgaW1hZ2Uuc2l6ZXMgPSBzaXplcztcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHNyY3NldCkge1xcbiAgICAgICAgaW1hZ2Uuc3Jjc2V0ID0gc3Jjc2V0O1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoc3JjKSB7XFxuICAgICAgICBpbWFnZS5zcmMgPSBzcmM7XFxuICAgICAgfVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIG9uUmVhZHkoKTtcXG4gICAgfVxcbiAgfSBlbHNlIHtcXG4gICAgLy8gaW1hZ2UgYWxyZWFkeSBsb2FkZWQuLi5cXG4gICAgb25SZWFkeSgpO1xcbiAgfVxcbn1cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9wYXJ1cy8uL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS9pbWFnZXMvbG9hZEltYWdlLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvaW1hZ2VzL3ByZWxvYWRJbWFnZXMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvaW1hZ2VzL3ByZWxvYWRJbWFnZXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcImRlZmF1bHRcXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBwcmVsb2FkSW1hZ2VzKVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbmZ1bmN0aW9uIHByZWxvYWRJbWFnZXMoKSB7XFxuICB2YXIgc3dpcGVyID0gdGhpcztcXG4gIHN3aXBlci5pbWFnZXNUb0xvYWQgPSBzd2lwZXIuJGVsLmZpbmQoJ2ltZycpO1xcblxcbiAgZnVuY3Rpb24gb25SZWFkeSgpIHtcXG4gICAgaWYgKHR5cGVvZiBzd2lwZXIgPT09ICd1bmRlZmluZWQnIHx8IHN3aXBlciA9PT0gbnVsbCB8fCAhc3dpcGVyIHx8IHN3aXBlci5kZXN0cm95ZWQpIHJldHVybjtcXG4gICAgaWYgKHN3aXBlci5pbWFnZXNMb2FkZWQgIT09IHVuZGVmaW5lZCkgc3dpcGVyLmltYWdlc0xvYWRlZCArPSAxO1xcblxcbiAgICBpZiAoc3dpcGVyLmltYWdlc0xvYWRlZCA9PT0gc3dpcGVyLmltYWdlc1RvTG9hZC5sZW5ndGgpIHtcXG4gICAgICBpZiAoc3dpcGVyLnBhcmFtcy51cGRhdGVPbkltYWdlc1JlYWR5KSBzd2lwZXIudXBkYXRlKCk7XFxuICAgICAgc3dpcGVyLmVtaXQoJ2ltYWdlc1JlYWR5Jyk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3dpcGVyLmltYWdlc1RvTG9hZC5sZW5ndGg7IGkgKz0gMSkge1xcbiAgICB2YXIgaW1hZ2VFbCA9IHN3aXBlci5pbWFnZXNUb0xvYWRbaV07XFxuICAgIHN3aXBlci5sb2FkSW1hZ2UoaW1hZ2VFbCwgaW1hZ2VFbC5jdXJyZW50U3JjIHx8IGltYWdlRWwuZ2V0QXR0cmlidXRlKCdzcmMnKSwgaW1hZ2VFbC5zcmNzZXQgfHwgaW1hZ2VFbC5nZXRBdHRyaWJ1dGUoJ3NyY3NldCcpLCBpbWFnZUVsLnNpemVzIHx8IGltYWdlRWwuZ2V0QXR0cmlidXRlKCdzaXplcycpLCB0cnVlLCBvblJlYWR5KTtcXG4gIH1cXG59XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vcGFydXMvLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvaW1hZ2VzL3ByZWxvYWRJbWFnZXMuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS9sb29wL2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvbG9vcC9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJkZWZhdWx0XFxcIjogKCkgPT4gKF9fV0VCUEFDS19ERUZBVUxUX0VYUE9SVF9fKVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbG9vcENyZWF0ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9sb29wQ3JlYXRlICovIFxcXCIuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS9sb29wL2xvb3BDcmVhdGUuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2xvb3BGaXhfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbG9vcEZpeCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvbG9vcC9sb29wRml4LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9sb29wRGVzdHJveV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9sb29wRGVzdHJveSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvbG9vcC9sb29wRGVzdHJveS5qc1xcXCIpO1xcblxcblxcblxcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgX19XRUJQQUNLX0RFRkFVTFRfRVhQT1JUX18gPSAoe1xcbiAgbG9vcENyZWF0ZTogX2xvb3BDcmVhdGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiZGVmYXVsdFxcXCJdLFxcbiAgbG9vcEZpeDogX2xvb3BGaXhfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiZGVmYXVsdFxcXCJdLFxcbiAgbG9vcERlc3Ryb3k6IF9sb29wRGVzdHJveV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJkZWZhdWx0XFxcIl1cXG59KTtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9wYXJ1cy8uL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS9sb29wL2luZGV4LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvbG9vcC9sb29wQ3JlYXRlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS9sb29wL2xvb3BDcmVhdGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJkZWZhdWx0XFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gbG9vcENyZWF0ZSlcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgc3NyX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgc3NyLXdpbmRvdyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc3NyLXdpbmRvdy9zc3Itd2luZG93LmVzbS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfZG9tX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi8uLi91dGlscy9kb20gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vdXRpbHMvZG9tLmpzXFxcIik7XFxuXFxuXFxuZnVuY3Rpb24gbG9vcENyZWF0ZSgpIHtcXG4gIHZhciBzd2lwZXIgPSB0aGlzO1xcbiAgdmFyIGRvY3VtZW50ID0gKDAsc3NyX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmdldERvY3VtZW50KSgpO1xcbiAgdmFyIHBhcmFtcyA9IHN3aXBlci5wYXJhbXMsXFxuICAgICAgJHdyYXBwZXJFbCA9IHN3aXBlci4kd3JhcHBlckVsOyAvLyBSZW1vdmUgZHVwbGljYXRlZCBzbGlkZXNcXG5cXG4gICR3cmFwcGVyRWwuY2hpbGRyZW4oXFxcIi5cXFwiICsgcGFyYW1zLnNsaWRlQ2xhc3MgKyBcXFwiLlxcXCIgKyBwYXJhbXMuc2xpZGVEdXBsaWNhdGVDbGFzcykucmVtb3ZlKCk7XFxuICB2YXIgc2xpZGVzID0gJHdyYXBwZXJFbC5jaGlsZHJlbihcXFwiLlxcXCIgKyBwYXJhbXMuc2xpZGVDbGFzcyk7XFxuXFxuICBpZiAocGFyYW1zLmxvb3BGaWxsR3JvdXBXaXRoQmxhbmspIHtcXG4gICAgdmFyIGJsYW5rU2xpZGVzTnVtID0gcGFyYW1zLnNsaWRlc1Blckdyb3VwIC0gc2xpZGVzLmxlbmd0aCAlIHBhcmFtcy5zbGlkZXNQZXJHcm91cDtcXG5cXG4gICAgaWYgKGJsYW5rU2xpZGVzTnVtICE9PSBwYXJhbXMuc2xpZGVzUGVyR3JvdXApIHtcXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJsYW5rU2xpZGVzTnVtOyBpICs9IDEpIHtcXG4gICAgICAgIHZhciBibGFua05vZGUgPSAoMCxfdXRpbHNfZG9tX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcImRlZmF1bHRcXFwiXSkoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykpLmFkZENsYXNzKHBhcmFtcy5zbGlkZUNsYXNzICsgXFxcIiBcXFwiICsgcGFyYW1zLnNsaWRlQmxhbmtDbGFzcyk7XFxuICAgICAgICAkd3JhcHBlckVsLmFwcGVuZChibGFua05vZGUpO1xcbiAgICAgIH1cXG5cXG4gICAgICBzbGlkZXMgPSAkd3JhcHBlckVsLmNoaWxkcmVuKFxcXCIuXFxcIiArIHBhcmFtcy5zbGlkZUNsYXNzKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgaWYgKHBhcmFtcy5zbGlkZXNQZXJWaWV3ID09PSAnYXV0bycgJiYgIXBhcmFtcy5sb29wZWRTbGlkZXMpIHBhcmFtcy5sb29wZWRTbGlkZXMgPSBzbGlkZXMubGVuZ3RoO1xcbiAgc3dpcGVyLmxvb3BlZFNsaWRlcyA9IE1hdGguY2VpbChwYXJzZUZsb2F0KHBhcmFtcy5sb29wZWRTbGlkZXMgfHwgcGFyYW1zLnNsaWRlc1BlclZpZXcsIDEwKSk7XFxuICBzd2lwZXIubG9vcGVkU2xpZGVzICs9IHBhcmFtcy5sb29wQWRkaXRpb25hbFNsaWRlcztcXG5cXG4gIGlmIChzd2lwZXIubG9vcGVkU2xpZGVzID4gc2xpZGVzLmxlbmd0aCkge1xcbiAgICBzd2lwZXIubG9vcGVkU2xpZGVzID0gc2xpZGVzLmxlbmd0aDtcXG4gIH1cXG5cXG4gIHZhciBwcmVwZW5kU2xpZGVzID0gW107XFxuICB2YXIgYXBwZW5kU2xpZGVzID0gW107XFxuICBzbGlkZXMuZWFjaChmdW5jdGlvbiAoZWwsIGluZGV4KSB7XFxuICAgIHZhciBzbGlkZSA9ICgwLF91dGlsc19kb21fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiZGVmYXVsdFxcXCJdKShlbCk7XFxuXFxuICAgIGlmIChpbmRleCA8IHN3aXBlci5sb29wZWRTbGlkZXMpIHtcXG4gICAgICBhcHBlbmRTbGlkZXMucHVzaChlbCk7XFxuICAgIH1cXG5cXG4gICAgaWYgKGluZGV4IDwgc2xpZGVzLmxlbmd0aCAmJiBpbmRleCA+PSBzbGlkZXMubGVuZ3RoIC0gc3dpcGVyLmxvb3BlZFNsaWRlcykge1xcbiAgICAgIHByZXBlbmRTbGlkZXMucHVzaChlbCk7XFxuICAgIH1cXG5cXG4gICAgc2xpZGUuYXR0cignZGF0YS1zd2lwZXItc2xpZGUtaW5kZXgnLCBpbmRleCk7XFxuICB9KTtcXG5cXG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcHBlbmRTbGlkZXMubGVuZ3RoOyBfaSArPSAxKSB7XFxuICAgICR3cmFwcGVyRWwuYXBwZW5kKCgwLF91dGlsc19kb21fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiZGVmYXVsdFxcXCJdKShhcHBlbmRTbGlkZXNbX2ldLmNsb25lTm9kZSh0cnVlKSkuYWRkQ2xhc3MocGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3MpKTtcXG4gIH1cXG5cXG4gIGZvciAodmFyIF9pMiA9IHByZXBlbmRTbGlkZXMubGVuZ3RoIC0gMTsgX2kyID49IDA7IF9pMiAtPSAxKSB7XFxuICAgICR3cmFwcGVyRWwucHJlcGVuZCgoMCxfdXRpbHNfZG9tX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcImRlZmF1bHRcXFwiXSkocHJlcGVuZFNsaWRlc1tfaTJdLmNsb25lTm9kZSh0cnVlKSkuYWRkQ2xhc3MocGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3MpKTtcXG4gIH1cXG59XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vcGFydXMvLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvbG9vcC9sb29wQ3JlYXRlLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvbG9vcC9sb29wRGVzdHJveS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL2xvb3AvbG9vcERlc3Ryb3kuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwiZGVmYXVsdFxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIGxvb3BEZXN0cm95KVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbmZ1bmN0aW9uIGxvb3BEZXN0cm95KCkge1xcbiAgdmFyIHN3aXBlciA9IHRoaXM7XFxuICB2YXIgJHdyYXBwZXJFbCA9IHN3aXBlci4kd3JhcHBlckVsLFxcbiAgICAgIHBhcmFtcyA9IHN3aXBlci5wYXJhbXMsXFxuICAgICAgc2xpZGVzID0gc3dpcGVyLnNsaWRlcztcXG4gICR3cmFwcGVyRWwuY2hpbGRyZW4oXFxcIi5cXFwiICsgcGFyYW1zLnNsaWRlQ2xhc3MgKyBcXFwiLlxcXCIgKyBwYXJhbXMuc2xpZGVEdXBsaWNhdGVDbGFzcyArIFxcXCIsLlxcXCIgKyBwYXJhbXMuc2xpZGVDbGFzcyArIFxcXCIuXFxcIiArIHBhcmFtcy5zbGlkZUJsYW5rQ2xhc3MpLnJlbW92ZSgpO1xcbiAgc2xpZGVzLnJlbW92ZUF0dHIoJ2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4Jyk7XFxufVxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3BhcnVzLy4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL2xvb3AvbG9vcERlc3Ryb3kuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS9sb29wL2xvb3BGaXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL2xvb3AvbG9vcEZpeC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcImRlZmF1bHRcXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBsb29wRml4KVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbmZ1bmN0aW9uIGxvb3BGaXgoKSB7XFxuICB2YXIgc3dpcGVyID0gdGhpcztcXG4gIHN3aXBlci5lbWl0KCdiZWZvcmVMb29wRml4Jyk7XFxuICB2YXIgYWN0aXZlSW5kZXggPSBzd2lwZXIuYWN0aXZlSW5kZXgsXFxuICAgICAgc2xpZGVzID0gc3dpcGVyLnNsaWRlcyxcXG4gICAgICBsb29wZWRTbGlkZXMgPSBzd2lwZXIubG9vcGVkU2xpZGVzLFxcbiAgICAgIGFsbG93U2xpZGVQcmV2ID0gc3dpcGVyLmFsbG93U2xpZGVQcmV2LFxcbiAgICAgIGFsbG93U2xpZGVOZXh0ID0gc3dpcGVyLmFsbG93U2xpZGVOZXh0LFxcbiAgICAgIHNuYXBHcmlkID0gc3dpcGVyLnNuYXBHcmlkLFxcbiAgICAgIHJ0bCA9IHN3aXBlci5ydGxUcmFuc2xhdGU7XFxuICB2YXIgbmV3SW5kZXg7XFxuICBzd2lwZXIuYWxsb3dTbGlkZVByZXYgPSB0cnVlO1xcbiAgc3dpcGVyLmFsbG93U2xpZGVOZXh0ID0gdHJ1ZTtcXG4gIHZhciBzbmFwVHJhbnNsYXRlID0gLXNuYXBHcmlkW2FjdGl2ZUluZGV4XTtcXG4gIHZhciBkaWZmID0gc25hcFRyYW5zbGF0ZSAtIHN3aXBlci5nZXRUcmFuc2xhdGUoKTsgLy8gRml4IEZvciBOZWdhdGl2ZSBPdmVyc2xpZGluZ1xcblxcbiAgaWYgKGFjdGl2ZUluZGV4IDwgbG9vcGVkU2xpZGVzKSB7XFxuICAgIG5ld0luZGV4ID0gc2xpZGVzLmxlbmd0aCAtIGxvb3BlZFNsaWRlcyAqIDMgKyBhY3RpdmVJbmRleDtcXG4gICAgbmV3SW5kZXggKz0gbG9vcGVkU2xpZGVzO1xcbiAgICB2YXIgc2xpZGVDaGFuZ2VkID0gc3dpcGVyLnNsaWRlVG8obmV3SW5kZXgsIDAsIGZhbHNlLCB0cnVlKTtcXG5cXG4gICAgaWYgKHNsaWRlQ2hhbmdlZCAmJiBkaWZmICE9PSAwKSB7XFxuICAgICAgc3dpcGVyLnNldFRyYW5zbGF0ZSgocnRsID8gLXN3aXBlci50cmFuc2xhdGUgOiBzd2lwZXIudHJhbnNsYXRlKSAtIGRpZmYpO1xcbiAgICB9XFxuICB9IGVsc2UgaWYgKGFjdGl2ZUluZGV4ID49IHNsaWRlcy5sZW5ndGggLSBsb29wZWRTbGlkZXMpIHtcXG4gICAgLy8gRml4IEZvciBQb3NpdGl2ZSBPdmVyc2xpZGluZ1xcbiAgICBuZXdJbmRleCA9IC1zbGlkZXMubGVuZ3RoICsgYWN0aXZlSW5kZXggKyBsb29wZWRTbGlkZXM7XFxuICAgIG5ld0luZGV4ICs9IGxvb3BlZFNsaWRlcztcXG5cXG4gICAgdmFyIF9zbGlkZUNoYW5nZWQgPSBzd2lwZXIuc2xpZGVUbyhuZXdJbmRleCwgMCwgZmFsc2UsIHRydWUpO1xcblxcbiAgICBpZiAoX3NsaWRlQ2hhbmdlZCAmJiBkaWZmICE9PSAwKSB7XFxuICAgICAgc3dpcGVyLnNldFRyYW5zbGF0ZSgocnRsID8gLXN3aXBlci50cmFuc2xhdGUgOiBzd2lwZXIudHJhbnNsYXRlKSAtIGRpZmYpO1xcbiAgICB9XFxuICB9XFxuXFxuICBzd2lwZXIuYWxsb3dTbGlkZVByZXYgPSBhbGxvd1NsaWRlUHJldjtcXG4gIHN3aXBlci5hbGxvd1NsaWRlTmV4dCA9IGFsbG93U2xpZGVOZXh0O1xcbiAgc3dpcGVyLmVtaXQoJ2xvb3BGaXgnKTtcXG59XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vcGFydXMvLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvbG9vcC9sb29wRml4LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvbWFuaXB1bGF0aW9uL2FkZFNsaWRlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS9tYW5pcHVsYXRpb24vYWRkU2xpZGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJkZWZhdWx0XFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gYWRkU2xpZGUpXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuZnVuY3Rpb24gYWRkU2xpZGUoaW5kZXgsIHNsaWRlcykge1xcbiAgdmFyIHN3aXBlciA9IHRoaXM7XFxuICB2YXIgJHdyYXBwZXJFbCA9IHN3aXBlci4kd3JhcHBlckVsLFxcbiAgICAgIHBhcmFtcyA9IHN3aXBlci5wYXJhbXMsXFxuICAgICAgYWN0aXZlSW5kZXggPSBzd2lwZXIuYWN0aXZlSW5kZXg7XFxuICB2YXIgYWN0aXZlSW5kZXhCdWZmZXIgPSBhY3RpdmVJbmRleDtcXG5cXG4gIGlmIChwYXJhbXMubG9vcCkge1xcbiAgICBhY3RpdmVJbmRleEJ1ZmZlciAtPSBzd2lwZXIubG9vcGVkU2xpZGVzO1xcbiAgICBzd2lwZXIubG9vcERlc3Ryb3koKTtcXG4gICAgc3dpcGVyLnNsaWRlcyA9ICR3cmFwcGVyRWwuY2hpbGRyZW4oXFxcIi5cXFwiICsgcGFyYW1zLnNsaWRlQ2xhc3MpO1xcbiAgfVxcblxcbiAgdmFyIGJhc2VMZW5ndGggPSBzd2lwZXIuc2xpZGVzLmxlbmd0aDtcXG5cXG4gIGlmIChpbmRleCA8PSAwKSB7XFxuICAgIHN3aXBlci5wcmVwZW5kU2xpZGUoc2xpZGVzKTtcXG4gICAgcmV0dXJuO1xcbiAgfVxcblxcbiAgaWYgKGluZGV4ID49IGJhc2VMZW5ndGgpIHtcXG4gICAgc3dpcGVyLmFwcGVuZFNsaWRlKHNsaWRlcyk7XFxuICAgIHJldHVybjtcXG4gIH1cXG5cXG4gIHZhciBuZXdBY3RpdmVJbmRleCA9IGFjdGl2ZUluZGV4QnVmZmVyID4gaW5kZXggPyBhY3RpdmVJbmRleEJ1ZmZlciArIDEgOiBhY3RpdmVJbmRleEJ1ZmZlcjtcXG4gIHZhciBzbGlkZXNCdWZmZXIgPSBbXTtcXG5cXG4gIGZvciAodmFyIGkgPSBiYXNlTGVuZ3RoIC0gMTsgaSA+PSBpbmRleDsgaSAtPSAxKSB7XFxuICAgIHZhciBjdXJyZW50U2xpZGUgPSBzd2lwZXIuc2xpZGVzLmVxKGkpO1xcbiAgICBjdXJyZW50U2xpZGUucmVtb3ZlKCk7XFxuICAgIHNsaWRlc0J1ZmZlci51bnNoaWZ0KGN1cnJlbnRTbGlkZSk7XFxuICB9XFxuXFxuICBpZiAodHlwZW9mIHNsaWRlcyA9PT0gJ29iamVjdCcgJiYgJ2xlbmd0aCcgaW4gc2xpZGVzKSB7XFxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBzbGlkZXMubGVuZ3RoOyBfaSArPSAxKSB7XFxuICAgICAgaWYgKHNsaWRlc1tfaV0pICR3cmFwcGVyRWwuYXBwZW5kKHNsaWRlc1tfaV0pO1xcbiAgICB9XFxuXFxuICAgIG5ld0FjdGl2ZUluZGV4ID0gYWN0aXZlSW5kZXhCdWZmZXIgPiBpbmRleCA/IGFjdGl2ZUluZGV4QnVmZmVyICsgc2xpZGVzLmxlbmd0aCA6IGFjdGl2ZUluZGV4QnVmZmVyO1xcbiAgfSBlbHNlIHtcXG4gICAgJHdyYXBwZXJFbC5hcHBlbmQoc2xpZGVzKTtcXG4gIH1cXG5cXG4gIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IHNsaWRlc0J1ZmZlci5sZW5ndGg7IF9pMiArPSAxKSB7XFxuICAgICR3cmFwcGVyRWwuYXBwZW5kKHNsaWRlc0J1ZmZlcltfaTJdKTtcXG4gIH1cXG5cXG4gIGlmIChwYXJhbXMubG9vcCkge1xcbiAgICBzd2lwZXIubG9vcENyZWF0ZSgpO1xcbiAgfVxcblxcbiAgaWYgKCEocGFyYW1zLm9ic2VydmVyICYmIHN3aXBlci5zdXBwb3J0Lm9ic2VydmVyKSkge1xcbiAgICBzd2lwZXIudXBkYXRlKCk7XFxuICB9XFxuXFxuICBpZiAocGFyYW1zLmxvb3ApIHtcXG4gICAgc3dpcGVyLnNsaWRlVG8obmV3QWN0aXZlSW5kZXggKyBzd2lwZXIubG9vcGVkU2xpZGVzLCAwLCBmYWxzZSk7XFxuICB9IGVsc2Uge1xcbiAgICBzd2lwZXIuc2xpZGVUbyhuZXdBY3RpdmVJbmRleCwgMCwgZmFsc2UpO1xcbiAgfVxcbn1cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9wYXJ1cy8uL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS9tYW5pcHVsYXRpb24vYWRkU2xpZGUuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS9tYW5pcHVsYXRpb24vYXBwZW5kU2xpZGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL21hbmlwdWxhdGlvbi9hcHBlbmRTbGlkZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcImRlZmF1bHRcXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBhcHBlbmRTbGlkZSlcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG5mdW5jdGlvbiBhcHBlbmRTbGlkZShzbGlkZXMpIHtcXG4gIHZhciBzd2lwZXIgPSB0aGlzO1xcbiAgdmFyICR3cmFwcGVyRWwgPSBzd2lwZXIuJHdyYXBwZXJFbCxcXG4gICAgICBwYXJhbXMgPSBzd2lwZXIucGFyYW1zO1xcblxcbiAgaWYgKHBhcmFtcy5sb29wKSB7XFxuICAgIHN3aXBlci5sb29wRGVzdHJveSgpO1xcbiAgfVxcblxcbiAgaWYgKHR5cGVvZiBzbGlkZXMgPT09ICdvYmplY3QnICYmICdsZW5ndGgnIGluIHNsaWRlcykge1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWRlcy5sZW5ndGg7IGkgKz0gMSkge1xcbiAgICAgIGlmIChzbGlkZXNbaV0pICR3cmFwcGVyRWwuYXBwZW5kKHNsaWRlc1tpXSk7XFxuICAgIH1cXG4gIH0gZWxzZSB7XFxuICAgICR3cmFwcGVyRWwuYXBwZW5kKHNsaWRlcyk7XFxuICB9XFxuXFxuICBpZiAocGFyYW1zLmxvb3ApIHtcXG4gICAgc3dpcGVyLmxvb3BDcmVhdGUoKTtcXG4gIH1cXG5cXG4gIGlmICghKHBhcmFtcy5vYnNlcnZlciAmJiBzd2lwZXIuc3VwcG9ydC5vYnNlcnZlcikpIHtcXG4gICAgc3dpcGVyLnVwZGF0ZSgpO1xcbiAgfVxcbn1cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9wYXJ1cy8uL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS9tYW5pcHVsYXRpb24vYXBwZW5kU2xpZGUuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS9tYW5pcHVsYXRpb24vaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL21hbmlwdWxhdGlvbi9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcImRlZmF1bHRcXFwiOiAoKSA9PiAoX19XRUJQQUNLX0RFRkFVTFRfRVhQT1JUX18pXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9hcHBlbmRTbGlkZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9hcHBlbmRTbGlkZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvbWFuaXB1bGF0aW9uL2FwcGVuZFNsaWRlLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9wcmVwZW5kU2xpZGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcHJlcGVuZFNsaWRlICovIFxcXCIuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS9tYW5pcHVsYXRpb24vcHJlcGVuZFNsaWRlLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9hZGRTbGlkZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9hZGRTbGlkZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvbWFuaXB1bGF0aW9uL2FkZFNsaWRlLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9yZW1vdmVTbGlkZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9yZW1vdmVTbGlkZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvbWFuaXB1bGF0aW9uL3JlbW92ZVNsaWRlLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9yZW1vdmVBbGxTbGlkZXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcmVtb3ZlQWxsU2xpZGVzICovIFxcXCIuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS9tYW5pcHVsYXRpb24vcmVtb3ZlQWxsU2xpZGVzLmpzXFxcIik7XFxuXFxuXFxuXFxuXFxuXFxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBfX1dFQlBBQ0tfREVGQVVMVF9FWFBPUlRfXyA9ICh7XFxuICBhcHBlbmRTbGlkZTogX2FwcGVuZFNsaWRlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImRlZmF1bHRcXFwiXSxcXG4gIHByZXBlbmRTbGlkZTogX3ByZXBlbmRTbGlkZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJkZWZhdWx0XFxcIl0sXFxuICBhZGRTbGlkZTogX2FkZFNsaWRlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcImRlZmF1bHRcXFwiXSxcXG4gIHJlbW92ZVNsaWRlOiBfcmVtb3ZlU2xpZGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcXFwiZGVmYXVsdFxcXCJdLFxcbiAgcmVtb3ZlQWxsU2xpZGVzOiBfcmVtb3ZlQWxsU2xpZGVzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXFxcImRlZmF1bHRcXFwiXVxcbn0pO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3BhcnVzLy4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL21hbmlwdWxhdGlvbi9pbmRleC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL21hbmlwdWxhdGlvbi9wcmVwZW5kU2xpZGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS9tYW5pcHVsYXRpb24vcHJlcGVuZFNsaWRlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcImRlZmF1bHRcXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBwcmVwZW5kU2xpZGUpXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuZnVuY3Rpb24gcHJlcGVuZFNsaWRlKHNsaWRlcykge1xcbiAgdmFyIHN3aXBlciA9IHRoaXM7XFxuICB2YXIgcGFyYW1zID0gc3dpcGVyLnBhcmFtcyxcXG4gICAgICAkd3JhcHBlckVsID0gc3dpcGVyLiR3cmFwcGVyRWwsXFxuICAgICAgYWN0aXZlSW5kZXggPSBzd2lwZXIuYWN0aXZlSW5kZXg7XFxuXFxuICBpZiAocGFyYW1zLmxvb3ApIHtcXG4gICAgc3dpcGVyLmxvb3BEZXN0cm95KCk7XFxuICB9XFxuXFxuICB2YXIgbmV3QWN0aXZlSW5kZXggPSBhY3RpdmVJbmRleCArIDE7XFxuXFxuICBpZiAodHlwZW9mIHNsaWRlcyA9PT0gJ29iamVjdCcgJiYgJ2xlbmd0aCcgaW4gc2xpZGVzKSB7XFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpZGVzLmxlbmd0aDsgaSArPSAxKSB7XFxuICAgICAgaWYgKHNsaWRlc1tpXSkgJHdyYXBwZXJFbC5wcmVwZW5kKHNsaWRlc1tpXSk7XFxuICAgIH1cXG5cXG4gICAgbmV3QWN0aXZlSW5kZXggPSBhY3RpdmVJbmRleCArIHNsaWRlcy5sZW5ndGg7XFxuICB9IGVsc2Uge1xcbiAgICAkd3JhcHBlckVsLnByZXBlbmQoc2xpZGVzKTtcXG4gIH1cXG5cXG4gIGlmIChwYXJhbXMubG9vcCkge1xcbiAgICBzd2lwZXIubG9vcENyZWF0ZSgpO1xcbiAgfVxcblxcbiAgaWYgKCEocGFyYW1zLm9ic2VydmVyICYmIHN3aXBlci5zdXBwb3J0Lm9ic2VydmVyKSkge1xcbiAgICBzd2lwZXIudXBkYXRlKCk7XFxuICB9XFxuXFxuICBzd2lwZXIuc2xpZGVUbyhuZXdBY3RpdmVJbmRleCwgMCwgZmFsc2UpO1xcbn1cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9wYXJ1cy8uL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS9tYW5pcHVsYXRpb24vcHJlcGVuZFNsaWRlLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvbWFuaXB1bGF0aW9uL3JlbW92ZUFsbFNsaWRlcy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL21hbmlwdWxhdGlvbi9yZW1vdmVBbGxTbGlkZXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwiZGVmYXVsdFxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIHJlbW92ZUFsbFNsaWRlcylcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG5mdW5jdGlvbiByZW1vdmVBbGxTbGlkZXMoKSB7XFxuICB2YXIgc3dpcGVyID0gdGhpcztcXG4gIHZhciBzbGlkZXNJbmRleGVzID0gW107XFxuXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN3aXBlci5zbGlkZXMubGVuZ3RoOyBpICs9IDEpIHtcXG4gICAgc2xpZGVzSW5kZXhlcy5wdXNoKGkpO1xcbiAgfVxcblxcbiAgc3dpcGVyLnJlbW92ZVNsaWRlKHNsaWRlc0luZGV4ZXMpO1xcbn1cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9wYXJ1cy8uL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS9tYW5pcHVsYXRpb24vcmVtb3ZlQWxsU2xpZGVzLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvbWFuaXB1bGF0aW9uL3JlbW92ZVNsaWRlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS9tYW5pcHVsYXRpb24vcmVtb3ZlU2xpZGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJkZWZhdWx0XFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gcmVtb3ZlU2xpZGUpXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuZnVuY3Rpb24gcmVtb3ZlU2xpZGUoc2xpZGVzSW5kZXhlcykge1xcbiAgdmFyIHN3aXBlciA9IHRoaXM7XFxuICB2YXIgcGFyYW1zID0gc3dpcGVyLnBhcmFtcyxcXG4gICAgICAkd3JhcHBlckVsID0gc3dpcGVyLiR3cmFwcGVyRWwsXFxuICAgICAgYWN0aXZlSW5kZXggPSBzd2lwZXIuYWN0aXZlSW5kZXg7XFxuICB2YXIgYWN0aXZlSW5kZXhCdWZmZXIgPSBhY3RpdmVJbmRleDtcXG5cXG4gIGlmIChwYXJhbXMubG9vcCkge1xcbiAgICBhY3RpdmVJbmRleEJ1ZmZlciAtPSBzd2lwZXIubG9vcGVkU2xpZGVzO1xcbiAgICBzd2lwZXIubG9vcERlc3Ryb3koKTtcXG4gICAgc3dpcGVyLnNsaWRlcyA9ICR3cmFwcGVyRWwuY2hpbGRyZW4oXFxcIi5cXFwiICsgcGFyYW1zLnNsaWRlQ2xhc3MpO1xcbiAgfVxcblxcbiAgdmFyIG5ld0FjdGl2ZUluZGV4ID0gYWN0aXZlSW5kZXhCdWZmZXI7XFxuICB2YXIgaW5kZXhUb1JlbW92ZTtcXG5cXG4gIGlmICh0eXBlb2Ygc2xpZGVzSW5kZXhlcyA9PT0gJ29iamVjdCcgJiYgJ2xlbmd0aCcgaW4gc2xpZGVzSW5kZXhlcykge1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWRlc0luZGV4ZXMubGVuZ3RoOyBpICs9IDEpIHtcXG4gICAgICBpbmRleFRvUmVtb3ZlID0gc2xpZGVzSW5kZXhlc1tpXTtcXG4gICAgICBpZiAoc3dpcGVyLnNsaWRlc1tpbmRleFRvUmVtb3ZlXSkgc3dpcGVyLnNsaWRlcy5lcShpbmRleFRvUmVtb3ZlKS5yZW1vdmUoKTtcXG4gICAgICBpZiAoaW5kZXhUb1JlbW92ZSA8IG5ld0FjdGl2ZUluZGV4KSBuZXdBY3RpdmVJbmRleCAtPSAxO1xcbiAgICB9XFxuXFxuICAgIG5ld0FjdGl2ZUluZGV4ID0gTWF0aC5tYXgobmV3QWN0aXZlSW5kZXgsIDApO1xcbiAgfSBlbHNlIHtcXG4gICAgaW5kZXhUb1JlbW92ZSA9IHNsaWRlc0luZGV4ZXM7XFxuICAgIGlmIChzd2lwZXIuc2xpZGVzW2luZGV4VG9SZW1vdmVdKSBzd2lwZXIuc2xpZGVzLmVxKGluZGV4VG9SZW1vdmUpLnJlbW92ZSgpO1xcbiAgICBpZiAoaW5kZXhUb1JlbW92ZSA8IG5ld0FjdGl2ZUluZGV4KSBuZXdBY3RpdmVJbmRleCAtPSAxO1xcbiAgICBuZXdBY3RpdmVJbmRleCA9IE1hdGgubWF4KG5ld0FjdGl2ZUluZGV4LCAwKTtcXG4gIH1cXG5cXG4gIGlmIChwYXJhbXMubG9vcCkge1xcbiAgICBzd2lwZXIubG9vcENyZWF0ZSgpO1xcbiAgfVxcblxcbiAgaWYgKCEocGFyYW1zLm9ic2VydmVyICYmIHN3aXBlci5zdXBwb3J0Lm9ic2VydmVyKSkge1xcbiAgICBzd2lwZXIudXBkYXRlKCk7XFxuICB9XFxuXFxuICBpZiAocGFyYW1zLmxvb3ApIHtcXG4gICAgc3dpcGVyLnNsaWRlVG8obmV3QWN0aXZlSW5kZXggKyBzd2lwZXIubG9vcGVkU2xpZGVzLCAwLCBmYWxzZSk7XFxuICB9IGVsc2Uge1xcbiAgICBzd2lwZXIuc2xpZGVUbyhuZXdBY3RpdmVJbmRleCwgMCwgZmFsc2UpO1xcbiAgfVxcbn1cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9wYXJ1cy8uL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS9tYW5pcHVsYXRpb24vcmVtb3ZlU2xpZGUuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS9tb2R1bGFyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvbW9kdWxhci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJkZWZhdWx0XFxcIjogKCkgPT4gKF9fV0VCUEFDS19ERUZBVUxUX0VYUE9SVF9fKVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3V0aWxzL3V0aWxzICovIFxcXCIuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL3V0aWxzL3V0aWxzLmpzXFxcIik7XFxuXFxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBfX1dFQlBBQ0tfREVGQVVMVF9FWFBPUlRfXyA9ICh7XFxuICB1c2VQYXJhbXM6IGZ1bmN0aW9uIHVzZVBhcmFtcyhpbnN0YW5jZVBhcmFtcykge1xcbiAgICB2YXIgaW5zdGFuY2UgPSB0aGlzO1xcbiAgICBpZiAoIWluc3RhbmNlLm1vZHVsZXMpIHJldHVybjtcXG4gICAgT2JqZWN0LmtleXMoaW5zdGFuY2UubW9kdWxlcykuZm9yRWFjaChmdW5jdGlvbiAobW9kdWxlTmFtZSkge1xcbiAgICAgIHZhciBtb2R1bGUgPSBpbnN0YW5jZS5tb2R1bGVzW21vZHVsZU5hbWVdOyAvLyBFeHRlbmQgcGFyYW1zXFxuXFxuICAgICAgaWYgKG1vZHVsZS5wYXJhbXMpIHtcXG4gICAgICAgICgwLF91dGlsc191dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmV4dGVuZCkoaW5zdGFuY2VQYXJhbXMsIG1vZHVsZS5wYXJhbXMpO1xcbiAgICAgIH1cXG4gICAgfSk7XFxuICB9LFxcbiAgdXNlTW9kdWxlczogZnVuY3Rpb24gdXNlTW9kdWxlcyhtb2R1bGVzUGFyYW1zKSB7XFxuICAgIGlmIChtb2R1bGVzUGFyYW1zID09PSB2b2lkIDApIHtcXG4gICAgICBtb2R1bGVzUGFyYW1zID0ge307XFxuICAgIH1cXG5cXG4gICAgdmFyIGluc3RhbmNlID0gdGhpcztcXG4gICAgaWYgKCFpbnN0YW5jZS5tb2R1bGVzKSByZXR1cm47XFxuICAgIE9iamVjdC5rZXlzKGluc3RhbmNlLm1vZHVsZXMpLmZvckVhY2goZnVuY3Rpb24gKG1vZHVsZU5hbWUpIHtcXG4gICAgICB2YXIgbW9kdWxlID0gaW5zdGFuY2UubW9kdWxlc1ttb2R1bGVOYW1lXTtcXG4gICAgICB2YXIgbW9kdWxlUGFyYW1zID0gbW9kdWxlc1BhcmFtc1ttb2R1bGVOYW1lXSB8fCB7fTsgLy8gQWRkIGV2ZW50IGxpc3RlbmVyc1xcblxcbiAgICAgIGlmIChtb2R1bGUub24gJiYgaW5zdGFuY2Uub24pIHtcXG4gICAgICAgIE9iamVjdC5rZXlzKG1vZHVsZS5vbikuZm9yRWFjaChmdW5jdGlvbiAobW9kdWxlRXZlbnROYW1lKSB7XFxuICAgICAgICAgIGluc3RhbmNlLm9uKG1vZHVsZUV2ZW50TmFtZSwgbW9kdWxlLm9uW21vZHVsZUV2ZW50TmFtZV0pO1xcbiAgICAgICAgfSk7XFxuICAgICAgfSAvLyBNb2R1bGUgY3JlYXRlIGNhbGxiYWNrXFxuXFxuXFxuICAgICAgaWYgKG1vZHVsZS5jcmVhdGUpIHtcXG4gICAgICAgIG1vZHVsZS5jcmVhdGUuYmluZChpbnN0YW5jZSkobW9kdWxlUGFyYW1zKTtcXG4gICAgICB9XFxuICAgIH0pO1xcbiAgfVxcbn0pO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3BhcnVzLy4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL21vZHVsYXIuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS9zbGlkZS9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS9zbGlkZS9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwiZGVmYXVsdFxcXCI6ICgpID0+IChfX1dFQlBBQ0tfREVGQVVMVF9FWFBPUlRfXylcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3NsaWRlVG9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc2xpZGVUbyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvc2xpZGUvc2xpZGVUby5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc2xpZGVUb0xvb3BfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc2xpZGVUb0xvb3AgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL3NsaWRlL3NsaWRlVG9Mb29wLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zbGlkZU5leHRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc2xpZGVOZXh0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS9zbGlkZS9zbGlkZU5leHQuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3NsaWRlUHJldl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zbGlkZVByZXYgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL3NsaWRlL3NsaWRlUHJldi5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc2xpZGVSZXNldF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zbGlkZVJlc2V0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS9zbGlkZS9zbGlkZVJlc2V0LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zbGlkZVRvQ2xvc2VzdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zbGlkZVRvQ2xvc2VzdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvc2xpZGUvc2xpZGVUb0Nsb3Nlc3QuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3NsaWRlVG9DbGlja2VkU2xpZGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc2xpZGVUb0NsaWNrZWRTbGlkZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvc2xpZGUvc2xpZGVUb0NsaWNrZWRTbGlkZS5qc1xcXCIpO1xcblxcblxcblxcblxcblxcblxcblxcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgX19XRUJQQUNLX0RFRkFVTFRfRVhQT1JUX18gPSAoe1xcbiAgc2xpZGVUbzogX3NsaWRlVG9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiZGVmYXVsdFxcXCJdLFxcbiAgc2xpZGVUb0xvb3A6IF9zbGlkZVRvTG9vcF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJkZWZhdWx0XFxcIl0sXFxuICBzbGlkZU5leHQ6IF9zbGlkZU5leHRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwiZGVmYXVsdFxcXCJdLFxcbiAgc2xpZGVQcmV2OiBfc2xpZGVQcmV2X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXFxcImRlZmF1bHRcXFwiXSxcXG4gIHNsaWRlUmVzZXQ6IF9zbGlkZVJlc2V0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXFxcImRlZmF1bHRcXFwiXSxcXG4gIHNsaWRlVG9DbG9zZXN0OiBfc2xpZGVUb0Nsb3Nlc3RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcXFwiZGVmYXVsdFxcXCJdLFxcbiAgc2xpZGVUb0NsaWNrZWRTbGlkZTogX3NsaWRlVG9DbGlja2VkU2xpZGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcXFwiZGVmYXVsdFxcXCJdXFxufSk7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vcGFydXMvLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvc2xpZGUvaW5kZXguanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS9zbGlkZS9zbGlkZU5leHQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL3NsaWRlL3NsaWRlTmV4dC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcImRlZmF1bHRcXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBzbGlkZU5leHQpXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBcXFwib2ZmXFxcIiAqL1xcbmZ1bmN0aW9uIHNsaWRlTmV4dChzcGVlZCwgcnVuQ2FsbGJhY2tzLCBpbnRlcm5hbCkge1xcbiAgaWYgKHNwZWVkID09PSB2b2lkIDApIHtcXG4gICAgc3BlZWQgPSB0aGlzLnBhcmFtcy5zcGVlZDtcXG4gIH1cXG5cXG4gIGlmIChydW5DYWxsYmFja3MgPT09IHZvaWQgMCkge1xcbiAgICBydW5DYWxsYmFja3MgPSB0cnVlO1xcbiAgfVxcblxcbiAgdmFyIHN3aXBlciA9IHRoaXM7XFxuICB2YXIgcGFyYW1zID0gc3dpcGVyLnBhcmFtcyxcXG4gICAgICBhbmltYXRpbmcgPSBzd2lwZXIuYW5pbWF0aW5nLFxcbiAgICAgIGVuYWJsZWQgPSBzd2lwZXIuZW5hYmxlZDtcXG4gIGlmICghZW5hYmxlZCkgcmV0dXJuIHN3aXBlcjtcXG4gIHZhciBpbmNyZW1lbnQgPSBzd2lwZXIuYWN0aXZlSW5kZXggPCBwYXJhbXMuc2xpZGVzUGVyR3JvdXBTa2lwID8gMSA6IHBhcmFtcy5zbGlkZXNQZXJHcm91cDtcXG5cXG4gIGlmIChwYXJhbXMubG9vcCkge1xcbiAgICBpZiAoYW5pbWF0aW5nICYmIHBhcmFtcy5sb29wUHJldmVudHNTbGlkZSkgcmV0dXJuIGZhbHNlO1xcbiAgICBzd2lwZXIubG9vcEZpeCgpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcXG5cXG4gICAgc3dpcGVyLl9jbGllbnRMZWZ0ID0gc3dpcGVyLiR3cmFwcGVyRWxbMF0uY2xpZW50TGVmdDtcXG4gIH1cXG5cXG4gIHJldHVybiBzd2lwZXIuc2xpZGVUbyhzd2lwZXIuYWN0aXZlSW5kZXggKyBpbmNyZW1lbnQsIHNwZWVkLCBydW5DYWxsYmFja3MsIGludGVybmFsKTtcXG59XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vcGFydXMvLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvc2xpZGUvc2xpZGVOZXh0LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvc2xpZGUvc2xpZGVQcmV2LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS9zbGlkZS9zbGlkZVByZXYuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJkZWZhdWx0XFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gc2xpZGVQcmV2KVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogXFxcIm9mZlxcXCIgKi9cXG5mdW5jdGlvbiBzbGlkZVByZXYoc3BlZWQsIHJ1bkNhbGxiYWNrcywgaW50ZXJuYWwpIHtcXG4gIGlmIChzcGVlZCA9PT0gdm9pZCAwKSB7XFxuICAgIHNwZWVkID0gdGhpcy5wYXJhbXMuc3BlZWQ7XFxuICB9XFxuXFxuICBpZiAocnVuQ2FsbGJhY2tzID09PSB2b2lkIDApIHtcXG4gICAgcnVuQ2FsbGJhY2tzID0gdHJ1ZTtcXG4gIH1cXG5cXG4gIHZhciBzd2lwZXIgPSB0aGlzO1xcbiAgdmFyIHBhcmFtcyA9IHN3aXBlci5wYXJhbXMsXFxuICAgICAgYW5pbWF0aW5nID0gc3dpcGVyLmFuaW1hdGluZyxcXG4gICAgICBzbmFwR3JpZCA9IHN3aXBlci5zbmFwR3JpZCxcXG4gICAgICBzbGlkZXNHcmlkID0gc3dpcGVyLnNsaWRlc0dyaWQsXFxuICAgICAgcnRsVHJhbnNsYXRlID0gc3dpcGVyLnJ0bFRyYW5zbGF0ZSxcXG4gICAgICBlbmFibGVkID0gc3dpcGVyLmVuYWJsZWQ7XFxuICBpZiAoIWVuYWJsZWQpIHJldHVybiBzd2lwZXI7XFxuXFxuICBpZiAocGFyYW1zLmxvb3ApIHtcXG4gICAgaWYgKGFuaW1hdGluZyAmJiBwYXJhbXMubG9vcFByZXZlbnRzU2xpZGUpIHJldHVybiBmYWxzZTtcXG4gICAgc3dpcGVyLmxvb3BGaXgoKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXFxuXFxuICAgIHN3aXBlci5fY2xpZW50TGVmdCA9IHN3aXBlci4kd3JhcHBlckVsWzBdLmNsaWVudExlZnQ7XFxuICB9XFxuXFxuICB2YXIgdHJhbnNsYXRlID0gcnRsVHJhbnNsYXRlID8gc3dpcGVyLnRyYW5zbGF0ZSA6IC1zd2lwZXIudHJhbnNsYXRlO1xcblxcbiAgZnVuY3Rpb24gbm9ybWFsaXplKHZhbCkge1xcbiAgICBpZiAodmFsIDwgMCkgcmV0dXJuIC1NYXRoLmZsb29yKE1hdGguYWJzKHZhbCkpO1xcbiAgICByZXR1cm4gTWF0aC5mbG9vcih2YWwpO1xcbiAgfVxcblxcbiAgdmFyIG5vcm1hbGl6ZWRUcmFuc2xhdGUgPSBub3JtYWxpemUodHJhbnNsYXRlKTtcXG4gIHZhciBub3JtYWxpemVkU25hcEdyaWQgPSBzbmFwR3JpZC5tYXAoZnVuY3Rpb24gKHZhbCkge1xcbiAgICByZXR1cm4gbm9ybWFsaXplKHZhbCk7XFxuICB9KTtcXG4gIHZhciBwcmV2U25hcCA9IHNuYXBHcmlkW25vcm1hbGl6ZWRTbmFwR3JpZC5pbmRleE9mKG5vcm1hbGl6ZWRUcmFuc2xhdGUpIC0gMV07XFxuXFxuICBpZiAodHlwZW9mIHByZXZTbmFwID09PSAndW5kZWZpbmVkJyAmJiBwYXJhbXMuY3NzTW9kZSkge1xcbiAgICBzbmFwR3JpZC5mb3JFYWNoKGZ1bmN0aW9uIChzbmFwKSB7XFxuICAgICAgaWYgKCFwcmV2U25hcCAmJiBub3JtYWxpemVkVHJhbnNsYXRlID49IHNuYXApIHByZXZTbmFwID0gc25hcDtcXG4gICAgfSk7XFxuICB9XFxuXFxuICB2YXIgcHJldkluZGV4O1xcblxcbiAgaWYgKHR5cGVvZiBwcmV2U25hcCAhPT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgcHJldkluZGV4ID0gc2xpZGVzR3JpZC5pbmRleE9mKHByZXZTbmFwKTtcXG4gICAgaWYgKHByZXZJbmRleCA8IDApIHByZXZJbmRleCA9IHN3aXBlci5hY3RpdmVJbmRleCAtIDE7XFxuICB9XFxuXFxuICByZXR1cm4gc3dpcGVyLnNsaWRlVG8ocHJldkluZGV4LCBzcGVlZCwgcnVuQ2FsbGJhY2tzLCBpbnRlcm5hbCk7XFxufVxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3BhcnVzLy4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL3NsaWRlL3NsaWRlUHJldi5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL3NsaWRlL3NsaWRlUmVzZXQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS9zbGlkZS9zbGlkZVJlc2V0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcImRlZmF1bHRcXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBzbGlkZVJlc2V0KVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogXFxcIm9mZlxcXCIgKi9cXG5mdW5jdGlvbiBzbGlkZVJlc2V0KHNwZWVkLCBydW5DYWxsYmFja3MsIGludGVybmFsKSB7XFxuICBpZiAoc3BlZWQgPT09IHZvaWQgMCkge1xcbiAgICBzcGVlZCA9IHRoaXMucGFyYW1zLnNwZWVkO1xcbiAgfVxcblxcbiAgaWYgKHJ1bkNhbGxiYWNrcyA9PT0gdm9pZCAwKSB7XFxuICAgIHJ1bkNhbGxiYWNrcyA9IHRydWU7XFxuICB9XFxuXFxuICB2YXIgc3dpcGVyID0gdGhpcztcXG4gIHJldHVybiBzd2lwZXIuc2xpZGVUbyhzd2lwZXIuYWN0aXZlSW5kZXgsIHNwZWVkLCBydW5DYWxsYmFja3MsIGludGVybmFsKTtcXG59XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vcGFydXMvLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvc2xpZGUvc2xpZGVSZXNldC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL3NsaWRlL3NsaWRlVG8uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS9zbGlkZS9zbGlkZVRvLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcImRlZmF1bHRcXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBzbGlkZVRvKVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbmZ1bmN0aW9uIHNsaWRlVG8oaW5kZXgsIHNwZWVkLCBydW5DYWxsYmFja3MsIGludGVybmFsLCBpbml0aWFsKSB7XFxuICBpZiAoaW5kZXggPT09IHZvaWQgMCkge1xcbiAgICBpbmRleCA9IDA7XFxuICB9XFxuXFxuICBpZiAoc3BlZWQgPT09IHZvaWQgMCkge1xcbiAgICBzcGVlZCA9IHRoaXMucGFyYW1zLnNwZWVkO1xcbiAgfVxcblxcbiAgaWYgKHJ1bkNhbGxiYWNrcyA9PT0gdm9pZCAwKSB7XFxuICAgIHJ1bkNhbGxiYWNrcyA9IHRydWU7XFxuICB9XFxuXFxuICBpZiAodHlwZW9mIGluZGV4ICE9PSAnbnVtYmVyJyAmJiB0eXBlb2YgaW5kZXggIT09ICdzdHJpbmcnKSB7XFxuICAgIHRocm93IG5ldyBFcnJvcihcXFwiVGhlICdpbmRleCcgYXJndW1lbnQgY2Fubm90IGhhdmUgdHlwZSBvdGhlciB0aGFuICdudW1iZXInIG9yICdzdHJpbmcnLiBbXFxcIiArIHR5cGVvZiBpbmRleCArIFxcXCJdIGdpdmVuLlxcXCIpO1xcbiAgfVxcblxcbiAgaWYgKHR5cGVvZiBpbmRleCA9PT0gJ3N0cmluZycpIHtcXG4gICAgLyoqXFxuICAgICAqIFRoZSBgaW5kZXhgIGFyZ3VtZW50IGNvbnZlcnRlZCBmcm9tIGBzdHJpbmdgIHRvIGBudW1iZXJgLlxcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxcbiAgICAgKi9cXG4gICAgdmFyIGluZGV4QXNOdW1iZXIgPSBwYXJzZUludChpbmRleCwgMTApO1xcbiAgICAvKipcXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBgaW5kZXhgIGFyZ3VtZW50IGlzIGEgdmFsaWQgYG51bWJlcmBcXG4gICAgICogYWZ0ZXIgYmVpbmcgY29udmVydGVkIGZyb20gdGhlIGBzdHJpbmdgIHR5cGUuXFxuICAgICAqIEB0eXBlIHtib29sZWFufVxcbiAgICAgKi9cXG5cXG4gICAgdmFyIGlzVmFsaWROdW1iZXIgPSBpc0Zpbml0ZShpbmRleEFzTnVtYmVyKTtcXG5cXG4gICAgaWYgKCFpc1ZhbGlkTnVtYmVyKSB7XFxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXCJUaGUgcGFzc2VkLWluICdpbmRleCcgKHN0cmluZykgY291bGRuJ3QgYmUgY29udmVydGVkIHRvICdudW1iZXInLiBbXFxcIiArIGluZGV4ICsgXFxcIl0gZ2l2ZW4uXFxcIik7XFxuICAgIH0gLy8gS25vd2luZyB0aGF0IHRoZSBjb252ZXJ0ZWQgYGluZGV4YCBpcyBhIHZhbGlkIG51bWJlcixcXG4gICAgLy8gd2UgY2FuIHVwZGF0ZSB0aGUgb3JpZ2luYWwgYXJndW1lbnQncyB2YWx1ZS5cXG5cXG5cXG4gICAgaW5kZXggPSBpbmRleEFzTnVtYmVyO1xcbiAgfVxcblxcbiAgdmFyIHN3aXBlciA9IHRoaXM7XFxuICB2YXIgc2xpZGVJbmRleCA9IGluZGV4O1xcbiAgaWYgKHNsaWRlSW5kZXggPCAwKSBzbGlkZUluZGV4ID0gMDtcXG4gIHZhciBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLFxcbiAgICAgIHNuYXBHcmlkID0gc3dpcGVyLnNuYXBHcmlkLFxcbiAgICAgIHNsaWRlc0dyaWQgPSBzd2lwZXIuc2xpZGVzR3JpZCxcXG4gICAgICBwcmV2aW91c0luZGV4ID0gc3dpcGVyLnByZXZpb3VzSW5kZXgsXFxuICAgICAgYWN0aXZlSW5kZXggPSBzd2lwZXIuYWN0aXZlSW5kZXgsXFxuICAgICAgcnRsID0gc3dpcGVyLnJ0bFRyYW5zbGF0ZSxcXG4gICAgICB3cmFwcGVyRWwgPSBzd2lwZXIud3JhcHBlckVsLFxcbiAgICAgIGVuYWJsZWQgPSBzd2lwZXIuZW5hYmxlZDtcXG5cXG4gIGlmIChzd2lwZXIuYW5pbWF0aW5nICYmIHBhcmFtcy5wcmV2ZW50SW50ZXJhY3Rpb25PblRyYW5zaXRpb24gfHwgIWVuYWJsZWQgJiYgIWludGVybmFsICYmICFpbml0aWFsKSB7XFxuICAgIHJldHVybiBmYWxzZTtcXG4gIH1cXG5cXG4gIHZhciBza2lwID0gTWF0aC5taW4oc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJHcm91cFNraXAsIHNsaWRlSW5kZXgpO1xcbiAgdmFyIHNuYXBJbmRleCA9IHNraXAgKyBNYXRoLmZsb29yKChzbGlkZUluZGV4IC0gc2tpcCkgLyBzd2lwZXIucGFyYW1zLnNsaWRlc1Blckdyb3VwKTtcXG4gIGlmIChzbmFwSW5kZXggPj0gc25hcEdyaWQubGVuZ3RoKSBzbmFwSW5kZXggPSBzbmFwR3JpZC5sZW5ndGggLSAxO1xcblxcbiAgaWYgKChhY3RpdmVJbmRleCB8fCBwYXJhbXMuaW5pdGlhbFNsaWRlIHx8IDApID09PSAocHJldmlvdXNJbmRleCB8fCAwKSAmJiBydW5DYWxsYmFja3MpIHtcXG4gICAgc3dpcGVyLmVtaXQoJ2JlZm9yZVNsaWRlQ2hhbmdlU3RhcnQnKTtcXG4gIH1cXG5cXG4gIHZhciB0cmFuc2xhdGUgPSAtc25hcEdyaWRbc25hcEluZGV4XTsgLy8gVXBkYXRlIHByb2dyZXNzXFxuXFxuICBzd2lwZXIudXBkYXRlUHJvZ3Jlc3ModHJhbnNsYXRlKTsgLy8gTm9ybWFsaXplIHNsaWRlSW5kZXhcXG5cXG4gIGlmIChwYXJhbXMubm9ybWFsaXplU2xpZGVJbmRleCkge1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWRlc0dyaWQubGVuZ3RoOyBpICs9IDEpIHtcXG4gICAgICB2YXIgbm9ybWFsaXplZFRyYW5zbGF0ZSA9IC1NYXRoLmZsb29yKHRyYW5zbGF0ZSAqIDEwMCk7XFxuICAgICAgdmFyIG5vcm1hbGl6ZWRHaXJkID0gTWF0aC5mbG9vcihzbGlkZXNHcmlkW2ldICogMTAwKTtcXG4gICAgICB2YXIgbm9ybWFsaXplZEdyaWROZXh0ID0gTWF0aC5mbG9vcihzbGlkZXNHcmlkW2kgKyAxXSAqIDEwMCk7XFxuXFxuICAgICAgaWYgKHR5cGVvZiBzbGlkZXNHcmlkW2kgKyAxXSAhPT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICAgIGlmIChub3JtYWxpemVkVHJhbnNsYXRlID49IG5vcm1hbGl6ZWRHaXJkICYmIG5vcm1hbGl6ZWRUcmFuc2xhdGUgPCBub3JtYWxpemVkR3JpZE5leHQgLSAobm9ybWFsaXplZEdyaWROZXh0IC0gbm9ybWFsaXplZEdpcmQpIC8gMikge1xcbiAgICAgICAgICBzbGlkZUluZGV4ID0gaTtcXG4gICAgICAgIH0gZWxzZSBpZiAobm9ybWFsaXplZFRyYW5zbGF0ZSA+PSBub3JtYWxpemVkR2lyZCAmJiBub3JtYWxpemVkVHJhbnNsYXRlIDwgbm9ybWFsaXplZEdyaWROZXh0KSB7XFxuICAgICAgICAgIHNsaWRlSW5kZXggPSBpICsgMTtcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2UgaWYgKG5vcm1hbGl6ZWRUcmFuc2xhdGUgPj0gbm9ybWFsaXplZEdpcmQpIHtcXG4gICAgICAgIHNsaWRlSW5kZXggPSBpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfSAvLyBEaXJlY3Rpb25zIGxvY2tzXFxuXFxuXFxuICBpZiAoc3dpcGVyLmluaXRpYWxpemVkICYmIHNsaWRlSW5kZXggIT09IGFjdGl2ZUluZGV4KSB7XFxuICAgIGlmICghc3dpcGVyLmFsbG93U2xpZGVOZXh0ICYmIHRyYW5zbGF0ZSA8IHN3aXBlci50cmFuc2xhdGUgJiYgdHJhbnNsYXRlIDwgc3dpcGVyLm1pblRyYW5zbGF0ZSgpKSB7XFxuICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9XFxuXFxuICAgIGlmICghc3dpcGVyLmFsbG93U2xpZGVQcmV2ICYmIHRyYW5zbGF0ZSA+IHN3aXBlci50cmFuc2xhdGUgJiYgdHJhbnNsYXRlID4gc3dpcGVyLm1heFRyYW5zbGF0ZSgpKSB7XFxuICAgICAgaWYgKChhY3RpdmVJbmRleCB8fCAwKSAhPT0gc2xpZGVJbmRleCkgcmV0dXJuIGZhbHNlO1xcbiAgICB9XFxuICB9XFxuXFxuICB2YXIgZGlyZWN0aW9uO1xcbiAgaWYgKHNsaWRlSW5kZXggPiBhY3RpdmVJbmRleCkgZGlyZWN0aW9uID0gJ25leHQnO2Vsc2UgaWYgKHNsaWRlSW5kZXggPCBhY3RpdmVJbmRleCkgZGlyZWN0aW9uID0gJ3ByZXYnO2Vsc2UgZGlyZWN0aW9uID0gJ3Jlc2V0JzsgLy8gVXBkYXRlIEluZGV4XFxuXFxuICBpZiAocnRsICYmIC10cmFuc2xhdGUgPT09IHN3aXBlci50cmFuc2xhdGUgfHwgIXJ0bCAmJiB0cmFuc2xhdGUgPT09IHN3aXBlci50cmFuc2xhdGUpIHtcXG4gICAgc3dpcGVyLnVwZGF0ZUFjdGl2ZUluZGV4KHNsaWRlSW5kZXgpOyAvLyBVcGRhdGUgSGVpZ2h0XFxuXFxuICAgIGlmIChwYXJhbXMuYXV0b0hlaWdodCkge1xcbiAgICAgIHN3aXBlci51cGRhdGVBdXRvSGVpZ2h0KCk7XFxuICAgIH1cXG5cXG4gICAgc3dpcGVyLnVwZGF0ZVNsaWRlc0NsYXNzZXMoKTtcXG5cXG4gICAgaWYgKHBhcmFtcy5lZmZlY3QgIT09ICdzbGlkZScpIHtcXG4gICAgICBzd2lwZXIuc2V0VHJhbnNsYXRlKHRyYW5zbGF0ZSk7XFxuICAgIH1cXG5cXG4gICAgaWYgKGRpcmVjdGlvbiAhPT0gJ3Jlc2V0Jykge1xcbiAgICAgIHN3aXBlci50cmFuc2l0aW9uU3RhcnQocnVuQ2FsbGJhY2tzLCBkaXJlY3Rpb24pO1xcbiAgICAgIHN3aXBlci50cmFuc2l0aW9uRW5kKHJ1bkNhbGxiYWNrcywgZGlyZWN0aW9uKTtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gZmFsc2U7XFxuICB9XFxuXFxuICBpZiAocGFyYW1zLmNzc01vZGUpIHtcXG4gICAgdmFyIGlzSCA9IHN3aXBlci5pc0hvcml6b250YWwoKTtcXG4gICAgdmFyIHQgPSAtdHJhbnNsYXRlO1xcblxcbiAgICBpZiAocnRsKSB7XFxuICAgICAgdCA9IHdyYXBwZXJFbC5zY3JvbGxXaWR0aCAtIHdyYXBwZXJFbC5vZmZzZXRXaWR0aCAtIHQ7XFxuICAgIH1cXG5cXG4gICAgaWYgKHNwZWVkID09PSAwKSB7XFxuICAgICAgd3JhcHBlckVsW2lzSCA/ICdzY3JvbGxMZWZ0JyA6ICdzY3JvbGxUb3AnXSA9IHQ7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXFxuICAgICAgaWYgKHdyYXBwZXJFbC5zY3JvbGxUbykge1xcbiAgICAgICAgdmFyIF93cmFwcGVyRWwkc2Nyb2xsVG87XFxuXFxuICAgICAgICB3cmFwcGVyRWwuc2Nyb2xsVG8oKF93cmFwcGVyRWwkc2Nyb2xsVG8gPSB7fSwgX3dyYXBwZXJFbCRzY3JvbGxUb1tpc0ggPyAnbGVmdCcgOiAndG9wJ10gPSB0LCBfd3JhcHBlckVsJHNjcm9sbFRvLmJlaGF2aW9yID0gJ3Ntb290aCcsIF93cmFwcGVyRWwkc2Nyb2xsVG8pKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgd3JhcHBlckVsW2lzSCA/ICdzY3JvbGxMZWZ0JyA6ICdzY3JvbGxUb3AnXSA9IHQ7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHJldHVybiB0cnVlO1xcbiAgfVxcblxcbiAgaWYgKHNwZWVkID09PSAwKSB7XFxuICAgIHN3aXBlci5zZXRUcmFuc2l0aW9uKDApO1xcbiAgICBzd2lwZXIuc2V0VHJhbnNsYXRlKHRyYW5zbGF0ZSk7XFxuICAgIHN3aXBlci51cGRhdGVBY3RpdmVJbmRleChzbGlkZUluZGV4KTtcXG4gICAgc3dpcGVyLnVwZGF0ZVNsaWRlc0NsYXNzZXMoKTtcXG4gICAgc3dpcGVyLmVtaXQoJ2JlZm9yZVRyYW5zaXRpb25TdGFydCcsIHNwZWVkLCBpbnRlcm5hbCk7XFxuICAgIHN3aXBlci50cmFuc2l0aW9uU3RhcnQocnVuQ2FsbGJhY2tzLCBkaXJlY3Rpb24pO1xcbiAgICBzd2lwZXIudHJhbnNpdGlvbkVuZChydW5DYWxsYmFja3MsIGRpcmVjdGlvbik7XFxuICB9IGVsc2Uge1xcbiAgICBzd2lwZXIuc2V0VHJhbnNpdGlvbihzcGVlZCk7XFxuICAgIHN3aXBlci5zZXRUcmFuc2xhdGUodHJhbnNsYXRlKTtcXG4gICAgc3dpcGVyLnVwZGF0ZUFjdGl2ZUluZGV4KHNsaWRlSW5kZXgpO1xcbiAgICBzd2lwZXIudXBkYXRlU2xpZGVzQ2xhc3NlcygpO1xcbiAgICBzd2lwZXIuZW1pdCgnYmVmb3JlVHJhbnNpdGlvblN0YXJ0Jywgc3BlZWQsIGludGVybmFsKTtcXG4gICAgc3dpcGVyLnRyYW5zaXRpb25TdGFydChydW5DYWxsYmFja3MsIGRpcmVjdGlvbik7XFxuXFxuICAgIGlmICghc3dpcGVyLmFuaW1hdGluZykge1xcbiAgICAgIHN3aXBlci5hbmltYXRpbmcgPSB0cnVlO1xcblxcbiAgICAgIGlmICghc3dpcGVyLm9uU2xpZGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kKSB7XFxuICAgICAgICBzd2lwZXIub25TbGlkZVRvV3JhcHBlclRyYW5zaXRpb25FbmQgPSBmdW5jdGlvbiB0cmFuc2l0aW9uRW5kKGUpIHtcXG4gICAgICAgICAgaWYgKCFzd2lwZXIgfHwgc3dpcGVyLmRlc3Ryb3llZCkgcmV0dXJuO1xcbiAgICAgICAgICBpZiAoZS50YXJnZXQgIT09IHRoaXMpIHJldHVybjtcXG4gICAgICAgICAgc3dpcGVyLiR3cmFwcGVyRWxbMF0ucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHN3aXBlci5vblNsaWRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZCk7XFxuICAgICAgICAgIHN3aXBlci4kd3JhcHBlckVsWzBdLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3dlYmtpdFRyYW5zaXRpb25FbmQnLCBzd2lwZXIub25TbGlkZVRvV3JhcHBlclRyYW5zaXRpb25FbmQpO1xcbiAgICAgICAgICBzd2lwZXIub25TbGlkZVRvV3JhcHBlclRyYW5zaXRpb25FbmQgPSBudWxsO1xcbiAgICAgICAgICBkZWxldGUgc3dpcGVyLm9uU2xpZGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kO1xcbiAgICAgICAgICBzd2lwZXIudHJhbnNpdGlvbkVuZChydW5DYWxsYmFja3MsIGRpcmVjdGlvbik7XFxuICAgICAgICB9O1xcbiAgICAgIH1cXG5cXG4gICAgICBzd2lwZXIuJHdyYXBwZXJFbFswXS5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgc3dpcGVyLm9uU2xpZGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kKTtcXG4gICAgICBzd2lwZXIuJHdyYXBwZXJFbFswXS5hZGRFdmVudExpc3RlbmVyKCd3ZWJraXRUcmFuc2l0aW9uRW5kJywgc3dpcGVyLm9uU2xpZGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgcmV0dXJuIHRydWU7XFxufVxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3BhcnVzLy4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL3NsaWRlL3NsaWRlVG8uanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS9zbGlkZS9zbGlkZVRvQ2xpY2tlZFNsaWRlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvc2xpZGUvc2xpZGVUb0NsaWNrZWRTbGlkZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJkZWZhdWx0XFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gc2xpZGVUb0NsaWNrZWRTbGlkZSlcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2RvbV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vLi4vdXRpbHMvZG9tICovIFxcXCIuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL3V0aWxzL2RvbS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uLy4uL3V0aWxzL3V0aWxzICovIFxcXCIuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL3V0aWxzL3V0aWxzLmpzXFxcIik7XFxuXFxuXFxuZnVuY3Rpb24gc2xpZGVUb0NsaWNrZWRTbGlkZSgpIHtcXG4gIHZhciBzd2lwZXIgPSB0aGlzO1xcbiAgdmFyIHBhcmFtcyA9IHN3aXBlci5wYXJhbXMsXFxuICAgICAgJHdyYXBwZXJFbCA9IHN3aXBlci4kd3JhcHBlckVsO1xcbiAgdmFyIHNsaWRlc1BlclZpZXcgPSBwYXJhbXMuc2xpZGVzUGVyVmlldyA9PT0gJ2F1dG8nID8gc3dpcGVyLnNsaWRlc1BlclZpZXdEeW5hbWljKCkgOiBwYXJhbXMuc2xpZGVzUGVyVmlldztcXG4gIHZhciBzbGlkZVRvSW5kZXggPSBzd2lwZXIuY2xpY2tlZEluZGV4O1xcbiAgdmFyIHJlYWxJbmRleDtcXG5cXG4gIGlmIChwYXJhbXMubG9vcCkge1xcbiAgICBpZiAoc3dpcGVyLmFuaW1hdGluZykgcmV0dXJuO1xcbiAgICByZWFsSW5kZXggPSBwYXJzZUludCgoMCxfdXRpbHNfZG9tX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImRlZmF1bHRcXFwiXSkoc3dpcGVyLmNsaWNrZWRTbGlkZSkuYXR0cignZGF0YS1zd2lwZXItc2xpZGUtaW5kZXgnKSwgMTApO1xcblxcbiAgICBpZiAocGFyYW1zLmNlbnRlcmVkU2xpZGVzKSB7XFxuICAgICAgaWYgKHNsaWRlVG9JbmRleCA8IHN3aXBlci5sb29wZWRTbGlkZXMgLSBzbGlkZXNQZXJWaWV3IC8gMiB8fCBzbGlkZVRvSW5kZXggPiBzd2lwZXIuc2xpZGVzLmxlbmd0aCAtIHN3aXBlci5sb29wZWRTbGlkZXMgKyBzbGlkZXNQZXJWaWV3IC8gMikge1xcbiAgICAgICAgc3dpcGVyLmxvb3BGaXgoKTtcXG4gICAgICAgIHNsaWRlVG9JbmRleCA9ICR3cmFwcGVyRWwuY2hpbGRyZW4oXFxcIi5cXFwiICsgcGFyYW1zLnNsaWRlQ2xhc3MgKyBcXFwiW2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVxcXFxcXFwiXFxcIiArIHJlYWxJbmRleCArIFxcXCJcXFxcXFxcIl06bm90KC5cXFwiICsgcGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3MgKyBcXFwiKVxcXCIpLmVxKDApLmluZGV4KCk7XFxuICAgICAgICAoMCxfdXRpbHNfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5uZXh0VGljaykoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBzd2lwZXIuc2xpZGVUbyhzbGlkZVRvSW5kZXgpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHN3aXBlci5zbGlkZVRvKHNsaWRlVG9JbmRleCk7XFxuICAgICAgfVxcbiAgICB9IGVsc2UgaWYgKHNsaWRlVG9JbmRleCA+IHN3aXBlci5zbGlkZXMubGVuZ3RoIC0gc2xpZGVzUGVyVmlldykge1xcbiAgICAgIHN3aXBlci5sb29wRml4KCk7XFxuICAgICAgc2xpZGVUb0luZGV4ID0gJHdyYXBwZXJFbC5jaGlsZHJlbihcXFwiLlxcXCIgKyBwYXJhbXMuc2xpZGVDbGFzcyArIFxcXCJbZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XFxcXFxcXCJcXFwiICsgcmVhbEluZGV4ICsgXFxcIlxcXFxcXFwiXTpub3QoLlxcXCIgKyBwYXJhbXMuc2xpZGVEdXBsaWNhdGVDbGFzcyArIFxcXCIpXFxcIikuZXEoMCkuaW5kZXgoKTtcXG4gICAgICAoMCxfdXRpbHNfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5uZXh0VGljaykoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgc3dpcGVyLnNsaWRlVG8oc2xpZGVUb0luZGV4KTtcXG4gICAgICB9KTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBzd2lwZXIuc2xpZGVUbyhzbGlkZVRvSW5kZXgpO1xcbiAgICB9XFxuICB9IGVsc2Uge1xcbiAgICBzd2lwZXIuc2xpZGVUbyhzbGlkZVRvSW5kZXgpO1xcbiAgfVxcbn1cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9wYXJ1cy8uL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS9zbGlkZS9zbGlkZVRvQ2xpY2tlZFNsaWRlLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvc2xpZGUvc2xpZGVUb0Nsb3Nlc3QuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvc2xpZGUvc2xpZGVUb0Nsb3Nlc3QuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcImRlZmF1bHRcXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBzbGlkZVRvQ2xvc2VzdClcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG4vKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFxcXCJvZmZcXFwiICovXFxuZnVuY3Rpb24gc2xpZGVUb0Nsb3Nlc3Qoc3BlZWQsIHJ1bkNhbGxiYWNrcywgaW50ZXJuYWwsIHRocmVzaG9sZCkge1xcbiAgaWYgKHNwZWVkID09PSB2b2lkIDApIHtcXG4gICAgc3BlZWQgPSB0aGlzLnBhcmFtcy5zcGVlZDtcXG4gIH1cXG5cXG4gIGlmIChydW5DYWxsYmFja3MgPT09IHZvaWQgMCkge1xcbiAgICBydW5DYWxsYmFja3MgPSB0cnVlO1xcbiAgfVxcblxcbiAgaWYgKHRocmVzaG9sZCA9PT0gdm9pZCAwKSB7XFxuICAgIHRocmVzaG9sZCA9IDAuNTtcXG4gIH1cXG5cXG4gIHZhciBzd2lwZXIgPSB0aGlzO1xcbiAgdmFyIGluZGV4ID0gc3dpcGVyLmFjdGl2ZUluZGV4O1xcbiAgdmFyIHNraXAgPSBNYXRoLm1pbihzd2lwZXIucGFyYW1zLnNsaWRlc1Blckdyb3VwU2tpcCwgaW5kZXgpO1xcbiAgdmFyIHNuYXBJbmRleCA9IHNraXAgKyBNYXRoLmZsb29yKChpbmRleCAtIHNraXApIC8gc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJHcm91cCk7XFxuICB2YXIgdHJhbnNsYXRlID0gc3dpcGVyLnJ0bFRyYW5zbGF0ZSA/IHN3aXBlci50cmFuc2xhdGUgOiAtc3dpcGVyLnRyYW5zbGF0ZTtcXG5cXG4gIGlmICh0cmFuc2xhdGUgPj0gc3dpcGVyLnNuYXBHcmlkW3NuYXBJbmRleF0pIHtcXG4gICAgLy8gVGhlIGN1cnJlbnQgdHJhbnNsYXRlIGlzIG9uIG9yIGFmdGVyIHRoZSBjdXJyZW50IHNuYXAgaW5kZXgsIHNvIHRoZSBjaG9pY2VcXG4gICAgLy8gaXMgYmV0d2VlbiB0aGUgY3VycmVudCBpbmRleCBhbmQgdGhlIG9uZSBhZnRlciBpdC5cXG4gICAgdmFyIGN1cnJlbnRTbmFwID0gc3dpcGVyLnNuYXBHcmlkW3NuYXBJbmRleF07XFxuICAgIHZhciBuZXh0U25hcCA9IHN3aXBlci5zbmFwR3JpZFtzbmFwSW5kZXggKyAxXTtcXG5cXG4gICAgaWYgKHRyYW5zbGF0ZSAtIGN1cnJlbnRTbmFwID4gKG5leHRTbmFwIC0gY3VycmVudFNuYXApICogdGhyZXNob2xkKSB7XFxuICAgICAgaW5kZXggKz0gc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJHcm91cDtcXG4gICAgfVxcbiAgfSBlbHNlIHtcXG4gICAgLy8gVGhlIGN1cnJlbnQgdHJhbnNsYXRlIGlzIGJlZm9yZSB0aGUgY3VycmVudCBzbmFwIGluZGV4LCBzbyB0aGUgY2hvaWNlXFxuICAgIC8vIGlzIGJldHdlZW4gdGhlIGN1cnJlbnQgaW5kZXggYW5kIHRoZSBvbmUgYmVmb3JlIGl0LlxcbiAgICB2YXIgcHJldlNuYXAgPSBzd2lwZXIuc25hcEdyaWRbc25hcEluZGV4IC0gMV07XFxuICAgIHZhciBfY3VycmVudFNuYXAgPSBzd2lwZXIuc25hcEdyaWRbc25hcEluZGV4XTtcXG5cXG4gICAgaWYgKHRyYW5zbGF0ZSAtIHByZXZTbmFwIDw9IChfY3VycmVudFNuYXAgLSBwcmV2U25hcCkgKiB0aHJlc2hvbGQpIHtcXG4gICAgICBpbmRleCAtPSBzd2lwZXIucGFyYW1zLnNsaWRlc1Blckdyb3VwO1xcbiAgICB9XFxuICB9XFxuXFxuICBpbmRleCA9IE1hdGgubWF4KGluZGV4LCAwKTtcXG4gIGluZGV4ID0gTWF0aC5taW4oaW5kZXgsIHN3aXBlci5zbGlkZXNHcmlkLmxlbmd0aCAtIDEpO1xcbiAgcmV0dXJuIHN3aXBlci5zbGlkZVRvKGluZGV4LCBzcGVlZCwgcnVuQ2FsbGJhY2tzLCBpbnRlcm5hbCk7XFxufVxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3BhcnVzLy4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL3NsaWRlL3NsaWRlVG9DbG9zZXN0LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvc2xpZGUvc2xpZGVUb0xvb3AuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvc2xpZGUvc2xpZGVUb0xvb3AuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcImRlZmF1bHRcXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBzbGlkZVRvTG9vcClcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG5mdW5jdGlvbiBzbGlkZVRvTG9vcChpbmRleCwgc3BlZWQsIHJ1bkNhbGxiYWNrcywgaW50ZXJuYWwpIHtcXG4gIGlmIChpbmRleCA9PT0gdm9pZCAwKSB7XFxuICAgIGluZGV4ID0gMDtcXG4gIH1cXG5cXG4gIGlmIChzcGVlZCA9PT0gdm9pZCAwKSB7XFxuICAgIHNwZWVkID0gdGhpcy5wYXJhbXMuc3BlZWQ7XFxuICB9XFxuXFxuICBpZiAocnVuQ2FsbGJhY2tzID09PSB2b2lkIDApIHtcXG4gICAgcnVuQ2FsbGJhY2tzID0gdHJ1ZTtcXG4gIH1cXG5cXG4gIHZhciBzd2lwZXIgPSB0aGlzO1xcbiAgdmFyIG5ld0luZGV4ID0gaW5kZXg7XFxuXFxuICBpZiAoc3dpcGVyLnBhcmFtcy5sb29wKSB7XFxuICAgIG5ld0luZGV4ICs9IHN3aXBlci5sb29wZWRTbGlkZXM7XFxuICB9XFxuXFxuICByZXR1cm4gc3dpcGVyLnNsaWRlVG8obmV3SW5kZXgsIHNwZWVkLCBydW5DYWxsYmFja3MsIGludGVybmFsKTtcXG59XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vcGFydXMvLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvc2xpZGUvc2xpZGVUb0xvb3AuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS90cmFuc2l0aW9uL2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvdHJhbnNpdGlvbi9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJkZWZhdWx0XFxcIjogKCkgPT4gKF9fV0VCUEFDS19ERUZBVUxUX0VYUE9SVF9fKVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc2V0VHJhbnNpdGlvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zZXRUcmFuc2l0aW9uICovIFxcXCIuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS90cmFuc2l0aW9uL3NldFRyYW5zaXRpb24uanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3RyYW5zaXRpb25TdGFydF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90cmFuc2l0aW9uU3RhcnQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL3RyYW5zaXRpb24vdHJhbnNpdGlvblN0YXJ0LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90cmFuc2l0aW9uRW5kX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RyYW5zaXRpb25FbmQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL3RyYW5zaXRpb24vdHJhbnNpdGlvbkVuZC5qc1xcXCIpO1xcblxcblxcblxcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgX19XRUJQQUNLX0RFRkFVTFRfRVhQT1JUX18gPSAoe1xcbiAgc2V0VHJhbnNpdGlvbjogX3NldFRyYW5zaXRpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiZGVmYXVsdFxcXCJdLFxcbiAgdHJhbnNpdGlvblN0YXJ0OiBfdHJhbnNpdGlvblN0YXJ0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcImRlZmF1bHRcXFwiXSxcXG4gIHRyYW5zaXRpb25FbmQ6IF90cmFuc2l0aW9uRW5kX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcImRlZmF1bHRcXFwiXVxcbn0pO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3BhcnVzLy4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL3RyYW5zaXRpb24vaW5kZXguanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS90cmFuc2l0aW9uL3NldFRyYW5zaXRpb24uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL3RyYW5zaXRpb24vc2V0VHJhbnNpdGlvbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcImRlZmF1bHRcXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBzZXRUcmFuc2l0aW9uKVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbmZ1bmN0aW9uIHNldFRyYW5zaXRpb24oZHVyYXRpb24sIGJ5Q29udHJvbGxlcikge1xcbiAgdmFyIHN3aXBlciA9IHRoaXM7XFxuXFxuICBpZiAoIXN3aXBlci5wYXJhbXMuY3NzTW9kZSkge1xcbiAgICBzd2lwZXIuJHdyYXBwZXJFbC50cmFuc2l0aW9uKGR1cmF0aW9uKTtcXG4gIH1cXG5cXG4gIHN3aXBlci5lbWl0KCdzZXRUcmFuc2l0aW9uJywgZHVyYXRpb24sIGJ5Q29udHJvbGxlcik7XFxufVxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3BhcnVzLy4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL3RyYW5zaXRpb24vc2V0VHJhbnNpdGlvbi5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL3RyYW5zaXRpb24vdHJhbnNpdGlvbkVuZC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvdHJhbnNpdGlvbi90cmFuc2l0aW9uRW5kLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwiZGVmYXVsdFxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIHRyYW5zaXRpb25FbmQpXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuZnVuY3Rpb24gdHJhbnNpdGlvbkVuZChydW5DYWxsYmFja3MsIGRpcmVjdGlvbikge1xcbiAgaWYgKHJ1bkNhbGxiYWNrcyA9PT0gdm9pZCAwKSB7XFxuICAgIHJ1bkNhbGxiYWNrcyA9IHRydWU7XFxuICB9XFxuXFxuICB2YXIgc3dpcGVyID0gdGhpcztcXG4gIHZhciBhY3RpdmVJbmRleCA9IHN3aXBlci5hY3RpdmVJbmRleCxcXG4gICAgICBwcmV2aW91c0luZGV4ID0gc3dpcGVyLnByZXZpb3VzSW5kZXgsXFxuICAgICAgcGFyYW1zID0gc3dpcGVyLnBhcmFtcztcXG4gIHN3aXBlci5hbmltYXRpbmcgPSBmYWxzZTtcXG4gIGlmIChwYXJhbXMuY3NzTW9kZSkgcmV0dXJuO1xcbiAgc3dpcGVyLnNldFRyYW5zaXRpb24oMCk7XFxuICB2YXIgZGlyID0gZGlyZWN0aW9uO1xcblxcbiAgaWYgKCFkaXIpIHtcXG4gICAgaWYgKGFjdGl2ZUluZGV4ID4gcHJldmlvdXNJbmRleCkgZGlyID0gJ25leHQnO2Vsc2UgaWYgKGFjdGl2ZUluZGV4IDwgcHJldmlvdXNJbmRleCkgZGlyID0gJ3ByZXYnO2Vsc2UgZGlyID0gJ3Jlc2V0JztcXG4gIH1cXG5cXG4gIHN3aXBlci5lbWl0KCd0cmFuc2l0aW9uRW5kJyk7XFxuXFxuICBpZiAocnVuQ2FsbGJhY2tzICYmIGFjdGl2ZUluZGV4ICE9PSBwcmV2aW91c0luZGV4KSB7XFxuICAgIGlmIChkaXIgPT09ICdyZXNldCcpIHtcXG4gICAgICBzd2lwZXIuZW1pdCgnc2xpZGVSZXNldFRyYW5zaXRpb25FbmQnKTtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgc3dpcGVyLmVtaXQoJ3NsaWRlQ2hhbmdlVHJhbnNpdGlvbkVuZCcpO1xcblxcbiAgICBpZiAoZGlyID09PSAnbmV4dCcpIHtcXG4gICAgICBzd2lwZXIuZW1pdCgnc2xpZGVOZXh0VHJhbnNpdGlvbkVuZCcpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHN3aXBlci5lbWl0KCdzbGlkZVByZXZUcmFuc2l0aW9uRW5kJyk7XFxuICAgIH1cXG4gIH1cXG59XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vcGFydXMvLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvdHJhbnNpdGlvbi90cmFuc2l0aW9uRW5kLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvdHJhbnNpdGlvbi90cmFuc2l0aW9uU3RhcnQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvdHJhbnNpdGlvbi90cmFuc2l0aW9uU3RhcnQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcImRlZmF1bHRcXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyB0cmFuc2l0aW9uU3RhcnQpXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuZnVuY3Rpb24gdHJhbnNpdGlvblN0YXJ0KHJ1bkNhbGxiYWNrcywgZGlyZWN0aW9uKSB7XFxuICBpZiAocnVuQ2FsbGJhY2tzID09PSB2b2lkIDApIHtcXG4gICAgcnVuQ2FsbGJhY2tzID0gdHJ1ZTtcXG4gIH1cXG5cXG4gIHZhciBzd2lwZXIgPSB0aGlzO1xcbiAgdmFyIGFjdGl2ZUluZGV4ID0gc3dpcGVyLmFjdGl2ZUluZGV4LFxcbiAgICAgIHBhcmFtcyA9IHN3aXBlci5wYXJhbXMsXFxuICAgICAgcHJldmlvdXNJbmRleCA9IHN3aXBlci5wcmV2aW91c0luZGV4O1xcbiAgaWYgKHBhcmFtcy5jc3NNb2RlKSByZXR1cm47XFxuXFxuICBpZiAocGFyYW1zLmF1dG9IZWlnaHQpIHtcXG4gICAgc3dpcGVyLnVwZGF0ZUF1dG9IZWlnaHQoKTtcXG4gIH1cXG5cXG4gIHZhciBkaXIgPSBkaXJlY3Rpb247XFxuXFxuICBpZiAoIWRpcikge1xcbiAgICBpZiAoYWN0aXZlSW5kZXggPiBwcmV2aW91c0luZGV4KSBkaXIgPSAnbmV4dCc7ZWxzZSBpZiAoYWN0aXZlSW5kZXggPCBwcmV2aW91c0luZGV4KSBkaXIgPSAncHJldic7ZWxzZSBkaXIgPSAncmVzZXQnO1xcbiAgfVxcblxcbiAgc3dpcGVyLmVtaXQoJ3RyYW5zaXRpb25TdGFydCcpO1xcblxcbiAgaWYgKHJ1bkNhbGxiYWNrcyAmJiBhY3RpdmVJbmRleCAhPT0gcHJldmlvdXNJbmRleCkge1xcbiAgICBpZiAoZGlyID09PSAncmVzZXQnKSB7XFxuICAgICAgc3dpcGVyLmVtaXQoJ3NsaWRlUmVzZXRUcmFuc2l0aW9uU3RhcnQnKTtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgc3dpcGVyLmVtaXQoJ3NsaWRlQ2hhbmdlVHJhbnNpdGlvblN0YXJ0Jyk7XFxuXFxuICAgIGlmIChkaXIgPT09ICduZXh0Jykge1xcbiAgICAgIHN3aXBlci5lbWl0KCdzbGlkZU5leHRUcmFuc2l0aW9uU3RhcnQnKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBzd2lwZXIuZW1pdCgnc2xpZGVQcmV2VHJhbnNpdGlvblN0YXJ0Jyk7XFxuICAgIH1cXG4gIH1cXG59XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vcGFydXMvLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvdHJhbnNpdGlvbi90cmFuc2l0aW9uU3RhcnQuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS90cmFuc2xhdGUvZ2V0VHJhbnNsYXRlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvdHJhbnNsYXRlL2dldFRyYW5zbGF0ZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJkZWZhdWx0XFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gZ2V0U3dpcGVyVHJhbnNsYXRlKVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uLy4uL3V0aWxzL3V0aWxzICovIFxcXCIuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL3V0aWxzL3V0aWxzLmpzXFxcIik7XFxuXFxuZnVuY3Rpb24gZ2V0U3dpcGVyVHJhbnNsYXRlKGF4aXMpIHtcXG4gIGlmIChheGlzID09PSB2b2lkIDApIHtcXG4gICAgYXhpcyA9IHRoaXMuaXNIb3Jpem9udGFsKCkgPyAneCcgOiAneSc7XFxuICB9XFxuXFxuICB2YXIgc3dpcGVyID0gdGhpcztcXG4gIHZhciBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLFxcbiAgICAgIHJ0bCA9IHN3aXBlci5ydGxUcmFuc2xhdGUsXFxuICAgICAgdHJhbnNsYXRlID0gc3dpcGVyLnRyYW5zbGF0ZSxcXG4gICAgICAkd3JhcHBlckVsID0gc3dpcGVyLiR3cmFwcGVyRWw7XFxuXFxuICBpZiAocGFyYW1zLnZpcnR1YWxUcmFuc2xhdGUpIHtcXG4gICAgcmV0dXJuIHJ0bCA/IC10cmFuc2xhdGUgOiB0cmFuc2xhdGU7XFxuICB9XFxuXFxuICBpZiAocGFyYW1zLmNzc01vZGUpIHtcXG4gICAgcmV0dXJuIHRyYW5zbGF0ZTtcXG4gIH1cXG5cXG4gIHZhciBjdXJyZW50VHJhbnNsYXRlID0gKDAsX3V0aWxzX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uZ2V0VHJhbnNsYXRlKSgkd3JhcHBlckVsWzBdLCBheGlzKTtcXG4gIGlmIChydGwpIGN1cnJlbnRUcmFuc2xhdGUgPSAtY3VycmVudFRyYW5zbGF0ZTtcXG4gIHJldHVybiBjdXJyZW50VHJhbnNsYXRlIHx8IDA7XFxufVxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3BhcnVzLy4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL3RyYW5zbGF0ZS9nZXRUcmFuc2xhdGUuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS90cmFuc2xhdGUvaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL3RyYW5zbGF0ZS9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcImRlZmF1bHRcXFwiOiAoKSA9PiAoX19XRUJQQUNLX0RFRkFVTFRfRVhQT1JUX18pXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9nZXRUcmFuc2xhdGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ2V0VHJhbnNsYXRlICovIFxcXCIuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS90cmFuc2xhdGUvZ2V0VHJhbnNsYXRlLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zZXRUcmFuc2xhdGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc2V0VHJhbnNsYXRlICovIFxcXCIuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS90cmFuc2xhdGUvc2V0VHJhbnNsYXRlLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taW5UcmFuc2xhdGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbWluVHJhbnNsYXRlICovIFxcXCIuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS90cmFuc2xhdGUvbWluVHJhbnNsYXRlLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9tYXhUcmFuc2xhdGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbWF4VHJhbnNsYXRlICovIFxcXCIuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS90cmFuc2xhdGUvbWF4VHJhbnNsYXRlLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90cmFuc2xhdGVUb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90cmFuc2xhdGVUbyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvdHJhbnNsYXRlL3RyYW5zbGF0ZVRvLmpzXFxcIik7XFxuXFxuXFxuXFxuXFxuXFxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBfX1dFQlBBQ0tfREVGQVVMVF9FWFBPUlRfXyA9ICh7XFxuICBnZXRUcmFuc2xhdGU6IF9nZXRUcmFuc2xhdGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiZGVmYXVsdFxcXCJdLFxcbiAgc2V0VHJhbnNsYXRlOiBfc2V0VHJhbnNsYXRlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcImRlZmF1bHRcXFwiXSxcXG4gIG1pblRyYW5zbGF0ZTogX21pblRyYW5zbGF0ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJkZWZhdWx0XFxcIl0sXFxuICBtYXhUcmFuc2xhdGU6IF9tYXhUcmFuc2xhdGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcXFwiZGVmYXVsdFxcXCJdLFxcbiAgdHJhbnNsYXRlVG86IF90cmFuc2xhdGVUb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1xcXCJkZWZhdWx0XFxcIl1cXG59KTtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9wYXJ1cy8uL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS90cmFuc2xhdGUvaW5kZXguanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS90cmFuc2xhdGUvbWF4VHJhbnNsYXRlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvdHJhbnNsYXRlL21heFRyYW5zbGF0ZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJkZWZhdWx0XFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gbWF4VHJhbnNsYXRlKVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbmZ1bmN0aW9uIG1heFRyYW5zbGF0ZSgpIHtcXG4gIHJldHVybiAtdGhpcy5zbmFwR3JpZFt0aGlzLnNuYXBHcmlkLmxlbmd0aCAtIDFdO1xcbn1cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9wYXJ1cy8uL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS90cmFuc2xhdGUvbWF4VHJhbnNsYXRlLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvdHJhbnNsYXRlL21pblRyYW5zbGF0ZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL3RyYW5zbGF0ZS9taW5UcmFuc2xhdGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwiZGVmYXVsdFxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIG1pblRyYW5zbGF0ZSlcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG5mdW5jdGlvbiBtaW5UcmFuc2xhdGUoKSB7XFxuICByZXR1cm4gLXRoaXMuc25hcEdyaWRbMF07XFxufVxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3BhcnVzLy4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL3RyYW5zbGF0ZS9taW5UcmFuc2xhdGUuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS90cmFuc2xhdGUvc2V0VHJhbnNsYXRlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvdHJhbnNsYXRlL3NldFRyYW5zbGF0ZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJkZWZhdWx0XFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gc2V0VHJhbnNsYXRlKVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbmZ1bmN0aW9uIHNldFRyYW5zbGF0ZSh0cmFuc2xhdGUsIGJ5Q29udHJvbGxlcikge1xcbiAgdmFyIHN3aXBlciA9IHRoaXM7XFxuICB2YXIgcnRsID0gc3dpcGVyLnJ0bFRyYW5zbGF0ZSxcXG4gICAgICBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLFxcbiAgICAgICR3cmFwcGVyRWwgPSBzd2lwZXIuJHdyYXBwZXJFbCxcXG4gICAgICB3cmFwcGVyRWwgPSBzd2lwZXIud3JhcHBlckVsLFxcbiAgICAgIHByb2dyZXNzID0gc3dpcGVyLnByb2dyZXNzO1xcbiAgdmFyIHggPSAwO1xcbiAgdmFyIHkgPSAwO1xcbiAgdmFyIHogPSAwO1xcblxcbiAgaWYgKHN3aXBlci5pc0hvcml6b250YWwoKSkge1xcbiAgICB4ID0gcnRsID8gLXRyYW5zbGF0ZSA6IHRyYW5zbGF0ZTtcXG4gIH0gZWxzZSB7XFxuICAgIHkgPSB0cmFuc2xhdGU7XFxuICB9XFxuXFxuICBpZiAocGFyYW1zLnJvdW5kTGVuZ3Rocykge1xcbiAgICB4ID0gTWF0aC5mbG9vcih4KTtcXG4gICAgeSA9IE1hdGguZmxvb3IoeSk7XFxuICB9XFxuXFxuICBpZiAocGFyYW1zLmNzc01vZGUpIHtcXG4gICAgd3JhcHBlckVsW3N3aXBlci5pc0hvcml6b250YWwoKSA/ICdzY3JvbGxMZWZ0JyA6ICdzY3JvbGxUb3AnXSA9IHN3aXBlci5pc0hvcml6b250YWwoKSA/IC14IDogLXk7XFxuICB9IGVsc2UgaWYgKCFwYXJhbXMudmlydHVhbFRyYW5zbGF0ZSkge1xcbiAgICAkd3JhcHBlckVsLnRyYW5zZm9ybShcXFwidHJhbnNsYXRlM2QoXFxcIiArIHggKyBcXFwicHgsIFxcXCIgKyB5ICsgXFxcInB4LCBcXFwiICsgeiArIFxcXCJweClcXFwiKTtcXG4gIH1cXG5cXG4gIHN3aXBlci5wcmV2aW91c1RyYW5zbGF0ZSA9IHN3aXBlci50cmFuc2xhdGU7XFxuICBzd2lwZXIudHJhbnNsYXRlID0gc3dpcGVyLmlzSG9yaXpvbnRhbCgpID8geCA6IHk7IC8vIENoZWNrIGlmIHdlIG5lZWQgdG8gdXBkYXRlIHByb2dyZXNzXFxuXFxuICB2YXIgbmV3UHJvZ3Jlc3M7XFxuICB2YXIgdHJhbnNsYXRlc0RpZmYgPSBzd2lwZXIubWF4VHJhbnNsYXRlKCkgLSBzd2lwZXIubWluVHJhbnNsYXRlKCk7XFxuXFxuICBpZiAodHJhbnNsYXRlc0RpZmYgPT09IDApIHtcXG4gICAgbmV3UHJvZ3Jlc3MgPSAwO1xcbiAgfSBlbHNlIHtcXG4gICAgbmV3UHJvZ3Jlc3MgPSAodHJhbnNsYXRlIC0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpKSAvIHRyYW5zbGF0ZXNEaWZmO1xcbiAgfVxcblxcbiAgaWYgKG5ld1Byb2dyZXNzICE9PSBwcm9ncmVzcykge1xcbiAgICBzd2lwZXIudXBkYXRlUHJvZ3Jlc3ModHJhbnNsYXRlKTtcXG4gIH1cXG5cXG4gIHN3aXBlci5lbWl0KCdzZXRUcmFuc2xhdGUnLCBzd2lwZXIudHJhbnNsYXRlLCBieUNvbnRyb2xsZXIpO1xcbn1cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9wYXJ1cy8uL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS90cmFuc2xhdGUvc2V0VHJhbnNsYXRlLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvdHJhbnNsYXRlL3RyYW5zbGF0ZVRvLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS90cmFuc2xhdGUvdHJhbnNsYXRlVG8uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJkZWZhdWx0XFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gdHJhbnNsYXRlVG8pXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuZnVuY3Rpb24gdHJhbnNsYXRlVG8odHJhbnNsYXRlLCBzcGVlZCwgcnVuQ2FsbGJhY2tzLCB0cmFuc2xhdGVCb3VuZHMsIGludGVybmFsKSB7XFxuICBpZiAodHJhbnNsYXRlID09PSB2b2lkIDApIHtcXG4gICAgdHJhbnNsYXRlID0gMDtcXG4gIH1cXG5cXG4gIGlmIChzcGVlZCA9PT0gdm9pZCAwKSB7XFxuICAgIHNwZWVkID0gdGhpcy5wYXJhbXMuc3BlZWQ7XFxuICB9XFxuXFxuICBpZiAocnVuQ2FsbGJhY2tzID09PSB2b2lkIDApIHtcXG4gICAgcnVuQ2FsbGJhY2tzID0gdHJ1ZTtcXG4gIH1cXG5cXG4gIGlmICh0cmFuc2xhdGVCb3VuZHMgPT09IHZvaWQgMCkge1xcbiAgICB0cmFuc2xhdGVCb3VuZHMgPSB0cnVlO1xcbiAgfVxcblxcbiAgdmFyIHN3aXBlciA9IHRoaXM7XFxuICB2YXIgcGFyYW1zID0gc3dpcGVyLnBhcmFtcyxcXG4gICAgICB3cmFwcGVyRWwgPSBzd2lwZXIud3JhcHBlckVsO1xcblxcbiAgaWYgKHN3aXBlci5hbmltYXRpbmcgJiYgcGFyYW1zLnByZXZlbnRJbnRlcmFjdGlvbk9uVHJhbnNpdGlvbikge1xcbiAgICByZXR1cm4gZmFsc2U7XFxuICB9XFxuXFxuICB2YXIgbWluVHJhbnNsYXRlID0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpO1xcbiAgdmFyIG1heFRyYW5zbGF0ZSA9IHN3aXBlci5tYXhUcmFuc2xhdGUoKTtcXG4gIHZhciBuZXdUcmFuc2xhdGU7XFxuICBpZiAodHJhbnNsYXRlQm91bmRzICYmIHRyYW5zbGF0ZSA+IG1pblRyYW5zbGF0ZSkgbmV3VHJhbnNsYXRlID0gbWluVHJhbnNsYXRlO2Vsc2UgaWYgKHRyYW5zbGF0ZUJvdW5kcyAmJiB0cmFuc2xhdGUgPCBtYXhUcmFuc2xhdGUpIG5ld1RyYW5zbGF0ZSA9IG1heFRyYW5zbGF0ZTtlbHNlIG5ld1RyYW5zbGF0ZSA9IHRyYW5zbGF0ZTsgLy8gVXBkYXRlIHByb2dyZXNzXFxuXFxuICBzd2lwZXIudXBkYXRlUHJvZ3Jlc3MobmV3VHJhbnNsYXRlKTtcXG5cXG4gIGlmIChwYXJhbXMuY3NzTW9kZSkge1xcbiAgICB2YXIgaXNIID0gc3dpcGVyLmlzSG9yaXpvbnRhbCgpO1xcblxcbiAgICBpZiAoc3BlZWQgPT09IDApIHtcXG4gICAgICB3cmFwcGVyRWxbaXNIID8gJ3Njcm9sbExlZnQnIDogJ3Njcm9sbFRvcCddID0gLW5ld1RyYW5zbGF0ZTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcXG4gICAgICBpZiAod3JhcHBlckVsLnNjcm9sbFRvKSB7XFxuICAgICAgICB2YXIgX3dyYXBwZXJFbCRzY3JvbGxUbztcXG5cXG4gICAgICAgIHdyYXBwZXJFbC5zY3JvbGxUbygoX3dyYXBwZXJFbCRzY3JvbGxUbyA9IHt9LCBfd3JhcHBlckVsJHNjcm9sbFRvW2lzSCA/ICdsZWZ0JyA6ICd0b3AnXSA9IC1uZXdUcmFuc2xhdGUsIF93cmFwcGVyRWwkc2Nyb2xsVG8uYmVoYXZpb3IgPSAnc21vb3RoJywgX3dyYXBwZXJFbCRzY3JvbGxUbykpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB3cmFwcGVyRWxbaXNIID8gJ3Njcm9sbExlZnQnIDogJ3Njcm9sbFRvcCddID0gLW5ld1RyYW5zbGF0ZTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIHRydWU7XFxuICB9XFxuXFxuICBpZiAoc3BlZWQgPT09IDApIHtcXG4gICAgc3dpcGVyLnNldFRyYW5zaXRpb24oMCk7XFxuICAgIHN3aXBlci5zZXRUcmFuc2xhdGUobmV3VHJhbnNsYXRlKTtcXG5cXG4gICAgaWYgKHJ1bkNhbGxiYWNrcykge1xcbiAgICAgIHN3aXBlci5lbWl0KCdiZWZvcmVUcmFuc2l0aW9uU3RhcnQnLCBzcGVlZCwgaW50ZXJuYWwpO1xcbiAgICAgIHN3aXBlci5lbWl0KCd0cmFuc2l0aW9uRW5kJyk7XFxuICAgIH1cXG4gIH0gZWxzZSB7XFxuICAgIHN3aXBlci5zZXRUcmFuc2l0aW9uKHNwZWVkKTtcXG4gICAgc3dpcGVyLnNldFRyYW5zbGF0ZShuZXdUcmFuc2xhdGUpO1xcblxcbiAgICBpZiAocnVuQ2FsbGJhY2tzKSB7XFxuICAgICAgc3dpcGVyLmVtaXQoJ2JlZm9yZVRyYW5zaXRpb25TdGFydCcsIHNwZWVkLCBpbnRlcm5hbCk7XFxuICAgICAgc3dpcGVyLmVtaXQoJ3RyYW5zaXRpb25TdGFydCcpO1xcbiAgICB9XFxuXFxuICAgIGlmICghc3dpcGVyLmFuaW1hdGluZykge1xcbiAgICAgIHN3aXBlci5hbmltYXRpbmcgPSB0cnVlO1xcblxcbiAgICAgIGlmICghc3dpcGVyLm9uVHJhbnNsYXRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZCkge1xcbiAgICAgICAgc3dpcGVyLm9uVHJhbnNsYXRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZCA9IGZ1bmN0aW9uIHRyYW5zaXRpb25FbmQoZSkge1xcbiAgICAgICAgICBpZiAoIXN3aXBlciB8fCBzd2lwZXIuZGVzdHJveWVkKSByZXR1cm47XFxuICAgICAgICAgIGlmIChlLnRhcmdldCAhPT0gdGhpcykgcmV0dXJuO1xcbiAgICAgICAgICBzd2lwZXIuJHdyYXBwZXJFbFswXS5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgc3dpcGVyLm9uVHJhbnNsYXRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZCk7XFxuICAgICAgICAgIHN3aXBlci4kd3JhcHBlckVsWzBdLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3dlYmtpdFRyYW5zaXRpb25FbmQnLCBzd2lwZXIub25UcmFuc2xhdGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kKTtcXG4gICAgICAgICAgc3dpcGVyLm9uVHJhbnNsYXRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZCA9IG51bGw7XFxuICAgICAgICAgIGRlbGV0ZSBzd2lwZXIub25UcmFuc2xhdGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kO1xcblxcbiAgICAgICAgICBpZiAocnVuQ2FsbGJhY2tzKSB7XFxuICAgICAgICAgICAgc3dpcGVyLmVtaXQoJ3RyYW5zaXRpb25FbmQnKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfTtcXG4gICAgICB9XFxuXFxuICAgICAgc3dpcGVyLiR3cmFwcGVyRWxbMF0uYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHN3aXBlci5vblRyYW5zbGF0ZVRvV3JhcHBlclRyYW5zaXRpb25FbmQpO1xcbiAgICAgIHN3aXBlci4kd3JhcHBlckVsWzBdLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmtpdFRyYW5zaXRpb25FbmQnLCBzd2lwZXIub25UcmFuc2xhdGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgcmV0dXJuIHRydWU7XFxufVxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3BhcnVzLy4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL3RyYW5zbGF0ZS90cmFuc2xhdGVUby5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL3VwZGF0ZS9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvdXBkYXRlL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwiZGVmYXVsdFxcXCI6ICgpID0+IChfX1dFQlBBQ0tfREVGQVVMVF9FWFBPUlRfXylcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3VwZGF0ZVNpemVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXBkYXRlU2l6ZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvdXBkYXRlL3VwZGF0ZVNpemUuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3VwZGF0ZVNsaWRlc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91cGRhdGVTbGlkZXMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL3VwZGF0ZS91cGRhdGVTbGlkZXMuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3VwZGF0ZUF1dG9IZWlnaHRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXBkYXRlQXV0b0hlaWdodCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvdXBkYXRlL3VwZGF0ZUF1dG9IZWlnaHQuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3VwZGF0ZVNsaWRlc09mZnNldF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91cGRhdGVTbGlkZXNPZmZzZXQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL3VwZGF0ZS91cGRhdGVTbGlkZXNPZmZzZXQuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3VwZGF0ZVNsaWRlc1Byb2dyZXNzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3VwZGF0ZVNsaWRlc1Byb2dyZXNzICovIFxcXCIuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS91cGRhdGUvdXBkYXRlU2xpZGVzUHJvZ3Jlc3MuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3VwZGF0ZVByb2dyZXNzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3VwZGF0ZVByb2dyZXNzICovIFxcXCIuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS91cGRhdGUvdXBkYXRlUHJvZ3Jlc3MuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3VwZGF0ZVNsaWRlc0NsYXNzZXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXBkYXRlU2xpZGVzQ2xhc3NlcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvdXBkYXRlL3VwZGF0ZVNsaWRlc0NsYXNzZXMuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3VwZGF0ZUFjdGl2ZUluZGV4X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3VwZGF0ZUFjdGl2ZUluZGV4ICovIFxcXCIuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS91cGRhdGUvdXBkYXRlQWN0aXZlSW5kZXguanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3VwZGF0ZUNsaWNrZWRTbGlkZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91cGRhdGVDbGlja2VkU2xpZGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL3VwZGF0ZS91cGRhdGVDbGlja2VkU2xpZGUuanNcXFwiKTtcXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IF9fV0VCUEFDS19ERUZBVUxUX0VYUE9SVF9fID0gKHtcXG4gIHVwZGF0ZVNpemU6IF91cGRhdGVTaXplX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImRlZmF1bHRcXFwiXSxcXG4gIHVwZGF0ZVNsaWRlczogX3VwZGF0ZVNsaWRlc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJkZWZhdWx0XFxcIl0sXFxuICB1cGRhdGVBdXRvSGVpZ2h0OiBfdXBkYXRlQXV0b0hlaWdodF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJkZWZhdWx0XFxcIl0sXFxuICB1cGRhdGVTbGlkZXNPZmZzZXQ6IF91cGRhdGVTbGlkZXNPZmZzZXRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcXFwiZGVmYXVsdFxcXCJdLFxcbiAgdXBkYXRlU2xpZGVzUHJvZ3Jlc3M6IF91cGRhdGVTbGlkZXNQcm9ncmVzc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1xcXCJkZWZhdWx0XFxcIl0sXFxuICB1cGRhdGVQcm9ncmVzczogX3VwZGF0ZVByb2dyZXNzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXFxcImRlZmF1bHRcXFwiXSxcXG4gIHVwZGF0ZVNsaWRlc0NsYXNzZXM6IF91cGRhdGVTbGlkZXNDbGFzc2VzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXFxcImRlZmF1bHRcXFwiXSxcXG4gIHVwZGF0ZUFjdGl2ZUluZGV4OiBfdXBkYXRlQWN0aXZlSW5kZXhfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcXFwiZGVmYXVsdFxcXCJdLFxcbiAgdXBkYXRlQ2xpY2tlZFNsaWRlOiBfdXBkYXRlQ2xpY2tlZFNsaWRlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X19bXFxcImRlZmF1bHRcXFwiXVxcbn0pO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3BhcnVzLy4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL3VwZGF0ZS9pbmRleC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL3VwZGF0ZS91cGRhdGVBY3RpdmVJbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvdXBkYXRlL3VwZGF0ZUFjdGl2ZUluZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwiZGVmYXVsdFxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIHVwZGF0ZUFjdGl2ZUluZGV4KVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uLy4uL3V0aWxzL3V0aWxzICovIFxcXCIuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL3V0aWxzL3V0aWxzLmpzXFxcIik7XFxuXFxuZnVuY3Rpb24gdXBkYXRlQWN0aXZlSW5kZXgobmV3QWN0aXZlSW5kZXgpIHtcXG4gIHZhciBzd2lwZXIgPSB0aGlzO1xcbiAgdmFyIHRyYW5zbGF0ZSA9IHN3aXBlci5ydGxUcmFuc2xhdGUgPyBzd2lwZXIudHJhbnNsYXRlIDogLXN3aXBlci50cmFuc2xhdGU7XFxuICB2YXIgc2xpZGVzR3JpZCA9IHN3aXBlci5zbGlkZXNHcmlkLFxcbiAgICAgIHNuYXBHcmlkID0gc3dpcGVyLnNuYXBHcmlkLFxcbiAgICAgIHBhcmFtcyA9IHN3aXBlci5wYXJhbXMsXFxuICAgICAgcHJldmlvdXNJbmRleCA9IHN3aXBlci5hY3RpdmVJbmRleCxcXG4gICAgICBwcmV2aW91c1JlYWxJbmRleCA9IHN3aXBlci5yZWFsSW5kZXgsXFxuICAgICAgcHJldmlvdXNTbmFwSW5kZXggPSBzd2lwZXIuc25hcEluZGV4O1xcbiAgdmFyIGFjdGl2ZUluZGV4ID0gbmV3QWN0aXZlSW5kZXg7XFxuICB2YXIgc25hcEluZGV4O1xcblxcbiAgaWYgKHR5cGVvZiBhY3RpdmVJbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGlkZXNHcmlkLmxlbmd0aDsgaSArPSAxKSB7XFxuICAgICAgaWYgKHR5cGVvZiBzbGlkZXNHcmlkW2kgKyAxXSAhPT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICAgIGlmICh0cmFuc2xhdGUgPj0gc2xpZGVzR3JpZFtpXSAmJiB0cmFuc2xhdGUgPCBzbGlkZXNHcmlkW2kgKyAxXSAtIChzbGlkZXNHcmlkW2kgKyAxXSAtIHNsaWRlc0dyaWRbaV0pIC8gMikge1xcbiAgICAgICAgICBhY3RpdmVJbmRleCA9IGk7XFxuICAgICAgICB9IGVsc2UgaWYgKHRyYW5zbGF0ZSA+PSBzbGlkZXNHcmlkW2ldICYmIHRyYW5zbGF0ZSA8IHNsaWRlc0dyaWRbaSArIDFdKSB7XFxuICAgICAgICAgIGFjdGl2ZUluZGV4ID0gaSArIDE7XFxuICAgICAgICB9XFxuICAgICAgfSBlbHNlIGlmICh0cmFuc2xhdGUgPj0gc2xpZGVzR3JpZFtpXSkge1xcbiAgICAgICAgYWN0aXZlSW5kZXggPSBpO1xcbiAgICAgIH1cXG4gICAgfSAvLyBOb3JtYWxpemUgc2xpZGVJbmRleFxcblxcblxcbiAgICBpZiAocGFyYW1zLm5vcm1hbGl6ZVNsaWRlSW5kZXgpIHtcXG4gICAgICBpZiAoYWN0aXZlSW5kZXggPCAwIHx8IHR5cGVvZiBhY3RpdmVJbmRleCA9PT0gJ3VuZGVmaW5lZCcpIGFjdGl2ZUluZGV4ID0gMDtcXG4gICAgfVxcbiAgfVxcblxcbiAgaWYgKHNuYXBHcmlkLmluZGV4T2YodHJhbnNsYXRlKSA+PSAwKSB7XFxuICAgIHNuYXBJbmRleCA9IHNuYXBHcmlkLmluZGV4T2YodHJhbnNsYXRlKTtcXG4gIH0gZWxzZSB7XFxuICAgIHZhciBza2lwID0gTWF0aC5taW4ocGFyYW1zLnNsaWRlc1Blckdyb3VwU2tpcCwgYWN0aXZlSW5kZXgpO1xcbiAgICBzbmFwSW5kZXggPSBza2lwICsgTWF0aC5mbG9vcigoYWN0aXZlSW5kZXggLSBza2lwKSAvIHBhcmFtcy5zbGlkZXNQZXJHcm91cCk7XFxuICB9XFxuXFxuICBpZiAoc25hcEluZGV4ID49IHNuYXBHcmlkLmxlbmd0aCkgc25hcEluZGV4ID0gc25hcEdyaWQubGVuZ3RoIC0gMTtcXG5cXG4gIGlmIChhY3RpdmVJbmRleCA9PT0gcHJldmlvdXNJbmRleCkge1xcbiAgICBpZiAoc25hcEluZGV4ICE9PSBwcmV2aW91c1NuYXBJbmRleCkge1xcbiAgICAgIHN3aXBlci5zbmFwSW5kZXggPSBzbmFwSW5kZXg7XFxuICAgICAgc3dpcGVyLmVtaXQoJ3NuYXBJbmRleENoYW5nZScpO1xcbiAgICB9XFxuXFxuICAgIHJldHVybjtcXG4gIH0gLy8gR2V0IHJlYWwgaW5kZXhcXG5cXG5cXG4gIHZhciByZWFsSW5kZXggPSBwYXJzZUludChzd2lwZXIuc2xpZGVzLmVxKGFjdGl2ZUluZGV4KS5hdHRyKCdkYXRhLXN3aXBlci1zbGlkZS1pbmRleCcpIHx8IGFjdGl2ZUluZGV4LCAxMCk7XFxuICAoMCxfdXRpbHNfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5leHRlbmQpKHN3aXBlciwge1xcbiAgICBzbmFwSW5kZXg6IHNuYXBJbmRleCxcXG4gICAgcmVhbEluZGV4OiByZWFsSW5kZXgsXFxuICAgIHByZXZpb3VzSW5kZXg6IHByZXZpb3VzSW5kZXgsXFxuICAgIGFjdGl2ZUluZGV4OiBhY3RpdmVJbmRleFxcbiAgfSk7XFxuICBzd2lwZXIuZW1pdCgnYWN0aXZlSW5kZXhDaGFuZ2UnKTtcXG4gIHN3aXBlci5lbWl0KCdzbmFwSW5kZXhDaGFuZ2UnKTtcXG5cXG4gIGlmIChwcmV2aW91c1JlYWxJbmRleCAhPT0gcmVhbEluZGV4KSB7XFxuICAgIHN3aXBlci5lbWl0KCdyZWFsSW5kZXhDaGFuZ2UnKTtcXG4gIH1cXG5cXG4gIGlmIChzd2lwZXIuaW5pdGlhbGl6ZWQgfHwgc3dpcGVyLnBhcmFtcy5ydW5DYWxsYmFja3NPbkluaXQpIHtcXG4gICAgc3dpcGVyLmVtaXQoJ3NsaWRlQ2hhbmdlJyk7XFxuICB9XFxufVxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3BhcnVzLy4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL3VwZGF0ZS91cGRhdGVBY3RpdmVJbmRleC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL3VwZGF0ZS91cGRhdGVBdXRvSGVpZ2h0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL3VwZGF0ZS91cGRhdGVBdXRvSGVpZ2h0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJkZWZhdWx0XFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gdXBkYXRlQXV0b0hlaWdodClcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG5mdW5jdGlvbiB1cGRhdGVBdXRvSGVpZ2h0KHNwZWVkKSB7XFxuICB2YXIgc3dpcGVyID0gdGhpcztcXG4gIHZhciBhY3RpdmVTbGlkZXMgPSBbXTtcXG4gIHZhciBpc1ZpcnR1YWwgPSBzd2lwZXIudmlydHVhbCAmJiBzd2lwZXIucGFyYW1zLnZpcnR1YWwuZW5hYmxlZDtcXG4gIHZhciBuZXdIZWlnaHQgPSAwO1xcbiAgdmFyIGk7XFxuXFxuICBpZiAodHlwZW9mIHNwZWVkID09PSAnbnVtYmVyJykge1xcbiAgICBzd2lwZXIuc2V0VHJhbnNpdGlvbihzcGVlZCk7XFxuICB9IGVsc2UgaWYgKHNwZWVkID09PSB0cnVlKSB7XFxuICAgIHN3aXBlci5zZXRUcmFuc2l0aW9uKHN3aXBlci5wYXJhbXMuc3BlZWQpO1xcbiAgfVxcblxcbiAgdmFyIGdldFNsaWRlQnlJbmRleCA9IGZ1bmN0aW9uIGdldFNsaWRlQnlJbmRleChpbmRleCkge1xcbiAgICBpZiAoaXNWaXJ0dWFsKSB7XFxuICAgICAgcmV0dXJuIHN3aXBlci5zbGlkZXMuZmlsdGVyKGZ1bmN0aW9uIChlbCkge1xcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1zd2lwZXItc2xpZGUtaW5kZXgnKSwgMTApID09PSBpbmRleDtcXG4gICAgICB9KVswXTtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gc3dpcGVyLnNsaWRlcy5lcShpbmRleClbMF07XFxuICB9OyAvLyBGaW5kIHNsaWRlcyBjdXJyZW50bHkgaW4gdmlld1xcblxcblxcbiAgaWYgKHN3aXBlci5wYXJhbXMuc2xpZGVzUGVyVmlldyAhPT0gJ2F1dG8nICYmIHN3aXBlci5wYXJhbXMuc2xpZGVzUGVyVmlldyA+IDEpIHtcXG4gICAgaWYgKHN3aXBlci5wYXJhbXMuY2VudGVyZWRTbGlkZXMpIHtcXG4gICAgICBzd2lwZXIudmlzaWJsZVNsaWRlcy5lYWNoKGZ1bmN0aW9uIChzbGlkZSkge1xcbiAgICAgICAgYWN0aXZlU2xpZGVzLnB1c2goc2xpZGUpO1xcbiAgICAgIH0pO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBNYXRoLmNlaWwoc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJWaWV3KTsgaSArPSAxKSB7XFxuICAgICAgICB2YXIgaW5kZXggPSBzd2lwZXIuYWN0aXZlSW5kZXggKyBpO1xcbiAgICAgICAgaWYgKGluZGV4ID4gc3dpcGVyLnNsaWRlcy5sZW5ndGggJiYgIWlzVmlydHVhbCkgYnJlYWs7XFxuICAgICAgICBhY3RpdmVTbGlkZXMucHVzaChnZXRTbGlkZUJ5SW5kZXgoaW5kZXgpKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH0gZWxzZSB7XFxuICAgIGFjdGl2ZVNsaWRlcy5wdXNoKGdldFNsaWRlQnlJbmRleChzd2lwZXIuYWN0aXZlSW5kZXgpKTtcXG4gIH0gLy8gRmluZCBuZXcgaGVpZ2h0IGZyb20gaGlnaGVzdCBzbGlkZSBpbiB2aWV3XFxuXFxuXFxuICBmb3IgKGkgPSAwOyBpIDwgYWN0aXZlU2xpZGVzLmxlbmd0aDsgaSArPSAxKSB7XFxuICAgIGlmICh0eXBlb2YgYWN0aXZlU2xpZGVzW2ldICE9PSAndW5kZWZpbmVkJykge1xcbiAgICAgIHZhciBoZWlnaHQgPSBhY3RpdmVTbGlkZXNbaV0ub2Zmc2V0SGVpZ2h0O1xcbiAgICAgIG5ld0hlaWdodCA9IGhlaWdodCA+IG5ld0hlaWdodCA/IGhlaWdodCA6IG5ld0hlaWdodDtcXG4gICAgfVxcbiAgfSAvLyBVcGRhdGUgSGVpZ2h0XFxuXFxuXFxuICBpZiAobmV3SGVpZ2h0KSBzd2lwZXIuJHdyYXBwZXJFbC5jc3MoJ2hlaWdodCcsIG5ld0hlaWdodCArIFxcXCJweFxcXCIpO1xcbn1cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9wYXJ1cy8uL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS91cGRhdGUvdXBkYXRlQXV0b0hlaWdodC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL3VwZGF0ZS91cGRhdGVDbGlja2VkU2xpZGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS91cGRhdGUvdXBkYXRlQ2xpY2tlZFNsaWRlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcImRlZmF1bHRcXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyB1cGRhdGVDbGlja2VkU2xpZGUpXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19kb21fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uLy4uL3V0aWxzL2RvbSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS91dGlscy9kb20uanNcXFwiKTtcXG5cXG5mdW5jdGlvbiB1cGRhdGVDbGlja2VkU2xpZGUoZSkge1xcbiAgdmFyIHN3aXBlciA9IHRoaXM7XFxuICB2YXIgcGFyYW1zID0gc3dpcGVyLnBhcmFtcztcXG4gIHZhciBzbGlkZSA9ICgwLF91dGlsc19kb21fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiZGVmYXVsdFxcXCJdKShlLnRhcmdldCkuY2xvc2VzdChcXFwiLlxcXCIgKyBwYXJhbXMuc2xpZGVDbGFzcylbMF07XFxuICB2YXIgc2xpZGVGb3VuZCA9IGZhbHNlO1xcbiAgdmFyIHNsaWRlSW5kZXg7XFxuXFxuICBpZiAoc2xpZGUpIHtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzd2lwZXIuc2xpZGVzLmxlbmd0aDsgaSArPSAxKSB7XFxuICAgICAgaWYgKHN3aXBlci5zbGlkZXNbaV0gPT09IHNsaWRlKSB7XFxuICAgICAgICBzbGlkZUZvdW5kID0gdHJ1ZTtcXG4gICAgICAgIHNsaWRlSW5kZXggPSBpO1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuXFxuICBpZiAoc2xpZGUgJiYgc2xpZGVGb3VuZCkge1xcbiAgICBzd2lwZXIuY2xpY2tlZFNsaWRlID0gc2xpZGU7XFxuXFxuICAgIGlmIChzd2lwZXIudmlydHVhbCAmJiBzd2lwZXIucGFyYW1zLnZpcnR1YWwuZW5hYmxlZCkge1xcbiAgICAgIHN3aXBlci5jbGlja2VkSW5kZXggPSBwYXJzZUludCgoMCxfdXRpbHNfZG9tX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImRlZmF1bHRcXFwiXSkoc2xpZGUpLmF0dHIoJ2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4JyksIDEwKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBzd2lwZXIuY2xpY2tlZEluZGV4ID0gc2xpZGVJbmRleDtcXG4gICAgfVxcbiAgfSBlbHNlIHtcXG4gICAgc3dpcGVyLmNsaWNrZWRTbGlkZSA9IHVuZGVmaW5lZDtcXG4gICAgc3dpcGVyLmNsaWNrZWRJbmRleCA9IHVuZGVmaW5lZDtcXG4gICAgcmV0dXJuO1xcbiAgfVxcblxcbiAgaWYgKHBhcmFtcy5zbGlkZVRvQ2xpY2tlZFNsaWRlICYmIHN3aXBlci5jbGlja2VkSW5kZXggIT09IHVuZGVmaW5lZCAmJiBzd2lwZXIuY2xpY2tlZEluZGV4ICE9PSBzd2lwZXIuYWN0aXZlSW5kZXgpIHtcXG4gICAgc3dpcGVyLnNsaWRlVG9DbGlja2VkU2xpZGUoKTtcXG4gIH1cXG59XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vcGFydXMvLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvdXBkYXRlL3VwZGF0ZUNsaWNrZWRTbGlkZS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL3VwZGF0ZS91cGRhdGVQcm9ncmVzcy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvdXBkYXRlL3VwZGF0ZVByb2dyZXNzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwiZGVmYXVsdFxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIHVwZGF0ZVByb2dyZXNzKVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uLy4uL3V0aWxzL3V0aWxzICovIFxcXCIuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL3V0aWxzL3V0aWxzLmpzXFxcIik7XFxuXFxuZnVuY3Rpb24gdXBkYXRlUHJvZ3Jlc3ModHJhbnNsYXRlKSB7XFxuICB2YXIgc3dpcGVyID0gdGhpcztcXG5cXG4gIGlmICh0eXBlb2YgdHJhbnNsYXRlID09PSAndW5kZWZpbmVkJykge1xcbiAgICB2YXIgbXVsdGlwbGllciA9IHN3aXBlci5ydGxUcmFuc2xhdGUgPyAtMSA6IDE7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxcblxcbiAgICB0cmFuc2xhdGUgPSBzd2lwZXIgJiYgc3dpcGVyLnRyYW5zbGF0ZSAmJiBzd2lwZXIudHJhbnNsYXRlICogbXVsdGlwbGllciB8fCAwO1xcbiAgfVxcblxcbiAgdmFyIHBhcmFtcyA9IHN3aXBlci5wYXJhbXM7XFxuICB2YXIgdHJhbnNsYXRlc0RpZmYgPSBzd2lwZXIubWF4VHJhbnNsYXRlKCkgLSBzd2lwZXIubWluVHJhbnNsYXRlKCk7XFxuICB2YXIgcHJvZ3Jlc3MgPSBzd2lwZXIucHJvZ3Jlc3MsXFxuICAgICAgaXNCZWdpbm5pbmcgPSBzd2lwZXIuaXNCZWdpbm5pbmcsXFxuICAgICAgaXNFbmQgPSBzd2lwZXIuaXNFbmQ7XFxuICB2YXIgd2FzQmVnaW5uaW5nID0gaXNCZWdpbm5pbmc7XFxuICB2YXIgd2FzRW5kID0gaXNFbmQ7XFxuXFxuICBpZiAodHJhbnNsYXRlc0RpZmYgPT09IDApIHtcXG4gICAgcHJvZ3Jlc3MgPSAwO1xcbiAgICBpc0JlZ2lubmluZyA9IHRydWU7XFxuICAgIGlzRW5kID0gdHJ1ZTtcXG4gIH0gZWxzZSB7XFxuICAgIHByb2dyZXNzID0gKHRyYW5zbGF0ZSAtIHN3aXBlci5taW5UcmFuc2xhdGUoKSkgLyB0cmFuc2xhdGVzRGlmZjtcXG4gICAgaXNCZWdpbm5pbmcgPSBwcm9ncmVzcyA8PSAwO1xcbiAgICBpc0VuZCA9IHByb2dyZXNzID49IDE7XFxuICB9XFxuXFxuICAoMCxfdXRpbHNfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5leHRlbmQpKHN3aXBlciwge1xcbiAgICBwcm9ncmVzczogcHJvZ3Jlc3MsXFxuICAgIGlzQmVnaW5uaW5nOiBpc0JlZ2lubmluZyxcXG4gICAgaXNFbmQ6IGlzRW5kXFxuICB9KTtcXG4gIGlmIChwYXJhbXMud2F0Y2hTbGlkZXNQcm9ncmVzcyB8fCBwYXJhbXMud2F0Y2hTbGlkZXNWaXNpYmlsaXR5IHx8IHBhcmFtcy5jZW50ZXJlZFNsaWRlcyAmJiBwYXJhbXMuYXV0b0hlaWdodCkgc3dpcGVyLnVwZGF0ZVNsaWRlc1Byb2dyZXNzKHRyYW5zbGF0ZSk7XFxuXFxuICBpZiAoaXNCZWdpbm5pbmcgJiYgIXdhc0JlZ2lubmluZykge1xcbiAgICBzd2lwZXIuZW1pdCgncmVhY2hCZWdpbm5pbmcgdG9FZGdlJyk7XFxuICB9XFxuXFxuICBpZiAoaXNFbmQgJiYgIXdhc0VuZCkge1xcbiAgICBzd2lwZXIuZW1pdCgncmVhY2hFbmQgdG9FZGdlJyk7XFxuICB9XFxuXFxuICBpZiAod2FzQmVnaW5uaW5nICYmICFpc0JlZ2lubmluZyB8fCB3YXNFbmQgJiYgIWlzRW5kKSB7XFxuICAgIHN3aXBlci5lbWl0KCdmcm9tRWRnZScpO1xcbiAgfVxcblxcbiAgc3dpcGVyLmVtaXQoJ3Byb2dyZXNzJywgcHJvZ3Jlc3MpO1xcbn1cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9wYXJ1cy8uL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS91cGRhdGUvdXBkYXRlUHJvZ3Jlc3MuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS91cGRhdGUvdXBkYXRlU2l6ZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS91cGRhdGUvdXBkYXRlU2l6ZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwiZGVmYXVsdFxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIHVwZGF0ZVNpemUpXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc191dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vLi4vdXRpbHMvdXRpbHMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vdXRpbHMvdXRpbHMuanNcXFwiKTtcXG5cXG5mdW5jdGlvbiB1cGRhdGVTaXplKCkge1xcbiAgdmFyIHN3aXBlciA9IHRoaXM7XFxuICB2YXIgd2lkdGg7XFxuICB2YXIgaGVpZ2h0O1xcbiAgdmFyICRlbCA9IHN3aXBlci4kZWw7XFxuXFxuICBpZiAodHlwZW9mIHN3aXBlci5wYXJhbXMud2lkdGggIT09ICd1bmRlZmluZWQnICYmIHN3aXBlci5wYXJhbXMud2lkdGggIT09IG51bGwpIHtcXG4gICAgd2lkdGggPSBzd2lwZXIucGFyYW1zLndpZHRoO1xcbiAgfSBlbHNlIHtcXG4gICAgd2lkdGggPSAkZWxbMF0uY2xpZW50V2lkdGg7XFxuICB9XFxuXFxuICBpZiAodHlwZW9mIHN3aXBlci5wYXJhbXMuaGVpZ2h0ICE9PSAndW5kZWZpbmVkJyAmJiBzd2lwZXIucGFyYW1zLmhlaWdodCAhPT0gbnVsbCkge1xcbiAgICBoZWlnaHQgPSBzd2lwZXIucGFyYW1zLmhlaWdodDtcXG4gIH0gZWxzZSB7XFxuICAgIGhlaWdodCA9ICRlbFswXS5jbGllbnRIZWlnaHQ7XFxuICB9XFxuXFxuICBpZiAod2lkdGggPT09IDAgJiYgc3dpcGVyLmlzSG9yaXpvbnRhbCgpIHx8IGhlaWdodCA9PT0gMCAmJiBzd2lwZXIuaXNWZXJ0aWNhbCgpKSB7XFxuICAgIHJldHVybjtcXG4gIH0gLy8gU3VidHJhY3QgcGFkZGluZ3NcXG5cXG5cXG4gIHdpZHRoID0gd2lkdGggLSBwYXJzZUludCgkZWwuY3NzKCdwYWRkaW5nLWxlZnQnKSB8fCAwLCAxMCkgLSBwYXJzZUludCgkZWwuY3NzKCdwYWRkaW5nLXJpZ2h0JykgfHwgMCwgMTApO1xcbiAgaGVpZ2h0ID0gaGVpZ2h0IC0gcGFyc2VJbnQoJGVsLmNzcygncGFkZGluZy10b3AnKSB8fCAwLCAxMCkgLSBwYXJzZUludCgkZWwuY3NzKCdwYWRkaW5nLWJvdHRvbScpIHx8IDAsIDEwKTtcXG4gIGlmIChOdW1iZXIuaXNOYU4od2lkdGgpKSB3aWR0aCA9IDA7XFxuICBpZiAoTnVtYmVyLmlzTmFOKGhlaWdodCkpIGhlaWdodCA9IDA7XFxuICAoMCxfdXRpbHNfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5leHRlbmQpKHN3aXBlciwge1xcbiAgICB3aWR0aDogd2lkdGgsXFxuICAgIGhlaWdodDogaGVpZ2h0LFxcbiAgICBzaXplOiBzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyB3aWR0aCA6IGhlaWdodFxcbiAgfSk7XFxufVxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3BhcnVzLy4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL3VwZGF0ZS91cGRhdGVTaXplLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvdXBkYXRlL3VwZGF0ZVNsaWRlcy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL3VwZGF0ZS91cGRhdGVTbGlkZXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwiZGVmYXVsdFxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIHVwZGF0ZVNsaWRlcylcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi8uLi91dGlscy91dGlscyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS91dGlscy91dGlscy5qc1xcXCIpO1xcblxcbmZ1bmN0aW9uIHVwZGF0ZVNsaWRlcygpIHtcXG4gIHZhciBzd2lwZXIgPSB0aGlzO1xcblxcbiAgZnVuY3Rpb24gZ2V0RGlyZWN0aW9uTGFiZWwocHJvcGVydHkpIHtcXG4gICAgaWYgKHN3aXBlci5pc0hvcml6b250YWwoKSkge1xcbiAgICAgIHJldHVybiBwcm9wZXJ0eTtcXG4gICAgfSAvLyBwcmV0dGllci1pZ25vcmVcXG5cXG5cXG4gICAgcmV0dXJuIHtcXG4gICAgICAnd2lkdGgnOiAnaGVpZ2h0JyxcXG4gICAgICAnbWFyZ2luLXRvcCc6ICdtYXJnaW4tbGVmdCcsXFxuICAgICAgJ21hcmdpbi1ib3R0b20gJzogJ21hcmdpbi1yaWdodCcsXFxuICAgICAgJ21hcmdpbi1sZWZ0JzogJ21hcmdpbi10b3AnLFxcbiAgICAgICdtYXJnaW4tcmlnaHQnOiAnbWFyZ2luLWJvdHRvbScsXFxuICAgICAgJ3BhZGRpbmctbGVmdCc6ICdwYWRkaW5nLXRvcCcsXFxuICAgICAgJ3BhZGRpbmctcmlnaHQnOiAncGFkZGluZy1ib3R0b20nLFxcbiAgICAgICdtYXJnaW5SaWdodCc6ICdtYXJnaW5Cb3R0b20nXFxuICAgIH1bcHJvcGVydHldO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gZ2V0RGlyZWN0aW9uUHJvcGVydHlWYWx1ZShub2RlLCBsYWJlbCkge1xcbiAgICByZXR1cm4gcGFyc2VGbG9hdChub2RlLmdldFByb3BlcnR5VmFsdWUoZ2V0RGlyZWN0aW9uTGFiZWwobGFiZWwpKSB8fCAwKTtcXG4gIH1cXG5cXG4gIHZhciBwYXJhbXMgPSBzd2lwZXIucGFyYW1zO1xcbiAgdmFyICR3cmFwcGVyRWwgPSBzd2lwZXIuJHdyYXBwZXJFbCxcXG4gICAgICBzd2lwZXJTaXplID0gc3dpcGVyLnNpemUsXFxuICAgICAgcnRsID0gc3dpcGVyLnJ0bFRyYW5zbGF0ZSxcXG4gICAgICB3cm9uZ1JUTCA9IHN3aXBlci53cm9uZ1JUTDtcXG4gIHZhciBpc1ZpcnR1YWwgPSBzd2lwZXIudmlydHVhbCAmJiBwYXJhbXMudmlydHVhbC5lbmFibGVkO1xcbiAgdmFyIHByZXZpb3VzU2xpZGVzTGVuZ3RoID0gaXNWaXJ0dWFsID8gc3dpcGVyLnZpcnR1YWwuc2xpZGVzLmxlbmd0aCA6IHN3aXBlci5zbGlkZXMubGVuZ3RoO1xcbiAgdmFyIHNsaWRlcyA9ICR3cmFwcGVyRWwuY2hpbGRyZW4oXFxcIi5cXFwiICsgc3dpcGVyLnBhcmFtcy5zbGlkZUNsYXNzKTtcXG4gIHZhciBzbGlkZXNMZW5ndGggPSBpc1ZpcnR1YWwgPyBzd2lwZXIudmlydHVhbC5zbGlkZXMubGVuZ3RoIDogc2xpZGVzLmxlbmd0aDtcXG4gIHZhciBzbmFwR3JpZCA9IFtdO1xcbiAgdmFyIHNsaWRlc0dyaWQgPSBbXTtcXG4gIHZhciBzbGlkZXNTaXplc0dyaWQgPSBbXTtcXG4gIHZhciBvZmZzZXRCZWZvcmUgPSBwYXJhbXMuc2xpZGVzT2Zmc2V0QmVmb3JlO1xcblxcbiAgaWYgKHR5cGVvZiBvZmZzZXRCZWZvcmUgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgb2Zmc2V0QmVmb3JlID0gcGFyYW1zLnNsaWRlc09mZnNldEJlZm9yZS5jYWxsKHN3aXBlcik7XFxuICB9XFxuXFxuICB2YXIgb2Zmc2V0QWZ0ZXIgPSBwYXJhbXMuc2xpZGVzT2Zmc2V0QWZ0ZXI7XFxuXFxuICBpZiAodHlwZW9mIG9mZnNldEFmdGVyID09PSAnZnVuY3Rpb24nKSB7XFxuICAgIG9mZnNldEFmdGVyID0gcGFyYW1zLnNsaWRlc09mZnNldEFmdGVyLmNhbGwoc3dpcGVyKTtcXG4gIH1cXG5cXG4gIHZhciBwcmV2aW91c1NuYXBHcmlkTGVuZ3RoID0gc3dpcGVyLnNuYXBHcmlkLmxlbmd0aDtcXG4gIHZhciBwcmV2aW91c1NsaWRlc0dyaWRMZW5ndGggPSBzd2lwZXIuc2xpZGVzR3JpZC5sZW5ndGg7XFxuICB2YXIgc3BhY2VCZXR3ZWVuID0gcGFyYW1zLnNwYWNlQmV0d2VlbjtcXG4gIHZhciBzbGlkZVBvc2l0aW9uID0gLW9mZnNldEJlZm9yZTtcXG4gIHZhciBwcmV2U2xpZGVTaXplID0gMDtcXG4gIHZhciBpbmRleCA9IDA7XFxuXFxuICBpZiAodHlwZW9mIHN3aXBlclNpemUgPT09ICd1bmRlZmluZWQnKSB7XFxuICAgIHJldHVybjtcXG4gIH1cXG5cXG4gIGlmICh0eXBlb2Ygc3BhY2VCZXR3ZWVuID09PSAnc3RyaW5nJyAmJiBzcGFjZUJldHdlZW4uaW5kZXhPZignJScpID49IDApIHtcXG4gICAgc3BhY2VCZXR3ZWVuID0gcGFyc2VGbG9hdChzcGFjZUJldHdlZW4ucmVwbGFjZSgnJScsICcnKSkgLyAxMDAgKiBzd2lwZXJTaXplO1xcbiAgfVxcblxcbiAgc3dpcGVyLnZpcnR1YWxTaXplID0gLXNwYWNlQmV0d2VlbjsgLy8gcmVzZXQgbWFyZ2luc1xcblxcbiAgaWYgKHJ0bCkgc2xpZGVzLmNzcyh7XFxuICAgIG1hcmdpbkxlZnQ6ICcnLFxcbiAgICBtYXJnaW5Cb3R0b206ICcnLFxcbiAgICBtYXJnaW5Ub3A6ICcnXFxuICB9KTtlbHNlIHNsaWRlcy5jc3Moe1xcbiAgICBtYXJnaW5SaWdodDogJycsXFxuICAgIG1hcmdpbkJvdHRvbTogJycsXFxuICAgIG1hcmdpblRvcDogJydcXG4gIH0pO1xcbiAgdmFyIHNsaWRlc051bWJlckV2ZW5Ub1Jvd3M7XFxuXFxuICBpZiAocGFyYW1zLnNsaWRlc1BlckNvbHVtbiA+IDEpIHtcXG4gICAgaWYgKE1hdGguZmxvb3Ioc2xpZGVzTGVuZ3RoIC8gcGFyYW1zLnNsaWRlc1BlckNvbHVtbikgPT09IHNsaWRlc0xlbmd0aCAvIHN3aXBlci5wYXJhbXMuc2xpZGVzUGVyQ29sdW1uKSB7XFxuICAgICAgc2xpZGVzTnVtYmVyRXZlblRvUm93cyA9IHNsaWRlc0xlbmd0aDtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBzbGlkZXNOdW1iZXJFdmVuVG9Sb3dzID0gTWF0aC5jZWlsKHNsaWRlc0xlbmd0aCAvIHBhcmFtcy5zbGlkZXNQZXJDb2x1bW4pICogcGFyYW1zLnNsaWRlc1BlckNvbHVtbjtcXG4gICAgfVxcblxcbiAgICBpZiAocGFyYW1zLnNsaWRlc1BlclZpZXcgIT09ICdhdXRvJyAmJiBwYXJhbXMuc2xpZGVzUGVyQ29sdW1uRmlsbCA9PT0gJ3JvdycpIHtcXG4gICAgICBzbGlkZXNOdW1iZXJFdmVuVG9Sb3dzID0gTWF0aC5tYXgoc2xpZGVzTnVtYmVyRXZlblRvUm93cywgcGFyYW1zLnNsaWRlc1BlclZpZXcgKiBwYXJhbXMuc2xpZGVzUGVyQ29sdW1uKTtcXG4gICAgfVxcbiAgfSAvLyBDYWxjIHNsaWRlc1xcblxcblxcbiAgdmFyIHNsaWRlU2l6ZTtcXG4gIHZhciBzbGlkZXNQZXJDb2x1bW4gPSBwYXJhbXMuc2xpZGVzUGVyQ29sdW1uO1xcbiAgdmFyIHNsaWRlc1BlclJvdyA9IHNsaWRlc051bWJlckV2ZW5Ub1Jvd3MgLyBzbGlkZXNQZXJDb2x1bW47XFxuICB2YXIgbnVtRnVsbENvbHVtbnMgPSBNYXRoLmZsb29yKHNsaWRlc0xlbmd0aCAvIHBhcmFtcy5zbGlkZXNQZXJDb2x1bW4pO1xcblxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGlkZXNMZW5ndGg7IGkgKz0gMSkge1xcbiAgICBzbGlkZVNpemUgPSAwO1xcbiAgICB2YXIgc2xpZGUgPSBzbGlkZXMuZXEoaSk7XFxuXFxuICAgIGlmIChwYXJhbXMuc2xpZGVzUGVyQ29sdW1uID4gMSkge1xcbiAgICAgIC8vIFNldCBzbGlkZXMgb3JkZXJcXG4gICAgICB2YXIgbmV3U2xpZGVPcmRlckluZGV4ID0gdm9pZCAwO1xcbiAgICAgIHZhciBjb2x1bW4gPSB2b2lkIDA7XFxuICAgICAgdmFyIHJvdyA9IHZvaWQgMDtcXG5cXG4gICAgICBpZiAocGFyYW1zLnNsaWRlc1BlckNvbHVtbkZpbGwgPT09ICdyb3cnICYmIHBhcmFtcy5zbGlkZXNQZXJHcm91cCA+IDEpIHtcXG4gICAgICAgIHZhciBncm91cEluZGV4ID0gTWF0aC5mbG9vcihpIC8gKHBhcmFtcy5zbGlkZXNQZXJHcm91cCAqIHBhcmFtcy5zbGlkZXNQZXJDb2x1bW4pKTtcXG4gICAgICAgIHZhciBzbGlkZUluZGV4SW5Hcm91cCA9IGkgLSBwYXJhbXMuc2xpZGVzUGVyQ29sdW1uICogcGFyYW1zLnNsaWRlc1Blckdyb3VwICogZ3JvdXBJbmRleDtcXG4gICAgICAgIHZhciBjb2x1bW5zSW5Hcm91cCA9IGdyb3VwSW5kZXggPT09IDAgPyBwYXJhbXMuc2xpZGVzUGVyR3JvdXAgOiBNYXRoLm1pbihNYXRoLmNlaWwoKHNsaWRlc0xlbmd0aCAtIGdyb3VwSW5kZXggKiBzbGlkZXNQZXJDb2x1bW4gKiBwYXJhbXMuc2xpZGVzUGVyR3JvdXApIC8gc2xpZGVzUGVyQ29sdW1uKSwgcGFyYW1zLnNsaWRlc1Blckdyb3VwKTtcXG4gICAgICAgIHJvdyA9IE1hdGguZmxvb3Ioc2xpZGVJbmRleEluR3JvdXAgLyBjb2x1bW5zSW5Hcm91cCk7XFxuICAgICAgICBjb2x1bW4gPSBzbGlkZUluZGV4SW5Hcm91cCAtIHJvdyAqIGNvbHVtbnNJbkdyb3VwICsgZ3JvdXBJbmRleCAqIHBhcmFtcy5zbGlkZXNQZXJHcm91cDtcXG4gICAgICAgIG5ld1NsaWRlT3JkZXJJbmRleCA9IGNvbHVtbiArIHJvdyAqIHNsaWRlc051bWJlckV2ZW5Ub1Jvd3MgLyBzbGlkZXNQZXJDb2x1bW47XFxuICAgICAgICBzbGlkZS5jc3Moe1xcbiAgICAgICAgICAnLXdlYmtpdC1ib3gtb3JkaW5hbC1ncm91cCc6IG5ld1NsaWRlT3JkZXJJbmRleCxcXG4gICAgICAgICAgJy1tb3otYm94LW9yZGluYWwtZ3JvdXAnOiBuZXdTbGlkZU9yZGVySW5kZXgsXFxuICAgICAgICAgICctbXMtZmxleC1vcmRlcic6IG5ld1NsaWRlT3JkZXJJbmRleCxcXG4gICAgICAgICAgJy13ZWJraXQtb3JkZXInOiBuZXdTbGlkZU9yZGVySW5kZXgsXFxuICAgICAgICAgIG9yZGVyOiBuZXdTbGlkZU9yZGVySW5kZXhcXG4gICAgICAgIH0pO1xcbiAgICAgIH0gZWxzZSBpZiAocGFyYW1zLnNsaWRlc1BlckNvbHVtbkZpbGwgPT09ICdjb2x1bW4nKSB7XFxuICAgICAgICBjb2x1bW4gPSBNYXRoLmZsb29yKGkgLyBzbGlkZXNQZXJDb2x1bW4pO1xcbiAgICAgICAgcm93ID0gaSAtIGNvbHVtbiAqIHNsaWRlc1BlckNvbHVtbjtcXG5cXG4gICAgICAgIGlmIChjb2x1bW4gPiBudW1GdWxsQ29sdW1ucyB8fCBjb2x1bW4gPT09IG51bUZ1bGxDb2x1bW5zICYmIHJvdyA9PT0gc2xpZGVzUGVyQ29sdW1uIC0gMSkge1xcbiAgICAgICAgICByb3cgKz0gMTtcXG5cXG4gICAgICAgICAgaWYgKHJvdyA+PSBzbGlkZXNQZXJDb2x1bW4pIHtcXG4gICAgICAgICAgICByb3cgPSAwO1xcbiAgICAgICAgICAgIGNvbHVtbiArPSAxO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHJvdyA9IE1hdGguZmxvb3IoaSAvIHNsaWRlc1BlclJvdyk7XFxuICAgICAgICBjb2x1bW4gPSBpIC0gcm93ICogc2xpZGVzUGVyUm93O1xcbiAgICAgIH1cXG5cXG4gICAgICBzbGlkZS5jc3MoZ2V0RGlyZWN0aW9uTGFiZWwoJ21hcmdpbi10b3AnKSwgcm93ICE9PSAwID8gcGFyYW1zLnNwYWNlQmV0d2VlbiAmJiBwYXJhbXMuc3BhY2VCZXR3ZWVuICsgXFxcInB4XFxcIiA6ICcnKTtcXG4gICAgfVxcblxcbiAgICBpZiAoc2xpZGUuY3NzKCdkaXNwbGF5JykgPT09ICdub25lJykgY29udGludWU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcXG5cXG4gICAgaWYgKHBhcmFtcy5zbGlkZXNQZXJWaWV3ID09PSAnYXV0bycpIHtcXG4gICAgICB2YXIgc2xpZGVTdHlsZXMgPSBnZXRDb21wdXRlZFN0eWxlKHNsaWRlWzBdKTtcXG4gICAgICB2YXIgY3VycmVudFRyYW5zZm9ybSA9IHNsaWRlWzBdLnN0eWxlLnRyYW5zZm9ybTtcXG4gICAgICB2YXIgY3VycmVudFdlYktpdFRyYW5zZm9ybSA9IHNsaWRlWzBdLnN0eWxlLndlYmtpdFRyYW5zZm9ybTtcXG5cXG4gICAgICBpZiAoY3VycmVudFRyYW5zZm9ybSkge1xcbiAgICAgICAgc2xpZGVbMF0uc3R5bGUudHJhbnNmb3JtID0gJ25vbmUnO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoY3VycmVudFdlYktpdFRyYW5zZm9ybSkge1xcbiAgICAgICAgc2xpZGVbMF0uc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ25vbmUnO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAocGFyYW1zLnJvdW5kTGVuZ3Rocykge1xcbiAgICAgICAgc2xpZGVTaXplID0gc3dpcGVyLmlzSG9yaXpvbnRhbCgpID8gc2xpZGUub3V0ZXJXaWR0aCh0cnVlKSA6IHNsaWRlLm91dGVySGVpZ2h0KHRydWUpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcXG4gICAgICAgIHZhciB3aWR0aCA9IGdldERpcmVjdGlvblByb3BlcnR5VmFsdWUoc2xpZGVTdHlsZXMsICd3aWR0aCcpO1xcbiAgICAgICAgdmFyIHBhZGRpbmdMZWZ0ID0gZ2V0RGlyZWN0aW9uUHJvcGVydHlWYWx1ZShzbGlkZVN0eWxlcywgJ3BhZGRpbmctbGVmdCcpO1xcbiAgICAgICAgdmFyIHBhZGRpbmdSaWdodCA9IGdldERpcmVjdGlvblByb3BlcnR5VmFsdWUoc2xpZGVTdHlsZXMsICdwYWRkaW5nLXJpZ2h0Jyk7XFxuICAgICAgICB2YXIgbWFyZ2luTGVmdCA9IGdldERpcmVjdGlvblByb3BlcnR5VmFsdWUoc2xpZGVTdHlsZXMsICdtYXJnaW4tbGVmdCcpO1xcbiAgICAgICAgdmFyIG1hcmdpblJpZ2h0ID0gZ2V0RGlyZWN0aW9uUHJvcGVydHlWYWx1ZShzbGlkZVN0eWxlcywgJ21hcmdpbi1yaWdodCcpO1xcbiAgICAgICAgdmFyIGJveFNpemluZyA9IHNsaWRlU3R5bGVzLmdldFByb3BlcnR5VmFsdWUoJ2JveC1zaXppbmcnKTtcXG5cXG4gICAgICAgIGlmIChib3hTaXppbmcgJiYgYm94U2l6aW5nID09PSAnYm9yZGVyLWJveCcpIHtcXG4gICAgICAgICAgc2xpZGVTaXplID0gd2lkdGggKyBtYXJnaW5MZWZ0ICsgbWFyZ2luUmlnaHQ7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICB2YXIgX3NsaWRlJCA9IHNsaWRlWzBdLFxcbiAgICAgICAgICAgICAgY2xpZW50V2lkdGggPSBfc2xpZGUkLmNsaWVudFdpZHRoLFxcbiAgICAgICAgICAgICAgb2Zmc2V0V2lkdGggPSBfc2xpZGUkLm9mZnNldFdpZHRoO1xcbiAgICAgICAgICBzbGlkZVNpemUgPSB3aWR0aCArIHBhZGRpbmdMZWZ0ICsgcGFkZGluZ1JpZ2h0ICsgbWFyZ2luTGVmdCArIG1hcmdpblJpZ2h0ICsgKG9mZnNldFdpZHRoIC0gY2xpZW50V2lkdGgpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoY3VycmVudFRyYW5zZm9ybSkge1xcbiAgICAgICAgc2xpZGVbMF0uc3R5bGUudHJhbnNmb3JtID0gY3VycmVudFRyYW5zZm9ybTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGN1cnJlbnRXZWJLaXRUcmFuc2Zvcm0pIHtcXG4gICAgICAgIHNsaWRlWzBdLnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9IGN1cnJlbnRXZWJLaXRUcmFuc2Zvcm07XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChwYXJhbXMucm91bmRMZW5ndGhzKSBzbGlkZVNpemUgPSBNYXRoLmZsb29yKHNsaWRlU2l6ZSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgc2xpZGVTaXplID0gKHN3aXBlclNpemUgLSAocGFyYW1zLnNsaWRlc1BlclZpZXcgLSAxKSAqIHNwYWNlQmV0d2VlbikgLyBwYXJhbXMuc2xpZGVzUGVyVmlldztcXG4gICAgICBpZiAocGFyYW1zLnJvdW5kTGVuZ3Rocykgc2xpZGVTaXplID0gTWF0aC5mbG9vcihzbGlkZVNpemUpO1xcblxcbiAgICAgIGlmIChzbGlkZXNbaV0pIHtcXG4gICAgICAgIHNsaWRlc1tpXS5zdHlsZVtnZXREaXJlY3Rpb25MYWJlbCgnd2lkdGgnKV0gPSBzbGlkZVNpemUgKyBcXFwicHhcXFwiO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBpZiAoc2xpZGVzW2ldKSB7XFxuICAgICAgc2xpZGVzW2ldLnN3aXBlclNsaWRlU2l6ZSA9IHNsaWRlU2l6ZTtcXG4gICAgfVxcblxcbiAgICBzbGlkZXNTaXplc0dyaWQucHVzaChzbGlkZVNpemUpO1xcblxcbiAgICBpZiAocGFyYW1zLmNlbnRlcmVkU2xpZGVzKSB7XFxuICAgICAgc2xpZGVQb3NpdGlvbiA9IHNsaWRlUG9zaXRpb24gKyBzbGlkZVNpemUgLyAyICsgcHJldlNsaWRlU2l6ZSAvIDIgKyBzcGFjZUJldHdlZW47XFxuICAgICAgaWYgKHByZXZTbGlkZVNpemUgPT09IDAgJiYgaSAhPT0gMCkgc2xpZGVQb3NpdGlvbiA9IHNsaWRlUG9zaXRpb24gLSBzd2lwZXJTaXplIC8gMiAtIHNwYWNlQmV0d2VlbjtcXG4gICAgICBpZiAoaSA9PT0gMCkgc2xpZGVQb3NpdGlvbiA9IHNsaWRlUG9zaXRpb24gLSBzd2lwZXJTaXplIC8gMiAtIHNwYWNlQmV0d2VlbjtcXG4gICAgICBpZiAoTWF0aC5hYnMoc2xpZGVQb3NpdGlvbikgPCAxIC8gMTAwMCkgc2xpZGVQb3NpdGlvbiA9IDA7XFxuICAgICAgaWYgKHBhcmFtcy5yb3VuZExlbmd0aHMpIHNsaWRlUG9zaXRpb24gPSBNYXRoLmZsb29yKHNsaWRlUG9zaXRpb24pO1xcbiAgICAgIGlmIChpbmRleCAlIHBhcmFtcy5zbGlkZXNQZXJHcm91cCA9PT0gMCkgc25hcEdyaWQucHVzaChzbGlkZVBvc2l0aW9uKTtcXG4gICAgICBzbGlkZXNHcmlkLnB1c2goc2xpZGVQb3NpdGlvbik7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgaWYgKHBhcmFtcy5yb3VuZExlbmd0aHMpIHNsaWRlUG9zaXRpb24gPSBNYXRoLmZsb29yKHNsaWRlUG9zaXRpb24pO1xcbiAgICAgIGlmICgoaW5kZXggLSBNYXRoLm1pbihzd2lwZXIucGFyYW1zLnNsaWRlc1Blckdyb3VwU2tpcCwgaW5kZXgpKSAlIHN3aXBlci5wYXJhbXMuc2xpZGVzUGVyR3JvdXAgPT09IDApIHNuYXBHcmlkLnB1c2goc2xpZGVQb3NpdGlvbik7XFxuICAgICAgc2xpZGVzR3JpZC5wdXNoKHNsaWRlUG9zaXRpb24pO1xcbiAgICAgIHNsaWRlUG9zaXRpb24gPSBzbGlkZVBvc2l0aW9uICsgc2xpZGVTaXplICsgc3BhY2VCZXR3ZWVuO1xcbiAgICB9XFxuXFxuICAgIHN3aXBlci52aXJ0dWFsU2l6ZSArPSBzbGlkZVNpemUgKyBzcGFjZUJldHdlZW47XFxuICAgIHByZXZTbGlkZVNpemUgPSBzbGlkZVNpemU7XFxuICAgIGluZGV4ICs9IDE7XFxuICB9XFxuXFxuICBzd2lwZXIudmlydHVhbFNpemUgPSBNYXRoLm1heChzd2lwZXIudmlydHVhbFNpemUsIHN3aXBlclNpemUpICsgb2Zmc2V0QWZ0ZXI7XFxuICB2YXIgbmV3U2xpZGVzR3JpZDtcXG5cXG4gIGlmIChydGwgJiYgd3JvbmdSVEwgJiYgKHBhcmFtcy5lZmZlY3QgPT09ICdzbGlkZScgfHwgcGFyYW1zLmVmZmVjdCA9PT0gJ2NvdmVyZmxvdycpKSB7XFxuICAgICR3cmFwcGVyRWwuY3NzKHtcXG4gICAgICB3aWR0aDogc3dpcGVyLnZpcnR1YWxTaXplICsgcGFyYW1zLnNwYWNlQmV0d2VlbiArIFxcXCJweFxcXCJcXG4gICAgfSk7XFxuICB9XFxuXFxuICBpZiAocGFyYW1zLnNldFdyYXBwZXJTaXplKSB7XFxuICAgIHZhciBfJHdyYXBwZXJFbCRjc3M7XFxuXFxuICAgICR3cmFwcGVyRWwuY3NzKChfJHdyYXBwZXJFbCRjc3MgPSB7fSwgXyR3cmFwcGVyRWwkY3NzW2dldERpcmVjdGlvbkxhYmVsKCd3aWR0aCcpXSA9IHN3aXBlci52aXJ0dWFsU2l6ZSArIHBhcmFtcy5zcGFjZUJldHdlZW4gKyBcXFwicHhcXFwiLCBfJHdyYXBwZXJFbCRjc3MpKTtcXG4gIH1cXG5cXG4gIGlmIChwYXJhbXMuc2xpZGVzUGVyQ29sdW1uID4gMSkge1xcbiAgICB2YXIgXyR3cmFwcGVyRWwkY3NzMjtcXG5cXG4gICAgc3dpcGVyLnZpcnR1YWxTaXplID0gKHNsaWRlU2l6ZSArIHBhcmFtcy5zcGFjZUJldHdlZW4pICogc2xpZGVzTnVtYmVyRXZlblRvUm93cztcXG4gICAgc3dpcGVyLnZpcnR1YWxTaXplID0gTWF0aC5jZWlsKHN3aXBlci52aXJ0dWFsU2l6ZSAvIHBhcmFtcy5zbGlkZXNQZXJDb2x1bW4pIC0gcGFyYW1zLnNwYWNlQmV0d2VlbjtcXG4gICAgJHdyYXBwZXJFbC5jc3MoKF8kd3JhcHBlckVsJGNzczIgPSB7fSwgXyR3cmFwcGVyRWwkY3NzMltnZXREaXJlY3Rpb25MYWJlbCgnd2lkdGgnKV0gPSBzd2lwZXIudmlydHVhbFNpemUgKyBwYXJhbXMuc3BhY2VCZXR3ZWVuICsgXFxcInB4XFxcIiwgXyR3cmFwcGVyRWwkY3NzMikpO1xcblxcbiAgICBpZiAocGFyYW1zLmNlbnRlcmVkU2xpZGVzKSB7XFxuICAgICAgbmV3U2xpZGVzR3JpZCA9IFtdO1xcblxcbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBzbmFwR3JpZC5sZW5ndGg7IF9pICs9IDEpIHtcXG4gICAgICAgIHZhciBzbGlkZXNHcmlkSXRlbSA9IHNuYXBHcmlkW19pXTtcXG4gICAgICAgIGlmIChwYXJhbXMucm91bmRMZW5ndGhzKSBzbGlkZXNHcmlkSXRlbSA9IE1hdGguZmxvb3Ioc2xpZGVzR3JpZEl0ZW0pO1xcbiAgICAgICAgaWYgKHNuYXBHcmlkW19pXSA8IHN3aXBlci52aXJ0dWFsU2l6ZSArIHNuYXBHcmlkWzBdKSBuZXdTbGlkZXNHcmlkLnB1c2goc2xpZGVzR3JpZEl0ZW0pO1xcbiAgICAgIH1cXG5cXG4gICAgICBzbmFwR3JpZCA9IG5ld1NsaWRlc0dyaWQ7XFxuICAgIH1cXG4gIH0gLy8gUmVtb3ZlIGxhc3QgZ3JpZCBlbGVtZW50cyBkZXBlbmRpbmcgb24gd2lkdGhcXG5cXG5cXG4gIGlmICghcGFyYW1zLmNlbnRlcmVkU2xpZGVzKSB7XFxuICAgIG5ld1NsaWRlc0dyaWQgPSBbXTtcXG5cXG4gICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgc25hcEdyaWQubGVuZ3RoOyBfaTIgKz0gMSkge1xcbiAgICAgIHZhciBfc2xpZGVzR3JpZEl0ZW0gPSBzbmFwR3JpZFtfaTJdO1xcbiAgICAgIGlmIChwYXJhbXMucm91bmRMZW5ndGhzKSBfc2xpZGVzR3JpZEl0ZW0gPSBNYXRoLmZsb29yKF9zbGlkZXNHcmlkSXRlbSk7XFxuXFxuICAgICAgaWYgKHNuYXBHcmlkW19pMl0gPD0gc3dpcGVyLnZpcnR1YWxTaXplIC0gc3dpcGVyU2l6ZSkge1xcbiAgICAgICAgbmV3U2xpZGVzR3JpZC5wdXNoKF9zbGlkZXNHcmlkSXRlbSk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHNuYXBHcmlkID0gbmV3U2xpZGVzR3JpZDtcXG5cXG4gICAgaWYgKE1hdGguZmxvb3Ioc3dpcGVyLnZpcnR1YWxTaXplIC0gc3dpcGVyU2l6ZSkgLSBNYXRoLmZsb29yKHNuYXBHcmlkW3NuYXBHcmlkLmxlbmd0aCAtIDFdKSA+IDEpIHtcXG4gICAgICBzbmFwR3JpZC5wdXNoKHN3aXBlci52aXJ0dWFsU2l6ZSAtIHN3aXBlclNpemUpO1xcbiAgICB9XFxuICB9XFxuXFxuICBpZiAoc25hcEdyaWQubGVuZ3RoID09PSAwKSBzbmFwR3JpZCA9IFswXTtcXG5cXG4gIGlmIChwYXJhbXMuc3BhY2VCZXR3ZWVuICE9PSAwKSB7XFxuICAgIHZhciBfc2xpZGVzJGZpbHRlciRjc3M7XFxuXFxuICAgIHZhciBrZXkgPSBzd2lwZXIuaXNIb3Jpem9udGFsKCkgJiYgcnRsID8gJ21hcmdpbkxlZnQnIDogZ2V0RGlyZWN0aW9uTGFiZWwoJ21hcmdpblJpZ2h0Jyk7XFxuICAgIHNsaWRlcy5maWx0ZXIoZnVuY3Rpb24gKF8sIHNsaWRlSW5kZXgpIHtcXG4gICAgICBpZiAoIXBhcmFtcy5jc3NNb2RlKSByZXR1cm4gdHJ1ZTtcXG5cXG4gICAgICBpZiAoc2xpZGVJbmRleCA9PT0gc2xpZGVzLmxlbmd0aCAtIDEpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHRydWU7XFxuICAgIH0pLmNzcygoX3NsaWRlcyRmaWx0ZXIkY3NzID0ge30sIF9zbGlkZXMkZmlsdGVyJGNzc1trZXldID0gc3BhY2VCZXR3ZWVuICsgXFxcInB4XFxcIiwgX3NsaWRlcyRmaWx0ZXIkY3NzKSk7XFxuICB9XFxuXFxuICBpZiAocGFyYW1zLmNlbnRlcmVkU2xpZGVzICYmIHBhcmFtcy5jZW50ZXJlZFNsaWRlc0JvdW5kcykge1xcbiAgICB2YXIgYWxsU2xpZGVzU2l6ZSA9IDA7XFxuICAgIHNsaWRlc1NpemVzR3JpZC5mb3JFYWNoKGZ1bmN0aW9uIChzbGlkZVNpemVWYWx1ZSkge1xcbiAgICAgIGFsbFNsaWRlc1NpemUgKz0gc2xpZGVTaXplVmFsdWUgKyAocGFyYW1zLnNwYWNlQmV0d2VlbiA/IHBhcmFtcy5zcGFjZUJldHdlZW4gOiAwKTtcXG4gICAgfSk7XFxuICAgIGFsbFNsaWRlc1NpemUgLT0gcGFyYW1zLnNwYWNlQmV0d2VlbjtcXG4gICAgdmFyIG1heFNuYXAgPSBhbGxTbGlkZXNTaXplIC0gc3dpcGVyU2l6ZTtcXG4gICAgc25hcEdyaWQgPSBzbmFwR3JpZC5tYXAoZnVuY3Rpb24gKHNuYXApIHtcXG4gICAgICBpZiAoc25hcCA8IDApIHJldHVybiAtb2Zmc2V0QmVmb3JlO1xcbiAgICAgIGlmIChzbmFwID4gbWF4U25hcCkgcmV0dXJuIG1heFNuYXAgKyBvZmZzZXRBZnRlcjtcXG4gICAgICByZXR1cm4gc25hcDtcXG4gICAgfSk7XFxuICB9XFxuXFxuICBpZiAocGFyYW1zLmNlbnRlckluc3VmZmljaWVudFNsaWRlcykge1xcbiAgICB2YXIgX2FsbFNsaWRlc1NpemUgPSAwO1xcbiAgICBzbGlkZXNTaXplc0dyaWQuZm9yRWFjaChmdW5jdGlvbiAoc2xpZGVTaXplVmFsdWUpIHtcXG4gICAgICBfYWxsU2xpZGVzU2l6ZSArPSBzbGlkZVNpemVWYWx1ZSArIChwYXJhbXMuc3BhY2VCZXR3ZWVuID8gcGFyYW1zLnNwYWNlQmV0d2VlbiA6IDApO1xcbiAgICB9KTtcXG4gICAgX2FsbFNsaWRlc1NpemUgLT0gcGFyYW1zLnNwYWNlQmV0d2VlbjtcXG5cXG4gICAgaWYgKF9hbGxTbGlkZXNTaXplIDwgc3dpcGVyU2l6ZSkge1xcbiAgICAgIHZhciBhbGxTbGlkZXNPZmZzZXQgPSAoc3dpcGVyU2l6ZSAtIF9hbGxTbGlkZXNTaXplKSAvIDI7XFxuICAgICAgc25hcEdyaWQuZm9yRWFjaChmdW5jdGlvbiAoc25hcCwgc25hcEluZGV4KSB7XFxuICAgICAgICBzbmFwR3JpZFtzbmFwSW5kZXhdID0gc25hcCAtIGFsbFNsaWRlc09mZnNldDtcXG4gICAgICB9KTtcXG4gICAgICBzbGlkZXNHcmlkLmZvckVhY2goZnVuY3Rpb24gKHNuYXAsIHNuYXBJbmRleCkge1xcbiAgICAgICAgc2xpZGVzR3JpZFtzbmFwSW5kZXhdID0gc25hcCArIGFsbFNsaWRlc09mZnNldDtcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgfVxcblxcbiAgKDAsX3V0aWxzX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uZXh0ZW5kKShzd2lwZXIsIHtcXG4gICAgc2xpZGVzOiBzbGlkZXMsXFxuICAgIHNuYXBHcmlkOiBzbmFwR3JpZCxcXG4gICAgc2xpZGVzR3JpZDogc2xpZGVzR3JpZCxcXG4gICAgc2xpZGVzU2l6ZXNHcmlkOiBzbGlkZXNTaXplc0dyaWRcXG4gIH0pO1xcblxcbiAgaWYgKHNsaWRlc0xlbmd0aCAhPT0gcHJldmlvdXNTbGlkZXNMZW5ndGgpIHtcXG4gICAgc3dpcGVyLmVtaXQoJ3NsaWRlc0xlbmd0aENoYW5nZScpO1xcbiAgfVxcblxcbiAgaWYgKHNuYXBHcmlkLmxlbmd0aCAhPT0gcHJldmlvdXNTbmFwR3JpZExlbmd0aCkge1xcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy53YXRjaE92ZXJmbG93KSBzd2lwZXIuY2hlY2tPdmVyZmxvdygpO1xcbiAgICBzd2lwZXIuZW1pdCgnc25hcEdyaWRMZW5ndGhDaGFuZ2UnKTtcXG4gIH1cXG5cXG4gIGlmIChzbGlkZXNHcmlkLmxlbmd0aCAhPT0gcHJldmlvdXNTbGlkZXNHcmlkTGVuZ3RoKSB7XFxuICAgIHN3aXBlci5lbWl0KCdzbGlkZXNHcmlkTGVuZ3RoQ2hhbmdlJyk7XFxuICB9XFxuXFxuICBpZiAocGFyYW1zLndhdGNoU2xpZGVzUHJvZ3Jlc3MgfHwgcGFyYW1zLndhdGNoU2xpZGVzVmlzaWJpbGl0eSkge1xcbiAgICBzd2lwZXIudXBkYXRlU2xpZGVzT2Zmc2V0KCk7XFxuICB9XFxufVxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3BhcnVzLy4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL3VwZGF0ZS91cGRhdGVTbGlkZXMuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS91cGRhdGUvdXBkYXRlU2xpZGVzQ2xhc3Nlcy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS91cGRhdGUvdXBkYXRlU2xpZGVzQ2xhc3Nlcy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwiZGVmYXVsdFxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIHVwZGF0ZVNsaWRlc0NsYXNzZXMpXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuZnVuY3Rpb24gdXBkYXRlU2xpZGVzQ2xhc3NlcygpIHtcXG4gIHZhciBzd2lwZXIgPSB0aGlzO1xcbiAgdmFyIHNsaWRlcyA9IHN3aXBlci5zbGlkZXMsXFxuICAgICAgcGFyYW1zID0gc3dpcGVyLnBhcmFtcyxcXG4gICAgICAkd3JhcHBlckVsID0gc3dpcGVyLiR3cmFwcGVyRWwsXFxuICAgICAgYWN0aXZlSW5kZXggPSBzd2lwZXIuYWN0aXZlSW5kZXgsXFxuICAgICAgcmVhbEluZGV4ID0gc3dpcGVyLnJlYWxJbmRleDtcXG4gIHZhciBpc1ZpcnR1YWwgPSBzd2lwZXIudmlydHVhbCAmJiBwYXJhbXMudmlydHVhbC5lbmFibGVkO1xcbiAgc2xpZGVzLnJlbW92ZUNsYXNzKHBhcmFtcy5zbGlkZUFjdGl2ZUNsYXNzICsgXFxcIiBcXFwiICsgcGFyYW1zLnNsaWRlTmV4dENsYXNzICsgXFxcIiBcXFwiICsgcGFyYW1zLnNsaWRlUHJldkNsYXNzICsgXFxcIiBcXFwiICsgcGFyYW1zLnNsaWRlRHVwbGljYXRlQWN0aXZlQ2xhc3MgKyBcXFwiIFxcXCIgKyBwYXJhbXMuc2xpZGVEdXBsaWNhdGVOZXh0Q2xhc3MgKyBcXFwiIFxcXCIgKyBwYXJhbXMuc2xpZGVEdXBsaWNhdGVQcmV2Q2xhc3MpO1xcbiAgdmFyIGFjdGl2ZVNsaWRlO1xcblxcbiAgaWYgKGlzVmlydHVhbCkge1xcbiAgICBhY3RpdmVTbGlkZSA9IHN3aXBlci4kd3JhcHBlckVsLmZpbmQoXFxcIi5cXFwiICsgcGFyYW1zLnNsaWRlQ2xhc3MgKyBcXFwiW2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVxcXFxcXFwiXFxcIiArIGFjdGl2ZUluZGV4ICsgXFxcIlxcXFxcXFwiXVxcXCIpO1xcbiAgfSBlbHNlIHtcXG4gICAgYWN0aXZlU2xpZGUgPSBzbGlkZXMuZXEoYWN0aXZlSW5kZXgpO1xcbiAgfSAvLyBBY3RpdmUgY2xhc3Nlc1xcblxcblxcbiAgYWN0aXZlU2xpZGUuYWRkQ2xhc3MocGFyYW1zLnNsaWRlQWN0aXZlQ2xhc3MpO1xcblxcbiAgaWYgKHBhcmFtcy5sb29wKSB7XFxuICAgIC8vIER1cGxpY2F0ZSB0byBhbGwgbG9vcGVkIHNsaWRlc1xcbiAgICBpZiAoYWN0aXZlU2xpZGUuaGFzQ2xhc3MocGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3MpKSB7XFxuICAgICAgJHdyYXBwZXJFbC5jaGlsZHJlbihcXFwiLlxcXCIgKyBwYXJhbXMuc2xpZGVDbGFzcyArIFxcXCI6bm90KC5cXFwiICsgcGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3MgKyBcXFwiKVtkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cXFxcXFxcIlxcXCIgKyByZWFsSW5kZXggKyBcXFwiXFxcXFxcXCJdXFxcIikuYWRkQ2xhc3MocGFyYW1zLnNsaWRlRHVwbGljYXRlQWN0aXZlQ2xhc3MpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgICR3cmFwcGVyRWwuY2hpbGRyZW4oXFxcIi5cXFwiICsgcGFyYW1zLnNsaWRlQ2xhc3MgKyBcXFwiLlxcXCIgKyBwYXJhbXMuc2xpZGVEdXBsaWNhdGVDbGFzcyArIFxcXCJbZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XFxcXFxcXCJcXFwiICsgcmVhbEluZGV4ICsgXFxcIlxcXFxcXFwiXVxcXCIpLmFkZENsYXNzKHBhcmFtcy5zbGlkZUR1cGxpY2F0ZUFjdGl2ZUNsYXNzKTtcXG4gICAgfVxcbiAgfSAvLyBOZXh0IFNsaWRlXFxuXFxuXFxuICB2YXIgbmV4dFNsaWRlID0gYWN0aXZlU2xpZGUubmV4dEFsbChcXFwiLlxcXCIgKyBwYXJhbXMuc2xpZGVDbGFzcykuZXEoMCkuYWRkQ2xhc3MocGFyYW1zLnNsaWRlTmV4dENsYXNzKTtcXG5cXG4gIGlmIChwYXJhbXMubG9vcCAmJiBuZXh0U2xpZGUubGVuZ3RoID09PSAwKSB7XFxuICAgIG5leHRTbGlkZSA9IHNsaWRlcy5lcSgwKTtcXG4gICAgbmV4dFNsaWRlLmFkZENsYXNzKHBhcmFtcy5zbGlkZU5leHRDbGFzcyk7XFxuICB9IC8vIFByZXYgU2xpZGVcXG5cXG5cXG4gIHZhciBwcmV2U2xpZGUgPSBhY3RpdmVTbGlkZS5wcmV2QWxsKFxcXCIuXFxcIiArIHBhcmFtcy5zbGlkZUNsYXNzKS5lcSgwKS5hZGRDbGFzcyhwYXJhbXMuc2xpZGVQcmV2Q2xhc3MpO1xcblxcbiAgaWYgKHBhcmFtcy5sb29wICYmIHByZXZTbGlkZS5sZW5ndGggPT09IDApIHtcXG4gICAgcHJldlNsaWRlID0gc2xpZGVzLmVxKC0xKTtcXG4gICAgcHJldlNsaWRlLmFkZENsYXNzKHBhcmFtcy5zbGlkZVByZXZDbGFzcyk7XFxuICB9XFxuXFxuICBpZiAocGFyYW1zLmxvb3ApIHtcXG4gICAgLy8gRHVwbGljYXRlIHRvIGFsbCBsb29wZWQgc2xpZGVzXFxuICAgIGlmIChuZXh0U2xpZGUuaGFzQ2xhc3MocGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3MpKSB7XFxuICAgICAgJHdyYXBwZXJFbC5jaGlsZHJlbihcXFwiLlxcXCIgKyBwYXJhbXMuc2xpZGVDbGFzcyArIFxcXCI6bm90KC5cXFwiICsgcGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3MgKyBcXFwiKVtkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cXFxcXFxcIlxcXCIgKyBuZXh0U2xpZGUuYXR0cignZGF0YS1zd2lwZXItc2xpZGUtaW5kZXgnKSArIFxcXCJcXFxcXFxcIl1cXFwiKS5hZGRDbGFzcyhwYXJhbXMuc2xpZGVEdXBsaWNhdGVOZXh0Q2xhc3MpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgICR3cmFwcGVyRWwuY2hpbGRyZW4oXFxcIi5cXFwiICsgcGFyYW1zLnNsaWRlQ2xhc3MgKyBcXFwiLlxcXCIgKyBwYXJhbXMuc2xpZGVEdXBsaWNhdGVDbGFzcyArIFxcXCJbZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XFxcXFxcXCJcXFwiICsgbmV4dFNsaWRlLmF0dHIoJ2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4JykgKyBcXFwiXFxcXFxcXCJdXFxcIikuYWRkQ2xhc3MocGFyYW1zLnNsaWRlRHVwbGljYXRlTmV4dENsYXNzKTtcXG4gICAgfVxcblxcbiAgICBpZiAocHJldlNsaWRlLmhhc0NsYXNzKHBhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzKSkge1xcbiAgICAgICR3cmFwcGVyRWwuY2hpbGRyZW4oXFxcIi5cXFwiICsgcGFyYW1zLnNsaWRlQ2xhc3MgKyBcXFwiOm5vdCguXFxcIiArIHBhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzICsgXFxcIilbZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XFxcXFxcXCJcXFwiICsgcHJldlNsaWRlLmF0dHIoJ2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4JykgKyBcXFwiXFxcXFxcXCJdXFxcIikuYWRkQ2xhc3MocGFyYW1zLnNsaWRlRHVwbGljYXRlUHJldkNsYXNzKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAkd3JhcHBlckVsLmNoaWxkcmVuKFxcXCIuXFxcIiArIHBhcmFtcy5zbGlkZUNsYXNzICsgXFxcIi5cXFwiICsgcGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3MgKyBcXFwiW2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVxcXFxcXFwiXFxcIiArIHByZXZTbGlkZS5hdHRyKCdkYXRhLXN3aXBlci1zbGlkZS1pbmRleCcpICsgXFxcIlxcXFxcXFwiXVxcXCIpLmFkZENsYXNzKHBhcmFtcy5zbGlkZUR1cGxpY2F0ZVByZXZDbGFzcyk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHN3aXBlci5lbWl0U2xpZGVzQ2xhc3NlcygpO1xcbn1cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9wYXJ1cy8uL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS91cGRhdGUvdXBkYXRlU2xpZGVzQ2xhc3Nlcy5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL3VwZGF0ZS91cGRhdGVTbGlkZXNPZmZzZXQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvY29yZS91cGRhdGUvdXBkYXRlU2xpZGVzT2Zmc2V0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcImRlZmF1bHRcXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyB1cGRhdGVTbGlkZXNPZmZzZXQpXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuZnVuY3Rpb24gdXBkYXRlU2xpZGVzT2Zmc2V0KCkge1xcbiAgdmFyIHN3aXBlciA9IHRoaXM7XFxuICB2YXIgc2xpZGVzID0gc3dpcGVyLnNsaWRlcztcXG5cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpZGVzLmxlbmd0aDsgaSArPSAxKSB7XFxuICAgIHNsaWRlc1tpXS5zd2lwZXJTbGlkZU9mZnNldCA9IHN3aXBlci5pc0hvcml6b250YWwoKSA/IHNsaWRlc1tpXS5vZmZzZXRMZWZ0IDogc2xpZGVzW2ldLm9mZnNldFRvcDtcXG4gIH1cXG59XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vcGFydXMvLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvdXBkYXRlL3VwZGF0ZVNsaWRlc09mZnNldC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL3VwZGF0ZS91cGRhdGVTbGlkZXNQcm9ncmVzcy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvdXBkYXRlL3VwZGF0ZVNsaWRlc1Byb2dyZXNzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwiZGVmYXVsdFxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIHVwZGF0ZVNsaWRlc1Byb2dyZXNzKVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfZG9tX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi8uLi91dGlscy9kb20gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vdXRpbHMvZG9tLmpzXFxcIik7XFxuXFxuZnVuY3Rpb24gdXBkYXRlU2xpZGVzUHJvZ3Jlc3ModHJhbnNsYXRlKSB7XFxuICBpZiAodHJhbnNsYXRlID09PSB2b2lkIDApIHtcXG4gICAgdHJhbnNsYXRlID0gdGhpcyAmJiB0aGlzLnRyYW5zbGF0ZSB8fCAwO1xcbiAgfVxcblxcbiAgdmFyIHN3aXBlciA9IHRoaXM7XFxuICB2YXIgcGFyYW1zID0gc3dpcGVyLnBhcmFtcztcXG4gIHZhciBzbGlkZXMgPSBzd2lwZXIuc2xpZGVzLFxcbiAgICAgIHJ0bCA9IHN3aXBlci5ydGxUcmFuc2xhdGU7XFxuICBpZiAoc2xpZGVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xcbiAgaWYgKHR5cGVvZiBzbGlkZXNbMF0uc3dpcGVyU2xpZGVPZmZzZXQgPT09ICd1bmRlZmluZWQnKSBzd2lwZXIudXBkYXRlU2xpZGVzT2Zmc2V0KCk7XFxuICB2YXIgb2Zmc2V0Q2VudGVyID0gLXRyYW5zbGF0ZTtcXG4gIGlmIChydGwpIG9mZnNldENlbnRlciA9IHRyYW5zbGF0ZTsgLy8gVmlzaWJsZSBTbGlkZXNcXG5cXG4gIHNsaWRlcy5yZW1vdmVDbGFzcyhwYXJhbXMuc2xpZGVWaXNpYmxlQ2xhc3MpO1xcbiAgc3dpcGVyLnZpc2libGVTbGlkZXNJbmRleGVzID0gW107XFxuICBzd2lwZXIudmlzaWJsZVNsaWRlcyA9IFtdO1xcblxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGlkZXMubGVuZ3RoOyBpICs9IDEpIHtcXG4gICAgdmFyIHNsaWRlID0gc2xpZGVzW2ldO1xcbiAgICB2YXIgc2xpZGVQcm9ncmVzcyA9IChvZmZzZXRDZW50ZXIgKyAocGFyYW1zLmNlbnRlcmVkU2xpZGVzID8gc3dpcGVyLm1pblRyYW5zbGF0ZSgpIDogMCkgLSBzbGlkZS5zd2lwZXJTbGlkZU9mZnNldCkgLyAoc2xpZGUuc3dpcGVyU2xpZGVTaXplICsgcGFyYW1zLnNwYWNlQmV0d2Vlbik7XFxuXFxuICAgIGlmIChwYXJhbXMud2F0Y2hTbGlkZXNWaXNpYmlsaXR5IHx8IHBhcmFtcy5jZW50ZXJlZFNsaWRlcyAmJiBwYXJhbXMuYXV0b0hlaWdodCkge1xcbiAgICAgIHZhciBzbGlkZUJlZm9yZSA9IC0ob2Zmc2V0Q2VudGVyIC0gc2xpZGUuc3dpcGVyU2xpZGVPZmZzZXQpO1xcbiAgICAgIHZhciBzbGlkZUFmdGVyID0gc2xpZGVCZWZvcmUgKyBzd2lwZXIuc2xpZGVzU2l6ZXNHcmlkW2ldO1xcbiAgICAgIHZhciBpc1Zpc2libGUgPSBzbGlkZUJlZm9yZSA+PSAwICYmIHNsaWRlQmVmb3JlIDwgc3dpcGVyLnNpemUgLSAxIHx8IHNsaWRlQWZ0ZXIgPiAxICYmIHNsaWRlQWZ0ZXIgPD0gc3dpcGVyLnNpemUgfHwgc2xpZGVCZWZvcmUgPD0gMCAmJiBzbGlkZUFmdGVyID49IHN3aXBlci5zaXplO1xcblxcbiAgICAgIGlmIChpc1Zpc2libGUpIHtcXG4gICAgICAgIHN3aXBlci52aXNpYmxlU2xpZGVzLnB1c2goc2xpZGUpO1xcbiAgICAgICAgc3dpcGVyLnZpc2libGVTbGlkZXNJbmRleGVzLnB1c2goaSk7XFxuICAgICAgICBzbGlkZXMuZXEoaSkuYWRkQ2xhc3MocGFyYW1zLnNsaWRlVmlzaWJsZUNsYXNzKTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgc2xpZGUucHJvZ3Jlc3MgPSBydGwgPyAtc2xpZGVQcm9ncmVzcyA6IHNsaWRlUHJvZ3Jlc3M7XFxuICB9XFxuXFxuICBzd2lwZXIudmlzaWJsZVNsaWRlcyA9ICgwLF91dGlsc19kb21fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiZGVmYXVsdFxcXCJdKShzd2lwZXIudmlzaWJsZVNsaWRlcyk7XFxufVxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3BhcnVzLy4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9jb3JlL3VwZGF0ZS91cGRhdGVTbGlkZXNQcm9ncmVzcy5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9uYXZpZ2F0aW9uL25hdmlnYXRpb24uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvbmF2aWdhdGlvbi9uYXZpZ2F0aW9uLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcImRlZmF1bHRcXFwiOiAoKSA9PiAoX19XRUJQQUNLX0RFRkFVTFRfRVhQT1JUX18pXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19kb21fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3V0aWxzL2RvbSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS91dGlscy9kb20uanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi91dGlscy91dGlscyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS91dGlscy91dGlscy5qc1xcXCIpO1xcbmZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XFxuXFxuXFxuXFxudmFyIE5hdmlnYXRpb24gPSB7XFxuICB0b2dnbGVFbDogZnVuY3Rpb24gdG9nZ2xlRWwoJGVsLCBkaXNhYmxlZCkge1xcbiAgICAkZWxbZGlzYWJsZWQgPyAnYWRkQ2xhc3MnIDogJ3JlbW92ZUNsYXNzJ10odGhpcy5wYXJhbXMubmF2aWdhdGlvbi5kaXNhYmxlZENsYXNzKTtcXG4gICAgaWYgKCRlbFswXSAmJiAkZWxbMF0udGFnTmFtZSA9PT0gJ0JVVFRPTicpICRlbFswXS5kaXNhYmxlZCA9IGRpc2FibGVkO1xcbiAgfSxcXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKCkge1xcbiAgICAvLyBVcGRhdGUgTmF2aWdhdGlvbiBCdXR0b25zXFxuICAgIHZhciBzd2lwZXIgPSB0aGlzO1xcbiAgICB2YXIgcGFyYW1zID0gc3dpcGVyLnBhcmFtcy5uYXZpZ2F0aW9uO1xcbiAgICB2YXIgdG9nZ2xlRWwgPSBzd2lwZXIubmF2aWdhdGlvbi50b2dnbGVFbDtcXG4gICAgaWYgKHN3aXBlci5wYXJhbXMubG9vcCkgcmV0dXJuO1xcbiAgICB2YXIgX3N3aXBlciRuYXZpZ2F0aW9uID0gc3dpcGVyLm5hdmlnYXRpb24sXFxuICAgICAgICAkbmV4dEVsID0gX3N3aXBlciRuYXZpZ2F0aW9uLiRuZXh0RWwsXFxuICAgICAgICAkcHJldkVsID0gX3N3aXBlciRuYXZpZ2F0aW9uLiRwcmV2RWw7XFxuXFxuICAgIGlmICgkcHJldkVsICYmICRwcmV2RWwubGVuZ3RoID4gMCkge1xcbiAgICAgIGlmIChzd2lwZXIuaXNCZWdpbm5pbmcpIHtcXG4gICAgICAgIHRvZ2dsZUVsKCRwcmV2RWwsIHRydWUpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB0b2dnbGVFbCgkcHJldkVsLCBmYWxzZSk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChzd2lwZXIucGFyYW1zLndhdGNoT3ZlcmZsb3cgJiYgc3dpcGVyLmVuYWJsZWQpIHtcXG4gICAgICAgICRwcmV2RWxbc3dpcGVyLmlzTG9ja2VkID8gJ2FkZENsYXNzJyA6ICdyZW1vdmVDbGFzcyddKHBhcmFtcy5sb2NrQ2xhc3MpO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBpZiAoJG5leHRFbCAmJiAkbmV4dEVsLmxlbmd0aCA+IDApIHtcXG4gICAgICBpZiAoc3dpcGVyLmlzRW5kKSB7XFxuICAgICAgICB0b2dnbGVFbCgkbmV4dEVsLCB0cnVlKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdG9nZ2xlRWwoJG5leHRFbCwgZmFsc2UpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoc3dpcGVyLnBhcmFtcy53YXRjaE92ZXJmbG93ICYmIHN3aXBlci5lbmFibGVkKSB7XFxuICAgICAgICAkbmV4dEVsW3N3aXBlci5pc0xvY2tlZCA/ICdhZGRDbGFzcycgOiAncmVtb3ZlQ2xhc3MnXShwYXJhbXMubG9ja0NsYXNzKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH0sXFxuICBvblByZXZDbGljazogZnVuY3Rpb24gb25QcmV2Q2xpY2soZSkge1xcbiAgICB2YXIgc3dpcGVyID0gdGhpcztcXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICBpZiAoc3dpcGVyLmlzQmVnaW5uaW5nICYmICFzd2lwZXIucGFyYW1zLmxvb3ApIHJldHVybjtcXG4gICAgc3dpcGVyLnNsaWRlUHJldigpO1xcbiAgfSxcXG4gIG9uTmV4dENsaWNrOiBmdW5jdGlvbiBvbk5leHRDbGljayhlKSB7XFxuICAgIHZhciBzd2lwZXIgPSB0aGlzO1xcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgIGlmIChzd2lwZXIuaXNFbmQgJiYgIXN3aXBlci5wYXJhbXMubG9vcCkgcmV0dXJuO1xcbiAgICBzd2lwZXIuc2xpZGVOZXh0KCk7XFxuICB9LFxcbiAgaW5pdDogZnVuY3Rpb24gaW5pdCgpIHtcXG4gICAgdmFyIHN3aXBlciA9IHRoaXM7XFxuICAgIHZhciBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLm5hdmlnYXRpb247XFxuICAgIHN3aXBlci5wYXJhbXMubmF2aWdhdGlvbiA9ICgwLF91dGlsc191dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLmNyZWF0ZUVsZW1lbnRJZk5vdERlZmluZWQpKHN3aXBlci4kZWwsIHN3aXBlci5wYXJhbXMubmF2aWdhdGlvbiwgc3dpcGVyLnBhcmFtcy5jcmVhdGVFbGVtZW50cywge1xcbiAgICAgIG5leHRFbDogJ3N3aXBlci1idXR0b24tbmV4dCcsXFxuICAgICAgcHJldkVsOiAnc3dpcGVyLWJ1dHRvbi1wcmV2J1xcbiAgICB9KTtcXG4gICAgaWYgKCEocGFyYW1zLm5leHRFbCB8fCBwYXJhbXMucHJldkVsKSkgcmV0dXJuO1xcbiAgICB2YXIgJG5leHRFbDtcXG4gICAgdmFyICRwcmV2RWw7XFxuXFxuICAgIGlmIChwYXJhbXMubmV4dEVsKSB7XFxuICAgICAgJG5leHRFbCA9ICgwLF91dGlsc19kb21fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiZGVmYXVsdFxcXCJdKShwYXJhbXMubmV4dEVsKTtcXG5cXG4gICAgICBpZiAoc3dpcGVyLnBhcmFtcy51bmlxdWVOYXZFbGVtZW50cyAmJiB0eXBlb2YgcGFyYW1zLm5leHRFbCA9PT0gJ3N0cmluZycgJiYgJG5leHRFbC5sZW5ndGggPiAxICYmIHN3aXBlci4kZWwuZmluZChwYXJhbXMubmV4dEVsKS5sZW5ndGggPT09IDEpIHtcXG4gICAgICAgICRuZXh0RWwgPSBzd2lwZXIuJGVsLmZpbmQocGFyYW1zLm5leHRFbCk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGlmIChwYXJhbXMucHJldkVsKSB7XFxuICAgICAgJHByZXZFbCA9ICgwLF91dGlsc19kb21fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiZGVmYXVsdFxcXCJdKShwYXJhbXMucHJldkVsKTtcXG5cXG4gICAgICBpZiAoc3dpcGVyLnBhcmFtcy51bmlxdWVOYXZFbGVtZW50cyAmJiB0eXBlb2YgcGFyYW1zLnByZXZFbCA9PT0gJ3N0cmluZycgJiYgJHByZXZFbC5sZW5ndGggPiAxICYmIHN3aXBlci4kZWwuZmluZChwYXJhbXMucHJldkVsKS5sZW5ndGggPT09IDEpIHtcXG4gICAgICAgICRwcmV2RWwgPSBzd2lwZXIuJGVsLmZpbmQocGFyYW1zLnByZXZFbCk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGlmICgkbmV4dEVsICYmICRuZXh0RWwubGVuZ3RoID4gMCkge1xcbiAgICAgICRuZXh0RWwub24oJ2NsaWNrJywgc3dpcGVyLm5hdmlnYXRpb24ub25OZXh0Q2xpY2spO1xcbiAgICB9XFxuXFxuICAgIGlmICgkcHJldkVsICYmICRwcmV2RWwubGVuZ3RoID4gMCkge1xcbiAgICAgICRwcmV2RWwub24oJ2NsaWNrJywgc3dpcGVyLm5hdmlnYXRpb24ub25QcmV2Q2xpY2spO1xcbiAgICB9XFxuXFxuICAgICgwLF91dGlsc191dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLmV4dGVuZCkoc3dpcGVyLm5hdmlnYXRpb24sIHtcXG4gICAgICAkbmV4dEVsOiAkbmV4dEVsLFxcbiAgICAgIG5leHRFbDogJG5leHRFbCAmJiAkbmV4dEVsWzBdLFxcbiAgICAgICRwcmV2RWw6ICRwcmV2RWwsXFxuICAgICAgcHJldkVsOiAkcHJldkVsICYmICRwcmV2RWxbMF1cXG4gICAgfSk7XFxuXFxuICAgIGlmICghc3dpcGVyLmVuYWJsZWQpIHtcXG4gICAgICBpZiAoJG5leHRFbCkgJG5leHRFbC5hZGRDbGFzcyhwYXJhbXMubG9ja0NsYXNzKTtcXG4gICAgICBpZiAoJHByZXZFbCkgJHByZXZFbC5hZGRDbGFzcyhwYXJhbXMubG9ja0NsYXNzKTtcXG4gICAgfVxcbiAgfSxcXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XFxuICAgIHZhciBzd2lwZXIgPSB0aGlzO1xcbiAgICB2YXIgX3N3aXBlciRuYXZpZ2F0aW9uMiA9IHN3aXBlci5uYXZpZ2F0aW9uLFxcbiAgICAgICAgJG5leHRFbCA9IF9zd2lwZXIkbmF2aWdhdGlvbjIuJG5leHRFbCxcXG4gICAgICAgICRwcmV2RWwgPSBfc3dpcGVyJG5hdmlnYXRpb24yLiRwcmV2RWw7XFxuXFxuICAgIGlmICgkbmV4dEVsICYmICRuZXh0RWwubGVuZ3RoKSB7XFxuICAgICAgJG5leHRFbC5vZmYoJ2NsaWNrJywgc3dpcGVyLm5hdmlnYXRpb24ub25OZXh0Q2xpY2spO1xcbiAgICAgICRuZXh0RWwucmVtb3ZlQ2xhc3Moc3dpcGVyLnBhcmFtcy5uYXZpZ2F0aW9uLmRpc2FibGVkQ2xhc3MpO1xcbiAgICB9XFxuXFxuICAgIGlmICgkcHJldkVsICYmICRwcmV2RWwubGVuZ3RoKSB7XFxuICAgICAgJHByZXZFbC5vZmYoJ2NsaWNrJywgc3dpcGVyLm5hdmlnYXRpb24ub25QcmV2Q2xpY2spO1xcbiAgICAgICRwcmV2RWwucmVtb3ZlQ2xhc3Moc3dpcGVyLnBhcmFtcy5uYXZpZ2F0aW9uLmRpc2FibGVkQ2xhc3MpO1xcbiAgICB9XFxuICB9XFxufTtcXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IF9fV0VCUEFDS19ERUZBVUxUX0VYUE9SVF9fID0gKHtcXG4gIG5hbWU6ICduYXZpZ2F0aW9uJyxcXG4gIHBhcmFtczoge1xcbiAgICBuYXZpZ2F0aW9uOiB7XFxuICAgICAgbmV4dEVsOiBudWxsLFxcbiAgICAgIHByZXZFbDogbnVsbCxcXG4gICAgICBoaWRlT25DbGljazogZmFsc2UsXFxuICAgICAgZGlzYWJsZWRDbGFzczogJ3N3aXBlci1idXR0b24tZGlzYWJsZWQnLFxcbiAgICAgIGhpZGRlbkNsYXNzOiAnc3dpcGVyLWJ1dHRvbi1oaWRkZW4nLFxcbiAgICAgIGxvY2tDbGFzczogJ3N3aXBlci1idXR0b24tbG9jaydcXG4gICAgfVxcbiAgfSxcXG4gIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKCkge1xcbiAgICB2YXIgc3dpcGVyID0gdGhpcztcXG4gICAgKDAsX3V0aWxzX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uYmluZE1vZHVsZU1ldGhvZHMpKHN3aXBlciwge1xcbiAgICAgIG5hdmlnYXRpb246IF9leHRlbmRzKHt9LCBOYXZpZ2F0aW9uKVxcbiAgICB9KTtcXG4gIH0sXFxuICBvbjoge1xcbiAgICBpbml0OiBmdW5jdGlvbiBpbml0KHN3aXBlcikge1xcbiAgICAgIHN3aXBlci5uYXZpZ2F0aW9uLmluaXQoKTtcXG4gICAgICBzd2lwZXIubmF2aWdhdGlvbi51cGRhdGUoKTtcXG4gICAgfSxcXG4gICAgdG9FZGdlOiBmdW5jdGlvbiB0b0VkZ2Uoc3dpcGVyKSB7XFxuICAgICAgc3dpcGVyLm5hdmlnYXRpb24udXBkYXRlKCk7XFxuICAgIH0sXFxuICAgIGZyb21FZGdlOiBmdW5jdGlvbiBmcm9tRWRnZShzd2lwZXIpIHtcXG4gICAgICBzd2lwZXIubmF2aWdhdGlvbi51cGRhdGUoKTtcXG4gICAgfSxcXG4gICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveShzd2lwZXIpIHtcXG4gICAgICBzd2lwZXIubmF2aWdhdGlvbi5kZXN0cm95KCk7XFxuICAgIH0sXFxuICAgICdlbmFibGUgZGlzYWJsZSc6IGZ1bmN0aW9uIGVuYWJsZURpc2FibGUoc3dpcGVyKSB7XFxuICAgICAgdmFyIF9zd2lwZXIkbmF2aWdhdGlvbjMgPSBzd2lwZXIubmF2aWdhdGlvbixcXG4gICAgICAgICAgJG5leHRFbCA9IF9zd2lwZXIkbmF2aWdhdGlvbjMuJG5leHRFbCxcXG4gICAgICAgICAgJHByZXZFbCA9IF9zd2lwZXIkbmF2aWdhdGlvbjMuJHByZXZFbDtcXG5cXG4gICAgICBpZiAoJG5leHRFbCkge1xcbiAgICAgICAgJG5leHRFbFtzd2lwZXIuZW5hYmxlZCA/ICdyZW1vdmVDbGFzcycgOiAnYWRkQ2xhc3MnXShzd2lwZXIucGFyYW1zLm5hdmlnYXRpb24ubG9ja0NsYXNzKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCRwcmV2RWwpIHtcXG4gICAgICAgICRwcmV2RWxbc3dpcGVyLmVuYWJsZWQgPyAncmVtb3ZlQ2xhc3MnIDogJ2FkZENsYXNzJ10oc3dpcGVyLnBhcmFtcy5uYXZpZ2F0aW9uLmxvY2tDbGFzcyk7XFxuICAgICAgfVxcbiAgICB9LFxcbiAgICBjbGljazogZnVuY3Rpb24gY2xpY2soc3dpcGVyLCBlKSB7XFxuICAgICAgdmFyIF9zd2lwZXIkbmF2aWdhdGlvbjQgPSBzd2lwZXIubmF2aWdhdGlvbixcXG4gICAgICAgICAgJG5leHRFbCA9IF9zd2lwZXIkbmF2aWdhdGlvbjQuJG5leHRFbCxcXG4gICAgICAgICAgJHByZXZFbCA9IF9zd2lwZXIkbmF2aWdhdGlvbjQuJHByZXZFbDtcXG4gICAgICB2YXIgdGFyZ2V0RWwgPSBlLnRhcmdldDtcXG5cXG4gICAgICBpZiAoc3dpcGVyLnBhcmFtcy5uYXZpZ2F0aW9uLmhpZGVPbkNsaWNrICYmICEoMCxfdXRpbHNfZG9tX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImRlZmF1bHRcXFwiXSkodGFyZ2V0RWwpLmlzKCRwcmV2RWwpICYmICEoMCxfdXRpbHNfZG9tX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImRlZmF1bHRcXFwiXSkodGFyZ2V0RWwpLmlzKCRuZXh0RWwpKSB7XFxuICAgICAgICBpZiAoc3dpcGVyLnBhZ2luYXRpb24gJiYgc3dpcGVyLnBhcmFtcy5wYWdpbmF0aW9uICYmIHN3aXBlci5wYXJhbXMucGFnaW5hdGlvbi5jbGlja2FibGUgJiYgKHN3aXBlci5wYWdpbmF0aW9uLmVsID09PSB0YXJnZXRFbCB8fCBzd2lwZXIucGFnaW5hdGlvbi5lbC5jb250YWlucyh0YXJnZXRFbCkpKSByZXR1cm47XFxuICAgICAgICB2YXIgaXNIaWRkZW47XFxuXFxuICAgICAgICBpZiAoJG5leHRFbCkge1xcbiAgICAgICAgICBpc0hpZGRlbiA9ICRuZXh0RWwuaGFzQ2xhc3Moc3dpcGVyLnBhcmFtcy5uYXZpZ2F0aW9uLmhpZGRlbkNsYXNzKTtcXG4gICAgICAgIH0gZWxzZSBpZiAoJHByZXZFbCkge1xcbiAgICAgICAgICBpc0hpZGRlbiA9ICRwcmV2RWwuaGFzQ2xhc3Moc3dpcGVyLnBhcmFtcy5uYXZpZ2F0aW9uLmhpZGRlbkNsYXNzKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChpc0hpZGRlbiA9PT0gdHJ1ZSkge1xcbiAgICAgICAgICBzd2lwZXIuZW1pdCgnbmF2aWdhdGlvblNob3cnKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHN3aXBlci5lbWl0KCduYXZpZ2F0aW9uSGlkZScpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKCRuZXh0RWwpIHtcXG4gICAgICAgICAgJG5leHRFbC50b2dnbGVDbGFzcyhzd2lwZXIucGFyYW1zLm5hdmlnYXRpb24uaGlkZGVuQ2xhc3MpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKCRwcmV2RWwpIHtcXG4gICAgICAgICAgJHByZXZFbC50b2dnbGVDbGFzcyhzd2lwZXIucGFyYW1zLm5hdmlnYXRpb24uaGlkZGVuQ2xhc3MpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcbn0pO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3BhcnVzLy4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy9uYXZpZ2F0aW9uL25hdmlnYXRpb24uanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvcGFnaW5hdGlvbi9wYWdpbmF0aW9uLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL3BhZ2luYXRpb24vcGFnaW5hdGlvbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJkZWZhdWx0XFxcIjogKCkgPT4gKF9fV0VCUEFDS19ERUZBVUxUX0VYUE9SVF9fKVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfZG9tX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi91dGlscy9kb20gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vdXRpbHMvZG9tLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc191dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vdXRpbHMvdXRpbHMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vdXRpbHMvdXRpbHMuanNcXFwiKTtcXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxcblxcblxcblxcbnZhciBQYWdpbmF0aW9uID0ge1xcbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUoKSB7XFxuICAgIC8vIFJlbmRlciB8fCBVcGRhdGUgUGFnaW5hdGlvbiBidWxsZXRzL2l0ZW1zXFxuICAgIHZhciBzd2lwZXIgPSB0aGlzO1xcbiAgICB2YXIgcnRsID0gc3dpcGVyLnJ0bDtcXG4gICAgdmFyIHBhcmFtcyA9IHN3aXBlci5wYXJhbXMucGFnaW5hdGlvbjtcXG4gICAgaWYgKCFwYXJhbXMuZWwgfHwgIXN3aXBlci5wYWdpbmF0aW9uLmVsIHx8ICFzd2lwZXIucGFnaW5hdGlvbi4kZWwgfHwgc3dpcGVyLnBhZ2luYXRpb24uJGVsLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xcbiAgICB2YXIgc2xpZGVzTGVuZ3RoID0gc3dpcGVyLnZpcnR1YWwgJiYgc3dpcGVyLnBhcmFtcy52aXJ0dWFsLmVuYWJsZWQgPyBzd2lwZXIudmlydHVhbC5zbGlkZXMubGVuZ3RoIDogc3dpcGVyLnNsaWRlcy5sZW5ndGg7XFxuICAgIHZhciAkZWwgPSBzd2lwZXIucGFnaW5hdGlvbi4kZWw7IC8vIEN1cnJlbnQvVG90YWxcXG5cXG4gICAgdmFyIGN1cnJlbnQ7XFxuICAgIHZhciB0b3RhbCA9IHN3aXBlci5wYXJhbXMubG9vcCA/IE1hdGguY2VpbCgoc2xpZGVzTGVuZ3RoIC0gc3dpcGVyLmxvb3BlZFNsaWRlcyAqIDIpIC8gc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJHcm91cCkgOiBzd2lwZXIuc25hcEdyaWQubGVuZ3RoO1xcblxcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy5sb29wKSB7XFxuICAgICAgY3VycmVudCA9IE1hdGguY2VpbCgoc3dpcGVyLmFjdGl2ZUluZGV4IC0gc3dpcGVyLmxvb3BlZFNsaWRlcykgLyBzd2lwZXIucGFyYW1zLnNsaWRlc1Blckdyb3VwKTtcXG5cXG4gICAgICBpZiAoY3VycmVudCA+IHNsaWRlc0xlbmd0aCAtIDEgLSBzd2lwZXIubG9vcGVkU2xpZGVzICogMikge1xcbiAgICAgICAgY3VycmVudCAtPSBzbGlkZXNMZW5ndGggLSBzd2lwZXIubG9vcGVkU2xpZGVzICogMjtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGN1cnJlbnQgPiB0b3RhbCAtIDEpIGN1cnJlbnQgLT0gdG90YWw7XFxuICAgICAgaWYgKGN1cnJlbnQgPCAwICYmIHN3aXBlci5wYXJhbXMucGFnaW5hdGlvblR5cGUgIT09ICdidWxsZXRzJykgY3VycmVudCA9IHRvdGFsICsgY3VycmVudDtcXG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc3dpcGVyLnNuYXBJbmRleCAhPT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICBjdXJyZW50ID0gc3dpcGVyLnNuYXBJbmRleDtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBjdXJyZW50ID0gc3dpcGVyLmFjdGl2ZUluZGV4IHx8IDA7XFxuICAgIH0gLy8gVHlwZXNcXG5cXG5cXG4gICAgaWYgKHBhcmFtcy50eXBlID09PSAnYnVsbGV0cycgJiYgc3dpcGVyLnBhZ2luYXRpb24uYnVsbGV0cyAmJiBzd2lwZXIucGFnaW5hdGlvbi5idWxsZXRzLmxlbmd0aCA+IDApIHtcXG4gICAgICB2YXIgYnVsbGV0cyA9IHN3aXBlci5wYWdpbmF0aW9uLmJ1bGxldHM7XFxuICAgICAgdmFyIGZpcnN0SW5kZXg7XFxuICAgICAgdmFyIGxhc3RJbmRleDtcXG4gICAgICB2YXIgbWlkSW5kZXg7XFxuXFxuICAgICAgaWYgKHBhcmFtcy5keW5hbWljQnVsbGV0cykge1xcbiAgICAgICAgc3dpcGVyLnBhZ2luYXRpb24uYnVsbGV0U2l6ZSA9IGJ1bGxldHMuZXEoMClbc3dpcGVyLmlzSG9yaXpvbnRhbCgpID8gJ291dGVyV2lkdGgnIDogJ291dGVySGVpZ2h0J10odHJ1ZSk7XFxuICAgICAgICAkZWwuY3NzKHN3aXBlci5pc0hvcml6b250YWwoKSA/ICd3aWR0aCcgOiAnaGVpZ2h0Jywgc3dpcGVyLnBhZ2luYXRpb24uYnVsbGV0U2l6ZSAqIChwYXJhbXMuZHluYW1pY01haW5CdWxsZXRzICsgNCkgKyBcXFwicHhcXFwiKTtcXG5cXG4gICAgICAgIGlmIChwYXJhbXMuZHluYW1pY01haW5CdWxsZXRzID4gMSAmJiBzd2lwZXIucHJldmlvdXNJbmRleCAhPT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgIHN3aXBlci5wYWdpbmF0aW9uLmR5bmFtaWNCdWxsZXRJbmRleCArPSBjdXJyZW50IC0gc3dpcGVyLnByZXZpb3VzSW5kZXg7XFxuXFxuICAgICAgICAgIGlmIChzd2lwZXIucGFnaW5hdGlvbi5keW5hbWljQnVsbGV0SW5kZXggPiBwYXJhbXMuZHluYW1pY01haW5CdWxsZXRzIC0gMSkge1xcbiAgICAgICAgICAgIHN3aXBlci5wYWdpbmF0aW9uLmR5bmFtaWNCdWxsZXRJbmRleCA9IHBhcmFtcy5keW5hbWljTWFpbkJ1bGxldHMgLSAxO1xcbiAgICAgICAgICB9IGVsc2UgaWYgKHN3aXBlci5wYWdpbmF0aW9uLmR5bmFtaWNCdWxsZXRJbmRleCA8IDApIHtcXG4gICAgICAgICAgICBzd2lwZXIucGFnaW5hdGlvbi5keW5hbWljQnVsbGV0SW5kZXggPSAwO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICBmaXJzdEluZGV4ID0gY3VycmVudCAtIHN3aXBlci5wYWdpbmF0aW9uLmR5bmFtaWNCdWxsZXRJbmRleDtcXG4gICAgICAgIGxhc3RJbmRleCA9IGZpcnN0SW5kZXggKyAoTWF0aC5taW4oYnVsbGV0cy5sZW5ndGgsIHBhcmFtcy5keW5hbWljTWFpbkJ1bGxldHMpIC0gMSk7XFxuICAgICAgICBtaWRJbmRleCA9IChsYXN0SW5kZXggKyBmaXJzdEluZGV4KSAvIDI7XFxuICAgICAgfVxcblxcbiAgICAgIGJ1bGxldHMucmVtb3ZlQ2xhc3MocGFyYW1zLmJ1bGxldEFjdGl2ZUNsYXNzICsgXFxcIiBcXFwiICsgcGFyYW1zLmJ1bGxldEFjdGl2ZUNsYXNzICsgXFxcIi1uZXh0IFxcXCIgKyBwYXJhbXMuYnVsbGV0QWN0aXZlQ2xhc3MgKyBcXFwiLW5leHQtbmV4dCBcXFwiICsgcGFyYW1zLmJ1bGxldEFjdGl2ZUNsYXNzICsgXFxcIi1wcmV2IFxcXCIgKyBwYXJhbXMuYnVsbGV0QWN0aXZlQ2xhc3MgKyBcXFwiLXByZXYtcHJldiBcXFwiICsgcGFyYW1zLmJ1bGxldEFjdGl2ZUNsYXNzICsgXFxcIi1tYWluXFxcIik7XFxuXFxuICAgICAgaWYgKCRlbC5sZW5ndGggPiAxKSB7XFxuICAgICAgICBidWxsZXRzLmVhY2goZnVuY3Rpb24gKGJ1bGxldCkge1xcbiAgICAgICAgICB2YXIgJGJ1bGxldCA9ICgwLF91dGlsc19kb21fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiZGVmYXVsdFxcXCJdKShidWxsZXQpO1xcbiAgICAgICAgICB2YXIgYnVsbGV0SW5kZXggPSAkYnVsbGV0LmluZGV4KCk7XFxuXFxuICAgICAgICAgIGlmIChidWxsZXRJbmRleCA9PT0gY3VycmVudCkge1xcbiAgICAgICAgICAgICRidWxsZXQuYWRkQ2xhc3MocGFyYW1zLmJ1bGxldEFjdGl2ZUNsYXNzKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAocGFyYW1zLmR5bmFtaWNCdWxsZXRzKSB7XFxuICAgICAgICAgICAgaWYgKGJ1bGxldEluZGV4ID49IGZpcnN0SW5kZXggJiYgYnVsbGV0SW5kZXggPD0gbGFzdEluZGV4KSB7XFxuICAgICAgICAgICAgICAkYnVsbGV0LmFkZENsYXNzKHBhcmFtcy5idWxsZXRBY3RpdmVDbGFzcyArIFxcXCItbWFpblxcXCIpO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBpZiAoYnVsbGV0SW5kZXggPT09IGZpcnN0SW5kZXgpIHtcXG4gICAgICAgICAgICAgICRidWxsZXQucHJldigpLmFkZENsYXNzKHBhcmFtcy5idWxsZXRBY3RpdmVDbGFzcyArIFxcXCItcHJldlxcXCIpLnByZXYoKS5hZGRDbGFzcyhwYXJhbXMuYnVsbGV0QWN0aXZlQ2xhc3MgKyBcXFwiLXByZXYtcHJldlxcXCIpO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBpZiAoYnVsbGV0SW5kZXggPT09IGxhc3RJbmRleCkge1xcbiAgICAgICAgICAgICAgJGJ1bGxldC5uZXh0KCkuYWRkQ2xhc3MocGFyYW1zLmJ1bGxldEFjdGl2ZUNsYXNzICsgXFxcIi1uZXh0XFxcIikubmV4dCgpLmFkZENsYXNzKHBhcmFtcy5idWxsZXRBY3RpdmVDbGFzcyArIFxcXCItbmV4dC1uZXh0XFxcIik7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdmFyICRidWxsZXQgPSBidWxsZXRzLmVxKGN1cnJlbnQpO1xcbiAgICAgICAgdmFyIGJ1bGxldEluZGV4ID0gJGJ1bGxldC5pbmRleCgpO1xcbiAgICAgICAgJGJ1bGxldC5hZGRDbGFzcyhwYXJhbXMuYnVsbGV0QWN0aXZlQ2xhc3MpO1xcblxcbiAgICAgICAgaWYgKHBhcmFtcy5keW5hbWljQnVsbGV0cykge1xcbiAgICAgICAgICB2YXIgJGZpcnN0RGlzcGxheWVkQnVsbGV0ID0gYnVsbGV0cy5lcShmaXJzdEluZGV4KTtcXG4gICAgICAgICAgdmFyICRsYXN0RGlzcGxheWVkQnVsbGV0ID0gYnVsbGV0cy5lcShsYXN0SW5kZXgpO1xcblxcbiAgICAgICAgICBmb3IgKHZhciBpID0gZmlyc3RJbmRleDsgaSA8PSBsYXN0SW5kZXg7IGkgKz0gMSkge1xcbiAgICAgICAgICAgIGJ1bGxldHMuZXEoaSkuYWRkQ2xhc3MocGFyYW1zLmJ1bGxldEFjdGl2ZUNsYXNzICsgXFxcIi1tYWluXFxcIik7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMubG9vcCkge1xcbiAgICAgICAgICAgIGlmIChidWxsZXRJbmRleCA+PSBidWxsZXRzLmxlbmd0aCAtIHBhcmFtcy5keW5hbWljTWFpbkJ1bGxldHMpIHtcXG4gICAgICAgICAgICAgIGZvciAodmFyIF9pID0gcGFyYW1zLmR5bmFtaWNNYWluQnVsbGV0czsgX2kgPj0gMDsgX2kgLT0gMSkge1xcbiAgICAgICAgICAgICAgICBidWxsZXRzLmVxKGJ1bGxldHMubGVuZ3RoIC0gX2kpLmFkZENsYXNzKHBhcmFtcy5idWxsZXRBY3RpdmVDbGFzcyArIFxcXCItbWFpblxcXCIpO1xcbiAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgYnVsbGV0cy5lcShidWxsZXRzLmxlbmd0aCAtIHBhcmFtcy5keW5hbWljTWFpbkJ1bGxldHMgLSAxKS5hZGRDbGFzcyhwYXJhbXMuYnVsbGV0QWN0aXZlQ2xhc3MgKyBcXFwiLXByZXZcXFwiKTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgJGZpcnN0RGlzcGxheWVkQnVsbGV0LnByZXYoKS5hZGRDbGFzcyhwYXJhbXMuYnVsbGV0QWN0aXZlQ2xhc3MgKyBcXFwiLXByZXZcXFwiKS5wcmV2KCkuYWRkQ2xhc3MocGFyYW1zLmJ1bGxldEFjdGl2ZUNsYXNzICsgXFxcIi1wcmV2LXByZXZcXFwiKTtcXG4gICAgICAgICAgICAgICRsYXN0RGlzcGxheWVkQnVsbGV0Lm5leHQoKS5hZGRDbGFzcyhwYXJhbXMuYnVsbGV0QWN0aXZlQ2xhc3MgKyBcXFwiLW5leHRcXFwiKS5uZXh0KCkuYWRkQ2xhc3MocGFyYW1zLmJ1bGxldEFjdGl2ZUNsYXNzICsgXFxcIi1uZXh0LW5leHRcXFwiKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgJGZpcnN0RGlzcGxheWVkQnVsbGV0LnByZXYoKS5hZGRDbGFzcyhwYXJhbXMuYnVsbGV0QWN0aXZlQ2xhc3MgKyBcXFwiLXByZXZcXFwiKS5wcmV2KCkuYWRkQ2xhc3MocGFyYW1zLmJ1bGxldEFjdGl2ZUNsYXNzICsgXFxcIi1wcmV2LXByZXZcXFwiKTtcXG4gICAgICAgICAgICAkbGFzdERpc3BsYXllZEJ1bGxldC5uZXh0KCkuYWRkQ2xhc3MocGFyYW1zLmJ1bGxldEFjdGl2ZUNsYXNzICsgXFxcIi1uZXh0XFxcIikubmV4dCgpLmFkZENsYXNzKHBhcmFtcy5idWxsZXRBY3RpdmVDbGFzcyArIFxcXCItbmV4dC1uZXh0XFxcIik7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHBhcmFtcy5keW5hbWljQnVsbGV0cykge1xcbiAgICAgICAgdmFyIGR5bmFtaWNCdWxsZXRzTGVuZ3RoID0gTWF0aC5taW4oYnVsbGV0cy5sZW5ndGgsIHBhcmFtcy5keW5hbWljTWFpbkJ1bGxldHMgKyA0KTtcXG4gICAgICAgIHZhciBidWxsZXRzT2Zmc2V0ID0gKHN3aXBlci5wYWdpbmF0aW9uLmJ1bGxldFNpemUgKiBkeW5hbWljQnVsbGV0c0xlbmd0aCAtIHN3aXBlci5wYWdpbmF0aW9uLmJ1bGxldFNpemUpIC8gMiAtIG1pZEluZGV4ICogc3dpcGVyLnBhZ2luYXRpb24uYnVsbGV0U2l6ZTtcXG4gICAgICAgIHZhciBvZmZzZXRQcm9wID0gcnRsID8gJ3JpZ2h0JyA6ICdsZWZ0JztcXG4gICAgICAgIGJ1bGxldHMuY3NzKHN3aXBlci5pc0hvcml6b250YWwoKSA/IG9mZnNldFByb3AgOiAndG9wJywgYnVsbGV0c09mZnNldCArIFxcXCJweFxcXCIpO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBpZiAocGFyYW1zLnR5cGUgPT09ICdmcmFjdGlvbicpIHtcXG4gICAgICAkZWwuZmluZCgoMCxfdXRpbHNfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5jbGFzc2VzVG9TZWxlY3RvcikocGFyYW1zLmN1cnJlbnRDbGFzcykpLnRleHQocGFyYW1zLmZvcm1hdEZyYWN0aW9uQ3VycmVudChjdXJyZW50ICsgMSkpO1xcbiAgICAgICRlbC5maW5kKCgwLF91dGlsc191dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLmNsYXNzZXNUb1NlbGVjdG9yKShwYXJhbXMudG90YWxDbGFzcykpLnRleHQocGFyYW1zLmZvcm1hdEZyYWN0aW9uVG90YWwodG90YWwpKTtcXG4gICAgfVxcblxcbiAgICBpZiAocGFyYW1zLnR5cGUgPT09ICdwcm9ncmVzc2JhcicpIHtcXG4gICAgICB2YXIgcHJvZ3Jlc3NiYXJEaXJlY3Rpb247XFxuXFxuICAgICAgaWYgKHBhcmFtcy5wcm9ncmVzc2Jhck9wcG9zaXRlKSB7XFxuICAgICAgICBwcm9ncmVzc2JhckRpcmVjdGlvbiA9IHN3aXBlci5pc0hvcml6b250YWwoKSA/ICd2ZXJ0aWNhbCcgOiAnaG9yaXpvbnRhbCc7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHByb2dyZXNzYmFyRGlyZWN0aW9uID0gc3dpcGVyLmlzSG9yaXpvbnRhbCgpID8gJ2hvcml6b250YWwnIDogJ3ZlcnRpY2FsJztcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIHNjYWxlID0gKGN1cnJlbnQgKyAxKSAvIHRvdGFsO1xcbiAgICAgIHZhciBzY2FsZVggPSAxO1xcbiAgICAgIHZhciBzY2FsZVkgPSAxO1xcblxcbiAgICAgIGlmIChwcm9ncmVzc2JhckRpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnKSB7XFxuICAgICAgICBzY2FsZVggPSBzY2FsZTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgc2NhbGVZID0gc2NhbGU7XFxuICAgICAgfVxcblxcbiAgICAgICRlbC5maW5kKCgwLF91dGlsc191dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLmNsYXNzZXNUb1NlbGVjdG9yKShwYXJhbXMucHJvZ3Jlc3NiYXJGaWxsQ2xhc3MpKS50cmFuc2Zvcm0oXFxcInRyYW5zbGF0ZTNkKDAsMCwwKSBzY2FsZVgoXFxcIiArIHNjYWxlWCArIFxcXCIpIHNjYWxlWShcXFwiICsgc2NhbGVZICsgXFxcIilcXFwiKS50cmFuc2l0aW9uKHN3aXBlci5wYXJhbXMuc3BlZWQpO1xcbiAgICB9XFxuXFxuICAgIGlmIChwYXJhbXMudHlwZSA9PT0gJ2N1c3RvbScgJiYgcGFyYW1zLnJlbmRlckN1c3RvbSkge1xcbiAgICAgICRlbC5odG1sKHBhcmFtcy5yZW5kZXJDdXN0b20oc3dpcGVyLCBjdXJyZW50ICsgMSwgdG90YWwpKTtcXG4gICAgICBzd2lwZXIuZW1pdCgncGFnaW5hdGlvblJlbmRlcicsICRlbFswXSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgc3dpcGVyLmVtaXQoJ3BhZ2luYXRpb25VcGRhdGUnLCAkZWxbMF0pO1xcbiAgICB9XFxuXFxuICAgIGlmIChzd2lwZXIucGFyYW1zLndhdGNoT3ZlcmZsb3cgJiYgc3dpcGVyLmVuYWJsZWQpIHtcXG4gICAgICAkZWxbc3dpcGVyLmlzTG9ja2VkID8gJ2FkZENsYXNzJyA6ICdyZW1vdmVDbGFzcyddKHBhcmFtcy5sb2NrQ2xhc3MpO1xcbiAgICB9XFxuICB9LFxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XFxuICAgIC8vIFJlbmRlciBDb250YWluZXJcXG4gICAgdmFyIHN3aXBlciA9IHRoaXM7XFxuICAgIHZhciBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLnBhZ2luYXRpb247XFxuICAgIGlmICghcGFyYW1zLmVsIHx8ICFzd2lwZXIucGFnaW5hdGlvbi5lbCB8fCAhc3dpcGVyLnBhZ2luYXRpb24uJGVsIHx8IHN3aXBlci5wYWdpbmF0aW9uLiRlbC5sZW5ndGggPT09IDApIHJldHVybjtcXG4gICAgdmFyIHNsaWRlc0xlbmd0aCA9IHN3aXBlci52aXJ0dWFsICYmIHN3aXBlci5wYXJhbXMudmlydHVhbC5lbmFibGVkID8gc3dpcGVyLnZpcnR1YWwuc2xpZGVzLmxlbmd0aCA6IHN3aXBlci5zbGlkZXMubGVuZ3RoO1xcbiAgICB2YXIgJGVsID0gc3dpcGVyLnBhZ2luYXRpb24uJGVsO1xcbiAgICB2YXIgcGFnaW5hdGlvbkhUTUwgPSAnJztcXG5cXG4gICAgaWYgKHBhcmFtcy50eXBlID09PSAnYnVsbGV0cycpIHtcXG4gICAgICB2YXIgbnVtYmVyT2ZCdWxsZXRzID0gc3dpcGVyLnBhcmFtcy5sb29wID8gTWF0aC5jZWlsKChzbGlkZXNMZW5ndGggLSBzd2lwZXIubG9vcGVkU2xpZGVzICogMikgLyBzd2lwZXIucGFyYW1zLnNsaWRlc1Blckdyb3VwKSA6IHN3aXBlci5zbmFwR3JpZC5sZW5ndGg7XFxuXFxuICAgICAgaWYgKHN3aXBlci5wYXJhbXMuZnJlZU1vZGUgJiYgIXN3aXBlci5wYXJhbXMubG9vcCAmJiBudW1iZXJPZkJ1bGxldHMgPiBzbGlkZXNMZW5ndGgpIHtcXG4gICAgICAgIG51bWJlck9mQnVsbGV0cyA9IHNsaWRlc0xlbmd0aDtcXG4gICAgICB9XFxuXFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1iZXJPZkJ1bGxldHM7IGkgKz0gMSkge1xcbiAgICAgICAgaWYgKHBhcmFtcy5yZW5kZXJCdWxsZXQpIHtcXG4gICAgICAgICAgcGFnaW5hdGlvbkhUTUwgKz0gcGFyYW1zLnJlbmRlckJ1bGxldC5jYWxsKHN3aXBlciwgaSwgcGFyYW1zLmJ1bGxldENsYXNzKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHBhZ2luYXRpb25IVE1MICs9IFxcXCI8XFxcIiArIHBhcmFtcy5idWxsZXRFbGVtZW50ICsgXFxcIiBjbGFzcz1cXFxcXFxcIlxcXCIgKyBwYXJhbXMuYnVsbGV0Q2xhc3MgKyBcXFwiXFxcXFxcXCI+PC9cXFwiICsgcGFyYW1zLmJ1bGxldEVsZW1lbnQgKyBcXFwiPlxcXCI7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgICRlbC5odG1sKHBhZ2luYXRpb25IVE1MKTtcXG4gICAgICBzd2lwZXIucGFnaW5hdGlvbi5idWxsZXRzID0gJGVsLmZpbmQoKDAsX3V0aWxzX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uY2xhc3Nlc1RvU2VsZWN0b3IpKHBhcmFtcy5idWxsZXRDbGFzcykpO1xcbiAgICB9XFxuXFxuICAgIGlmIChwYXJhbXMudHlwZSA9PT0gJ2ZyYWN0aW9uJykge1xcbiAgICAgIGlmIChwYXJhbXMucmVuZGVyRnJhY3Rpb24pIHtcXG4gICAgICAgIHBhZ2luYXRpb25IVE1MID0gcGFyYW1zLnJlbmRlckZyYWN0aW9uLmNhbGwoc3dpcGVyLCBwYXJhbXMuY3VycmVudENsYXNzLCBwYXJhbXMudG90YWxDbGFzcyk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHBhZ2luYXRpb25IVE1MID0gXFxcIjxzcGFuIGNsYXNzPVxcXFxcXFwiXFxcIiArIHBhcmFtcy5jdXJyZW50Q2xhc3MgKyBcXFwiXFxcXFxcXCI+PC9zcGFuPlxcXCIgKyAnIC8gJyArIChcXFwiPHNwYW4gY2xhc3M9XFxcXFxcXCJcXFwiICsgcGFyYW1zLnRvdGFsQ2xhc3MgKyBcXFwiXFxcXFxcXCI+PC9zcGFuPlxcXCIpO1xcbiAgICAgIH1cXG5cXG4gICAgICAkZWwuaHRtbChwYWdpbmF0aW9uSFRNTCk7XFxuICAgIH1cXG5cXG4gICAgaWYgKHBhcmFtcy50eXBlID09PSAncHJvZ3Jlc3NiYXInKSB7XFxuICAgICAgaWYgKHBhcmFtcy5yZW5kZXJQcm9ncmVzc2Jhcikge1xcbiAgICAgICAgcGFnaW5hdGlvbkhUTUwgPSBwYXJhbXMucmVuZGVyUHJvZ3Jlc3NiYXIuY2FsbChzd2lwZXIsIHBhcmFtcy5wcm9ncmVzc2JhckZpbGxDbGFzcyk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHBhZ2luYXRpb25IVE1MID0gXFxcIjxzcGFuIGNsYXNzPVxcXFxcXFwiXFxcIiArIHBhcmFtcy5wcm9ncmVzc2JhckZpbGxDbGFzcyArIFxcXCJcXFxcXFxcIj48L3NwYW4+XFxcIjtcXG4gICAgICB9XFxuXFxuICAgICAgJGVsLmh0bWwocGFnaW5hdGlvbkhUTUwpO1xcbiAgICB9XFxuXFxuICAgIGlmIChwYXJhbXMudHlwZSAhPT0gJ2N1c3RvbScpIHtcXG4gICAgICBzd2lwZXIuZW1pdCgncGFnaW5hdGlvblJlbmRlcicsIHN3aXBlci5wYWdpbmF0aW9uLiRlbFswXSk7XFxuICAgIH1cXG4gIH0sXFxuICBpbml0OiBmdW5jdGlvbiBpbml0KCkge1xcbiAgICB2YXIgc3dpcGVyID0gdGhpcztcXG4gICAgc3dpcGVyLnBhcmFtcy5wYWdpbmF0aW9uID0gKDAsX3V0aWxzX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uY3JlYXRlRWxlbWVudElmTm90RGVmaW5lZCkoc3dpcGVyLiRlbCwgc3dpcGVyLnBhcmFtcy5wYWdpbmF0aW9uLCBzd2lwZXIucGFyYW1zLmNyZWF0ZUVsZW1lbnRzLCB7XFxuICAgICAgZWw6ICdzd2lwZXItcGFnaW5hdGlvbidcXG4gICAgfSk7XFxuICAgIHZhciBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLnBhZ2luYXRpb247XFxuICAgIGlmICghcGFyYW1zLmVsKSByZXR1cm47XFxuICAgIHZhciAkZWwgPSAoMCxfdXRpbHNfZG9tX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImRlZmF1bHRcXFwiXSkocGFyYW1zLmVsKTtcXG4gICAgaWYgKCRlbC5sZW5ndGggPT09IDApIHJldHVybjtcXG5cXG4gICAgaWYgKHN3aXBlci5wYXJhbXMudW5pcXVlTmF2RWxlbWVudHMgJiYgdHlwZW9mIHBhcmFtcy5lbCA9PT0gJ3N0cmluZycgJiYgJGVsLmxlbmd0aCA+IDEpIHtcXG4gICAgICAkZWwgPSBzd2lwZXIuJGVsLmZpbmQocGFyYW1zLmVsKTtcXG4gICAgfVxcblxcbiAgICBpZiAocGFyYW1zLnR5cGUgPT09ICdidWxsZXRzJyAmJiBwYXJhbXMuY2xpY2thYmxlKSB7XFxuICAgICAgJGVsLmFkZENsYXNzKHBhcmFtcy5jbGlja2FibGVDbGFzcyk7XFxuICAgIH1cXG5cXG4gICAgJGVsLmFkZENsYXNzKHBhcmFtcy5tb2RpZmllckNsYXNzICsgcGFyYW1zLnR5cGUpO1xcblxcbiAgICBpZiAocGFyYW1zLnR5cGUgPT09ICdidWxsZXRzJyAmJiBwYXJhbXMuZHluYW1pY0J1bGxldHMpIHtcXG4gICAgICAkZWwuYWRkQ2xhc3MoXFxcIlxcXCIgKyBwYXJhbXMubW9kaWZpZXJDbGFzcyArIHBhcmFtcy50eXBlICsgXFxcIi1keW5hbWljXFxcIik7XFxuICAgICAgc3dpcGVyLnBhZ2luYXRpb24uZHluYW1pY0J1bGxldEluZGV4ID0gMDtcXG5cXG4gICAgICBpZiAocGFyYW1zLmR5bmFtaWNNYWluQnVsbGV0cyA8IDEpIHtcXG4gICAgICAgIHBhcmFtcy5keW5hbWljTWFpbkJ1bGxldHMgPSAxO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBpZiAocGFyYW1zLnR5cGUgPT09ICdwcm9ncmVzc2JhcicgJiYgcGFyYW1zLnByb2dyZXNzYmFyT3Bwb3NpdGUpIHtcXG4gICAgICAkZWwuYWRkQ2xhc3MocGFyYW1zLnByb2dyZXNzYmFyT3Bwb3NpdGVDbGFzcyk7XFxuICAgIH1cXG5cXG4gICAgaWYgKHBhcmFtcy5jbGlja2FibGUpIHtcXG4gICAgICAkZWwub24oJ2NsaWNrJywgKDAsX3V0aWxzX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uY2xhc3Nlc1RvU2VsZWN0b3IpKHBhcmFtcy5idWxsZXRDbGFzcyksIGZ1bmN0aW9uIG9uQ2xpY2soZSkge1xcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgdmFyIGluZGV4ID0gKDAsX3V0aWxzX2RvbV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJkZWZhdWx0XFxcIl0pKHRoaXMpLmluZGV4KCkgKiBzd2lwZXIucGFyYW1zLnNsaWRlc1Blckdyb3VwO1xcbiAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMubG9vcCkgaW5kZXggKz0gc3dpcGVyLmxvb3BlZFNsaWRlcztcXG4gICAgICAgIHN3aXBlci5zbGlkZVRvKGluZGV4KTtcXG4gICAgICB9KTtcXG4gICAgfVxcblxcbiAgICAoMCxfdXRpbHNfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5leHRlbmQpKHN3aXBlci5wYWdpbmF0aW9uLCB7XFxuICAgICAgJGVsOiAkZWwsXFxuICAgICAgZWw6ICRlbFswXVxcbiAgICB9KTtcXG5cXG4gICAgaWYgKCFzd2lwZXIuZW5hYmxlZCkge1xcbiAgICAgICRlbC5hZGRDbGFzcyhwYXJhbXMubG9ja0NsYXNzKTtcXG4gICAgfVxcbiAgfSxcXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XFxuICAgIHZhciBzd2lwZXIgPSB0aGlzO1xcbiAgICB2YXIgcGFyYW1zID0gc3dpcGVyLnBhcmFtcy5wYWdpbmF0aW9uO1xcbiAgICBpZiAoIXBhcmFtcy5lbCB8fCAhc3dpcGVyLnBhZ2luYXRpb24uZWwgfHwgIXN3aXBlci5wYWdpbmF0aW9uLiRlbCB8fCBzd2lwZXIucGFnaW5hdGlvbi4kZWwubGVuZ3RoID09PSAwKSByZXR1cm47XFxuICAgIHZhciAkZWwgPSBzd2lwZXIucGFnaW5hdGlvbi4kZWw7XFxuICAgICRlbC5yZW1vdmVDbGFzcyhwYXJhbXMuaGlkZGVuQ2xhc3MpO1xcbiAgICAkZWwucmVtb3ZlQ2xhc3MocGFyYW1zLm1vZGlmaWVyQ2xhc3MgKyBwYXJhbXMudHlwZSk7XFxuICAgIGlmIChzd2lwZXIucGFnaW5hdGlvbi5idWxsZXRzKSBzd2lwZXIucGFnaW5hdGlvbi5idWxsZXRzLnJlbW92ZUNsYXNzKHBhcmFtcy5idWxsZXRBY3RpdmVDbGFzcyk7XFxuXFxuICAgIGlmIChwYXJhbXMuY2xpY2thYmxlKSB7XFxuICAgICAgJGVsLm9mZignY2xpY2snLCAoMCxfdXRpbHNfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5jbGFzc2VzVG9TZWxlY3RvcikocGFyYW1zLmJ1bGxldENsYXNzKSk7XFxuICAgIH1cXG4gIH1cXG59O1xcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgX19XRUJQQUNLX0RFRkFVTFRfRVhQT1JUX18gPSAoe1xcbiAgbmFtZTogJ3BhZ2luYXRpb24nLFxcbiAgcGFyYW1zOiB7XFxuICAgIHBhZ2luYXRpb246IHtcXG4gICAgICBlbDogbnVsbCxcXG4gICAgICBidWxsZXRFbGVtZW50OiAnc3BhbicsXFxuICAgICAgY2xpY2thYmxlOiBmYWxzZSxcXG4gICAgICBoaWRlT25DbGljazogZmFsc2UsXFxuICAgICAgcmVuZGVyQnVsbGV0OiBudWxsLFxcbiAgICAgIHJlbmRlclByb2dyZXNzYmFyOiBudWxsLFxcbiAgICAgIHJlbmRlckZyYWN0aW9uOiBudWxsLFxcbiAgICAgIHJlbmRlckN1c3RvbTogbnVsbCxcXG4gICAgICBwcm9ncmVzc2Jhck9wcG9zaXRlOiBmYWxzZSxcXG4gICAgICB0eXBlOiAnYnVsbGV0cycsXFxuICAgICAgLy8gJ2J1bGxldHMnIG9yICdwcm9ncmVzc2Jhcicgb3IgJ2ZyYWN0aW9uJyBvciAnY3VzdG9tJ1xcbiAgICAgIGR5bmFtaWNCdWxsZXRzOiBmYWxzZSxcXG4gICAgICBkeW5hbWljTWFpbkJ1bGxldHM6IDEsXFxuICAgICAgZm9ybWF0RnJhY3Rpb25DdXJyZW50OiBmdW5jdGlvbiBmb3JtYXRGcmFjdGlvbkN1cnJlbnQobnVtYmVyKSB7XFxuICAgICAgICByZXR1cm4gbnVtYmVyO1xcbiAgICAgIH0sXFxuICAgICAgZm9ybWF0RnJhY3Rpb25Ub3RhbDogZnVuY3Rpb24gZm9ybWF0RnJhY3Rpb25Ub3RhbChudW1iZXIpIHtcXG4gICAgICAgIHJldHVybiBudW1iZXI7XFxuICAgICAgfSxcXG4gICAgICBidWxsZXRDbGFzczogJ3N3aXBlci1wYWdpbmF0aW9uLWJ1bGxldCcsXFxuICAgICAgYnVsbGV0QWN0aXZlQ2xhc3M6ICdzd2lwZXItcGFnaW5hdGlvbi1idWxsZXQtYWN0aXZlJyxcXG4gICAgICBtb2RpZmllckNsYXNzOiAnc3dpcGVyLXBhZ2luYXRpb24tJyxcXG4gICAgICAvLyBORVdcXG4gICAgICBjdXJyZW50Q2xhc3M6ICdzd2lwZXItcGFnaW5hdGlvbi1jdXJyZW50JyxcXG4gICAgICB0b3RhbENsYXNzOiAnc3dpcGVyLXBhZ2luYXRpb24tdG90YWwnLFxcbiAgICAgIGhpZGRlbkNsYXNzOiAnc3dpcGVyLXBhZ2luYXRpb24taGlkZGVuJyxcXG4gICAgICBwcm9ncmVzc2JhckZpbGxDbGFzczogJ3N3aXBlci1wYWdpbmF0aW9uLXByb2dyZXNzYmFyLWZpbGwnLFxcbiAgICAgIHByb2dyZXNzYmFyT3Bwb3NpdGVDbGFzczogJ3N3aXBlci1wYWdpbmF0aW9uLXByb2dyZXNzYmFyLW9wcG9zaXRlJyxcXG4gICAgICBjbGlja2FibGVDbGFzczogJ3N3aXBlci1wYWdpbmF0aW9uLWNsaWNrYWJsZScsXFxuICAgICAgLy8gTkVXXFxuICAgICAgbG9ja0NsYXNzOiAnc3dpcGVyLXBhZ2luYXRpb24tbG9jaydcXG4gICAgfVxcbiAgfSxcXG4gIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKCkge1xcbiAgICB2YXIgc3dpcGVyID0gdGhpcztcXG4gICAgKDAsX3V0aWxzX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uYmluZE1vZHVsZU1ldGhvZHMpKHN3aXBlciwge1xcbiAgICAgIHBhZ2luYXRpb246IF9leHRlbmRzKHtcXG4gICAgICAgIGR5bmFtaWNCdWxsZXRJbmRleDogMFxcbiAgICAgIH0sIFBhZ2luYXRpb24pXFxuICAgIH0pO1xcbiAgfSxcXG4gIG9uOiB7XFxuICAgIGluaXQ6IGZ1bmN0aW9uIGluaXQoc3dpcGVyKSB7XFxuICAgICAgc3dpcGVyLnBhZ2luYXRpb24uaW5pdCgpO1xcbiAgICAgIHN3aXBlci5wYWdpbmF0aW9uLnJlbmRlcigpO1xcbiAgICAgIHN3aXBlci5wYWdpbmF0aW9uLnVwZGF0ZSgpO1xcbiAgICB9LFxcbiAgICBhY3RpdmVJbmRleENoYW5nZTogZnVuY3Rpb24gYWN0aXZlSW5kZXhDaGFuZ2Uoc3dpcGVyKSB7XFxuICAgICAgaWYgKHN3aXBlci5wYXJhbXMubG9vcCkge1xcbiAgICAgICAgc3dpcGVyLnBhZ2luYXRpb24udXBkYXRlKCk7XFxuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc3dpcGVyLnNuYXBJbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICAgIHN3aXBlci5wYWdpbmF0aW9uLnVwZGF0ZSgpO1xcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgc25hcEluZGV4Q2hhbmdlOiBmdW5jdGlvbiBzbmFwSW5kZXhDaGFuZ2Uoc3dpcGVyKSB7XFxuICAgICAgaWYgKCFzd2lwZXIucGFyYW1zLmxvb3ApIHtcXG4gICAgICAgIHN3aXBlci5wYWdpbmF0aW9uLnVwZGF0ZSgpO1xcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgc2xpZGVzTGVuZ3RoQ2hhbmdlOiBmdW5jdGlvbiBzbGlkZXNMZW5ndGhDaGFuZ2Uoc3dpcGVyKSB7XFxuICAgICAgaWYgKHN3aXBlci5wYXJhbXMubG9vcCkge1xcbiAgICAgICAgc3dpcGVyLnBhZ2luYXRpb24ucmVuZGVyKCk7XFxuICAgICAgICBzd2lwZXIucGFnaW5hdGlvbi51cGRhdGUoKTtcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIHNuYXBHcmlkTGVuZ3RoQ2hhbmdlOiBmdW5jdGlvbiBzbmFwR3JpZExlbmd0aENoYW5nZShzd2lwZXIpIHtcXG4gICAgICBpZiAoIXN3aXBlci5wYXJhbXMubG9vcCkge1xcbiAgICAgICAgc3dpcGVyLnBhZ2luYXRpb24ucmVuZGVyKCk7XFxuICAgICAgICBzd2lwZXIucGFnaW5hdGlvbi51cGRhdGUoKTtcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koc3dpcGVyKSB7XFxuICAgICAgc3dpcGVyLnBhZ2luYXRpb24uZGVzdHJveSgpO1xcbiAgICB9LFxcbiAgICAnZW5hYmxlIGRpc2FibGUnOiBmdW5jdGlvbiBlbmFibGVEaXNhYmxlKHN3aXBlcikge1xcbiAgICAgIHZhciAkZWwgPSBzd2lwZXIucGFnaW5hdGlvbi4kZWw7XFxuXFxuICAgICAgaWYgKCRlbCkge1xcbiAgICAgICAgJGVsW3N3aXBlci5lbmFibGVkID8gJ3JlbW92ZUNsYXNzJyA6ICdhZGRDbGFzcyddKHN3aXBlci5wYXJhbXMucGFnaW5hdGlvbi5sb2NrQ2xhc3MpO1xcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgY2xpY2s6IGZ1bmN0aW9uIGNsaWNrKHN3aXBlciwgZSkge1xcbiAgICAgIHZhciB0YXJnZXRFbCA9IGUudGFyZ2V0O1xcblxcbiAgICAgIGlmIChzd2lwZXIucGFyYW1zLnBhZ2luYXRpb24uZWwgJiYgc3dpcGVyLnBhcmFtcy5wYWdpbmF0aW9uLmhpZGVPbkNsaWNrICYmIHN3aXBlci5wYWdpbmF0aW9uLiRlbC5sZW5ndGggPiAwICYmICEoMCxfdXRpbHNfZG9tX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImRlZmF1bHRcXFwiXSkodGFyZ2V0RWwpLmhhc0NsYXNzKHN3aXBlci5wYXJhbXMucGFnaW5hdGlvbi5idWxsZXRDbGFzcykpIHtcXG4gICAgICAgIGlmIChzd2lwZXIubmF2aWdhdGlvbiAmJiAoc3dpcGVyLm5hdmlnYXRpb24ubmV4dEVsICYmIHRhcmdldEVsID09PSBzd2lwZXIubmF2aWdhdGlvbi5uZXh0RWwgfHwgc3dpcGVyLm5hdmlnYXRpb24ucHJldkVsICYmIHRhcmdldEVsID09PSBzd2lwZXIubmF2aWdhdGlvbi5wcmV2RWwpKSByZXR1cm47XFxuICAgICAgICB2YXIgaXNIaWRkZW4gPSBzd2lwZXIucGFnaW5hdGlvbi4kZWwuaGFzQ2xhc3Moc3dpcGVyLnBhcmFtcy5wYWdpbmF0aW9uLmhpZGRlbkNsYXNzKTtcXG5cXG4gICAgICAgIGlmIChpc0hpZGRlbiA9PT0gdHJ1ZSkge1xcbiAgICAgICAgICBzd2lwZXIuZW1pdCgncGFnaW5hdGlvblNob3cnKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHN3aXBlci5lbWl0KCdwYWdpbmF0aW9uSGlkZScpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgc3dpcGVyLnBhZ2luYXRpb24uJGVsLnRvZ2dsZUNsYXNzKHN3aXBlci5wYXJhbXMucGFnaW5hdGlvbi5oaWRkZW5DbGFzcyk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxufSk7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vcGFydXMvLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL3BhZ2luYXRpb24vcGFnaW5hdGlvbi5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy90aHVtYnMvdGh1bWJzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy90aHVtYnMvdGh1bWJzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJkZWZhdWx0XFxcIjogKCkgPT4gKF9fV0VCUEFDS19ERUZBVUxUX0VYUE9SVF9fKVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3V0aWxzL3V0aWxzICovIFxcXCIuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL3V0aWxzL3V0aWxzLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19kb21fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3V0aWxzL2RvbSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS91dGlscy9kb20uanNcXFwiKTtcXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxcblxcblxcblxcbnZhciBUaHVtYnMgPSB7XFxuICBpbml0OiBmdW5jdGlvbiBpbml0KCkge1xcbiAgICB2YXIgc3dpcGVyID0gdGhpcztcXG4gICAgdmFyIHRodW1ic1BhcmFtcyA9IHN3aXBlci5wYXJhbXMudGh1bWJzO1xcbiAgICBpZiAoc3dpcGVyLnRodW1icy5pbml0aWFsaXplZCkgcmV0dXJuIGZhbHNlO1xcbiAgICBzd2lwZXIudGh1bWJzLmluaXRpYWxpemVkID0gdHJ1ZTtcXG4gICAgdmFyIFN3aXBlckNsYXNzID0gc3dpcGVyLmNvbnN0cnVjdG9yO1xcblxcbiAgICBpZiAodGh1bWJzUGFyYW1zLnN3aXBlciBpbnN0YW5jZW9mIFN3aXBlckNsYXNzKSB7XFxuICAgICAgc3dpcGVyLnRodW1icy5zd2lwZXIgPSB0aHVtYnNQYXJhbXMuc3dpcGVyO1xcbiAgICAgICgwLF91dGlsc191dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLmV4dGVuZCkoc3dpcGVyLnRodW1icy5zd2lwZXIub3JpZ2luYWxQYXJhbXMsIHtcXG4gICAgICAgIHdhdGNoU2xpZGVzUHJvZ3Jlc3M6IHRydWUsXFxuICAgICAgICBzbGlkZVRvQ2xpY2tlZFNsaWRlOiBmYWxzZVxcbiAgICAgIH0pO1xcbiAgICAgICgwLF91dGlsc191dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLmV4dGVuZCkoc3dpcGVyLnRodW1icy5zd2lwZXIucGFyYW1zLCB7XFxuICAgICAgICB3YXRjaFNsaWRlc1Byb2dyZXNzOiB0cnVlLFxcbiAgICAgICAgc2xpZGVUb0NsaWNrZWRTbGlkZTogZmFsc2VcXG4gICAgICB9KTtcXG4gICAgfSBlbHNlIGlmICgoMCxfdXRpbHNfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5pc09iamVjdCkodGh1bWJzUGFyYW1zLnN3aXBlcikpIHtcXG4gICAgICBzd2lwZXIudGh1bWJzLnN3aXBlciA9IG5ldyBTd2lwZXJDbGFzcygoMCxfdXRpbHNfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5leHRlbmQpKHt9LCB0aHVtYnNQYXJhbXMuc3dpcGVyLCB7XFxuICAgICAgICB3YXRjaFNsaWRlc1Zpc2liaWxpdHk6IHRydWUsXFxuICAgICAgICB3YXRjaFNsaWRlc1Byb2dyZXNzOiB0cnVlLFxcbiAgICAgICAgc2xpZGVUb0NsaWNrZWRTbGlkZTogZmFsc2VcXG4gICAgICB9KSk7XFxuICAgICAgc3dpcGVyLnRodW1icy5zd2lwZXJDcmVhdGVkID0gdHJ1ZTtcXG4gICAgfVxcblxcbiAgICBzd2lwZXIudGh1bWJzLnN3aXBlci4kZWwuYWRkQ2xhc3Moc3dpcGVyLnBhcmFtcy50aHVtYnMudGh1bWJzQ29udGFpbmVyQ2xhc3MpO1xcbiAgICBzd2lwZXIudGh1bWJzLnN3aXBlci5vbigndGFwJywgc3dpcGVyLnRodW1icy5vblRodW1iQ2xpY2spO1xcbiAgICByZXR1cm4gdHJ1ZTtcXG4gIH0sXFxuICBvblRodW1iQ2xpY2s6IGZ1bmN0aW9uIG9uVGh1bWJDbGljaygpIHtcXG4gICAgdmFyIHN3aXBlciA9IHRoaXM7XFxuICAgIHZhciB0aHVtYnNTd2lwZXIgPSBzd2lwZXIudGh1bWJzLnN3aXBlcjtcXG4gICAgaWYgKCF0aHVtYnNTd2lwZXIpIHJldHVybjtcXG4gICAgdmFyIGNsaWNrZWRJbmRleCA9IHRodW1ic1N3aXBlci5jbGlja2VkSW5kZXg7XFxuICAgIHZhciBjbGlja2VkU2xpZGUgPSB0aHVtYnNTd2lwZXIuY2xpY2tlZFNsaWRlO1xcbiAgICBpZiAoY2xpY2tlZFNsaWRlICYmICgwLF91dGlsc19kb21fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiZGVmYXVsdFxcXCJdKShjbGlja2VkU2xpZGUpLmhhc0NsYXNzKHN3aXBlci5wYXJhbXMudGh1bWJzLnNsaWRlVGh1bWJBY3RpdmVDbGFzcykpIHJldHVybjtcXG4gICAgaWYgKHR5cGVvZiBjbGlja2VkSW5kZXggPT09ICd1bmRlZmluZWQnIHx8IGNsaWNrZWRJbmRleCA9PT0gbnVsbCkgcmV0dXJuO1xcbiAgICB2YXIgc2xpZGVUb0luZGV4O1xcblxcbiAgICBpZiAodGh1bWJzU3dpcGVyLnBhcmFtcy5sb29wKSB7XFxuICAgICAgc2xpZGVUb0luZGV4ID0gcGFyc2VJbnQoKDAsX3V0aWxzX2RvbV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJkZWZhdWx0XFxcIl0pKHRodW1ic1N3aXBlci5jbGlja2VkU2xpZGUpLmF0dHIoJ2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4JyksIDEwKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBzbGlkZVRvSW5kZXggPSBjbGlja2VkSW5kZXg7XFxuICAgIH1cXG5cXG4gICAgaWYgKHN3aXBlci5wYXJhbXMubG9vcCkge1xcbiAgICAgIHZhciBjdXJyZW50SW5kZXggPSBzd2lwZXIuYWN0aXZlSW5kZXg7XFxuXFxuICAgICAgaWYgKHN3aXBlci5zbGlkZXMuZXEoY3VycmVudEluZGV4KS5oYXNDbGFzcyhzd2lwZXIucGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3MpKSB7XFxuICAgICAgICBzd2lwZXIubG9vcEZpeCgpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcXG5cXG4gICAgICAgIHN3aXBlci5fY2xpZW50TGVmdCA9IHN3aXBlci4kd3JhcHBlckVsWzBdLmNsaWVudExlZnQ7XFxuICAgICAgICBjdXJyZW50SW5kZXggPSBzd2lwZXIuYWN0aXZlSW5kZXg7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBwcmV2SW5kZXggPSBzd2lwZXIuc2xpZGVzLmVxKGN1cnJlbnRJbmRleCkucHJldkFsbChcXFwiW2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVxcXFxcXFwiXFxcIiArIHNsaWRlVG9JbmRleCArIFxcXCJcXFxcXFxcIl1cXFwiKS5lcSgwKS5pbmRleCgpO1xcbiAgICAgIHZhciBuZXh0SW5kZXggPSBzd2lwZXIuc2xpZGVzLmVxKGN1cnJlbnRJbmRleCkubmV4dEFsbChcXFwiW2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVxcXFxcXFwiXFxcIiArIHNsaWRlVG9JbmRleCArIFxcXCJcXFxcXFxcIl1cXFwiKS5lcSgwKS5pbmRleCgpO1xcbiAgICAgIGlmICh0eXBlb2YgcHJldkluZGV4ID09PSAndW5kZWZpbmVkJykgc2xpZGVUb0luZGV4ID0gbmV4dEluZGV4O2Vsc2UgaWYgKHR5cGVvZiBuZXh0SW5kZXggPT09ICd1bmRlZmluZWQnKSBzbGlkZVRvSW5kZXggPSBwcmV2SW5kZXg7ZWxzZSBpZiAobmV4dEluZGV4IC0gY3VycmVudEluZGV4IDwgY3VycmVudEluZGV4IC0gcHJldkluZGV4KSBzbGlkZVRvSW5kZXggPSBuZXh0SW5kZXg7ZWxzZSBzbGlkZVRvSW5kZXggPSBwcmV2SW5kZXg7XFxuICAgIH1cXG5cXG4gICAgc3dpcGVyLnNsaWRlVG8oc2xpZGVUb0luZGV4KTtcXG4gIH0sXFxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZShpbml0aWFsKSB7XFxuICAgIHZhciBzd2lwZXIgPSB0aGlzO1xcbiAgICB2YXIgdGh1bWJzU3dpcGVyID0gc3dpcGVyLnRodW1icy5zd2lwZXI7XFxuICAgIGlmICghdGh1bWJzU3dpcGVyKSByZXR1cm47XFxuICAgIHZhciBzbGlkZXNQZXJWaWV3ID0gdGh1bWJzU3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJWaWV3ID09PSAnYXV0bycgPyB0aHVtYnNTd2lwZXIuc2xpZGVzUGVyVmlld0R5bmFtaWMoKSA6IHRodW1ic1N3aXBlci5wYXJhbXMuc2xpZGVzUGVyVmlldztcXG4gICAgdmFyIGF1dG9TY3JvbGxPZmZzZXQgPSBzd2lwZXIucGFyYW1zLnRodW1icy5hdXRvU2Nyb2xsT2Zmc2V0O1xcbiAgICB2YXIgdXNlT2Zmc2V0ID0gYXV0b1Njcm9sbE9mZnNldCAmJiAhdGh1bWJzU3dpcGVyLnBhcmFtcy5sb29wO1xcblxcbiAgICBpZiAoc3dpcGVyLnJlYWxJbmRleCAhPT0gdGh1bWJzU3dpcGVyLnJlYWxJbmRleCB8fCB1c2VPZmZzZXQpIHtcXG4gICAgICB2YXIgY3VycmVudFRodW1ic0luZGV4ID0gdGh1bWJzU3dpcGVyLmFjdGl2ZUluZGV4O1xcbiAgICAgIHZhciBuZXdUaHVtYnNJbmRleDtcXG4gICAgICB2YXIgZGlyZWN0aW9uO1xcblxcbiAgICAgIGlmICh0aHVtYnNTd2lwZXIucGFyYW1zLmxvb3ApIHtcXG4gICAgICAgIGlmICh0aHVtYnNTd2lwZXIuc2xpZGVzLmVxKGN1cnJlbnRUaHVtYnNJbmRleCkuaGFzQ2xhc3ModGh1bWJzU3dpcGVyLnBhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzKSkge1xcbiAgICAgICAgICB0aHVtYnNTd2lwZXIubG9vcEZpeCgpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcXG5cXG4gICAgICAgICAgdGh1bWJzU3dpcGVyLl9jbGllbnRMZWZ0ID0gdGh1bWJzU3dpcGVyLiR3cmFwcGVyRWxbMF0uY2xpZW50TGVmdDtcXG4gICAgICAgICAgY3VycmVudFRodW1ic0luZGV4ID0gdGh1bWJzU3dpcGVyLmFjdGl2ZUluZGV4O1xcbiAgICAgICAgfSAvLyBGaW5kIGFjdHVhbCB0aHVtYnMgaW5kZXggdG8gc2xpZGUgdG9cXG5cXG5cXG4gICAgICAgIHZhciBwcmV2VGh1bWJzSW5kZXggPSB0aHVtYnNTd2lwZXIuc2xpZGVzLmVxKGN1cnJlbnRUaHVtYnNJbmRleCkucHJldkFsbChcXFwiW2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVxcXFxcXFwiXFxcIiArIHN3aXBlci5yZWFsSW5kZXggKyBcXFwiXFxcXFxcXCJdXFxcIikuZXEoMCkuaW5kZXgoKTtcXG4gICAgICAgIHZhciBuZXh0VGh1bWJzSW5kZXggPSB0aHVtYnNTd2lwZXIuc2xpZGVzLmVxKGN1cnJlbnRUaHVtYnNJbmRleCkubmV4dEFsbChcXFwiW2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVxcXFxcXFwiXFxcIiArIHN3aXBlci5yZWFsSW5kZXggKyBcXFwiXFxcXFxcXCJdXFxcIikuZXEoMCkuaW5kZXgoKTtcXG5cXG4gICAgICAgIGlmICh0eXBlb2YgcHJldlRodW1ic0luZGV4ID09PSAndW5kZWZpbmVkJykge1xcbiAgICAgICAgICBuZXdUaHVtYnNJbmRleCA9IG5leHRUaHVtYnNJbmRleDtcXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5leHRUaHVtYnNJbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICAgICAgbmV3VGh1bWJzSW5kZXggPSBwcmV2VGh1bWJzSW5kZXg7XFxuICAgICAgICB9IGVsc2UgaWYgKG5leHRUaHVtYnNJbmRleCAtIGN1cnJlbnRUaHVtYnNJbmRleCA9PT0gY3VycmVudFRodW1ic0luZGV4IC0gcHJldlRodW1ic0luZGV4KSB7XFxuICAgICAgICAgIG5ld1RodW1ic0luZGV4ID0gdGh1bWJzU3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJHcm91cCA+IDEgPyBuZXh0VGh1bWJzSW5kZXggOiBjdXJyZW50VGh1bWJzSW5kZXg7XFxuICAgICAgICB9IGVsc2UgaWYgKG5leHRUaHVtYnNJbmRleCAtIGN1cnJlbnRUaHVtYnNJbmRleCA8IGN1cnJlbnRUaHVtYnNJbmRleCAtIHByZXZUaHVtYnNJbmRleCkge1xcbiAgICAgICAgICBuZXdUaHVtYnNJbmRleCA9IG5leHRUaHVtYnNJbmRleDtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIG5ld1RodW1ic0luZGV4ID0gcHJldlRodW1ic0luZGV4O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgZGlyZWN0aW9uID0gc3dpcGVyLmFjdGl2ZUluZGV4ID4gc3dpcGVyLnByZXZpb3VzSW5kZXggPyAnbmV4dCcgOiAncHJldic7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIG5ld1RodW1ic0luZGV4ID0gc3dpcGVyLnJlYWxJbmRleDtcXG4gICAgICAgIGRpcmVjdGlvbiA9IG5ld1RodW1ic0luZGV4ID4gc3dpcGVyLnByZXZpb3VzSW5kZXggPyAnbmV4dCcgOiAncHJldic7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh1c2VPZmZzZXQpIHtcXG4gICAgICAgIG5ld1RodW1ic0luZGV4ICs9IGRpcmVjdGlvbiA9PT0gJ25leHQnID8gYXV0b1Njcm9sbE9mZnNldCA6IC0xICogYXV0b1Njcm9sbE9mZnNldDtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRodW1ic1N3aXBlci52aXNpYmxlU2xpZGVzSW5kZXhlcyAmJiB0aHVtYnNTd2lwZXIudmlzaWJsZVNsaWRlc0luZGV4ZXMuaW5kZXhPZihuZXdUaHVtYnNJbmRleCkgPCAwKSB7XFxuICAgICAgICBpZiAodGh1bWJzU3dpcGVyLnBhcmFtcy5jZW50ZXJlZFNsaWRlcykge1xcbiAgICAgICAgICBpZiAobmV3VGh1bWJzSW5kZXggPiBjdXJyZW50VGh1bWJzSW5kZXgpIHtcXG4gICAgICAgICAgICBuZXdUaHVtYnNJbmRleCA9IG5ld1RodW1ic0luZGV4IC0gTWF0aC5mbG9vcihzbGlkZXNQZXJWaWV3IC8gMikgKyAxO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIG5ld1RodW1ic0luZGV4ID0gbmV3VGh1bWJzSW5kZXggKyBNYXRoLmZsb29yKHNsaWRlc1BlclZpZXcgLyAyKSAtIDE7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gZWxzZSBpZiAobmV3VGh1bWJzSW5kZXggPiBjdXJyZW50VGh1bWJzSW5kZXggJiYgdGh1bWJzU3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJHcm91cCA9PT0gMSkgey8vIG5ld1RodW1ic0luZGV4ID0gbmV3VGh1bWJzSW5kZXggLSBzbGlkZXNQZXJWaWV3ICsgMTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHRodW1ic1N3aXBlci5zbGlkZVRvKG5ld1RodW1ic0luZGV4LCBpbml0aWFsID8gMCA6IHVuZGVmaW5lZCk7XFxuICAgICAgfVxcbiAgICB9IC8vIEFjdGl2YXRlIHRodW1ic1xcblxcblxcbiAgICB2YXIgdGh1bWJzVG9BY3RpdmF0ZSA9IDE7XFxuICAgIHZhciB0aHVtYkFjdGl2ZUNsYXNzID0gc3dpcGVyLnBhcmFtcy50aHVtYnMuc2xpZGVUaHVtYkFjdGl2ZUNsYXNzO1xcblxcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJWaWV3ID4gMSAmJiAhc3dpcGVyLnBhcmFtcy5jZW50ZXJlZFNsaWRlcykge1xcbiAgICAgIHRodW1ic1RvQWN0aXZhdGUgPSBzd2lwZXIucGFyYW1zLnNsaWRlc1BlclZpZXc7XFxuICAgIH1cXG5cXG4gICAgaWYgKCFzd2lwZXIucGFyYW1zLnRodW1icy5tdWx0aXBsZUFjdGl2ZVRodW1icykge1xcbiAgICAgIHRodW1ic1RvQWN0aXZhdGUgPSAxO1xcbiAgICB9XFxuXFxuICAgIHRodW1ic1RvQWN0aXZhdGUgPSBNYXRoLmZsb29yKHRodW1ic1RvQWN0aXZhdGUpO1xcbiAgICB0aHVtYnNTd2lwZXIuc2xpZGVzLnJlbW92ZUNsYXNzKHRodW1iQWN0aXZlQ2xhc3MpO1xcblxcbiAgICBpZiAodGh1bWJzU3dpcGVyLnBhcmFtcy5sb29wIHx8IHRodW1ic1N3aXBlci5wYXJhbXMudmlydHVhbCAmJiB0aHVtYnNTd2lwZXIucGFyYW1zLnZpcnR1YWwuZW5hYmxlZCkge1xcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGh1bWJzVG9BY3RpdmF0ZTsgaSArPSAxKSB7XFxuICAgICAgICB0aHVtYnNTd2lwZXIuJHdyYXBwZXJFbC5jaGlsZHJlbihcXFwiW2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVxcXFxcXFwiXFxcIiArIChzd2lwZXIucmVhbEluZGV4ICsgaSkgKyBcXFwiXFxcXFxcXCJdXFxcIikuYWRkQ2xhc3ModGh1bWJBY3RpdmVDbGFzcyk7XFxuICAgICAgfVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCB0aHVtYnNUb0FjdGl2YXRlOyBfaSArPSAxKSB7XFxuICAgICAgICB0aHVtYnNTd2lwZXIuc2xpZGVzLmVxKHN3aXBlci5yZWFsSW5kZXggKyBfaSkuYWRkQ2xhc3ModGh1bWJBY3RpdmVDbGFzcyk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxufTtcXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IF9fV0VCUEFDS19ERUZBVUxUX0VYUE9SVF9fID0gKHtcXG4gIG5hbWU6ICd0aHVtYnMnLFxcbiAgcGFyYW1zOiB7XFxuICAgIHRodW1iczoge1xcbiAgICAgIHN3aXBlcjogbnVsbCxcXG4gICAgICBtdWx0aXBsZUFjdGl2ZVRodW1iczogdHJ1ZSxcXG4gICAgICBhdXRvU2Nyb2xsT2Zmc2V0OiAwLFxcbiAgICAgIHNsaWRlVGh1bWJBY3RpdmVDbGFzczogJ3N3aXBlci1zbGlkZS10aHVtYi1hY3RpdmUnLFxcbiAgICAgIHRodW1ic0NvbnRhaW5lckNsYXNzOiAnc3dpcGVyLWNvbnRhaW5lci10aHVtYnMnXFxuICAgIH1cXG4gIH0sXFxuICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcXG4gICAgdmFyIHN3aXBlciA9IHRoaXM7XFxuICAgICgwLF91dGlsc191dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLmJpbmRNb2R1bGVNZXRob2RzKShzd2lwZXIsIHtcXG4gICAgICB0aHVtYnM6IF9leHRlbmRzKHtcXG4gICAgICAgIHN3aXBlcjogbnVsbCxcXG4gICAgICAgIGluaXRpYWxpemVkOiBmYWxzZVxcbiAgICAgIH0sIFRodW1icylcXG4gICAgfSk7XFxuICB9LFxcbiAgb246IHtcXG4gICAgYmVmb3JlSW5pdDogZnVuY3Rpb24gYmVmb3JlSW5pdChzd2lwZXIpIHtcXG4gICAgICB2YXIgdGh1bWJzID0gc3dpcGVyLnBhcmFtcy50aHVtYnM7XFxuICAgICAgaWYgKCF0aHVtYnMgfHwgIXRodW1icy5zd2lwZXIpIHJldHVybjtcXG4gICAgICBzd2lwZXIudGh1bWJzLmluaXQoKTtcXG4gICAgICBzd2lwZXIudGh1bWJzLnVwZGF0ZSh0cnVlKTtcXG4gICAgfSxcXG4gICAgc2xpZGVDaGFuZ2U6IGZ1bmN0aW9uIHNsaWRlQ2hhbmdlKHN3aXBlcikge1xcbiAgICAgIGlmICghc3dpcGVyLnRodW1icy5zd2lwZXIpIHJldHVybjtcXG4gICAgICBzd2lwZXIudGh1bWJzLnVwZGF0ZSgpO1xcbiAgICB9LFxcbiAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZShzd2lwZXIpIHtcXG4gICAgICBpZiAoIXN3aXBlci50aHVtYnMuc3dpcGVyKSByZXR1cm47XFxuICAgICAgc3dpcGVyLnRodW1icy51cGRhdGUoKTtcXG4gICAgfSxcXG4gICAgcmVzaXplOiBmdW5jdGlvbiByZXNpemUoc3dpcGVyKSB7XFxuICAgICAgaWYgKCFzd2lwZXIudGh1bWJzLnN3aXBlcikgcmV0dXJuO1xcbiAgICAgIHN3aXBlci50aHVtYnMudXBkYXRlKCk7XFxuICAgIH0sXFxuICAgIG9ic2VydmVyVXBkYXRlOiBmdW5jdGlvbiBvYnNlcnZlclVwZGF0ZShzd2lwZXIpIHtcXG4gICAgICBpZiAoIXN3aXBlci50aHVtYnMuc3dpcGVyKSByZXR1cm47XFxuICAgICAgc3dpcGVyLnRodW1icy51cGRhdGUoKTtcXG4gICAgfSxcXG4gICAgc2V0VHJhbnNpdGlvbjogZnVuY3Rpb24gc2V0VHJhbnNpdGlvbihzd2lwZXIsIGR1cmF0aW9uKSB7XFxuICAgICAgdmFyIHRodW1ic1N3aXBlciA9IHN3aXBlci50aHVtYnMuc3dpcGVyO1xcbiAgICAgIGlmICghdGh1bWJzU3dpcGVyKSByZXR1cm47XFxuICAgICAgdGh1bWJzU3dpcGVyLnNldFRyYW5zaXRpb24oZHVyYXRpb24pO1xcbiAgICB9LFxcbiAgICBiZWZvcmVEZXN0cm95OiBmdW5jdGlvbiBiZWZvcmVEZXN0cm95KHN3aXBlcikge1xcbiAgICAgIHZhciB0aHVtYnNTd2lwZXIgPSBzd2lwZXIudGh1bWJzLnN3aXBlcjtcXG4gICAgICBpZiAoIXRodW1ic1N3aXBlcikgcmV0dXJuO1xcblxcbiAgICAgIGlmIChzd2lwZXIudGh1bWJzLnN3aXBlckNyZWF0ZWQgJiYgdGh1bWJzU3dpcGVyKSB7XFxuICAgICAgICB0aHVtYnNTd2lwZXIuZGVzdHJveSgpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcbn0pO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3BhcnVzLy4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vY29tcG9uZW50cy90aHVtYnMvdGh1bWJzLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9tb2R1bGVzL29ic2VydmVyL29ic2VydmVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL21vZHVsZXMvb2JzZXJ2ZXIvb2JzZXJ2ZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJkZWZhdWx0XFxcIjogKCkgPT4gKF9fV0VCUEFDS19ERUZBVUxUX0VYUE9SVF9fKVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBzc3Jfd2luZG93X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBzc3Itd2luZG93ICovIFxcXCIuL25vZGVfbW9kdWxlcy9zc3Itd2luZG93L3Nzci13aW5kb3cuZXNtLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc191dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vdXRpbHMvdXRpbHMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vdXRpbHMvdXRpbHMuanNcXFwiKTtcXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxcblxcblxcblxcbnZhciBPYnNlcnZlciA9IHtcXG4gIGF0dGFjaDogZnVuY3Rpb24gYXR0YWNoKHRhcmdldCwgb3B0aW9ucykge1xcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XFxuICAgICAgb3B0aW9ucyA9IHt9O1xcbiAgICB9XFxuXFxuICAgIHZhciB3aW5kb3cgPSAoMCxzc3Jfd2luZG93X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uZ2V0V2luZG93KSgpO1xcbiAgICB2YXIgc3dpcGVyID0gdGhpcztcXG4gICAgdmFyIE9ic2VydmVyRnVuYyA9IHdpbmRvdy5NdXRhdGlvbk9ic2VydmVyIHx8IHdpbmRvdy5XZWJraXRNdXRhdGlvbk9ic2VydmVyO1xcbiAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgT2JzZXJ2ZXJGdW5jKGZ1bmN0aW9uIChtdXRhdGlvbnMpIHtcXG4gICAgICAvLyBUaGUgb2JzZXJ2ZXJVcGRhdGUgZXZlbnQgc2hvdWxkIG9ubHkgYmUgdHJpZ2dlcmVkXFxuICAgICAgLy8gb25jZSBkZXNwaXRlIHRoZSBudW1iZXIgb2YgbXV0YXRpb25zLiAgQWRkaXRpb25hbFxcbiAgICAgIC8vIHRyaWdnZXJzIGFyZSByZWR1bmRhbnQgYW5kIGFyZSB2ZXJ5IGNvc3RseVxcbiAgICAgIGlmIChtdXRhdGlvbnMubGVuZ3RoID09PSAxKSB7XFxuICAgICAgICBzd2lwZXIuZW1pdCgnb2JzZXJ2ZXJVcGRhdGUnLCBtdXRhdGlvbnNbMF0pO1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgb2JzZXJ2ZXJVcGRhdGUgPSBmdW5jdGlvbiBvYnNlcnZlclVwZGF0ZSgpIHtcXG4gICAgICAgIHN3aXBlci5lbWl0KCdvYnNlcnZlclVwZGF0ZScsIG11dGF0aW9uc1swXSk7XFxuICAgICAgfTtcXG5cXG4gICAgICBpZiAod2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShvYnNlcnZlclVwZGF0ZSk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KG9ic2VydmVyVXBkYXRlLCAwKTtcXG4gICAgICB9XFxuICAgIH0pO1xcbiAgICBvYnNlcnZlci5vYnNlcnZlKHRhcmdldCwge1xcbiAgICAgIGF0dHJpYnV0ZXM6IHR5cGVvZiBvcHRpb25zLmF0dHJpYnV0ZXMgPT09ICd1bmRlZmluZWQnID8gdHJ1ZSA6IG9wdGlvbnMuYXR0cmlidXRlcyxcXG4gICAgICBjaGlsZExpc3Q6IHR5cGVvZiBvcHRpb25zLmNoaWxkTGlzdCA9PT0gJ3VuZGVmaW5lZCcgPyB0cnVlIDogb3B0aW9ucy5jaGlsZExpc3QsXFxuICAgICAgY2hhcmFjdGVyRGF0YTogdHlwZW9mIG9wdGlvbnMuY2hhcmFjdGVyRGF0YSA9PT0gJ3VuZGVmaW5lZCcgPyB0cnVlIDogb3B0aW9ucy5jaGFyYWN0ZXJEYXRhXFxuICAgIH0pO1xcbiAgICBzd2lwZXIub2JzZXJ2ZXIub2JzZXJ2ZXJzLnB1c2gob2JzZXJ2ZXIpO1xcbiAgfSxcXG4gIGluaXQ6IGZ1bmN0aW9uIGluaXQoKSB7XFxuICAgIHZhciBzd2lwZXIgPSB0aGlzO1xcbiAgICBpZiAoIXN3aXBlci5zdXBwb3J0Lm9ic2VydmVyIHx8ICFzd2lwZXIucGFyYW1zLm9ic2VydmVyKSByZXR1cm47XFxuXFxuICAgIGlmIChzd2lwZXIucGFyYW1zLm9ic2VydmVQYXJlbnRzKSB7XFxuICAgICAgdmFyIGNvbnRhaW5lclBhcmVudHMgPSBzd2lwZXIuJGVsLnBhcmVudHMoKTtcXG5cXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnRhaW5lclBhcmVudHMubGVuZ3RoOyBpICs9IDEpIHtcXG4gICAgICAgIHN3aXBlci5vYnNlcnZlci5hdHRhY2goY29udGFpbmVyUGFyZW50c1tpXSk7XFxuICAgICAgfVxcbiAgICB9IC8vIE9ic2VydmUgY29udGFpbmVyXFxuXFxuXFxuICAgIHN3aXBlci5vYnNlcnZlci5hdHRhY2goc3dpcGVyLiRlbFswXSwge1xcbiAgICAgIGNoaWxkTGlzdDogc3dpcGVyLnBhcmFtcy5vYnNlcnZlU2xpZGVDaGlsZHJlblxcbiAgICB9KTsgLy8gT2JzZXJ2ZSB3cmFwcGVyXFxuXFxuICAgIHN3aXBlci5vYnNlcnZlci5hdHRhY2goc3dpcGVyLiR3cmFwcGVyRWxbMF0sIHtcXG4gICAgICBhdHRyaWJ1dGVzOiBmYWxzZVxcbiAgICB9KTtcXG4gIH0sXFxuICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xcbiAgICB2YXIgc3dpcGVyID0gdGhpcztcXG4gICAgc3dpcGVyLm9ic2VydmVyLm9ic2VydmVycy5mb3JFYWNoKGZ1bmN0aW9uIChvYnNlcnZlcikge1xcbiAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcXG4gICAgfSk7XFxuICAgIHN3aXBlci5vYnNlcnZlci5vYnNlcnZlcnMgPSBbXTtcXG4gIH1cXG59O1xcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgX19XRUJQQUNLX0RFRkFVTFRfRVhQT1JUX18gPSAoe1xcbiAgbmFtZTogJ29ic2VydmVyJyxcXG4gIHBhcmFtczoge1xcbiAgICBvYnNlcnZlcjogZmFsc2UsXFxuICAgIG9ic2VydmVQYXJlbnRzOiBmYWxzZSxcXG4gICAgb2JzZXJ2ZVNsaWRlQ2hpbGRyZW46IGZhbHNlXFxuICB9LFxcbiAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUoKSB7XFxuICAgIHZhciBzd2lwZXIgPSB0aGlzO1xcbiAgICAoMCxfdXRpbHNfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5iaW5kTW9kdWxlTWV0aG9kcykoc3dpcGVyLCB7XFxuICAgICAgb2JzZXJ2ZXI6IF9leHRlbmRzKHt9LCBPYnNlcnZlciwge1xcbiAgICAgICAgb2JzZXJ2ZXJzOiBbXVxcbiAgICAgIH0pXFxuICAgIH0pO1xcbiAgfSxcXG4gIG9uOiB7XFxuICAgIGluaXQ6IGZ1bmN0aW9uIGluaXQoc3dpcGVyKSB7XFxuICAgICAgc3dpcGVyLm9ic2VydmVyLmluaXQoKTtcXG4gICAgfSxcXG4gICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveShzd2lwZXIpIHtcXG4gICAgICBzd2lwZXIub2JzZXJ2ZXIuZGVzdHJveSgpO1xcbiAgICB9XFxuICB9XFxufSk7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vcGFydXMvLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9tb2R1bGVzL29ic2VydmVyL29ic2VydmVyLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9tb2R1bGVzL3Jlc2l6ZS9yZXNpemUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9tb2R1bGVzL3Jlc2l6ZS9yZXNpemUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcImRlZmF1bHRcXFwiOiAoKSA9PiAoX19XRUJQQUNLX0RFRkFVTFRfRVhQT1JUX18pXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHNzci13aW5kb3cgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3Nzci13aW5kb3cvc3NyLXdpbmRvdy5lc20uanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi91dGlscy91dGlscyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS91dGlscy91dGlscy5qc1xcXCIpO1xcblxcblxcblxcbnZhciBzdXBwb3J0c1Jlc2l6ZU9ic2VydmVyID0gZnVuY3Rpb24gc3VwcG9ydHNSZXNpemVPYnNlcnZlcigpIHtcXG4gIHZhciB3aW5kb3cgPSAoMCxzc3Jfd2luZG93X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uZ2V0V2luZG93KSgpO1xcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cuUmVzaXplT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnO1xcbn07XFxuXFxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBfX1dFQlBBQ0tfREVGQVVMVF9FWFBPUlRfXyA9ICh7XFxuICBuYW1lOiAncmVzaXplJyxcXG4gIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKCkge1xcbiAgICB2YXIgc3dpcGVyID0gdGhpcztcXG4gICAgKDAsX3V0aWxzX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uZXh0ZW5kKShzd2lwZXIsIHtcXG4gICAgICByZXNpemU6IHtcXG4gICAgICAgIG9ic2VydmVyOiBudWxsLFxcbiAgICAgICAgY3JlYXRlT2JzZXJ2ZXI6IGZ1bmN0aW9uIGNyZWF0ZU9ic2VydmVyKCkge1xcbiAgICAgICAgICBpZiAoIXN3aXBlciB8fCBzd2lwZXIuZGVzdHJveWVkIHx8ICFzd2lwZXIuaW5pdGlhbGl6ZWQpIHJldHVybjtcXG4gICAgICAgICAgc3dpcGVyLnJlc2l6ZS5vYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihmdW5jdGlvbiAoZW50cmllcykge1xcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHN3aXBlci53aWR0aCxcXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gc3dpcGVyLmhlaWdodDtcXG4gICAgICAgICAgICB2YXIgbmV3V2lkdGggPSB3aWR0aDtcXG4gICAgICAgICAgICB2YXIgbmV3SGVpZ2h0ID0gaGVpZ2h0O1xcbiAgICAgICAgICAgIGVudHJpZXMuZm9yRWFjaChmdW5jdGlvbiAoX3JlZikge1xcbiAgICAgICAgICAgICAgdmFyIGNvbnRlbnRCb3hTaXplID0gX3JlZi5jb250ZW50Qm94U2l6ZSxcXG4gICAgICAgICAgICAgICAgICBjb250ZW50UmVjdCA9IF9yZWYuY29udGVudFJlY3QsXFxuICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gX3JlZi50YXJnZXQ7XFxuICAgICAgICAgICAgICBpZiAodGFyZ2V0ICYmIHRhcmdldCAhPT0gc3dpcGVyLmVsKSByZXR1cm47XFxuICAgICAgICAgICAgICBuZXdXaWR0aCA9IGNvbnRlbnRSZWN0ID8gY29udGVudFJlY3Qud2lkdGggOiAoY29udGVudEJveFNpemVbMF0gfHwgY29udGVudEJveFNpemUpLmlubGluZVNpemU7XFxuICAgICAgICAgICAgICBuZXdIZWlnaHQgPSBjb250ZW50UmVjdCA/IGNvbnRlbnRSZWN0LmhlaWdodCA6IChjb250ZW50Qm94U2l6ZVswXSB8fCBjb250ZW50Qm94U2l6ZSkuYmxvY2tTaXplO1xcbiAgICAgICAgICAgIH0pO1xcblxcbiAgICAgICAgICAgIGlmIChuZXdXaWR0aCAhPT0gd2lkdGggfHwgbmV3SGVpZ2h0ICE9PSBoZWlnaHQpIHtcXG4gICAgICAgICAgICAgIHN3aXBlci5yZXNpemUucmVzaXplSGFuZGxlcigpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSk7XFxuICAgICAgICAgIHN3aXBlci5yZXNpemUub2JzZXJ2ZXIub2JzZXJ2ZShzd2lwZXIuZWwpO1xcbiAgICAgICAgfSxcXG4gICAgICAgIHJlbW92ZU9ic2VydmVyOiBmdW5jdGlvbiByZW1vdmVPYnNlcnZlcigpIHtcXG4gICAgICAgICAgaWYgKHN3aXBlci5yZXNpemUub2JzZXJ2ZXIgJiYgc3dpcGVyLnJlc2l6ZS5vYnNlcnZlci51bm9ic2VydmUgJiYgc3dpcGVyLmVsKSB7XFxuICAgICAgICAgICAgc3dpcGVyLnJlc2l6ZS5vYnNlcnZlci51bm9ic2VydmUoc3dpcGVyLmVsKTtcXG4gICAgICAgICAgICBzd2lwZXIucmVzaXplLm9ic2VydmVyID0gbnVsbDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSxcXG4gICAgICAgIHJlc2l6ZUhhbmRsZXI6IGZ1bmN0aW9uIHJlc2l6ZUhhbmRsZXIoKSB7XFxuICAgICAgICAgIGlmICghc3dpcGVyIHx8IHN3aXBlci5kZXN0cm95ZWQgfHwgIXN3aXBlci5pbml0aWFsaXplZCkgcmV0dXJuO1xcbiAgICAgICAgICBzd2lwZXIuZW1pdCgnYmVmb3JlUmVzaXplJyk7XFxuICAgICAgICAgIHN3aXBlci5lbWl0KCdyZXNpemUnKTtcXG4gICAgICAgIH0sXFxuICAgICAgICBvcmllbnRhdGlvbkNoYW5nZUhhbmRsZXI6IGZ1bmN0aW9uIG9yaWVudGF0aW9uQ2hhbmdlSGFuZGxlcigpIHtcXG4gICAgICAgICAgaWYgKCFzd2lwZXIgfHwgc3dpcGVyLmRlc3Ryb3llZCB8fCAhc3dpcGVyLmluaXRpYWxpemVkKSByZXR1cm47XFxuICAgICAgICAgIHN3aXBlci5lbWl0KCdvcmllbnRhdGlvbmNoYW5nZScpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfSk7XFxuICB9LFxcbiAgb246IHtcXG4gICAgaW5pdDogZnVuY3Rpb24gaW5pdChzd2lwZXIpIHtcXG4gICAgICB2YXIgd2luZG93ID0gKDAsc3NyX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmdldFdpbmRvdykoKTtcXG5cXG4gICAgICBpZiAoc3dpcGVyLnBhcmFtcy5yZXNpemVPYnNlcnZlciAmJiBzdXBwb3J0c1Jlc2l6ZU9ic2VydmVyKCkpIHtcXG4gICAgICAgIHN3aXBlci5yZXNpemUuY3JlYXRlT2JzZXJ2ZXIoKTtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9IC8vIEVtaXQgcmVzaXplXFxuXFxuXFxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHN3aXBlci5yZXNpemUucmVzaXplSGFuZGxlcik7IC8vIEVtaXQgb3JpZW50YXRpb25jaGFuZ2VcXG5cXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignb3JpZW50YXRpb25jaGFuZ2UnLCBzd2lwZXIucmVzaXplLm9yaWVudGF0aW9uQ2hhbmdlSGFuZGxlcik7XFxuICAgIH0sXFxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koc3dpcGVyKSB7XFxuICAgICAgdmFyIHdpbmRvdyA9ICgwLHNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5nZXRXaW5kb3cpKCk7XFxuICAgICAgc3dpcGVyLnJlc2l6ZS5yZW1vdmVPYnNlcnZlcigpO1xcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBzd2lwZXIucmVzaXplLnJlc2l6ZUhhbmRsZXIpO1xcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdvcmllbnRhdGlvbmNoYW5nZScsIHN3aXBlci5yZXNpemUub3JpZW50YXRpb25DaGFuZ2VIYW5kbGVyKTtcXG4gICAgfVxcbiAgfVxcbn0pO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3BhcnVzLy4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vbW9kdWxlcy9yZXNpemUvcmVzaXplLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS91dGlscy9kb20uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS91dGlscy9kb20uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcImRlZmF1bHRcXFwiOiAoKSA9PiAoX19XRUJQQUNLX0RFRkFVTFRfRVhQT1JUX18pXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGRvbTdfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGRvbTcgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2RvbTcvZG9tNy5lc20uanNcXFwiKTtcXG5cXG52YXIgTWV0aG9kcyA9IHtcXG4gIGFkZENsYXNzOiBkb203X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uYWRkQ2xhc3MsXFxuICByZW1vdmVDbGFzczogZG9tN19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLnJlbW92ZUNsYXNzLFxcbiAgaGFzQ2xhc3M6IGRvbTdfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5oYXNDbGFzcyxcXG4gIHRvZ2dsZUNsYXNzOiBkb203X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18udG9nZ2xlQ2xhc3MsXFxuICBhdHRyOiBkb203X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uYXR0cixcXG4gIHJlbW92ZUF0dHI6IGRvbTdfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5yZW1vdmVBdHRyLFxcbiAgdHJhbnNmb3JtOiBkb203X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18udHJhbnNmb3JtLFxcbiAgdHJhbnNpdGlvbjogZG9tN19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLnRyYW5zaXRpb24sXFxuICBvbjogZG9tN19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLm9uLFxcbiAgb2ZmOiBkb203X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18ub2ZmLFxcbiAgdHJpZ2dlcjogZG9tN19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLnRyaWdnZXIsXFxuICB0cmFuc2l0aW9uRW5kOiBkb203X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18udHJhbnNpdGlvbkVuZCxcXG4gIG91dGVyV2lkdGg6IGRvbTdfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5vdXRlcldpZHRoLFxcbiAgb3V0ZXJIZWlnaHQ6IGRvbTdfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5vdXRlckhlaWdodCxcXG4gIHN0eWxlczogZG9tN19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLnN0eWxlcyxcXG4gIG9mZnNldDogZG9tN19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLm9mZnNldCxcXG4gIGNzczogZG9tN19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmNzcyxcXG4gIGVhY2g6IGRvbTdfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5lYWNoLFxcbiAgaHRtbDogZG9tN19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmh0bWwsXFxuICB0ZXh0OiBkb203X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18udGV4dCxcXG4gIGlzOiBkb203X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uaXMsXFxuICBpbmRleDogZG9tN19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmluZGV4LFxcbiAgZXE6IGRvbTdfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5lcSxcXG4gIGFwcGVuZDogZG9tN19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmFwcGVuZCxcXG4gIHByZXBlbmQ6IGRvbTdfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5wcmVwZW5kLFxcbiAgbmV4dDogZG9tN19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLm5leHQsXFxuICBuZXh0QWxsOiBkb203X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18ubmV4dEFsbCxcXG4gIHByZXY6IGRvbTdfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5wcmV2LFxcbiAgcHJldkFsbDogZG9tN19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLnByZXZBbGwsXFxuICBwYXJlbnQ6IGRvbTdfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5wYXJlbnQsXFxuICBwYXJlbnRzOiBkb203X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18ucGFyZW50cyxcXG4gIGNsb3Nlc3Q6IGRvbTdfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5jbG9zZXN0LFxcbiAgZmluZDogZG9tN19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmZpbmQsXFxuICBjaGlsZHJlbjogZG9tN19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmNoaWxkcmVuLFxcbiAgZmlsdGVyOiBkb203X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uZmlsdGVyLFxcbiAgcmVtb3ZlOiBkb203X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18ucmVtb3ZlXFxufTtcXG5PYmplY3Qua2V5cyhNZXRob2RzKS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2ROYW1lKSB7XFxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZG9tN19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLiQuZm4sIG1ldGhvZE5hbWUsIHtcXG4gICAgdmFsdWU6IE1ldGhvZHNbbWV0aG9kTmFtZV0sXFxuICAgIHdyaXRhYmxlOiB0cnVlXFxuICB9KTtcXG59KTtcXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IF9fV0VCUEFDS19ERUZBVUxUX0VYUE9SVF9fID0gKGRvbTdfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy4kKTtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9wYXJ1cy8uL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL3V0aWxzL2RvbS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vdXRpbHMvZ2V0LWJyb3dzZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL3V0aWxzL2dldC1icm93c2VyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgZ2V0QnJvd3NlcjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gZ2V0QnJvd3NlcilcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgc3NyX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgc3NyLXdpbmRvdyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc3NyLXdpbmRvdy9zc3Itd2luZG93LmVzbS5qc1xcXCIpO1xcblxcbnZhciBicm93c2VyO1xcblxcbmZ1bmN0aW9uIGNhbGNCcm93c2VyKCkge1xcbiAgdmFyIHdpbmRvdyA9ICgwLHNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5nZXRXaW5kb3cpKCk7XFxuXFxuICBmdW5jdGlvbiBpc1NhZmFyaSgpIHtcXG4gICAgdmFyIHVhID0gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcXG4gICAgcmV0dXJuIHVhLmluZGV4T2YoJ3NhZmFyaScpID49IDAgJiYgdWEuaW5kZXhPZignY2hyb21lJykgPCAwICYmIHVhLmluZGV4T2YoJ2FuZHJvaWQnKSA8IDA7XFxuICB9XFxuXFxuICByZXR1cm4ge1xcbiAgICBpc0VkZ2U6ICEhd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0VkZ2UvZyksXFxuICAgIGlzU2FmYXJpOiBpc1NhZmFyaSgpLFxcbiAgICBpc1dlYlZpZXc6IC8oaVBob25lfGlQb2R8aVBhZCkuKkFwcGxlV2ViS2l0KD8hLipTYWZhcmkpL2kudGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudClcXG4gIH07XFxufVxcblxcbmZ1bmN0aW9uIGdldEJyb3dzZXIoKSB7XFxuICBpZiAoIWJyb3dzZXIpIHtcXG4gICAgYnJvd3NlciA9IGNhbGNCcm93c2VyKCk7XFxuICB9XFxuXFxuICByZXR1cm4gYnJvd3NlcjtcXG59XFxuXFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vcGFydXMvLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS91dGlscy9nZXQtYnJvd3Nlci5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vdXRpbHMvZ2V0LWRldmljZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS91dGlscy9nZXQtZGV2aWNlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBnZXREZXZpY2U6ICgpID0+ICgvKiBiaW5kaW5nICovIGdldERldmljZSlcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgc3NyX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgc3NyLXdpbmRvdyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc3NyLXdpbmRvdy9zc3Itd2luZG93LmVzbS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZ2V0X3N1cHBvcnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ2V0LXN1cHBvcnQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vdXRpbHMvZ2V0LXN1cHBvcnQuanNcXFwiKTtcXG5cXG5cXG52YXIgZGV2aWNlO1xcblxcbmZ1bmN0aW9uIGNhbGNEZXZpY2UoX3RlbXApIHtcXG4gIHZhciBfcmVmID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXAsXFxuICAgICAgdXNlckFnZW50ID0gX3JlZi51c2VyQWdlbnQ7XFxuXFxuICB2YXIgc3VwcG9ydCA9ICgwLF9nZXRfc3VwcG9ydF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLmdldFN1cHBvcnQpKCk7XFxuICB2YXIgd2luZG93ID0gKDAsc3NyX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmdldFdpbmRvdykoKTtcXG4gIHZhciBwbGF0Zm9ybSA9IHdpbmRvdy5uYXZpZ2F0b3IucGxhdGZvcm07XFxuICB2YXIgdWEgPSB1c2VyQWdlbnQgfHwgd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQ7XFxuICB2YXIgZGV2aWNlID0ge1xcbiAgICBpb3M6IGZhbHNlLFxcbiAgICBhbmRyb2lkOiBmYWxzZVxcbiAgfTtcXG4gIHZhciBzY3JlZW5XaWR0aCA9IHdpbmRvdy5zY3JlZW4ud2lkdGg7XFxuICB2YXIgc2NyZWVuSGVpZ2h0ID0gd2luZG93LnNjcmVlbi5oZWlnaHQ7XFxuICB2YXIgYW5kcm9pZCA9IHVhLm1hdGNoKC8oQW5kcm9pZCk7P1tcXFxcc1xcXFwvXSsoW1xcXFxkLl0rKT8vKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxcblxcbiAgdmFyIGlwYWQgPSB1YS5tYXRjaCgvKGlQYWQpLipPU1xcXFxzKFtcXFxcZF9dKykvKTtcXG4gIHZhciBpcG9kID0gdWEubWF0Y2goLyhpUG9kKSguKk9TXFxcXHMoW1xcXFxkX10rKSk/Lyk7XFxuICB2YXIgaXBob25lID0gIWlwYWQgJiYgdWEubWF0Y2goLyhpUGhvbmVcXFxcc09TfGlPUylcXFxccyhbXFxcXGRfXSspLyk7XFxuICB2YXIgd2luZG93cyA9IHBsYXRmb3JtID09PSAnV2luMzInO1xcbiAgdmFyIG1hY29zID0gcGxhdGZvcm0gPT09ICdNYWNJbnRlbCc7IC8vIGlQYWRPcyAxMyBmaXhcXG5cXG4gIHZhciBpUGFkU2NyZWVucyA9IFsnMTAyNHgxMzY2JywgJzEzNjZ4MTAyNCcsICc4MzR4MTE5NCcsICcxMTk0eDgzNCcsICc4MzR4MTExMicsICcxMTEyeDgzNCcsICc3Njh4MTAyNCcsICcxMDI0eDc2OCcsICc4MjB4MTE4MCcsICcxMTgweDgyMCcsICc4MTB4MTA4MCcsICcxMDgweDgxMCddO1xcblxcbiAgaWYgKCFpcGFkICYmIG1hY29zICYmIHN1cHBvcnQudG91Y2ggJiYgaVBhZFNjcmVlbnMuaW5kZXhPZihzY3JlZW5XaWR0aCArIFxcXCJ4XFxcIiArIHNjcmVlbkhlaWdodCkgPj0gMCkge1xcbiAgICBpcGFkID0gdWEubWF0Y2goLyhWZXJzaW9uKVxcXFwvKFtcXFxcZC5dKykvKTtcXG4gICAgaWYgKCFpcGFkKSBpcGFkID0gWzAsIDEsICcxM18wXzAnXTtcXG4gICAgbWFjb3MgPSBmYWxzZTtcXG4gIH0gLy8gQW5kcm9pZFxcblxcblxcbiAgaWYgKGFuZHJvaWQgJiYgIXdpbmRvd3MpIHtcXG4gICAgZGV2aWNlLm9zID0gJ2FuZHJvaWQnO1xcbiAgICBkZXZpY2UuYW5kcm9pZCA9IHRydWU7XFxuICB9XFxuXFxuICBpZiAoaXBhZCB8fCBpcGhvbmUgfHwgaXBvZCkge1xcbiAgICBkZXZpY2Uub3MgPSAnaW9zJztcXG4gICAgZGV2aWNlLmlvcyA9IHRydWU7XFxuICB9IC8vIEV4cG9ydCBvYmplY3RcXG5cXG5cXG4gIHJldHVybiBkZXZpY2U7XFxufVxcblxcbmZ1bmN0aW9uIGdldERldmljZShvdmVycmlkZXMpIHtcXG4gIGlmIChvdmVycmlkZXMgPT09IHZvaWQgMCkge1xcbiAgICBvdmVycmlkZXMgPSB7fTtcXG4gIH1cXG5cXG4gIGlmICghZGV2aWNlKSB7XFxuICAgIGRldmljZSA9IGNhbGNEZXZpY2Uob3ZlcnJpZGVzKTtcXG4gIH1cXG5cXG4gIHJldHVybiBkZXZpY2U7XFxufVxcblxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3BhcnVzLy4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vdXRpbHMvZ2V0LWRldmljZS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vdXRpbHMvZ2V0LXN1cHBvcnQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL3V0aWxzL2dldC1zdXBwb3J0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgZ2V0U3VwcG9ydDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gZ2V0U3VwcG9ydClcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgc3NyX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgc3NyLXdpbmRvdyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc3NyLXdpbmRvdy9zc3Itd2luZG93LmVzbS5qc1xcXCIpO1xcblxcbnZhciBzdXBwb3J0O1xcblxcbmZ1bmN0aW9uIGNhbGNTdXBwb3J0KCkge1xcbiAgdmFyIHdpbmRvdyA9ICgwLHNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5nZXRXaW5kb3cpKCk7XFxuICB2YXIgZG9jdW1lbnQgPSAoMCxzc3Jfd2luZG93X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uZ2V0RG9jdW1lbnQpKCk7XFxuICByZXR1cm4ge1xcbiAgICB0b3VjaDogISEoJ29udG91Y2hzdGFydCcgaW4gd2luZG93IHx8IHdpbmRvdy5Eb2N1bWVudFRvdWNoICYmIGRvY3VtZW50IGluc3RhbmNlb2Ygd2luZG93LkRvY3VtZW50VG91Y2gpLFxcbiAgICBwb2ludGVyRXZlbnRzOiAhIXdpbmRvdy5Qb2ludGVyRXZlbnQgJiYgJ21heFRvdWNoUG9pbnRzJyBpbiB3aW5kb3cubmF2aWdhdG9yICYmIHdpbmRvdy5uYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPj0gMCxcXG4gICAgb2JzZXJ2ZXI6IGZ1bmN0aW9uIGNoZWNrT2JzZXJ2ZXIoKSB7XFxuICAgICAgcmV0dXJuICdNdXRhdGlvbk9ic2VydmVyJyBpbiB3aW5kb3cgfHwgJ1dlYmtpdE11dGF0aW9uT2JzZXJ2ZXInIGluIHdpbmRvdztcXG4gICAgfSgpLFxcbiAgICBwYXNzaXZlTGlzdGVuZXI6IGZ1bmN0aW9uIGNoZWNrUGFzc2l2ZUxpc3RlbmVyKCkge1xcbiAgICAgIHZhciBzdXBwb3J0c1Bhc3NpdmUgPSBmYWxzZTtcXG5cXG4gICAgICB0cnkge1xcbiAgICAgICAgdmFyIG9wdHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdwYXNzaXZlJywge1xcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XFxuICAgICAgICAgICAgc3VwcG9ydHNQYXNzaXZlID0gdHJ1ZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdFBhc3NpdmVMaXN0ZW5lcicsIG51bGwsIG9wdHMpO1xcbiAgICAgIH0gY2F0Y2ggKGUpIHsvLyBObyBzdXBwb3J0XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBzdXBwb3J0c1Bhc3NpdmU7XFxuICAgIH0oKSxcXG4gICAgZ2VzdHVyZXM6IGZ1bmN0aW9uIGNoZWNrR2VzdHVyZXMoKSB7XFxuICAgICAgcmV0dXJuICdvbmdlc3R1cmVzdGFydCcgaW4gd2luZG93O1xcbiAgICB9KClcXG4gIH07XFxufVxcblxcbmZ1bmN0aW9uIGdldFN1cHBvcnQoKSB7XFxuICBpZiAoIXN1cHBvcnQpIHtcXG4gICAgc3VwcG9ydCA9IGNhbGNTdXBwb3J0KCk7XFxuICB9XFxuXFxuICByZXR1cm4gc3VwcG9ydDtcXG59XFxuXFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vcGFydXMvLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS91dGlscy9nZXQtc3VwcG9ydC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vdXRpbHMvdXRpbHMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL3V0aWxzL3V0aWxzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgYmluZE1vZHVsZU1ldGhvZHM6ICgpID0+ICgvKiBiaW5kaW5nICovIGJpbmRNb2R1bGVNZXRob2RzKSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIGNsYXNzZXNUb1NlbGVjdG9yOiAoKSA9PiAoLyogYmluZGluZyAqLyBjbGFzc2VzVG9TZWxlY3RvciksXFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBjcmVhdGVFbGVtZW50SWZOb3REZWZpbmVkOiAoKSA9PiAoLyogYmluZGluZyAqLyBjcmVhdGVFbGVtZW50SWZOb3REZWZpbmVkKSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIGRlbGV0ZVByb3BzOiAoKSA9PiAoLyogYmluZGluZyAqLyBkZWxldGVQcm9wcyksXFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBleHRlbmQ6ICgpID0+ICgvKiBiaW5kaW5nICovIGV4dGVuZCksXFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBnZXRDb21wdXRlZFN0eWxlOiAoKSA9PiAoLyogYmluZGluZyAqLyBnZXRDb21wdXRlZFN0eWxlKSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIGdldFRyYW5zbGF0ZTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gZ2V0VHJhbnNsYXRlKSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIGlzT2JqZWN0OiAoKSA9PiAoLyogYmluZGluZyAqLyBpc09iamVjdCksXFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBuZXh0VGljazogKCkgPT4gKC8qIGJpbmRpbmcgKi8gbmV4dFRpY2spLFxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgbm93OiAoKSA9PiAoLyogYmluZGluZyAqLyBub3cpXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHNzci13aW5kb3cgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3Nzci13aW5kb3cvc3NyLXdpbmRvdy5lc20uanNcXFwiKTtcXG5cXG5cXG5mdW5jdGlvbiBkZWxldGVQcm9wcyhvYmopIHtcXG4gIHZhciBvYmplY3QgPSBvYmo7XFxuICBPYmplY3Qua2V5cyhvYmplY3QpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xcbiAgICB0cnkge1xcbiAgICAgIG9iamVjdFtrZXldID0gbnVsbDtcXG4gICAgfSBjYXRjaCAoZSkgey8vIG5vIGdldHRlciBmb3Igb2JqZWN0XFxuICAgIH1cXG5cXG4gICAgdHJ5IHtcXG4gICAgICBkZWxldGUgb2JqZWN0W2tleV07XFxuICAgIH0gY2F0Y2ggKGUpIHsvLyBzb21ldGhpbmcgZ290IHdyb25nXFxuICAgIH1cXG4gIH0pO1xcbn1cXG5cXG5mdW5jdGlvbiBuZXh0VGljayhjYWxsYmFjaywgZGVsYXkpIHtcXG4gIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7XFxuICAgIGRlbGF5ID0gMDtcXG4gIH1cXG5cXG4gIHJldHVybiBzZXRUaW1lb3V0KGNhbGxiYWNrLCBkZWxheSk7XFxufVxcblxcbmZ1bmN0aW9uIG5vdygpIHtcXG4gIHJldHVybiBEYXRlLm5vdygpO1xcbn1cXG5cXG5mdW5jdGlvbiBnZXRDb21wdXRlZFN0eWxlKGVsKSB7XFxuICB2YXIgd2luZG93ID0gKDAsc3NyX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmdldFdpbmRvdykoKTtcXG4gIHZhciBzdHlsZTtcXG5cXG4gIGlmICh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSkge1xcbiAgICBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsLCBudWxsKTtcXG4gIH1cXG5cXG4gIGlmICghc3R5bGUgJiYgZWwuY3VycmVudFN0eWxlKSB7XFxuICAgIHN0eWxlID0gZWwuY3VycmVudFN0eWxlO1xcbiAgfVxcblxcbiAgaWYgKCFzdHlsZSkge1xcbiAgICBzdHlsZSA9IGVsLnN0eWxlO1xcbiAgfVxcblxcbiAgcmV0dXJuIHN0eWxlO1xcbn1cXG5cXG5mdW5jdGlvbiBnZXRUcmFuc2xhdGUoZWwsIGF4aXMpIHtcXG4gIGlmIChheGlzID09PSB2b2lkIDApIHtcXG4gICAgYXhpcyA9ICd4JztcXG4gIH1cXG5cXG4gIHZhciB3aW5kb3cgPSAoMCxzc3Jfd2luZG93X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uZ2V0V2luZG93KSgpO1xcbiAgdmFyIG1hdHJpeDtcXG4gIHZhciBjdXJUcmFuc2Zvcm07XFxuICB2YXIgdHJhbnNmb3JtTWF0cml4O1xcbiAgdmFyIGN1clN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbCwgbnVsbCk7XFxuXFxuICBpZiAod2luZG93LldlYktpdENTU01hdHJpeCkge1xcbiAgICBjdXJUcmFuc2Zvcm0gPSBjdXJTdHlsZS50cmFuc2Zvcm0gfHwgY3VyU3R5bGUud2Via2l0VHJhbnNmb3JtO1xcblxcbiAgICBpZiAoY3VyVHJhbnNmb3JtLnNwbGl0KCcsJykubGVuZ3RoID4gNikge1xcbiAgICAgIGN1clRyYW5zZm9ybSA9IGN1clRyYW5zZm9ybS5zcGxpdCgnLCAnKS5tYXAoZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgIHJldHVybiBhLnJlcGxhY2UoJywnLCAnLicpO1xcbiAgICAgIH0pLmpvaW4oJywgJyk7XFxuICAgIH0gLy8gU29tZSBvbGQgdmVyc2lvbnMgb2YgV2Via2l0IGNob2tlIHdoZW4gJ25vbmUnIGlzIHBhc3NlZDsgcGFzc1xcbiAgICAvLyBlbXB0eSBzdHJpbmcgaW5zdGVhZCBpbiB0aGlzIGNhc2VcXG5cXG5cXG4gICAgdHJhbnNmb3JtTWF0cml4ID0gbmV3IHdpbmRvdy5XZWJLaXRDU1NNYXRyaXgoY3VyVHJhbnNmb3JtID09PSAnbm9uZScgPyAnJyA6IGN1clRyYW5zZm9ybSk7XFxuICB9IGVsc2Uge1xcbiAgICB0cmFuc2Zvcm1NYXRyaXggPSBjdXJTdHlsZS5Nb3pUcmFuc2Zvcm0gfHwgY3VyU3R5bGUuT1RyYW5zZm9ybSB8fCBjdXJTdHlsZS5Nc1RyYW5zZm9ybSB8fCBjdXJTdHlsZS5tc1RyYW5zZm9ybSB8fCBjdXJTdHlsZS50cmFuc2Zvcm0gfHwgY3VyU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgndHJhbnNmb3JtJykucmVwbGFjZSgndHJhbnNsYXRlKCcsICdtYXRyaXgoMSwgMCwgMCwgMSwnKTtcXG4gICAgbWF0cml4ID0gdHJhbnNmb3JtTWF0cml4LnRvU3RyaW5nKCkuc3BsaXQoJywnKTtcXG4gIH1cXG5cXG4gIGlmIChheGlzID09PSAneCcpIHtcXG4gICAgLy8gTGF0ZXN0IENocm9tZSBhbmQgd2Via2l0cyBGaXhcXG4gICAgaWYgKHdpbmRvdy5XZWJLaXRDU1NNYXRyaXgpIGN1clRyYW5zZm9ybSA9IHRyYW5zZm9ybU1hdHJpeC5tNDE7IC8vIENyYXp5IElFMTAgTWF0cml4XFxuICAgIGVsc2UgaWYgKG1hdHJpeC5sZW5ndGggPT09IDE2KSBjdXJUcmFuc2Zvcm0gPSBwYXJzZUZsb2F0KG1hdHJpeFsxMl0pOyAvLyBOb3JtYWwgQnJvd3NlcnNcXG4gICAgICBlbHNlIGN1clRyYW5zZm9ybSA9IHBhcnNlRmxvYXQobWF0cml4WzRdKTtcXG4gIH1cXG5cXG4gIGlmIChheGlzID09PSAneScpIHtcXG4gICAgLy8gTGF0ZXN0IENocm9tZSBhbmQgd2Via2l0cyBGaXhcXG4gICAgaWYgKHdpbmRvdy5XZWJLaXRDU1NNYXRyaXgpIGN1clRyYW5zZm9ybSA9IHRyYW5zZm9ybU1hdHJpeC5tNDI7IC8vIENyYXp5IElFMTAgTWF0cml4XFxuICAgIGVsc2UgaWYgKG1hdHJpeC5sZW5ndGggPT09IDE2KSBjdXJUcmFuc2Zvcm0gPSBwYXJzZUZsb2F0KG1hdHJpeFsxM10pOyAvLyBOb3JtYWwgQnJvd3NlcnNcXG4gICAgICBlbHNlIGN1clRyYW5zZm9ybSA9IHBhcnNlRmxvYXQobWF0cml4WzVdKTtcXG4gIH1cXG5cXG4gIHJldHVybiBjdXJUcmFuc2Zvcm0gfHwgMDtcXG59XFxuXFxuZnVuY3Rpb24gaXNPYmplY3Qobykge1xcbiAgcmV0dXJuIHR5cGVvZiBvID09PSAnb2JqZWN0JyAmJiBvICE9PSBudWxsICYmIG8uY29uc3RydWN0b3IgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKSA9PT0gJ09iamVjdCc7XFxufVxcblxcbmZ1bmN0aW9uIGlzTm9kZShub2RlKSB7XFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LkhUTUxFbGVtZW50ICE9PSAndW5kZWZpbmVkJykge1xcbiAgICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xcbiAgfVxcblxcbiAgcmV0dXJuIG5vZGUgJiYgKG5vZGUubm9kZVR5cGUgPT09IDEgfHwgbm9kZS5ub2RlVHlwZSA9PT0gMTEpO1xcbn1cXG5cXG5mdW5jdGlvbiBleHRlbmQoKSB7XFxuICB2YXIgdG8gPSBPYmplY3QoYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdKTtcXG4gIHZhciBub0V4dGVuZCA9IFsnX19wcm90b19fJywgJ2NvbnN0cnVjdG9yJywgJ3Byb3RvdHlwZSddO1xcblxcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpICs9IDEpIHtcXG4gICAgdmFyIG5leHRTb3VyY2UgPSBpIDwgMCB8fCBhcmd1bWVudHMubGVuZ3RoIDw9IGkgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbaV07XFxuXFxuICAgIGlmIChuZXh0U291cmNlICE9PSB1bmRlZmluZWQgJiYgbmV4dFNvdXJjZSAhPT0gbnVsbCAmJiAhaXNOb2RlKG5leHRTb3VyY2UpKSB7XFxuICAgICAgdmFyIGtleXNBcnJheSA9IE9iamVjdC5rZXlzKE9iamVjdChuZXh0U291cmNlKSkuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcXG4gICAgICAgIHJldHVybiBub0V4dGVuZC5pbmRleE9mKGtleSkgPCAwO1xcbiAgICAgIH0pO1xcblxcbiAgICAgIGZvciAodmFyIG5leHRJbmRleCA9IDAsIGxlbiA9IGtleXNBcnJheS5sZW5ndGg7IG5leHRJbmRleCA8IGxlbjsgbmV4dEluZGV4ICs9IDEpIHtcXG4gICAgICAgIHZhciBuZXh0S2V5ID0ga2V5c0FycmF5W25leHRJbmRleF07XFxuICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobmV4dFNvdXJjZSwgbmV4dEtleSk7XFxuXFxuICAgICAgICBpZiAoZGVzYyAhPT0gdW5kZWZpbmVkICYmIGRlc2MuZW51bWVyYWJsZSkge1xcbiAgICAgICAgICBpZiAoaXNPYmplY3QodG9bbmV4dEtleV0pICYmIGlzT2JqZWN0KG5leHRTb3VyY2VbbmV4dEtleV0pKSB7XFxuICAgICAgICAgICAgaWYgKG5leHRTb3VyY2VbbmV4dEtleV0uX19zd2lwZXJfXykge1xcbiAgICAgICAgICAgICAgdG9bbmV4dEtleV0gPSBuZXh0U291cmNlW25leHRLZXldO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICBleHRlbmQodG9bbmV4dEtleV0sIG5leHRTb3VyY2VbbmV4dEtleV0pO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSBlbHNlIGlmICghaXNPYmplY3QodG9bbmV4dEtleV0pICYmIGlzT2JqZWN0KG5leHRTb3VyY2VbbmV4dEtleV0pKSB7XFxuICAgICAgICAgICAgdG9bbmV4dEtleV0gPSB7fTtcXG5cXG4gICAgICAgICAgICBpZiAobmV4dFNvdXJjZVtuZXh0S2V5XS5fX3N3aXBlcl9fKSB7XFxuICAgICAgICAgICAgICB0b1tuZXh0S2V5XSA9IG5leHRTb3VyY2VbbmV4dEtleV07XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgIGV4dGVuZCh0b1tuZXh0S2V5XSwgbmV4dFNvdXJjZVtuZXh0S2V5XSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHRvW25leHRLZXldID0gbmV4dFNvdXJjZVtuZXh0S2V5XTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcblxcbiAgcmV0dXJuIHRvO1xcbn1cXG5cXG5mdW5jdGlvbiBiaW5kTW9kdWxlTWV0aG9kcyhpbnN0YW5jZSwgb2JqKSB7XFxuICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xcbiAgICBpZiAoaXNPYmplY3Qob2JqW2tleV0pKSB7XFxuICAgICAgT2JqZWN0LmtleXMob2JqW2tleV0pLmZvckVhY2goZnVuY3Rpb24gKHN1YktleSkge1xcbiAgICAgICAgaWYgKHR5cGVvZiBvYmpba2V5XVtzdWJLZXldID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICAgIG9ialtrZXldW3N1YktleV0gPSBvYmpba2V5XVtzdWJLZXldLmJpbmQoaW5zdGFuY2UpO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcbiAgICB9XFxuXFxuICAgIGluc3RhbmNlW2tleV0gPSBvYmpba2V5XTtcXG4gIH0pO1xcbn1cXG5cXG5mdW5jdGlvbiBjbGFzc2VzVG9TZWxlY3RvcihjbGFzc2VzKSB7XFxuICBpZiAoY2xhc3NlcyA9PT0gdm9pZCAwKSB7XFxuICAgIGNsYXNzZXMgPSAnJztcXG4gIH1cXG5cXG4gIHJldHVybiBcXFwiLlxcXCIgKyBjbGFzc2VzLnRyaW0oKS5yZXBsYWNlKC8oW1xcXFwuOiFcXFxcL10pL2csICdcXFxcXFxcXCQxJykgLy8gZXNsaW50LWRpc2FibGUtbGluZVxcbiAgLnJlcGxhY2UoLyAvZywgJy4nKTtcXG59XFxuXFxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudElmTm90RGVmaW5lZCgkY29udGFpbmVyLCBwYXJhbXMsIGNyZWF0ZUVsZW1lbnRzLCBjaGVja1Byb3BzKSB7XFxuICB2YXIgZG9jdW1lbnQgPSAoMCxzc3Jfd2luZG93X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uZ2V0RG9jdW1lbnQpKCk7XFxuXFxuICBpZiAoY3JlYXRlRWxlbWVudHMpIHtcXG4gICAgT2JqZWN0LmtleXMoY2hlY2tQcm9wcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XFxuICAgICAgaWYgKCFwYXJhbXNba2V5XSAmJiBwYXJhbXMuYXV0byA9PT0gdHJ1ZSkge1xcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcXG4gICAgICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gY2hlY2tQcm9wc1trZXldO1xcbiAgICAgICAgJGNvbnRhaW5lci5hcHBlbmQoZWxlbWVudCk7XFxuICAgICAgICBwYXJhbXNba2V5XSA9IGVsZW1lbnQ7XFxuICAgICAgfVxcbiAgICB9KTtcXG4gIH1cXG5cXG4gIHJldHVybiBwYXJhbXM7XFxufVxcblxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3BhcnVzLy4vbm9kZV9tb2R1bGVzL3N3aXBlci9lc20vdXRpbHMvdXRpbHMuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21tb24uYmxvY2tzL2J1cmdlci9idXJnZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbW1vbi5ibG9ja3MvYnVyZ2VyL2J1cmdlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2hlYWRlcl9oZWFkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2hlYWRlci9oZWFkZXIgKi8gXFxcIi4vc3JjL2NvbW1vbi5ibG9ja3MvaGVhZGVyL2hlYWRlci5qc1xcXCIpO1xcblxcblxcbmNvbnN0IENTU19CVVJHRVIgPSAnYnVyZ2VyJztcXG5jb25zdCBlbEJ1cmdlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy4nICsgQ1NTX0JVUkdFUik7XFxuXFxuaWYgKCFlbEJ1cmdlcikge1xcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFNlbGVjdG9yIFxcXFwnLiR7Q1NTX0JVUkdFUn1cXFxcJyBub3QgYXZhaWxhYmxlLmApO1xcbn1cXG5cXG5mdW5jdGlvbiB0b2dnbGVNZW51ICgpIHtcXG4gICAgKDAsX2hlYWRlcl9oZWFkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy50b2dnbGVNb2JpbGVNZW51KSgpO1xcbiAgICBlbEJ1cmdlci5jbGFzc0xpc3QudG9nZ2xlKENTU19CVVJHRVIgKyAnX2lzLXNob3ctbWVudScpO1xcbn1cXG5cXG5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuJyArIENTU19CVVJHRVIpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdG9nZ2xlTWVudSk7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vcGFydXMvLi9zcmMvY29tbW9uLmJsb2Nrcy9idXJnZXIvYnVyZ2VyLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tbW9uLmJsb2Nrcy9nYWxsZXJ5LXNsaWRlci9nYWxsZXJ5LXNsaWRlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbW1vbi5ibG9ja3MvZ2FsbGVyeS1zbGlkZXIvZ2FsbGVyeS1zbGlkZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc2VydmljZV9nYWxsZXJ5X3NlcnZpY2VfZ2FsbGVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vc2VydmljZS1nYWxsZXJ5L3NlcnZpY2UtZ2FsbGVyeSAqLyBcXFwiLi9zcmMvY29tbW9uLmJsb2Nrcy9zZXJ2aWNlLWdhbGxlcnkvc2VydmljZS1nYWxsZXJ5LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zZXJ2aWNlX3NsaWRlcl9zZXJ2aWNlX3NsaWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vc2VydmljZS1zbGlkZXIvc2VydmljZS1zbGlkZXIgKi8gXFxcIi4vc3JjL2NvbW1vbi5ibG9ja3Mvc2VydmljZS1zbGlkZXIvc2VydmljZS1zbGlkZXIuanNcXFwiKTtcXG5cXG5cXG5cXG5jb25zdCBDU1NfR0FMTEVSWV9TTElERVIgPSAnZ2FsbGVyeS1zbGlkZXInO1xcbmNvbnN0IGVsR2FsbGVyeVNsaWRlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy4nICsgQ1NTX0dBTExFUllfU0xJREVSKTtcXG5cXG5pZiAoZWxHYWxsZXJ5U2xpZGVyLmxlbmd0aCA+IDApIHtcXG4gICAgZWxHYWxsZXJ5U2xpZGVyLmZvckVhY2goZ2FsbGVyeVNsaWRlciA9PiB7XFxuICAgICAgICBjb25zdCBnYWxsZXJ5ID0gKDAsX3NlcnZpY2VfZ2FsbGVyeV9zZXJ2aWNlX2dhbGxlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5zZXJ2aWNlR2FsbGVyeUluaXQpKGdhbGxlcnlTbGlkZXIucXVlcnlTZWxlY3RvcignLnNlcnZpY2UtZ2FsbGVyeScpKTtcXG5cXG4gICAgICAgICgwLF9zZXJ2aWNlX3NsaWRlcl9zZXJ2aWNlX3NsaWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLnNlcnZpY2VTbGlkZXJJbml0KShnYWxsZXJ5U2xpZGVyLnF1ZXJ5U2VsZWN0b3IoJy5zZXJ2aWNlLXNsaWRlcicpLCBnYWxsZXJ5KTtcXG4gICAgfSk7XFxufVxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3BhcnVzLy4vc3JjL2NvbW1vbi5ibG9ja3MvZ2FsbGVyeS1zbGlkZXIvZ2FsbGVyeS1zbGlkZXIuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21tb24uYmxvY2tzL2hlYWRlci9oZWFkZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbW1vbi5ibG9ja3MvaGVhZGVyL2hlYWRlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgZml4ZWRIZWFkZXJPbkRlc2t0b3A6ICgpID0+ICgvKiBiaW5kaW5nICovIGZpeGVkSGVhZGVyT25EZXNrdG9wKSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIGhpZGVNZW51T25SZXNpemU6ICgpID0+ICgvKiBiaW5kaW5nICovIGhpZGVNZW51T25SZXNpemUpLFxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgaXNNb2JpbGU6ICgpID0+ICgvKiBiaW5kaW5nICovIGlzTW9iaWxlKSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIHRvZ2dsZU1vYmlsZU1lbnU6ICgpID0+ICgvKiBiaW5kaW5nICovIHRvZ2dsZU1vYmlsZU1lbnUpXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuY29uc3QgQ1NTX0hFQURFUiA9ICdoZWFkZXInO1xcbmNvbnN0IGVsSGVhZGVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLicgKyBDU1NfSEVBREVSKTtcXG5sZXQgaXNNb2JpbGUgPSBmYWxzZTtcXG5cXG5pZiAoIWVsSGVhZGVyKSB7XFxuICAgIHRocm93IG5ldyBFcnJvcihgU2VsZWN0b3IgXFxcXCcuJHtDU1NfSEVBREVSfVxcXFwnIG5vdCBhdmFpbGFibGUuYCk7XFxufVxcblxcbmZ1bmN0aW9uIGxvY2tTY3JvbGwgKCkge1xcbiAgICBkb2N1bWVudC5ib2R5LnN0eWxlLnNldFByb3BlcnR5KCdwYWRkaW5nLXJpZ2h0Jywgd2luZG93LmlubmVyV2lkdGggLSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggKyAncHgnKTtcXG4gICAgZG9jdW1lbnQuYm9keS5zdHlsZS5zZXRQcm9wZXJ0eSgnb3ZlcmZsb3cnLCAnaGlkZGVuJyk7XFxufVxcblxcbmZ1bmN0aW9uIHVuTG9ja1Njcm9sbCAoKSB7XFxuICAgIGRvY3VtZW50LmJvZHkuc3R5bGUucmVtb3ZlUHJvcGVydHkoJ3BhZGRpbmctcmlnaHQnKTtcXG4gICAgZG9jdW1lbnQuYm9keS5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgnb3ZlcmZsb3cnKTtcXG59XFxuXFxuZnVuY3Rpb24gdG9nZ2xlTW9iaWxlTWVudSAoKSB7XFxuICAgIGlzTW9iaWxlID0gIWlzTW9iaWxlO1xcbiAgICBpc01vYmlsZSA/IGxvY2tTY3JvbGwoKSA6IHVuTG9ja1Njcm9sbCgpO1xcbiAgICBlbEhlYWRlci5jbGFzc0xpc3QudG9nZ2xlKENTU19IRUFERVIgKyAnX2lzLXNob3ctbWVudScpO1xcbn1cXG5cXG5mdW5jdGlvbiBoaWRlTWVudU9uUmVzaXplICgpIHtcXG4gICAgaWYgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCA+PSAxMDI0ICYmIGVsSGVhZGVyLmNsYXNzTGlzdC5jb250YWlucyhDU1NfSEVBREVSICsgJ19pcy1zaG93LW1lbnUnKSkge1xcbiAgICAgICAgaXNNb2JpbGUgPSBmYWxzZTtcXG4gICAgICAgIGVsSGVhZGVyLmNsYXNzTGlzdC5yZW1vdmUoQ1NTX0hFQURFUiArICdfaXMtc2hvdy1tZW51Jyk7XFxuICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuYnVyZ2VyJykuY2xhc3NMaXN0LnJlbW92ZSgnYnVyZ2VyX2lzLXNob3ctbWVudScpO1xcbiAgICAgICAgdW5Mb2NrU2Nyb2xsKCk7XFxuICAgIH1cXG59XFxuXFxuZnVuY3Rpb24gZml4ZWRIZWFkZXJPbkRlc2t0b3AgKGlzRml4ZWQpIHtcXG4gICAgaXNGaXhlZCA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5wYWdlJykuc3R5bGUuc2V0UHJvcGVydHkoJ3BhZGRpbmctdG9wJywgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLicgKyBDU1NfSEVBREVSKS5vZmZzZXRIZWlnaHQgKyAncHgnKSA6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5wYWdlJykuc3R5bGUucmVtb3ZlUHJvcGVydHkoJ3BhZGRpbmctdG9wJyk7XFxuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy4nICsgQ1NTX0hFQURFUikuY2xhc3NMaXN0W2lzRml4ZWQgPyAnYWRkJyA6ICdyZW1vdmUnXShDU1NfSEVBREVSICsgJ19maXhlZCcpO1xcbn1cXG5cXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9wYXJ1cy8uL3NyYy9jb21tb24uYmxvY2tzL2hlYWRlci9oZWFkZXIuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21tb24uYmxvY2tzL2luZm9ncmFwaGljL2luZm9ncmFwaGljLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tbW9uLmJsb2Nrcy9pbmZvZ3JhcGhpYy9pbmZvZ3JhcGhpYy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIGRlc3Ryb3lJbmZvZ3JhcGhpY1NsaWRlcjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gZGVzdHJveUluZm9ncmFwaGljU2xpZGVyKVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbmNvbnN0IENTU19JTkZPR1JBUEhJQyA9ICdpbmZvZ3JhcGhpYyc7XFxuY29uc3QgZWxJbmZvZ3JhcGhpYyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy4nICsgQ1NTX0lORk9HUkFQSElDKTtcXG5cXG5sZXQgYWN0aXZlSW5kZXggPSAwO1xcblxcbmZ1bmN0aW9uIGNyZWF0ZVBhZ2luYXRpb25FbGVtZW50cyAoKSB7XFxuICAgIGNvbnN0IHBhZ2luYXRpb24gPSBlbEluZm9ncmFwaGljLnF1ZXJ5U2VsZWN0b3IoJy4nICsgQ1NTX0lORk9HUkFQSElDICsgJ19fcGFnaW5hdGlvbicpO1xcbiAgICBjb25zdCBsZW5ndGggPSBlbEluZm9ncmFwaGljLnF1ZXJ5U2VsZWN0b3JBbGwoJy4nICsgQ1NTX0lORk9HUkFQSElDICsgJ19faXRlbScpLmxlbmd0aDtcXG5cXG4gICAgaWYgKGxlbmd0aCA+PSAzKSB7XFxuICAgICAgICBwYWdpbmF0aW9uLmlubmVySFRNTCA9IGA8c3BhbiBjbGFzcz1cXFwiJHtDU1NfSU5GT0dSQVBISUN9X19idWxsZXQgJHtDU1NfSU5GT0dSQVBISUN9X19idWxsZXRfYWN0aXZlXFxcIj48L3NwYW4+PHNwYW4gY2xhc3M9XFxcIiR7Q1NTX0lORk9HUkFQSElDfV9fYnVsbGV0XFxcIj48L3NwYW4+YFxcbiAgICB9XFxufVxcblxcbmZ1bmN0aW9uIGFjdGl2YXRpb25CdWxsZXQgKGJ1bGxldCwgaW5kZXgpIHtcXG4gICAgZWxJbmZvZ3JhcGhpYy5xdWVyeVNlbGVjdG9yKCcuJyArIENTU19JTkZPR1JBUEhJQyArICdfX2J1bGxldF9hY3RpdmUnKS5jbGFzc0xpc3QucmVtb3ZlKENTU19JTkZPR1JBUEhJQyArICdfX2J1bGxldF9hY3RpdmUnKTtcXG4gICAgYnVsbGV0LmNsYXNzTGlzdC5hZGQoQ1NTX0lORk9HUkFQSElDICsgJ19fYnVsbGV0X2FjdGl2ZScpO1xcbn1cXG5cXG5mdW5jdGlvbiBzd2lwZSAoYnVsbGV0LCBpbmRleCkge1xcbiAgICBjb25zdCBzdGVwID0gMjtcXG4gICAgY29uc3Qgd2lkdGggPSBpbmRleCA9PT0gMCA/IDAgOiAnLScgKyBlbEluZm9ncmFwaGljLnF1ZXJ5U2VsZWN0b3IoJy4nICsgQ1NTX0lORk9HUkFQSElDICsgJ19fdGFibGUtaXRlbScpLm9mZnNldFdpZHRoICogKHN0ZXAgKiBpbmRleCk7XFxuXFxuICAgIGVsSW5mb2dyYXBoaWMucXVlcnlTZWxlY3RvcignLmluZm9ncmFwaGljX190YWJsZScpLnN0eWxlLnNldFByb3BlcnR5KCd0cmFuc2Zvcm0nLCAgYHRyYW5zbGF0ZVgoJHt3aWR0aH1weClgKTtcXG59XFxuXFxuZnVuY3Rpb24gY2hhbmdlU2xpZGUgKGJ1bGxldCwgaW5kZXgpIHtcXG4gICAgaWYgKCFidWxsZXQuY2xhc3NMaXN0LmNvbnRhaW5zKENTU19JTkZPR1JBUEhJQyArICdfX2J1bGxldF9hY3RpdmUnKSAmJiB3aW5kb3cubWF0Y2hNZWRpYSgnKG1heC13aWR0aDogNzY3cHgpJykubWF0Y2hlcykge1xcbiAgICAgICAgYWN0aXZlSW5kZXggPSBpbmRleDtcXG4gICAgICAgIGFjdGl2YXRpb25CdWxsZXQoYnVsbGV0LCBpbmRleCk7XFxuICAgICAgICBzd2lwZShidWxsZXQsIGFjdGl2ZUluZGV4KTtcXG4gICAgfVxcbn1cXG5cXG5mdW5jdGlvbiBkZXN0cm95SW5mb2dyYXBoaWNTbGlkZXIgKCkge1xcbiAgICBpZiAoZWxJbmZvZ3JhcGhpYyAmJiB3aW5kb3cubWF0Y2hNZWRpYSgnKG1heC13aWR0aDogNzY3cHgpJykubWF0Y2hlcyAmJiBlbEluZm9ncmFwaGljLnF1ZXJ5U2VsZWN0b3JBbGwoJy4nICsgQ1NTX0lORk9HUkFQSElDICsgJ19faXRlbScpLmxlbmd0aCA+PSAzKSB7XFxuICAgICAgICBjb25zdCBzdGVwID0gMjtcXG4gICAgICAgIGNvbnN0IHdpZHRoID0gYWN0aXZlSW5kZXggPT09IDAgPyAwIDogJy0nICsgZWxJbmZvZ3JhcGhpYy5xdWVyeVNlbGVjdG9yKCcuJyArIENTU19JTkZPR1JBUEhJQyArICdfX3RhYmxlLWl0ZW0nKS5vZmZzZXRXaWR0aCAqIChzdGVwICogYWN0aXZlSW5kZXgpO1xcblxcbiAgICAgICAgZWxJbmZvZ3JhcGhpYy5xdWVyeVNlbGVjdG9yKCcuaW5mb2dyYXBoaWNfX3RhYmxlJykuc3R5bGUuc2V0UHJvcGVydHkoJ3RyYW5zZm9ybScsICBgdHJhbnNsYXRlWCgke3dpZHRofXB4KWApO1xcbiAgICB9XFxuXFxuICAgIGlmIChlbEluZm9ncmFwaGljICYmIHdpbmRvdy5tYXRjaE1lZGlhKCcobWluLXdpZHRoOiA3NjhweCknKS5tYXRjaGVzICYmIGVsSW5mb2dyYXBoaWMucXVlcnlTZWxlY3RvckFsbCgnLicgKyBDU1NfSU5GT0dSQVBISUMgKyAnX19pdGVtJykubGVuZ3RoID49IDMpIHtcXG4gICAgICAgIGVsSW5mb2dyYXBoaWMucXVlcnlTZWxlY3RvcignLicgKyBDU1NfSU5GT0dSQVBISUMgKyAnX190YWJsZScpLnN0eWxlLnJlbW92ZVByb3BlcnR5KCd0cmFuc2Zvcm0nKTtcXG4gICAgICAgIGVsSW5mb2dyYXBoaWMucXVlcnlTZWxlY3RvcignLicgKyBDU1NfSU5GT0dSQVBISUMgKyAnX19idWxsZXRfYWN0aXZlJykuY2xhc3NMaXN0LnJlbW92ZShDU1NfSU5GT0dSQVBISUMgKyAnX19idWxsZXRfYWN0aXZlJyk7XFxuICAgICAgICBlbEluZm9ncmFwaGljLnF1ZXJ5U2VsZWN0b3JBbGwoJy4nICsgQ1NTX0lORk9HUkFQSElDICsgJ19fYnVsbGV0JylbMF0uY2xhc3NMaXN0LmFkZChDU1NfSU5GT0dSQVBISUMgKyAnX19idWxsZXRfYWN0aXZlJyk7XFxuICAgICAgICBhY3RpdmVJbmRleCA9IDA7XFxuICAgIH1cXG59XFxuXFxuZnVuY3Rpb24gYWRkTGlzdGVuZXJzRm9yQnVsbGV0cyAoKSB7XFxuICAgIGlmIChlbEluZm9ncmFwaGljLnF1ZXJ5U2VsZWN0b3JBbGwoJy4nICsgQ1NTX0lORk9HUkFQSElDICsgJ19fYnVsbGV0JykubGVuZ3RoID49IDIpIHtcXG4gICAgICAgIGVsSW5mb2dyYXBoaWMucXVlcnlTZWxlY3RvckFsbCgnLicgKyBDU1NfSU5GT0dSQVBISUMgKyAnX19idWxsZXQnKS5mb3JFYWNoKChidWxsZXQsIGluZGV4KSA9PiB7XFxuICAgICAgICAgICAgYnVsbGV0LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4gY2hhbmdlU2xpZGUoYnVsbGV0LCBpbmRleCkpO1xcbiAgICAgICAgfSk7XFxuICAgIH1cXG5cXG4gICAgbGV0IGZpcnN0UGFyYW0gPSAwO1xcbiAgICBsZXQgaXNEb3duID0gZmFsc2U7XFxuXFxuICAgIGZ1bmN0aW9uIGNoYW5nZVNsaWRlQWZ0ZXJTd2lwZSAoZSkge1xcbiAgICAgICBpZiAoZS5jbGllbnRYIDwgZmlyc3RQYXJhbSAmJiBhY3RpdmVJbmRleCA8IGVsSW5mb2dyYXBoaWMucXVlcnlTZWxlY3RvckFsbCgnLicgKyBDU1NfSU5GT0dSQVBISUMgKyAnX19idWxsZXQnKS5sZW5ndGggLSAxICYmIHdpbmRvdy5tYXRjaE1lZGlhKCcobWF4LXdpZHRoOiA3NjdweCknKS5tYXRjaGVzICYmICFpc0Rvd24pIHtcXG4gICAgICAgICAgIGlzRG93biA9IHRydWU7XFxuICAgICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLnNldFByb3BlcnR5KCdwYWRkaW5nLXJpZ2h0Jywgd2luZG93LmlubmVyV2lkdGggLSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggKyAncHgnKTtcXG4gICAgICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUuc2V0UHJvcGVydHkoJ292ZXJmbG93JywgJ2hpZGRlbicpO1xcbiAgICAgICAgICAgY2hhbmdlU2xpZGUoZWxJbmZvZ3JhcGhpYy5xdWVyeVNlbGVjdG9yQWxsKCcuJyArIENTU19JTkZPR1JBUEhJQyArICdfX2J1bGxldCcpW2FjdGl2ZUluZGV4ICsgMV0sIGFjdGl2ZUluZGV4ICsgMSk7XFxuICAgICAgICAgICBlbEluZm9ncmFwaGljLnF1ZXJ5U2VsZWN0b3IoJy4nICsgQ1NTX0lORk9HUkFQSElDICsgJ19fdGFibGUnKS5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIGNoYW5nZVNsaWRlQWZ0ZXJTd2lwZSk7XFxuICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcXG4gICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLnJlbW92ZVByb3BlcnR5KCdwYWRkaW5nLXJpZ2h0Jyk7XFxuICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgnb3ZlcmZsb3cnKTtcXG4gICAgICAgICAgICAgICBpc0Rvd24gPSBmYWxzZTtcXG4gICAgICAgICAgIH0sIDUwMCk7XFxuICAgICAgIH1cXG5cXG4gICAgICAgaWYgKGUuY2xpZW50WCA+IGZpcnN0UGFyYW0gJiYgYWN0aXZlSW5kZXggPiAwICYmIHdpbmRvdy5tYXRjaE1lZGlhKCcobWF4LXdpZHRoOiA3NjdweCknKS5tYXRjaGVzICYmICFpc0Rvd24pIHtcXG4gICAgICAgICAgIGlzRG93biA9IHRydWU7XFxuICAgICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLnNldFByb3BlcnR5KCdwYWRkaW5nLXJpZ2h0Jywgd2luZG93LmlubmVyV2lkdGggLSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggKyAncHgnKTtcXG4gICAgICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUuc2V0UHJvcGVydHkoJ292ZXJmbG93JywgJ2hpZGRlbicpO1xcbiAgICAgICAgICAgY2hhbmdlU2xpZGUoZWxJbmZvZ3JhcGhpYy5xdWVyeVNlbGVjdG9yQWxsKCcuJyArIENTU19JTkZPR1JBUEhJQyArICdfX2J1bGxldCcpW2FjdGl2ZUluZGV4IC0gMV0sIGFjdGl2ZUluZGV4IC0gMSk7XFxuICAgICAgICAgICBlbEluZm9ncmFwaGljLnF1ZXJ5U2VsZWN0b3IoJy4nICsgQ1NTX0lORk9HUkFQSElDICsgJ19fdGFibGUnKS5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIGNoYW5nZVNsaWRlQWZ0ZXJTd2lwZSk7XFxuICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcXG4gICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLnJlbW92ZVByb3BlcnR5KCdwYWRkaW5nLXJpZ2h0Jyk7XFxuICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgnb3ZlcmZsb3cnKTtcXG4gICAgICAgICAgICAgICBpc0Rvd24gPSBmYWxzZTtcXG4gICAgICAgICAgIH0sIDUwMCk7XFxuICAgICAgIH1cXG4gICAgfVxcblxcbiAgICBlbEluZm9ncmFwaGljLnF1ZXJ5U2VsZWN0b3IoJy4nICsgQ1NTX0lORk9HUkFQSElDICsgJ19fdGFibGUnKS5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVyZG93bicsIGUgPT4ge1xcbiAgICAgICAgZmlyc3RQYXJhbSA9IGUuY2xpZW50WDtcXG4gICAgICAgIGVsSW5mb2dyYXBoaWMucXVlcnlTZWxlY3RvcignLicgKyBDU1NfSU5GT0dSQVBISUMgKyAnX190YWJsZScpLmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJtb3ZlJywgY2hhbmdlU2xpZGVBZnRlclN3aXBlKTtcXG4gICAgfSk7XFxuXFxuICAgIGVsSW5mb2dyYXBoaWMucXVlcnlTZWxlY3RvcignLicgKyBDU1NfSU5GT0dSQVBISUMgKyAnX190YWJsZScpLmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsICgpID0+IHtcXG4gICAgICAgIGVsSW5mb2dyYXBoaWMucXVlcnlTZWxlY3RvcignLicgKyBDU1NfSU5GT0dSQVBISUMgKyAnX190YWJsZScpLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJtb3ZlJywgY2hhbmdlU2xpZGVBZnRlclN3aXBlKTtcXG4gICAgfSk7XFxufVxcblxcbmlmIChlbEluZm9ncmFwaGljICYmIGVsSW5mb2dyYXBoaWMucXVlcnlTZWxlY3RvckFsbCgnLicgKyBDU1NfSU5GT0dSQVBISUMgKyAnX19pdGVtJykubGVuZ3RoID49IDMpIHtcXG4gICAgY3JlYXRlUGFnaW5hdGlvbkVsZW1lbnRzKCk7XFxuICAgIGFkZExpc3RlbmVyc0ZvckJ1bGxldHMoKTtcXG59XFxuXFxuaWYgKGVsSW5mb2dyYXBoaWMgJiYgZWxJbmZvZ3JhcGhpYy5xdWVyeVNlbGVjdG9yQWxsKCcuJyArIENTU19JTkZPR1JBUEhJQyArICdfX2l0ZW0nKS5sZW5ndGggPD0gMikge1xcbiAgICBlbEluZm9ncmFwaGljLnF1ZXJ5U2VsZWN0b3IoJy4nICsgQ1NTX0lORk9HUkFQSElDICsgJ19fcGFnaW5hdGlvbicpLnN0eWxlLnNldFByb3BlcnR5KCdkaXNwbGF5JywgJ25vbmUnKTtcXG59XFxuXFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vcGFydXMvLi9zcmMvY29tbW9uLmJsb2Nrcy9pbmZvZ3JhcGhpYy9pbmZvZ3JhcGhpYy5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbW1vbi5ibG9ja3MvbWFpbi1zbGlkZXIvbWFpbi1zbGlkZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21tb24uYmxvY2tzL21haW4tc2xpZGVyL21haW4tc2xpZGVyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2pzX3V0aWxzX3N3aXBlckluaXRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL2pzL3V0aWxzL3N3aXBlckluaXQgKi8gXFxcIi4vc3JjL2pzL3V0aWxzL3N3aXBlckluaXQuanNcXFwiKTtcXG5cXG5cXG5jb25zdCBDU1NfTUFJTl9TTElERVIgPSAnbWFpbi1zbGlkZXInO1xcbmNvbnN0IGVsTWFpblNsaWRlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy4nICsgQ1NTX01BSU5fU0xJREVSKTtcXG5cXG5pZiAoZWxNYWluU2xpZGVyKSB7XFxuICAgICgwLF9qc191dGlsc19zd2lwZXJJbml0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImRlZmF1bHRcXFwiXSkoZWxNYWluU2xpZGVyLCAnLnN3aXBlci1jb250YWluZXInLCB7XFxuICAgICAgICBzbGlkZXNQZXJWaWV3OiAxLFxcbiAgICAgICAgc3BlZWQ6IDEwMDAsXFxuICAgICAgICBhZGRpdGlvbmFsOntcXG4gICAgICAgICAgICBsb29wOiB0cnVlLFxcbiAgICAgICAgICAgIGJyZWFrcG9pbnRzOiB7XFxuICAgICAgICAgICAgICAgIDEwMjQ6e1xcbiAgICAgICAgICAgICAgICAgICAgc3BlZWQ6IDEwMDBcXG4gICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAgMDoge1xcbiAgICAgICAgICAgICAgICAgICAgc3BlZWQ6IDcwMCxcXG4gICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgYXV0b3BsYXk6IHtcXG4gICAgICAgICAgICBkZWxheTogNTAwMCxcXG4gICAgICAgICAgICBkaXNhYmxlT25JbnRlcmFjdGlvbjogZmFsc2VcXG4gICAgICAgIH0sXFxuICAgICAgICBuYXZpZ2F0aW9uOiB7XFxuICAgICAgICAgICAgcHJldkVsOiBlbE1haW5TbGlkZXIucXVlcnlTZWxlY3RvcignLicgKyBDU1NfTUFJTl9TTElERVIgKyAnX19zbGlkZXItYnRuX3ByZXYnKSxcXG4gICAgICAgICAgICBuZXh0RWw6IGVsTWFpblNsaWRlci5xdWVyeVNlbGVjdG9yKCcuJyArIENTU19NQUlOX1NMSURFUiArICdfX3NsaWRlci1idG5fbmV4dCcpXFxuICAgICAgICB9LFxcbiAgICAgICAgcGFnaW5hdGlvbjoge1xcbiAgICAgICAgICAgIGVsOiBlbE1haW5TbGlkZXIucXVlcnlTZWxlY3RvcignLicgKyBDU1NfTUFJTl9TTElERVIgKyAnX19wYWdpbmF0aW9uJyksXFxuICAgICAgICAgICAgdHlwZTogJ2J1bGxldHMnLFxcbiAgICAgICAgICAgIGJ1bGxldENsYXNzOiBDU1NfTUFJTl9TTElERVIgKyAnX19idWxsZXQnLFxcbiAgICAgICAgICAgIGJ1bGxldEFjdGl2ZUNsYXNzOiBDU1NfTUFJTl9TTElERVIgKyAnX19idWxsZXRfYWN0aXZlJyxcXG4gICAgICAgICAgICBjbGlja2FibGU6IHRydWVcXG4gICAgICAgIH1cXG4gICAgfSk7XFxufVxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3BhcnVzLy4vc3JjL2NvbW1vbi5ibG9ja3MvbWFpbi1zbGlkZXIvbWFpbi1zbGlkZXIuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21tb24uYmxvY2tzL21vYmlsZS1zbGlkZXIvbW9iaWxlLXNsaWRlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21tb24uYmxvY2tzL21vYmlsZS1zbGlkZXIvbW9iaWxlLXNsaWRlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBpbml0T3JEZXN0cm95TW9iaWxlU2xpZGVyOiAoKSA9PiAoLyogYmluZGluZyAqLyBpbml0T3JEZXN0cm95TW9iaWxlU2xpZGVyKVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBzd2lwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHN3aXBlciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvY29yZS1jbGFzcy5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBzd2lwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHN3aXBlciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2F1dG9wbGF5L2F1dG9wbGF5LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHN3aXBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgc3dpcGVyICovIFxcXCIuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvbmF2aWdhdGlvbi9uYXZpZ2F0aW9uLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHN3aXBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgc3dpcGVyICovIFxcXCIuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvcGFnaW5hdGlvbi9wYWdpbmF0aW9uLmpzXFxcIik7XFxuXFxuXFxuY29uc3QgQ1NTX01PQklMRV9TTElERVIgPSAnbW9iaWxlLXNsaWRlcic7XFxuY29uc3QgZWxNb2JpbGVTbGlkZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuJyArIENTU19NT0JJTEVfU0xJREVSKTtcXG5cXG5mdW5jdGlvbiBnZXRTd2lwZXJPcHRpb25zICgpIHtcXG4gICAgcmV0dXJuIHtcXG4gICAgICAgIHNsaWRlc1BlclZpZXc6IFxcXCJhdXRvXFxcIixcXG4gICAgICAgIHNwYWNlQmV0d2VlbjogMjAsXFxuICAgICAgICBzcGVlZDogNTAwLFxcbiAgICAgICAgd2F0Y2hTbGlkZXNWaXNpYmlsaXR5OiB0cnVlLFxcbiAgICAgICAgd2F0Y2hPdmVyZmxvdzogdHJ1ZSxcXG4gICAgICAgIHdhdGNoU2xpZGVzUHJvZ3Jlc3M6IHRydWUsXFxuICAgICAgICBicmVha3BvaW50czoge1xcbiAgICAgICAgICAgIDc2ODoge1xcbiAgICAgICAgICAgICAgICBzcGFjZUJldHdlZW46IDIwXFxuICAgICAgICAgICAgfSxcXG5cXG4gICAgICAgICAgICAwOiB7XFxuICAgICAgICAgICAgICAgIHNwYWNlQmV0d2VlbjogMTBcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgIH1cXG59XFxuXFxubGV0IG1vYmlsZVNsaWRlciA9IG51bGw7XFxuXFxuZnVuY3Rpb24gaW5pdE9yRGVzdHJveU1vYmlsZVNsaWRlciAoKSB7XFxuICAgIGlmICh3aW5kb3cubWF0Y2hNZWRpYSgnKG1heC13aWR0aDogMTAyM3B4KScpLm1hdGNoZXMgJiYgbW9iaWxlU2xpZGVyID09IG51bGwgJiYgZWxNb2JpbGVTbGlkZXIgJiYgZWxNb2JpbGVTbGlkZXIucXVlcnlTZWxlY3RvckFsbCgnLnN3aXBlci1zbGlkZScpLmxlbmd0aCA+IDApIHtcXG4gICAgICAgIG1vYmlsZVNsaWRlciA9IG5ldyBzd2lwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiZGVmYXVsdFxcXCJdKGVsTW9iaWxlU2xpZGVyLnF1ZXJ5U2VsZWN0b3IoJy5zd2lwZXItY29udGFpbmVyJyksIGdldFN3aXBlck9wdGlvbnMoKSlcXG4gICAgfVxcblxcbiAgICBpZiAoIXdpbmRvdy5tYXRjaE1lZGlhKCcobWF4LXdpZHRoOiAxMDIzcHgpJykubWF0Y2hlcyAmJiBtb2JpbGVTbGlkZXIgIT0gbnVsbCAmJiBlbE1vYmlsZVNsaWRlciAmJiBlbE1vYmlsZVNsaWRlci5xdWVyeVNlbGVjdG9yQWxsKCcuc3dpcGVyLXNsaWRlJykubGVuZ3RoID4gMCkge1xcbiAgICAgICAgbW9iaWxlU2xpZGVyLmRlc3Ryb3kodHJ1ZSwgdHJ1ZSk7XFxuICAgICAgICBtb2JpbGVTbGlkZXIgPSBudWxsO1xcbiAgICB9XFxufVxcblxcbmlmIChlbE1vYmlsZVNsaWRlciAmJiBlbE1vYmlsZVNsaWRlci5xdWVyeVNlbGVjdG9yQWxsKCcuc3dpcGVyLXNsaWRlJykubGVuZ3RoID4gMCkge1xcbiAgICBzd2lwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiZGVmYXVsdFxcXCJdLnVzZShbc3dpcGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcImRlZmF1bHRcXFwiXSwgc3dpcGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcImRlZmF1bHRcXFwiXSwgc3dpcGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXFxcImRlZmF1bHRcXFwiXV0pO1xcblxcbiAgICBpbml0T3JEZXN0cm95TW9iaWxlU2xpZGVyKCk7XFxufVxcblxcblxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3BhcnVzLy4vc3JjL2NvbW1vbi5ibG9ja3MvbW9iaWxlLXNsaWRlci9tb2JpbGUtc2xpZGVyLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tbW9uLmJsb2Nrcy9uYXYvbmF2LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21tb24uYmxvY2tzL25hdi9uYXYuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIGRlYWN0aXZhdGlvbk5hdk1lbnVPblJlc2l6ZTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gZGVhY3RpdmF0aW9uTmF2TWVudU9uUmVzaXplKVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfaGVhZGVyX2hlYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaGVhZGVyL2hlYWRlciAqLyBcXFwiLi9zcmMvY29tbW9uLmJsb2Nrcy9oZWFkZXIvaGVhZGVyLmpzXFxcIik7XFxuXFxuXFxuY29uc3QgQ1NTX05BViA9ICduYXYnO1xcbmNvbnN0IGVsTmF2ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLicgKyBDU1NfTkFWKTtcXG5cXG5pZiAoIWVsTmF2KSB7XFxuICAgIHRocm93IG5ldyBFcnJvcihgU2VsZWN0b3IgXFxcXCcuJHtDU1NfTkFWfVxcXFwnIG5vdCBhdmFpbGFibGUuYCk7XFxufVxcblxcbmxldCBpc0FjdGl2ZVNlY29uZExldmVsT25EZXNrdG9wID0gZmFsc2U7XFxuXFxuY29uc3QgYnRuQWN0aXZhdGlvbiA9IChidG4sIHR5cGUpID0+IGJ0bi5jbGFzc0xpc3RbdHlwZV0oQ1NTX05BViArICdfX2xpbmtfaXMtYWN0aXZlJyk7XFxuXFxuZnVuY3Rpb24gY29weU1lbnUgKGJ0bikge1xcbiAgICBjb25zdCBtZW51ID0gYnRuLm5leHRFbGVtZW50U2libGluZy5jbG9uZU5vZGUodHJ1ZSk7XFxuXFxuICAgIG1lbnUuY2xhc3NMaXN0LnJlbW92ZShDU1NfTkFWICsgJ19fbGlzdF9oaWRkZW4nKTtcXG4gICAgbWVudS5jbGFzc0xpc3QuYWRkKENTU19OQVYgKyAnX19saXN0X3NlY29uZC1sZXZlbCcpO1xcbiAgICBlbE5hdi5hcHBlbmQobWVudSk7XFxufVxcblxcbmZ1bmN0aW9uIGFjdGl2YXRpb25TZWNvbmRMZXZlbE9uRGVza3RvcCAoKSB7XFxuICAgICgwLF9oZWFkZXJfaGVhZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uZml4ZWRIZWFkZXJPbkRlc2t0b3ApKHRydWUpXFxuICAgIGJ0bkFjdGl2YXRpb24odGhpcywgJ2FkZCcpO1xcbiAgICBjb3B5TWVudSh0aGlzKTtcXG4gICAgaXNBY3RpdmVTZWNvbmRMZXZlbE9uRGVza3RvcCA9IHRydWU7XFxufVxcblxcbmZ1bmN0aW9uIHJlbW92ZVNlY29uZExldmVsICgpIHtcXG4gICAgaWYgKGVsTmF2LnF1ZXJ5U2VsZWN0b3IoJy4nICsgQ1NTX05BViArICdfX2xpc3Rfc2Vjb25kLWxldmVsJykpIGVsTmF2LnF1ZXJ5U2VsZWN0b3IoJy4nICsgQ1NTX05BViArICdfX2xpc3Rfc2Vjb25kLWxldmVsJykucmVtb3ZlKCk7XFxufVxcblxcbmZ1bmN0aW9uIGRlYWN0aXZhdGlvbk5hdk1lbnUgKGlzRGVza3RvcCwgYnRuKSB7XFxuICAgIGlmIChpc0Rlc2t0b3ApIHtcXG4gICAgICAgIHJlbW92ZVNlY29uZExldmVsKCk7XFxuICAgICAgICBidG5BY3RpdmF0aW9uKGJ0biwgJ3JlbW92ZScpO1xcbiAgICAgICAgKDAsX2hlYWRlcl9oZWFkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5maXhlZEhlYWRlck9uRGVza3RvcCkoZmFsc2UpO1xcbiAgICAgICAgaXNBY3RpdmVTZWNvbmRMZXZlbE9uRGVza3RvcCA9IGZhbHNlO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgZWxOYXYucXVlcnlTZWxlY3RvcignLicgKyBDU1NfTkFWICsgJ19fbGlzdF9pcy1zaG93JykuY2xhc3NMaXN0LnJlbW92ZShDU1NfTkFWICsgJ19fbGlzdF9pcy1zaG93Jyk7XFxuICAgICAgICBidG5BY3RpdmF0aW9uKGVsTmF2LnF1ZXJ5U2VsZWN0b3IoJy4nICsgQ1NTX05BViArICdfX2xpbmtfaXMtYWN0aXZlJyksICdyZW1vdmUnKTtcXG4gICAgfVxcbn1cXG5cXG5mdW5jdGlvbiBhY3RpdmF0aW9uU2Vjb25kTGV2ZWwgKCkge1xcbiAgICBpZiAoaXNBY3RpdmVTZWNvbmRMZXZlbE9uRGVza3RvcCkge1xcbiAgICAgICAgaWYgKCF0aGlzLmNsYXNzTGlzdC5jb250YWlucyhDU1NfTkFWICsgJ19fbGlua19pcy1hY3RpdmUnKSkge1xcbiAgICAgICAgICAgIGRlYWN0aXZhdGlvbk5hdk1lbnUodHJ1ZSwgZWxOYXYucXVlcnlTZWxlY3RvcignLicgKyBDU1NfTkFWICsgJ19fbGlua19pcy1hY3RpdmUnKSk7XFxuICAgICAgICAgICAgYWN0aXZhdGlvblNlY29uZExldmVsT25EZXNrdG9wLmJpbmQodGhpcykoKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgZGVhY3RpdmF0aW9uTmF2TWVudSh0cnVlLCBlbE5hdi5xdWVyeVNlbGVjdG9yKCcuJyArIENTU19OQVYgKyAnX19saW5rX2lzLWFjdGl2ZScpKTtcXG4gICAgICAgIH1cXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIGFjdGl2YXRpb25TZWNvbmRMZXZlbE9uRGVza3RvcC5iaW5kKHRoaXMpKCk7XFxuICAgIH1cXG59XFxuXFxuZnVuY3Rpb24gYWN0aXZhdGlvbk5hdk1lbnVPbk1vYmlsZSAoKSB7XFxuICAgIGlmIChlbE5hdi5xdWVyeVNlbGVjdG9yKCcuJyArIENTU19OQVYgKyAnX19saXN0X2lzLXNob3cnKSAmJiBlbE5hdi5xdWVyeVNlbGVjdG9yKCcuJyArIENTU19OQVYgKyAnX19saW5rX2lzLWFjdGl2ZScpICYmICF0aGlzLmNsYXNzTGlzdC5jb250YWlucyhDU1NfTkFWICsgJ19fbGlua19pcy1hY3RpdmUnKSkge1xcbiAgICAgICAgZGVhY3RpdmF0aW9uTmF2TWVudShmYWxzZSk7XFxuICAgIH1cXG5cXG4gICAgdGhpcy5uZXh0RWxlbWVudFNpYmxpbmcuY2xhc3NMaXN0LnRvZ2dsZShDU1NfTkFWICsgJ19fbGlzdF9pcy1zaG93Jyk7XFxuICAgIHRoaXMuY2xhc3NMaXN0LnRvZ2dsZShDU1NfTkFWICsgJ19fbGlua19pcy1hY3RpdmUnKTtcXG59XFxuXFxuZnVuY3Rpb24gZGVhY3RpdmF0aW9uTmF2TWVudU9uUmVzaXplICgpIHtcXG4gICAgaWYgKGlzQWN0aXZlU2Vjb25kTGV2ZWxPbkRlc2t0b3ApIHtcXG4gICAgICAgIGRlYWN0aXZhdGlvbk5hdk1lbnUodHJ1ZSwgZWxOYXYucXVlcnlTZWxlY3RvcignLicgKyBDU1NfTkFWICsgJ19fbGlua19pcy1hY3RpdmUnKSk7XFxuICAgIH1cXG5cXG4gICAgaWYgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCA+PSAxMDI0ICYmIGVsTmF2LnF1ZXJ5U2VsZWN0b3IoJy4nICsgQ1NTX05BViArICdfX2xpbmtfaXMtYWN0aXZlJykgJiYgZWxOYXYucXVlcnlTZWxlY3RvcignLicgKyBDU1NfTkFWICsgJ19fbGlzdF9oaWRkZW4ubmF2X19saXN0X2lzLXNob3cnKSkge1xcbiAgICAgICAgZGVhY3RpdmF0aW9uTmF2TWVudShmYWxzZSk7XFxuICAgIH1cXG59XFxuXFxuZnVuY3Rpb24gYWN0aXZhdGlvbk5hdk1lbnUgKCkge1xcbiAgICAoX2hlYWRlcl9oZWFkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5pc01vYmlsZSA/IGFjdGl2YXRpb25OYXZNZW51T25Nb2JpbGUuYmluZCh0aGlzKSA6IGFjdGl2YXRpb25TZWNvbmRMZXZlbC5iaW5kKHRoaXMpKSgpO1xcbn1cXG5cXG5lbE5hdi5xdWVyeVNlbGVjdG9yQWxsKCcuJyArIENTU19OQVYgKyAnX19saW5rX2J0bicpLmZvckVhY2goYnRuID0+IGJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGFjdGl2YXRpb25OYXZNZW51KSk7XFxuXFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vcGFydXMvLi9zcmMvY29tbW9uLmJsb2Nrcy9uYXYvbmF2LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tbW9uLmJsb2Nrcy9wYXJhbGxheC9wYXJhbGxheC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbW1vbi5ibG9ja3MvcGFyYWxsYXgvcGFyYWxsYXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBpbml0UGFyYWxsYXg6ICgpID0+ICgvKiBiaW5kaW5nICovIGluaXRQYXJhbGxheClcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG5jb25zdCBDU1NfQ09MTEFHRV9QQVJBTExBWCA9ICdjb2xsYWdlJztcXG5jb25zdCBDU1NfSU5GT0dSQVBISUNfUEFSQUxMQVggPSAnaW5mb2dyYXBoaWMnXFxuY29uc3QgZWxDb2xsYWdlUGFyYWxsYXggPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuJyArIENTU19DT0xMQUdFX1BBUkFMTEFYKTtcXG5jb25zdCBlbEluZm9ncmFwaGljUGFyYWxsYXggPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuJyArIENTU19JTkZPR1JBUEhJQ19QQVJBTExBWCk7XFxubGV0IGlzSW5pdCA9IGZhbHNlO1xcblxcbmNvbnN0IGdldENvb3JkWCA9IChlLCBwYXJhbGxheExlZnRPZmZzZXQsIHdyYXBwZXIpID0+IGUuY2xpZW50WCAtIHBhcmFsbGF4TGVmdE9mZnNldCAtIDAuNSAqIHdyYXBwZXIub2Zmc2V0V2lkdGg7XFxuY29uc3QgZ2V0Q29vcmRZID0gKGUsIHBhcmFsbGF4VG9wT2Zmc2V0LCB3cmFwcGVyKSA9PiBlLmNsaWVudFkgLSBwYXJhbGxheFRvcE9mZnNldCAtIDAuNSAqICB3cmFwcGVyLm9mZnNldEhlaWdodDtcXG5jb25zdCBnZXRQcm9wZXJ0eSA9IChjb29yZFgsIGNvb3JkWSwgc3BlZWQpID0+IGB0cmFuc2xhdGVYKCR7KGNvb3JkWCAqIHNwZWVkKS50b0ZpeGVkKDIpfXB4KSB0cmFuc2xhdGVZKCR7KGNvb3JkWSAqIHNwZWVkKS50b0ZpeGVkKDIpfXB4KWA7XFxuXFxuZnVuY3Rpb24gc2V0UHJvcGVydHlGb3JFbGVtZW50ICh0YXJnZXQsIGUsIHdyYXBwZXIsIHNwZWVkKSB7XFxuICAgIGNvbnNvbGUubG9nKHdyYXBwZXIpXFxuICAgIHRhcmdldC5zdHlsZS50cmFuc2Zvcm0gPSBnZXRQcm9wZXJ0eShnZXRDb29yZFgoZSwgd3JhcHBlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0LCB3cmFwcGVyKSxcXG4gICAgICAgIGdldENvb3JkWShlLCB3cmFwcGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCwgd3JhcHBlciksIHNwZWVkKTtcXG59XFxuXFxuZnVuY3Rpb24gaGFuZGxlQ29sbGFnZVBhcmFsbGF4IChlLCB3cmFwcGVyKSB7XFxuICAgIHNldFByb3BlcnR5Rm9yRWxlbWVudChlbENvbGxhZ2VQYXJhbGxheC5xdWVyeVNlbGVjdG9yKCcuY29sbGFnZV9fcGFyYWxsYXhfbGVmdCcpLCBlLCB3cmFwcGVyLCAwLjEzKTtcXG4gICAgc2V0UHJvcGVydHlGb3JFbGVtZW50KGVsQ29sbGFnZVBhcmFsbGF4LnF1ZXJ5U2VsZWN0b3IoJy5jb2xsYWdlX19wYXJhbGxheF9yaWdodCcpLCBlLCB3cmFwcGVyLCAwLjA3KTtcXG59XFxuXFxuZnVuY3Rpb24gaGFuZGxlSW5mb2dyYXBoaWNQYXJhbGxheCAoZSwgd3JhcHBlcikge1xcbiAgICBzZXRQcm9wZXJ0eUZvckVsZW1lbnQoZWxJbmZvZ3JhcGhpY1BhcmFsbGF4LnF1ZXJ5U2VsZWN0b3IoJy5pbmZvZ3JhcGhpY19fcGFyYWxsYXhfbGVmdCcpLCBlLCB3cmFwcGVyLCAwLjE0KTtcXG4gICAgc2V0UHJvcGVydHlGb3JFbGVtZW50KGVsSW5mb2dyYXBoaWNQYXJhbGxheC5xdWVyeVNlbGVjdG9yKCcuaW5mb2dyYXBoaWNfX3BhcmFsbGF4X3JpZ2h0JyksIGUsIHdyYXBwZXIsIDAuMDcpO1xcbn1cXG5cXG5mdW5jdGlvbiBpbml0UGFyYWxsYXggKCkge1xcbiAgICBpZiAoaXNJbml0IHx8ICF3aW5kb3cubWF0Y2hNZWRpYSgnKG1pbi13aWR0aDogMTAyNHB4KScpLm1hdGNoZXMgfHwgIXdpbmRvdy5tYXRjaE1lZGlhKCcoaG92ZXI6IGhvdmVyKScpLm1hdGNoZXMpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcblxcbiAgICBpZiAoZWxDb2xsYWdlUGFyYWxsYXggfHwgZWxJbmZvZ3JhcGhpY1BhcmFsbGF4KSB7XFxuICAgICAgICBpc0luaXQgPSB0cnVlO1xcblxcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBlID0+IHtcXG4gICAgICAgICAgICBpZiAoZWxDb2xsYWdlUGFyYWxsYXgucXVlcnlTZWxlY3RvcignLicgKyBDU1NfQ09MTEFHRV9QQVJBTExBWCArICdfX3dyYXBwZXInKSkge1xcbiAgICAgICAgICAgICAgICBoYW5kbGVDb2xsYWdlUGFyYWxsYXgoZSwgZWxDb2xsYWdlUGFyYWxsYXgucXVlcnlTZWxlY3RvcignLicgKyBDU1NfQ09MTEFHRV9QQVJBTExBWCArICdfX3dyYXBwZXInKSk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmIChlbEluZm9ncmFwaGljUGFyYWxsYXgucXVlcnlTZWxlY3RvcignLicgKyBDU1NfSU5GT0dSQVBISUNfUEFSQUxMQVggKyAnX193cmFwcGVyJykpIHtcXG4gICAgICAgICAgICAgICAgaGFuZGxlSW5mb2dyYXBoaWNQYXJhbGxheChlLCBlbEluZm9ncmFwaGljUGFyYWxsYXgucXVlcnlTZWxlY3RvcignLicgKyBDU1NfSU5GT0dSQVBISUNfUEFSQUxMQVggKyAnX193cmFwcGVyJykpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICB9XFxufVxcblxcbmluaXRQYXJhbGxheCgpO1xcblxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3BhcnVzLy4vc3JjL2NvbW1vbi5ibG9ja3MvcGFyYWxsYXgvcGFyYWxsYXguanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21tb24uYmxvY2tzL3NlcnZpY2UtZ2FsbGVyeS9zZXJ2aWNlLWdhbGxlcnkuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbW1vbi5ibG9ja3Mvc2VydmljZS1nYWxsZXJ5L3NlcnZpY2UtZ2FsbGVyeS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgc2VydmljZUdhbGxlcnlJbml0OiAoKSA9PiAoLyogYmluZGluZyAqLyBzZXJ2aWNlR2FsbGVyeUluaXQpXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9qc191dGlsc19zd2lwZXJJbml0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9qcy91dGlscy9zd2lwZXJJbml0ICovIFxcXCIuL3NyYy9qcy91dGlscy9zd2lwZXJJbml0LmpzXFxcIik7XFxuXFxuXFxuY29uc3QgQ1NTX1NFUlZJQ0VfR0FMTEVSWSA9ICdzZXJ2aWNlLWdhbGxlcnknO1xcbmZ1bmN0aW9uIHNlcnZpY2VHYWxsZXJ5SW5pdCAoZWwpIHtcXG4gICAgcmV0dXJuICgwLF9qc191dGlsc19zd2lwZXJJbml0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImRlZmF1bHRcXFwiXSkoZWwsICcuc3dpcGVyLWNvbnRhaW5lcicsIHtcXG4gICAgICAgIHNsaWRlc1BlclZpZXc6ICdhdXRvJyxcXG4gICAgICAgIHNwZWVkOiA1MDAsXFxuICAgICAgICBhZGRpdGlvbmFsOiB7XFxuICAgICAgICAgICAgc3BhY2VCZXR3ZWVuOiAyMyxcXG4gICAgICAgICAgICBmcmVlTW9kZTogdHJ1ZSxcXG4gICAgICAgICAgICBicmVha3BvaW50czoge1xcbiAgICAgICAgICAgICAgICA3Njg6IHtcXG4gICAgICAgICAgICAgICAgICAgIHNwYWNlQmV0d2VlbjogMjNcXG4gICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAgMDoge1xcbiAgICAgICAgICAgICAgICAgICAgc3BhY2VCZXR3ZWVuOiAxNFxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICBvbjoge1xcbiAgICAgICAgICAgICAgICBpbml0IChzd2lwZXIpIHtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChzd2lwZXIuaXNCZWdpbm5pbmcgJiYgc3dpcGVyLmlzRW5kKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZWwuY2xhc3NMaXN0LmFkZChDU1NfU0VSVklDRV9HQUxMRVJZICsgJ19jZW50ZXJlZCcpXFxuICAgICAgICAgICAgICAgICAgICAgICAgZWwuc3R5bGUuc2V0UHJvcGVydHkoJ29wYWNpdHknLCAnMScpO1xcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eSgnb3BhY2l0eScsICcxJyk7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH0sXFxuXFxuICAgICAgICAgICAgICAgIHJlc2l6ZSAoc3dpcGVyKSB7XFxuICAgICAgICAgICAgICAgICAgICBpZiAoc3dpcGVyLmlzQmVnaW5uaW5nICYmIHN3aXBlci5pc0VuZCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoQ1NTX1NFUlZJQ0VfR0FMTEVSWSArICdfY2VudGVyZWQnKVxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KCdvcGFjaXR5JywgJzEnKTtcXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShDU1NfU0VSVklDRV9HQUxMRVJZICsgJ19jZW50ZXJlZCcpXFxuICAgICAgICAgICAgICAgICAgICAgICAgZWwuc3R5bGUuc2V0UHJvcGVydHkoJ29wYWNpdHknLCAnMScpO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSxcXG4gICAgICAgIG5hdmlnYXRpb246IHtcXG4gICAgICAgICAgICBwcmV2RWw6IGVsLnF1ZXJ5U2VsZWN0b3IoJy4nICsgQ1NTX1NFUlZJQ0VfR0FMTEVSWSArICdfX3NsaWRlci1idG5fcHJldicpLFxcbiAgICAgICAgICAgIG5leHRFbDogZWwucXVlcnlTZWxlY3RvcignLicgKyBDU1NfU0VSVklDRV9HQUxMRVJZICsgJ19fc2xpZGVyLWJ0bl9uZXh0JylcXG4gICAgICAgIH0sXFxuICAgIH0pO1xcbn1cXG5cXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9wYXJ1cy8uL3NyYy9jb21tb24uYmxvY2tzL3NlcnZpY2UtZ2FsbGVyeS9zZXJ2aWNlLWdhbGxlcnkuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21tb24uYmxvY2tzL3NlcnZpY2Utc2xpZGVyL3NlcnZpY2Utc2xpZGVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tbW9uLmJsb2Nrcy9zZXJ2aWNlLXNsaWRlci9zZXJ2aWNlLXNsaWRlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIHNlcnZpY2VTbGlkZXJJbml0OiAoKSA9PiAoLyogYmluZGluZyAqLyBzZXJ2aWNlU2xpZGVySW5pdClcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2pzX3V0aWxzX3N3aXBlckluaXRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL2pzL3V0aWxzL3N3aXBlckluaXQgKi8gXFxcIi4vc3JjL2pzL3V0aWxzL3N3aXBlckluaXQuanNcXFwiKTtcXG5cXG5cXG5jb25zdCBDU1NfU0VSVklDRV9TTElERVIgPSAnc2VydmljZS1zbGlkZXInO1xcbmZ1bmN0aW9uIHNlcnZpY2VTbGlkZXJJbml0IChlbCwgZ2FsbGVyeVNsaWRlcikge1xcbiAgICBjb25zdCBvcHRpb25zID0ge1xcbiAgICAgICAgc2xpZGVzUGVyVmlldzogMSxcXG4gICAgICAgIHNwZWVkOiA1MDAsXFxuICAgICAgICBuYXZpZ2F0aW9uOiB7XFxuICAgICAgICAgICAgcHJldkVsOiBlbC5xdWVyeVNlbGVjdG9yKCcuJyArIENTU19TRVJWSUNFX1NMSURFUiArICdfX3NsaWRlci1idG5fcHJldicpLFxcbiAgICAgICAgICAgIG5leHRFbDogZWwucXVlcnlTZWxlY3RvcignLicgKyBDU1NfU0VSVklDRV9TTElERVIgKyAnX19zbGlkZXItYnRuX25leHQnKVxcbiAgICAgICAgfSxcXG4gICAgfTtcXG5cXG4gICAgaWYgKGdhbGxlcnlTbGlkZXIpIHtcXG4gICAgICAgIG9wdGlvbnMudGh1bWJzID0ge1xcbiAgICAgICAgICAgIHN3aXBlcjogZ2FsbGVyeVNsaWRlclxcbiAgICAgICAgfTtcXG4gICAgfVxcblxcbiAgICAoMCxfanNfdXRpbHNfc3dpcGVySW5pdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJkZWZhdWx0XFxcIl0pKGVsLCAnLnN3aXBlci1jb250YWluZXInLCBvcHRpb25zKTtcXG59XFxuXFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vcGFydXMvLi9zcmMvY29tbW9uLmJsb2Nrcy9zZXJ2aWNlLXNsaWRlci9zZXJ2aWNlLXNsaWRlci5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2pzL3BhZ2VzL2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2pzL3BhZ2VzL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9qc191dGlsc19yZXNpemVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL2pzL3V0aWxzL3Jlc2l6ZSAqLyBcXFwiLi9zcmMvanMvdXRpbHMvcmVzaXplLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9saWJyYXJ5X2Jsb2Nrc19zZWxlY3Rfc2VsZWN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9saWJyYXJ5LmJsb2Nrcy9zZWxlY3Qvc2VsZWN0ICovIFxcXCIuL3NyYy9saWJyYXJ5LmJsb2Nrcy9zZWxlY3Qvc2VsZWN0LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9saWJyYXJ5X2Jsb2Nrc19zZWxlY3Rfc2VsZWN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oX2xpYnJhcnlfYmxvY2tzX3NlbGVjdF9zZWxlY3RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb21tb25fYmxvY2tzX2hlYWRlcl9oZWFkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL2NvbW1vbi5ibG9ja3MvaGVhZGVyL2hlYWRlciAqLyBcXFwiLi9zcmMvY29tbW9uLmJsb2Nrcy9oZWFkZXIvaGVhZGVyLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb21tb25fYmxvY2tzX2J1cmdlcl9idXJnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL2NvbW1vbi5ibG9ja3MvYnVyZ2VyL2J1cmdlciAqLyBcXFwiLi9zcmMvY29tbW9uLmJsb2Nrcy9idXJnZXIvYnVyZ2VyLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb21tb25fYmxvY2tzX25hdl9uYXZfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL2NvbW1vbi5ibG9ja3MvbmF2L25hdiAqLyBcXFwiLi9zcmMvY29tbW9uLmJsb2Nrcy9uYXYvbmF2LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb21tb25fYmxvY2tzX21haW5fc2xpZGVyX21haW5fc2xpZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9jb21tb24uYmxvY2tzL21haW4tc2xpZGVyL21haW4tc2xpZGVyICovIFxcXCIuL3NyYy9jb21tb24uYmxvY2tzL21haW4tc2xpZGVyL21haW4tc2xpZGVyLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb21tb25fYmxvY2tzX21vYmlsZV9zbGlkZXJfbW9iaWxlX3NsaWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vY29tbW9uLmJsb2Nrcy9tb2JpbGUtc2xpZGVyL21vYmlsZS1zbGlkZXIgKi8gXFxcIi4vc3JjL2NvbW1vbi5ibG9ja3MvbW9iaWxlLXNsaWRlci9tb2JpbGUtc2xpZGVyLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb21tb25fYmxvY2tzX2luZm9ncmFwaGljX2luZm9ncmFwaGljX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9jb21tb24uYmxvY2tzL2luZm9ncmFwaGljL2luZm9ncmFwaGljICovIFxcXCIuL3NyYy9jb21tb24uYmxvY2tzL2luZm9ncmFwaGljL2luZm9ncmFwaGljLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb21tb25fYmxvY2tzX2dhbGxlcnlfc2xpZGVyX2dhbGxlcnlfc2xpZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9jb21tb24uYmxvY2tzL2dhbGxlcnktc2xpZGVyL2dhbGxlcnktc2xpZGVyICovIFxcXCIuL3NyYy9jb21tb24uYmxvY2tzL2dhbGxlcnktc2xpZGVyL2dhbGxlcnktc2xpZGVyLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb21tb25fYmxvY2tzX3BhcmFsbGF4X3BhcmFsbGF4X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9jb21tb24uYmxvY2tzL3BhcmFsbGF4L3BhcmFsbGF4ICovIFxcXCIuL3NyYy9jb21tb24uYmxvY2tzL3BhcmFsbGF4L3BhcmFsbGF4LmpzXFxcIik7XFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vcGFydXMvLi9zcmMvanMvcGFnZXMvaW5kZXguanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9qcy91dGlscy9yZXNpemUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2pzL3V0aWxzL3Jlc2l6ZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbW1vbl9ibG9ja3NfaGVhZGVyX2hlYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vY29tbW9uLmJsb2Nrcy9oZWFkZXIvaGVhZGVyICovIFxcXCIuL3NyYy9jb21tb24uYmxvY2tzL2hlYWRlci9oZWFkZXIuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbW1vbl9ibG9ja3NfbmF2X25hdl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vY29tbW9uLmJsb2Nrcy9uYXYvbmF2ICovIFxcXCIuL3NyYy9jb21tb24uYmxvY2tzL25hdi9uYXYuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbW1vbl9ibG9ja3NfbW9iaWxlX3NsaWRlcl9tb2JpbGVfc2xpZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9jb21tb24uYmxvY2tzL21vYmlsZS1zbGlkZXIvbW9iaWxlLXNsaWRlciAqLyBcXFwiLi9zcmMvY29tbW9uLmJsb2Nrcy9tb2JpbGUtc2xpZGVyL21vYmlsZS1zbGlkZXIuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbW1vbl9ibG9ja3NfaW5mb2dyYXBoaWNfaW5mb2dyYXBoaWNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL2NvbW1vbi5ibG9ja3MvaW5mb2dyYXBoaWMvaW5mb2dyYXBoaWMgKi8gXFxcIi4vc3JjL2NvbW1vbi5ibG9ja3MvaW5mb2dyYXBoaWMvaW5mb2dyYXBoaWMuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbW1vbl9ibG9ja3NfcGFyYWxsYXhfcGFyYWxsYXhfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL2NvbW1vbi5ibG9ja3MvcGFyYWxsYXgvcGFyYWxsYXggKi8gXFxcIi4vc3JjL2NvbW1vbi5ibG9ja3MvcGFyYWxsYXgvcGFyYWxsYXguanNcXFwiKTtcXG5cXG5cXG5cXG5cXG5cXG5cXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgKCkgPT4ge1xcbiAgICAoMCxfY29tbW9uX2Jsb2Nrc19oZWFkZXJfaGVhZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uaGlkZU1lbnVPblJlc2l6ZSkoKTtcXG4gICAgKDAsX2NvbW1vbl9ibG9ja3NfbmF2X25hdl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLmRlYWN0aXZhdGlvbk5hdk1lbnVPblJlc2l6ZSkoKTtcXG4gICAgKDAsX2NvbW1vbl9ibG9ja3NfbW9iaWxlX3NsaWRlcl9tb2JpbGVfc2xpZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18uaW5pdE9yRGVzdHJveU1vYmlsZVNsaWRlcikoKTtcXG4gICAgKDAsX2NvbW1vbl9ibG9ja3NfaW5mb2dyYXBoaWNfaW5mb2dyYXBoaWNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy5kZXN0cm95SW5mb2dyYXBoaWNTbGlkZXIpKCk7XFxuICAgICgwLF9jb21tb25fYmxvY2tzX3BhcmFsbGF4X3BhcmFsbGF4X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18uaW5pdFBhcmFsbGF4KSgpO1xcbn0pO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3BhcnVzLy4vc3JjL2pzL3V0aWxzL3Jlc2l6ZS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2pzL3V0aWxzL3N3aXBlckluaXQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9qcy91dGlscy9zd2lwZXJJbml0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcImRlZmF1bHRcXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBzd2lwZXJJbml0KVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBzd2lwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHN3aXBlciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL25hdmlnYXRpb24vbmF2aWdhdGlvbi5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBzd2lwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHN3aXBlciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL3BhZ2luYXRpb24vcGFnaW5hdGlvbi5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBzd2lwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHN3aXBlciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2F1dG9wbGF5L2F1dG9wbGF5LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHN3aXBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgc3dpcGVyICovIFxcXCIuL25vZGVfbW9kdWxlcy9zd2lwZXIvZXNtL2NvbXBvbmVudHMvdGh1bWJzL3RodW1icy5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBzd2lwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHN3aXBlciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc3dpcGVyL2VzbS9jb21wb25lbnRzL2NvcmUvY29yZS1jbGFzcy5qc1xcXCIpO1xcblxcblxcbmZ1bmN0aW9uIHN3aXBlckluaXQgKHBhcmVudCwgZWwsIG9wdGlvbnMpIHtcXG4gICAgY29uc3Qge3NsaWRlc1BlclZpZXcsIHNwZWVkLCBhZGRpdGlvbmFsLCBhdXRvcGxheSwgbmF2aWdhdGlvbiwgcGFnaW5hdGlvbiwgdGh1bWJzfSA9IG9wdGlvbnM7XFxuICAgIGNvbnN0IHNsaWRlckVsID0gcGFyZW50LnF1ZXJ5U2VsZWN0b3IoZWwpO1xcblxcbiAgICBpZiAoIXNsaWRlckVsIHx8IHNsaWRlckVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5zd2lwZXItc2xpZGUnKS5sZW5ndGggPT09IDApIHtcXG4gICAgICAgIHJldHVybiBjb25zb2xlLmVycm9yKCdzd2lwZXJJbml0OiBET00gZWxlbWVudHMgbm90IGZvdW5kJyk7XFxuICAgIH1cXG5cXG4gICAgY29uc3Qgc3dpcGVyT3B0aW9ucyA9IHtcXG4gICAgICAgIHNsaWRlc1BlclZpZXc6IHNsaWRlc1BlclZpZXcgfHwgMSxcXG4gICAgICAgIHNwZWVkOiBzcGVlZCB8fCAzMDBcXG4gICAgfTtcXG5cXG4gICAgT2JqZWN0LmFzc2lnbihzd2lwZXJPcHRpb25zLCBhZGRpdGlvbmFsKTtcXG5cXG4gICAgZnVuY3Rpb24gZ2V0U3dpcGVyVXNlT3B0aW9ucyAoKSB7XFxuICAgICAgICBsZXQgc3dpcGVyVXNlT3B0aW9ucyA9IFtdO1xcblxcbiAgICAgICAgaWYgKG5hdmlnYXRpb24gJiYgbmF2aWdhdGlvbi5wcmV2RWwgJiYgbmF2aWdhdGlvbi5uZXh0RWwpIHtcXG4gICAgICAgICAgICBzd2lwZXJVc2VPcHRpb25zLnB1c2goc3dpcGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImRlZmF1bHRcXFwiXSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAocGFnaW5hdGlvbiAmJiBwYWdpbmF0aW9uLmVsKSB7XFxuICAgICAgICAgICAgc3dpcGVyVXNlT3B0aW9ucy5wdXNoKHN3aXBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJkZWZhdWx0XFxcIl0pO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKGF1dG9wbGF5KSB7XFxuICAgICAgICAgICAgc3dpcGVyVXNlT3B0aW9ucy5wdXNoKHN3aXBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJkZWZhdWx0XFxcIl0pO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKHRodW1icykge1xcbiAgICAgICAgICAgIHN3aXBlclVzZU9wdGlvbnMucHVzaChzd2lwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcXFwiZGVmYXVsdFxcXCJdKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiBzd2lwZXJVc2VPcHRpb25zO1xcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIHNldFN3aXBlck9wdGlvbnMgKCkge1xcbiAgICAgICAgaWYgKG5hdmlnYXRpb24gJiYgbmF2aWdhdGlvbi5wcmV2RWwgJiYgbmF2aWdhdGlvbi5uZXh0RWwpIHtcXG4gICAgICAgICAgICBzd2lwZXJPcHRpb25zLm5hdmlnYXRpb24gPSBuYXZpZ2F0aW9uO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKHBhZ2luYXRpb24gJiYgcGFnaW5hdGlvbi5lbCkge1xcbiAgICAgICAgICAgIHN3aXBlck9wdGlvbnMucGFnaW5hdGlvbiA9IHBhZ2luYXRpb247XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoYXV0b3BsYXkpIHtcXG4gICAgICAgICAgICBzd2lwZXJPcHRpb25zLmF1dG9wbGF5ID0gYXV0b3BsYXk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAodGh1bWJzKSB7XFxuICAgICAgICAgICAgc3dpcGVyT3B0aW9ucy50aHVtYnMgPSB0aHVtYnM7XFxuICAgICAgICB9XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gaGlkZVN3aXBlclBhZ2luYXRpb25BbmRQYWdpbmF0aW9uICgpIHtcXG4gICAgICAgIGlmIChuYXZpZ2F0aW9uICYmIG5hdmlnYXRpb24ucHJldkVsICYmIG5hdmlnYXRpb24ubmV4dEVsKSB7XFxuICAgICAgICAgICAgbmF2aWdhdGlvbi5wcmV2RWwuc3R5bGUuc2V0UHJvcGVydHkoJ2Rpc3BsYXknLCAnbm9uZScpO1xcbiAgICAgICAgICAgIG5hdmlnYXRpb24ubmV4dEVsLnN0eWxlLnNldFByb3BlcnR5KCdkaXNwbGF5JywgJ25vbmUnKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChwYWdpbmF0aW9uLmVsKSB7XFxuICAgICAgICAgICAgcGFnaW5hdGlvbi5lbC5zdHlsZS5zZXRQcm9wZXJ0eSgnZGlzcGxheScsICdub25lJyk7XFxuICAgICAgICB9XFxuICAgIH1cXG5cXG4gICAgc2xpZGVyRWwucXVlcnlTZWxlY3RvckFsbCgnLnN3aXBlci1zbGlkZScpLmxlbmd0aCA+IDEgPyBzZXRTd2lwZXJPcHRpb25zKCkgOiAgaGlkZVN3aXBlclBhZ2luYXRpb25BbmRQYWdpbmF0aW9uKCk7XFxuXFxuICAgIGNvbnN0IHN3aXBlclVzZU9wdGlvbnMgPSBnZXRTd2lwZXJVc2VPcHRpb25zKCk7XFxuXFxuICAgIGlmIChzd2lwZXJVc2VPcHRpb25zLmxlbmd0aCA+IDApIHtcXG4gICAgICAgIHN3aXBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1xcXCJkZWZhdWx0XFxcIl0udXNlKHN3aXBlclVzZU9wdGlvbnMpO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBuZXcgc3dpcGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXFxcImRlZmF1bHRcXFwiXShwYXJlbnQucXVlcnlTZWxlY3RvcihlbCksIHN3aXBlck9wdGlvbnMpO1xcbn1cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9wYXJ1cy8uL3NyYy9qcy91dGlscy9zd2lwZXJJbml0LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvbGlicmFyeS5ibG9ja3Mvc2VsZWN0L3NlbGVjdC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2xpYnJhcnkuYmxvY2tzL3NlbGVjdC9zZWxlY3QuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoKSA9PiB7XG5cbmV2YWwoXCJjb25zdCBDU1NfU0VMRUNUID0gJ3NlbGVjdCc7XFxuY29uc3QgZWxTZWxlY3QgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuJyArIENTU19TRUxFQ1QpO1xcblxcbmlmIChlbFNlbGVjdC5sZW5ndGggPiAwKSB7XFxuICAgIGluaXQoKTtcXG59XFxuXFxuZnVuY3Rpb24gaW5pdCAoKSB7XFxuICAgIGNvbnN0IHNlbGVjdEVscyA9IFtdO1xcblxcbiAgICBlbFNlbGVjdC5mb3JFYWNoKChzZWxlY3QsIGluZGV4KSA9PiBzZWxlY3RJbml0KHNlbGVjdCwgaW5kZXgsIHNlbGVjdEVscykpO1xcbiAgICBvdXRzaWRlQ2xpY2soc2VsZWN0RWxzKTtcXG59XFxuXFxuZnVuY3Rpb24gc2VsZWN0SW5pdCAoc2VsZWN0LCBpbmRleCwgc2VsZWN0RWxzKSB7XFxuICAgIGlmICghc2VsZWN0LnF1ZXJ5U2VsZWN0b3IoJy4nICsgQ1NTX1NFTEVDVCArICdfX3ZhbHVlJykgfHwgIXNlbGVjdC5xdWVyeVNlbGVjdG9yKCcuJyArIENTU19TRUxFQ1QgKyAnX19oaWRkZW4tc2VsZWN0JykgfHwgc2VsZWN0LnF1ZXJ5U2VsZWN0b3JBbGwoJy5zZWxlY3RfX2l0ZW0nKS5sZW5ndGggPT09IDApIHtcXG4gICAgICAgIHJldHVybiBjb25zb2xlLmVycm9yKCdTZWxlY3Q6IHNvbWUgZWxlbWVudHMgaW4gdGhlIG1hcmt1cCBhcmUgbWlzc2luZycpO1xcbiAgICB9XFxuXFxuICAgIGNvbnN0IHNlbGVjdE9iaiA9IHtcXG4gICAgICAgIGlkOiBpbmRleCxcXG4gICAgICAgIGVsOiBzZWxlY3QsXFxuICAgICAgICAnI2lzT3Blbic6IGZhbHNlLFxcbiAgICAgICAgZ2V0IGlzT3BlblNlbGVjdCAoKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHRoaXNbJyNpc09wZW4nXTtcXG4gICAgICAgIH0sXFxuICAgICAgICBzZXQgaXNPcGVuU2VsZWN0IChpc09wZW5WYWx1ZSkge1xcbiAgICAgICAgICAgIHRoaXNbJyNpc09wZW4nXSA9IGlzT3BlblZhbHVlO1xcbiAgICAgICAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LnRvZ2dsZShDU1NfU0VMRUNUICsgJ19pcy1vcGVuJywgaXNPcGVuVmFsdWUpO1xcbiAgICAgICAgfSxcXG4gICAgICAgIHNldFZhbHVlIChzZWxlY3RlZFZhbHVlLCBhY3RpdmVJbmRleCkge1xcbiAgICAgICAgICAgIHRoaXMuZWwucXVlcnlTZWxlY3RvcignLicgKyBDU1NfU0VMRUNUICsgJ19fdmFsdWUnKS5pbm5lclRleHQgPSBzZWxlY3RlZFZhbHVlO1xcbiAgICAgICAgICAgIHRoaXMuZWwucXVlcnlTZWxlY3RvcignLicgKyBDU1NfU0VMRUNUICsgJ19faGlkZGVuLXNlbGVjdCcpLnNlbGVjdGVkSW5kZXggPSBhY3RpdmVJbmRleDtcXG4gICAgICAgIH1cXG4gICAgfTtcXG5cXG4gICAgc2VsZWN0RWxzLnB1c2goc2VsZWN0T2JqKTtcXG5cXG4gICAgc2VsZWN0LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZSA9PiBzZWxlY3RDbGljayhzZWxlY3RPYmosIHNlbGVjdEVscykpO1xcblxcbiAgICBzZWxlY3QucXVlcnlTZWxlY3RvckFsbCgnLicgKyBDU1NfU0VMRUNUICsgJ19faXRlbScpLmZvckVhY2goKG9wdGlvbiwgaW5kZXgpID0+IHtcXG4gICAgICAgIG9wdGlvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHNlbGVjdE9wdGlvbihzZWxlY3RPYmosIG9wdGlvbiwgaW5kZXgpKTtcXG4gICAgfSk7XFxufVxcblxcbmZ1bmN0aW9uIHNlbGVjdENsaWNrIChzZWxlY3RPYmosIHNlbGVjdEVscykge1xcbiAgICBzZWxlY3RPYmouaXNPcGVuU2VsZWN0ID0gIXNlbGVjdE9iai5pc09wZW5TZWxlY3Q7XFxuXFxuICAgIGZvciAobGV0IHNlbGVjdCBvZiBzZWxlY3RFbHMpIHtcXG4gICAgICAgIGlmIChzZWxlY3QuaWQgIT09IHNlbGVjdE9iai5pZCkgc2VsZWN0LmlzT3BlblNlbGVjdCA9IGZhbHNlO1xcbiAgICB9XFxufVxcblxcbmZ1bmN0aW9uIHNlbGVjdE9wdGlvbiAoc2VsZWN0T2JqLCBhY3RpdmVPcHRpb24sIGluZGV4KSB7XFxuICAgIHNlbGVjdE9iai5zZXRWYWx1ZShhY3RpdmVPcHRpb24uaW5uZXJUZXh0LCBpbmRleCk7XFxuICAgIGFjdGl2ZU9wdGlvbi5jbGFzc0xpc3QuYWRkKENTU19TRUxFQ1QgKyAnX19pdGVtX2lzLWFjdGl2ZScpO1xcbiAgICBzZWxlY3RPYmouZWwucXVlcnlTZWxlY3RvcignLicgKyBDU1NfU0VMRUNUICsgJ19faXRlbV9pcy1hY3RpdmUnKS5jbGFzc0xpc3QucmVtb3ZlKENTU19TRUxFQ1QgKyAnX19pdGVtX2lzLWFjdGl2ZScpO1xcbn1cXG5cXG5mdW5jdGlvbiBvdXRzaWRlQ2xpY2sgKHNlbGVjdEVscykge1xcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGUgPT4ge1xcbiAgICAgICAgaWYgKCFlLnRhcmdldC5jbG9zZXN0KCcuJyArIENTU19TRUxFQ1QpICYmIHNlbGVjdEVscy5sZW5ndGggPiAwKSB7XFxuICAgICAgICAgICAgc2VsZWN0RWxzLmZvckVhY2goc2VsZWN0ID0+IHtcXG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdC5pc09wZW5TZWxlY3QpIHNlbGVjdC5pc09wZW5TZWxlY3QgPSBmYWxzZTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgfSk7XFxufVxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3BhcnVzLy4vc3JjL2xpYnJhcnkuYmxvY2tzL3NlbGVjdC9zZWxlY3QuanM/XCIpO1xuXG4vKioqLyB9KVxuXG4vKioqKioqLyBcdH0pO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG4vKioqKioqLyBcdFx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvY29tcGF0IGdldCBkZWZhdWx0IGV4cG9ydCAqL1xuLyoqKioqKi8gXHQoKCkgPT4ge1xuLyoqKioqKi8gXHRcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gKG1vZHVsZSkgPT4ge1xuLyoqKioqKi8gXHRcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRcdCgpID0+IChtb2R1bGVbJ2RlZmF1bHQnXSkgOlxuLyoqKioqKi8gXHRcdFx0XHQoKSA9PiAobW9kdWxlKTtcbi8qKioqKiovIFx0XHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIHsgYTogZ2V0dGVyIH0pO1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHR9KSgpO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Lyogd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzICovXG4vKioqKioqLyBcdCgoKSA9PiB7XG4vKioqKioqLyBcdFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG4vKioqKioqLyBcdFx0XHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG4vKioqKioqLyBcdFx0XHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuLyoqKioqKi8gXHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG4vKioqKioqLyBcdFx0XHRcdH1cbi8qKioqKiovIFx0XHRcdH1cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHR9KSgpO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Lyogd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCAqL1xuLyoqKioqKi8gXHQoKCkgPT4ge1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSlcbi8qKioqKiovIFx0fSkoKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8qIHdlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QgKi9cbi8qKioqKiovIFx0KCgpID0+IHtcbi8qKioqKiovIFx0XHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcbi8qKioqKiovIFx0XHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuLyoqKioqKi8gXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbi8qKioqKiovIFx0XHRcdH1cbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0fSkoKTtcbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gc3RhcnR1cFxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0Ly8gVGhpcyBlbnRyeSBtb2R1bGUgY2FuJ3QgYmUgaW5saW5lZCBiZWNhdXNlIHRoZSBldmFsIGRldnRvb2wgaXMgdXNlZC5cbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19leHBvcnRzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvanMvcGFnZXMvaW5kZXguanNcIik7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gfSkoKVxuOyJdfQ==
